# action/public.d.ts

```ts
/** * Actions can return an object containing the two properties defined in this interface. Both are optional. * - update: An action can have a parameter. This method will be called whenever that parameter changes, * immediately after Svelte has applied updates to the markup. `ActionReturn` and `ActionReturn<undefined>` both * mean that the action accepts no parameters. * - destroy: Method that is called after the element is unmounted * * Additionally, you can specify which additional attributes and events the action enables on the applied element. * This applies to TypeScript typings only and has no effect at runtime. * * Example usage: * \`\`\`ts * interface Attributes { * newprop?: string; * 'on:event': (e: CustomEvent<boolean>) => void; * } * * export function myAction(node: HTMLElement, parameter: Parameter): ActionReturn<Parameter, Attributes> { * // ... * return { * update: (updatedParameter) => {...}, * destroy: () => {...} * }; * } * \`\`\` */ export interface ActionReturn< Parameter = undefined, Attributes extends Record<string, any> = Record<never, any> > { update?: (parameter: Parameter) => void; destroy?: () => void; /** * ### DO NOT USE THIS * This exists solely for type-checking and has no effect at runtime. * Set this through the `Attributes` generic instead. */ $$_attributes?: Attributes; } /** * Actions are functions that are called when an element is created. * You can use this interface to type such actions. * The following example defines an action that only works on `<div>` elements * and optionally accepts a parameter which it has a default value for: * \`\`\`ts * export const myAction: Action<HTMLDivElement, { someProperty: boolean } | undefined> = (node, param = { someProperty: true }) => { * // ... * } * \`\`\` * `Action<HTMLDivElement>` and `Action<HTMLDivElement, undefined>` both signal that the action accepts no parameters. * * You can return an object with methods `update` and `destroy` from the function and type which additional attributes and events it has. * See interface `ActionReturn` for more details. */ export interface Action< Element = HTMLElement, Parameter = undefined, Attributes extends Record<string, any> = Record<never, any> > { <Node extends Element>( ...args: undefined extends Parameter ? [node: Node, parameter?: Parameter] : [node: Node, parameter: Parameter] ): void | ActionReturn<Parameter, Attributes>; } // Implementation notes: // - undefined extends X instead of X extends undefined makes this work better with both strict and nonstrict mode
```

# ambient.d.ts

```ts
declare module '*.svelte' { // use prettier-ignore for a while because of https://github.com/sveltejs/language-tools/commit/026111228b5814a9109cc4d779d37fb02955fb8b // prettier-ignore import { SvelteComponent } from 'svelte' import { LegacyComponentType } from 'svelte/legacy'; const Comp: LegacyComponentType; type Comp = SvelteComponent; export default Comp; } /** * Declares reactive state. * * Example: * \`\`\`ts * let count = $state(0); * \`\`\` * * https://svelte.dev/docs/svelte/$state * * @param initial The initial value */ declare function $state<T>(initial: T): T; declare function $state<T>(): T | undefined; declare namespace $state { type Primitive = string | number | boolean | null | undefined; type TypedArray = | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array; /** The things that `structuredClone` can handle — https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm */ export type Cloneable = | ArrayBuffer | DataView | Date | Error | Map<any, any> | RegExp | Set<any> | TypedArray // web APIs | Blob | CryptoKey | DOMException | DOMMatrix | DOMMatrixReadOnly | DOMPoint | DOMPointReadOnly | DOMQuad | DOMRect | DOMRectReadOnly | File | FileList | FileSystemDirectoryHandle | FileSystemFileHandle | FileSystemHandle | ImageBitmap | ImageData | RTCCertificate | VideoFrame; /** Turn `SvelteDate`, `SvelteMap` and `SvelteSet` into their non-reactive counterparts. (`URL` is uncloneable.) */ type NonReactive<T> = T extends Date ? Date : T extends Map<infer K, infer V> ? Map<K, V> : T extends Set<infer K> ? Set<K> : T; type Snapshot<T> = T extends Primitive ? T : T extends Cloneable ? NonReactive<T> : T extends { toJSON(): infer R } ? R : T extends Array<infer U> ? Array<Snapshot<U>> : T extends object ? T extends { [key: string]: any } ? { [K in keyof T]: Snapshot<T[K]> } : never : never; /** * Declares state that is _not_ made deeply reactive — instead of mutating it, * you must reassign it. * * Example: * \`\`\`ts * <script> * let items = $state.raw([0]); * * const addItem = () => { * items = [...items, items.length]; * }; * </script> * * <button on:click={addItem}> * {items.join(', ')} * </button> * \`\`\` * * https://svelte.dev/docs/svelte/$state#$state.raw * * @param initial The initial value */ export function raw<T>(initial: T): T; export function raw<T>(): T | undefined; /** * To take a static snapshot of a deeply reactive `$state` proxy, use `$state.snapshot`: * * Example: * \`\`\`ts * <script> * let counter = $state({ count: 0 }); * * function onclick() { * // Will log `{ count: ... }` rather than `Proxy { ... }` * console.log($state.snapshot(counter)); * }; * </script> * \`\`\` * * https://svelte.dev/docs/svelte/$state#$state.snapshot * * @param state The value to snapshot */ export function snapshot<T>(state: T): Snapshot<T>; // prevent intellisense from being unhelpful /** @deprecated */ export const apply: never; /** @deprecated */ // @ts-ignore export const arguments: never; /** @deprecated */ export const bind: never; /** @deprecated */ export const call: never; /** @deprecated */ export const caller: never; /** @deprecated */ export const length: never; /** @deprecated */ export const name: never; /** @deprecated */ export const prototype: never; /** @deprecated */ export const toString: never; } /** * Declares derived state, i.e. one that depends on other state variables. * The expression inside `$derived(...)` should be free of side-effects. * * Example: * \`\`\`ts * let double = $derived(count * 2); * \`\`\` * * https://svelte.dev/docs/svelte/$derived * * @param expression The derived state expression */ declare function $derived<T>(expression: T): T; declare namespace $derived { /** * Sometimes you need to create complex derivations that don't fit inside a short expression. * In these cases, you can use `$derived.by` which accepts a function as its argument. * * Example: * \`\`\`ts * let total = $derived.by(() => { * let result = 0; * for (const n of numbers) { * result += n; * } * return result; * }); * \`\`\` * * https://svelte.dev/docs/svelte/$derived#$derived.by */ export function by<T>(fn: () => T): T; // prevent intellisense from being unhelpful /** @deprecated */ export const apply: never; /** @deprecated */ // @ts-ignore export const arguments: never; /** @deprecated */ export const bind: never; /** @deprecated */ export const call: never; /** @deprecated */ export const caller: never; /** @deprecated */ export const length: never; /** @deprecated */ export const name: never; /** @deprecated */ export const prototype: never; /** @deprecated */ export const toString: never; } /** * Runs code when a component is mounted to the DOM, and then whenever its dependencies change, i.e. `$state` or `$derived` values. * The timing of the execution is after the DOM has been updated. * * Example: * \`\`\`ts * $effect(() => console.log('The count is now ' + count)); * \`\`\` * * If you return a function from the effect, it will be called right before the effect is run again, or when the component is unmounted. * * Does not run during server side rendering. * * https://svelte.dev/docs/svelte/$effect * @param fn The function to execute */ declare function $effect(fn: () => void | (() => void)): void; declare namespace $effect { /** * Runs code right before a component is mounted to the DOM, and then whenever its dependencies change, i.e. `$state` or `$derived` values. * The timing of the execution is right before the DOM is updated. * * Example: * \`\`\`ts * $effect.pre(() => console.log('The count is now ' + count)); * \`\`\` * * If you return a function from the effect, it will be called right before the effect is run again, or when the component is unmounted. * * Does not run during server side rendering. * * https://svelte.dev/docs/svelte/$effect#$effect.pre * @param fn The function to execute */ export function pre(fn: () => void | (() => void)): void; /** * The `$effect.tracking` rune is an advanced feature that tells you whether or not the code is running inside a tracking context, such as an effect or inside your template. * * Example: * \`\`\`svelte * <script> * console.log('in component setup:', $effect.tracking()); // false * * $effect(() => { * console.log('in effect:', $effect.tracking()); // true * }); * </script> * * <p>in template: {$effect.tracking()}</p> <!-- true --> * \`\`\` * * This allows you to (for example) add things like subscriptions without causing memory leaks, by putting them in child effects. * * https://svelte.dev/docs/svelte/$effect#$effect.tracking */ export function tracking(): boolean; /** * The `$effect.root` rune is an advanced feature that creates a non-tracked scope that doesn't auto-cleanup. This is useful for * nested effects that you want to manually control. This rune also allows for creation of effects outside of the component * initialisation phase. * * Example: * \`\`\`svelte * <script> * let count = $state(0); * * const cleanup = $effect.root(() => { * $effect(() => { * console.log(count); * }) * * return () => { * console.log('effect root cleanup'); * } * }); * </script> * * <button onclick={() => cleanup()}>cleanup</button> * \`\`\` * * https://svelte.dev/docs/svelte/$effect#$effect.root */ export function root(fn: () => void | (() => void)): () => void; // prevent intellisense from being unhelpful /** @deprecated */ export const apply: never; /** @deprecated */ // @ts-ignore export const arguments: never; /** @deprecated */ export const bind: never; /** @deprecated */ export const call: never; /** @deprecated */ export const caller: never; /** @deprecated */ export const length: never; /** @deprecated */ export const name: never; /** @deprecated */ export const prototype: never; /** @deprecated */ export const toString: never; } /** * Declares the props that a component accepts. Example: * * \`\`\`ts * let { optionalProp = 42, requiredProp, bindableProp = $bindable() }: { optionalProp?: number; requiredProps: string; bindableProp: boolean } = $props(); * \`\`\` * * https://svelte.dev/docs/svelte/$props */ declare function $props(): any; declare namespace $props { /** * Generates an ID that is unique to the current component instance. When hydrating a server-rendered component, * the value will be consistent between server and client. * * This is useful for linking elements via attributes like `for` and `aria-labelledby`. * @since 5.20.0 */ export function id(): string; // prevent intellisense from being unhelpful /** @deprecated */ export const apply: never; /** @deprecated */ // @ts-ignore export const arguments: never; /** @deprecated */ export const bind: never; /** @deprecated */ export const call: never; /** @deprecated */ export const caller: never; /** @deprecated */ export const length: never; /** @deprecated */ export const name: never; /** @deprecated */ export const prototype: never; /** @deprecated */ export const toString: never; } /** * Declares a prop as bindable, meaning the parent component can use `bind:propName={value}` to bind to it. * * \`\`\`ts * let { propName = $bindable() }: { propName: boolean } = $props(); * \`\`\` * * https://svelte.dev/docs/svelte/$bindable */ declare function $bindable<T>(fallback?: T): T; declare namespace $bindable { // prevent intellisense from being unhelpful /** @deprecated */ export const apply: never; /** @deprecated */ // @ts-ignore export const arguments: never; /** @deprecated */ export const bind: never; /** @deprecated */ export const call: never; /** @deprecated */ export const caller: never; /** @deprecated */ export const length: never; /** @deprecated */ export const name: never; /** @deprecated */ export const prototype: never; /** @deprecated */ export const toString: never; } /** * Inspects one or more values whenever they, or the properties they contain, change. Example: * * \`\`\`ts * $inspect(someValue, someOtherValue) * \`\`\` * * `$inspect` returns a `with` function, which you can invoke with a callback function that * will be called with the value and the event type (`'init'` or `'update'`) on every change. * By default, the values will be logged to the console. * * \`\`\`ts * $inspect(x).with(console.trace); * $inspect(x, y).with(() => { debugger; }); * \`\`\` * * https://svelte.dev/docs/svelte/$inspect */ declare function $inspect<T extends any[]>( ...values: T ): { with: (fn: (type: 'init' | 'update', ...values: T) => void) => void }; declare namespace $inspect { /** * Tracks which reactive state changes caused an effect to re-run. Must be the first * statement of a function body. Example: * * \`\`\`svelte * <script> * let count = $state(0); * * $effect(() => { * $inspect.trace('my effect'); * * count; * }); * </script> */ export function trace(name?: string): void; // prevent intellisense from being unhelpful /** @deprecated */ export const apply: never; /** @deprecated */ // @ts-ignore export const arguments: never; /** @deprecated */ export const bind: never; /** @deprecated */ export const call: never; /** @deprecated */ export const caller: never; /** @deprecated */ export const length: never; /** @deprecated */ export const name: never; /** @deprecated */ export const prototype: never; /** @deprecated */ export const toString: never; } /** * Retrieves the `this` reference of the custom element that contains this component. Example: * * \`\`\`svelte * <svelte:options customElement="my-element" /> * * <script> * function greet(greeting) { * $host().dispatchEvent(new CustomEvent('greeting', { detail: greeting })) * } * </script> * * <button onclick={() => greet('hello')}>say hello</button> * \`\`\` * * Only available inside custom element components, and only on the client-side. * * https://svelte.dev/docs/svelte/$host */ declare function $host<El extends HTMLElement = HTMLElement>(): El; declare namespace $host { // prevent intellisense from being unhelpful /** @deprecated */ export const apply: never; /** @deprecated */ // @ts-ignore export const arguments: never; /** @deprecated */ export const bind: never; /** @deprecated */ export const call: never; /** @deprecated */ export const caller: never; /** @deprecated */ export const length: never; /** @deprecated */ export const name: never; /** @deprecated */ export const prototype: never; /** @deprecated */ export const toString: never; }
```

# animate/index.js

```js
/** @import { FlipParams, AnimationConfig } from './public.js' */ import { cubicOut } from '../easing/index.js'; /** * The flip function calculates the start and end position of an element and animates between them, translating the x and y values. * `flip` stands for [First, Last, Invert, Play](https://aerotwist.com/blog/flip-your-animations/). * * @param {Element} node * @param {{ from: DOMRect; to: DOMRect }} fromTo * @param {FlipParams} params * @returns {AnimationConfig} */ export function flip(node, { from, to }, params = {}) { var { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params; var style = getComputedStyle(node); // find the transform origin, expressed as a pair of values between 0 and 1 var transform = style.transform === 'none' ? '' : style.transform; var [ox, oy] = style.transformOrigin.split(' ').map(parseFloat); ox /= node.clientWidth; oy /= node.clientHeight; // calculate effect of parent transforms and zoom var zoom = get_zoom(node); // https://drafts.csswg.org/css-viewport/#effective-zoom var sx = node.clientWidth / to.width / zoom; var sy = node.clientHeight / to.height / zoom; // find the starting position of the transform origin var fx = from.left + from.width * ox; var fy = from.top + from.height * oy; // find the ending position of the transform origin var tx = to.left + to.width * ox; var ty = to.top + to.height * oy; // find the translation at the start of the transform var dx = (fx - tx) * sx; var dy = (fy - ty) * sy; // find the relative scale at the start of the transform var dsx = from.width / to.width; var dsy = from.height / to.height; return { delay, duration: typeof duration === 'function' ? duration(Math.sqrt(dx * dx + dy * dy)) : duration, easing, css: (t, u) => { var x = u * dx; var y = u * dy; var sx = t + u * dsx; var sy = t + u * dsy; return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`; } }; } /** * @param {Element} element */ function get_zoom(element) { if ('currentCSSZoom' in element) { return /** @type {number} */ (element.currentCSSZoom); } /** @type {Element | null} */ var current = element; var zoom = 1; while (current !== null) { zoom *= +getComputedStyle(current).zoom; current = /** @type {Element | null} */ (current.parentElement); } return zoom; }
```

# animate/public.d.ts

```ts
// todo: same as Transition, should it be shared? export interface AnimationConfig { delay?: number; duration?: number; easing?: (t: number) => number; css?: (t: number, u: number) => string; tick?: (t: number, u: number) => void; } export interface FlipParams { delay?: number; duration?: number | ((len: number) => number); easing?: (t: number) => number; } export * from './index.js';
```

# attachments/index.js

```js
/** @import { Action, ActionReturn } from '../action/public' */ /** @import { Attachment } from './public' */ import { noop, render_effect } from 'svelte/internal/client'; import { ATTACHMENT_KEY } from '../constants.js'; import { untrack } from '../index-client.js'; import { teardown } from '../internal/client/reactivity/effects.js'; /** * Creates an object key that will be recognised as an attachment when the object is spread onto an element, * as a programmatic alternative to using `{@attach ...}`. This can be useful for library authors, though * is generally not needed when building an app. * * \`\`\`svelte * <script> * import { createAttachmentKey } from 'svelte/attachments'; * * const props = { * class: 'cool', * onclick: () => alert('clicked'), * [createAttachmentKey()]: (node) => { * node.textContent = 'attached!'; * } * }; * </script> * * <button {...props}>click me</button> * \`\`\` * @since 5.29 */ export function createAttachmentKey() { return Symbol(ATTACHMENT_KEY); } /** * Converts an [action](https://svelte.dev/docs/svelte/use) into an [attachment](https://svelte.dev/docs/svelte/@attach) keeping the same behavior. * It's useful if you want to start using attachments on components but you have actions provided by a library. * * Note that the second argument, if provided, must be a function that _returns_ the argument to the * action function, not the argument itself. * * \`\`\`svelte * <!-- with an action --> * <div use:foo={bar}>...</div> * * <!-- with an attachment --> * <div {@attach fromAction(foo, () => bar)}>...</div> * \`\`\` * @template {EventTarget} E * @template {unknown} T * @overload * @param {Action<E, T> | ((element: E, arg: T) => void | ActionReturn<T>)} action The action function * @param {() => T} fn A function that returns the argument for the action * @returns {Attachment<E>} */ /** * Converts an [action](https://svelte.dev/docs/svelte/use) into an [attachment](https://svelte.dev/docs/svelte/@attach) keeping the same behavior. * It's useful if you want to start using attachments on components but you have actions provided by a library. * * Note that the second argument, if provided, must be a function that _returns_ the argument to the * action function, not the argument itself. * * \`\`\`svelte * <!-- with an action --> * <div use:foo={bar}>...</div> * * <!-- with an attachment --> * <div {@attach fromAction(foo, () => bar)}>...</div> * \`\`\` * @template {EventTarget} E * @overload * @param {Action<E, void> | ((element: E) => void | ActionReturn<void>)} action The action function * @returns {Attachment<E>} */ /** * Converts an [action](https://svelte.dev/docs/svelte/use) into an [attachment](https://svelte.dev/docs/svelte/@attach) keeping the same behavior. * It's useful if you want to start using attachments on components but you have actions provided by a library. * * Note that the second argument, if provided, must be a function that _returns_ the argument to the * action function, not the argument itself. * * \`\`\`svelte * <!-- with an action --> * <div use:foo={bar}>...</div> * * <!-- with an attachment --> * <div {@attach fromAction(foo, () => bar)}>...</div> * \`\`\` * * @template {EventTarget} E * @template {unknown} T * @param {Action<E, T> | ((element: E, arg: T) => void | ActionReturn<T>)} action The action function * @param {() => T} fn A function that returns the argument for the action * @returns {Attachment<E>} * @since 5.32 */ export function fromAction(action, fn = /** @type {() => T} */ (noop)) { return (element) => { const { update, destroy } = untrack(() => action(element, fn()) ?? {}); if (update) { var ran = false; render_effect(() => { const arg = fn(); if (ran) update(arg); }); ran = true; } if (destroy) { teardown(destroy); } }; }
```

# attachments/public.d.ts

```ts
/** * An [attachment](https://svelte.dev/docs/svelte/@attach) is a function that runs when an element is mounted * to the DOM, and optionally returns a function that is called when the element is later removed. * * It can be attached to an element with an `{@attach ...}` tag, or by spreading an object containing * a property created with [`createAttachmentKey`](https://svelte.dev/docs/svelte/svelte-attachments#createAttachmentKey). */ export interface Attachment<T extends EventTarget = Element> { (element: T): void | (() => void); } export * from './index.js';
```

# compiler/errors.js

```js
/* This file is generated by scripts/process-messages/index.js. Do not edit! */ import { CompileDiagnostic } from './utils/compile_diagnostic.js'; /** @typedef {{ start?: number, end?: number }} NodeLike */ class InternalCompileError extends Error { message = ''; // ensure this property is enumerable #diagnostic; /** * @param {string} code * @param {string} message * @param {[number, number] | undefined} position */ constructor(code, message, position) { super(message); this.stack = ''; // avoid unnecessary noise; don't set it as a class property or it becomes enumerable // We want to extend from Error so that various bundler plugins properly handle it. // But we also want to share the same object shape with that of warnings, therefore // we create an instance of the shared class an copy over its properties. this.#diagnostic = new CompileDiagnostic(code, message, position); Object.assign(this, this.#diagnostic); this.name = 'CompileError'; } toString() { return this.#diagnostic.toString(); } toJSON() { return this.#diagnostic.toJSON(); } } /** * @param {null | number | NodeLike} node * @param {string} code * @param {string} message * @returns {never} */ function e(node, code, message) { const start = typeof node === 'number' ? node : node?.start; const end = typeof node === 'number' ? node : node?.end; throw new InternalCompileError(code, message, start !== undefined ? [start, end ?? start] : undefined); } /** * Invalid compiler option: %details% * @param {null | number | NodeLike} node * @param {string} details * @returns {never} */ export function options_invalid_value(node, details) { e(node, 'options_invalid_value', `Invalid compiler option: ${details}\nhttps://svelte.dev/e/options_invalid_value`); } /** * Invalid compiler option: %details% * @param {null | number | NodeLike} node * @param {string} details * @returns {never} */ export function options_removed(node, details) { e(node, 'options_removed', `Invalid compiler option: ${details}\nhttps://svelte.dev/e/options_removed`); } /** * Unrecognised compiler option %keypath% * @param {null | number | NodeLike} node * @param {string} keypath * @returns {never} */ export function options_unrecognised(node, keypath) { e(node, 'options_unrecognised', `Unrecognised compiler option ${keypath}\nhttps://svelte.dev/e/options_unrecognised`); } /** * `$bindable()` can only be used inside a `$props()` declaration * @param {null | number | NodeLike} node * @returns {never} */ export function bindable_invalid_location(node) { e(node, 'bindable_invalid_location', `\`$bindable()\` can only be used inside a \`$props()\` declaration\nhttps://svelte.dev/e/bindable_invalid_location`); } /** * Cannot assign to %thing% * @param {null | number | NodeLike} node * @param {string} thing * @returns {never} */ export function constant_assignment(node, thing) { e(node, 'constant_assignment', `Cannot assign to ${thing}\nhttps://svelte.dev/e/constant_assignment`); } /** * Cannot bind to %thing% * @param {null | number | NodeLike} node * @param {string} thing * @returns {never} */ export function constant_binding(node, thing) { e(node, 'constant_binding', `Cannot bind to ${thing}\nhttps://svelte.dev/e/constant_binding`); } /** * `%name%` has already been declared * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function declaration_duplicate(node, name) { e(node, 'declaration_duplicate', `\`${name}\` has already been declared\nhttps://svelte.dev/e/declaration_duplicate`); } /** * Cannot declare a variable with the same name as an import inside `<script module>` * @param {null | number | NodeLike} node * @returns {never} */ export function declaration_duplicate_module_import(node) { e(node, 'declaration_duplicate_module_import', `Cannot declare a variable with the same name as an import inside \`<script module>\`\nhttps://svelte.dev/e/declaration_duplicate_module_import`); } /** * Cannot export derived state from a module. To expose the current derived value, export a function returning its value * @param {null | number | NodeLike} node * @returns {never} */ export function derived_invalid_export(node) { e(node, 'derived_invalid_export', `Cannot export derived state from a module. To expose the current derived value, export a function returning its value\nhttps://svelte.dev/e/derived_invalid_export`); } /** * The $ name is reserved, and cannot be used for variables and imports * @param {null | number | NodeLike} node * @returns {never} */ export function dollar_binding_invalid(node) { e(node, 'dollar_binding_invalid', `The $ name is reserved, and cannot be used for variables and imports\nhttps://svelte.dev/e/dollar_binding_invalid`); } /** * The $ prefix is reserved, and cannot be used for variables and imports * @param {null | number | NodeLike} node * @returns {never} */ export function dollar_prefix_invalid(node) { e(node, 'dollar_prefix_invalid', `The $ prefix is reserved, and cannot be used for variables and imports\nhttps://svelte.dev/e/dollar_prefix_invalid`); } /** * Cannot reassign or bind to each block argument in runes mode. Use the array and index variables instead (e.g. `array[i] = value` instead of `entry = value`, or `bind:value={array[i]}` instead of `bind:value={entry}`) * @param {null | number | NodeLike} node * @returns {never} */ export function each_item_invalid_assignment(node) { e(node, 'each_item_invalid_assignment', `Cannot reassign or bind to each block argument in runes mode. Use the array and index variables instead (e.g. \`array[i] = value\` instead of \`entry = value\`, or \`bind:value={array[i]}\` instead of \`bind:value={entry}\`)\nhttps://svelte.dev/e/each_item_invalid_assignment`); } /** * `$effect()` can only be used as an expression statement * @param {null | number | NodeLike} node * @returns {never} */ export function effect_invalid_placement(node) { e(node, 'effect_invalid_placement', `\`$effect()\` can only be used as an expression statement\nhttps://svelte.dev/e/effect_invalid_placement`); } /** * Cannot use `await` in deriveds and template expressions, or at the top level of a component, unless the `experimental.async` compiler option is `true` * @param {null | number | NodeLike} node * @returns {never} */ export function experimental_async(node) { e(node, 'experimental_async', `Cannot use \`await\` in deriveds and template expressions, or at the top level of a component, unless the \`experimental.async\` compiler option is \`true\`\nhttps://svelte.dev/e/experimental_async`); } /** * `%name%` is not defined * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function export_undefined(node, name) { e(node, 'export_undefined', `\`${name}\` is not defined\nhttps://svelte.dev/e/export_undefined`); } /** * `%name%` is an illegal variable name. To reference a global variable called `%name%`, use `globalThis.%name%` * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function global_reference_invalid(node, name) { e(node, 'global_reference_invalid', `\`${name}\` is an illegal variable name. To reference a global variable called \`${name}\`, use \`globalThis.${name}\`\nhttps://svelte.dev/e/global_reference_invalid`); } /** * `$host()` can only be used inside custom element component instances * @param {null | number | NodeLike} node * @returns {never} */ export function host_invalid_placement(node) { e(node, 'host_invalid_placement', `\`$host()\` can only be used inside custom element component instances\nhttps://svelte.dev/e/host_invalid_placement`); } /** * Imports of `svelte/internal/*` are forbidden. It contains private runtime code which is subject to change without notice. If you're importing from `svelte/internal/*` to work around a limitation of Svelte, please open an issue at https://github.com/sveltejs/svelte and explain your use case * @param {null | number | NodeLike} node * @returns {never} */ export function import_svelte_internal_forbidden(node) { e(node, 'import_svelte_internal_forbidden', `Imports of \`svelte/internal/*\` are forbidden. It contains private runtime code which is subject to change without notice. If you're importing from \`svelte/internal/*\` to work around a limitation of Svelte, please open an issue at https://github.com/sveltejs/svelte and explain your use case\nhttps://svelte.dev/e/import_svelte_internal_forbidden`); } /** * `$inspect.trace(...)` cannot be used inside a generator function * @param {null | number | NodeLike} node * @returns {never} */ export function inspect_trace_generator(node) { e(node, 'inspect_trace_generator', `\`$inspect.trace(...)\` cannot be used inside a generator function\nhttps://svelte.dev/e/inspect_trace_generator`); } /** * `$inspect.trace(...)` must be the first statement of a function body * @param {null | number | NodeLike} node * @returns {never} */ export function inspect_trace_invalid_placement(node) { e(node, 'inspect_trace_invalid_placement', `\`$inspect.trace(...)\` must be the first statement of a function body\nhttps://svelte.dev/e/inspect_trace_invalid_placement`); } /** * The arguments keyword cannot be used within the template or at the top level of a component * @param {null | number | NodeLike} node * @returns {never} */ export function invalid_arguments_usage(node) { e(node, 'invalid_arguments_usage', `The arguments keyword cannot be used within the template or at the top level of a component\nhttps://svelte.dev/e/invalid_arguments_usage`); } /** * Cannot use `await` in deriveds and template expressions, or at the top level of a component, unless in runes mode * @param {null | number | NodeLike} node * @returns {never} */ export function legacy_await_invalid(node) { e(node, 'legacy_await_invalid', `Cannot use \`await\` in deriveds and template expressions, or at the top level of a component, unless in runes mode\nhttps://svelte.dev/e/legacy_await_invalid`); } /** * Cannot use `export let` in runes mode — use `$props()` instead * @param {null | number | NodeLike} node * @returns {never} */ export function legacy_export_invalid(node) { e(node, 'legacy_export_invalid', `Cannot use \`export let\` in runes mode — use \`$props()\` instead\nhttps://svelte.dev/e/legacy_export_invalid`); } /** * Cannot use `$$props` in runes mode * @param {null | number | NodeLike} node * @returns {never} */ export function legacy_props_invalid(node) { e(node, 'legacy_props_invalid', `Cannot use \`$$props\` in runes mode\nhttps://svelte.dev/e/legacy_props_invalid`); } /** * `$:` is not allowed in runes mode, use `$derived` or `$effect` instead * @param {null | number | NodeLike} node * @returns {never} */ export function legacy_reactive_statement_invalid(node) { e(node, 'legacy_reactive_statement_invalid', `\`$:\` is not allowed in runes mode, use \`$derived\` or \`$effect\` instead\nhttps://svelte.dev/e/legacy_reactive_statement_invalid`); } /** * Cannot use `$$restProps` in runes mode * @param {null | number | NodeLike} node * @returns {never} */ export function legacy_rest_props_invalid(node) { e(node, 'legacy_rest_props_invalid', `Cannot use \`$$restProps\` in runes mode\nhttps://svelte.dev/e/legacy_rest_props_invalid`); } /** * A component cannot have a default export * @param {null | number | NodeLike} node * @returns {never} */ export function module_illegal_default_export(node) { e(node, 'module_illegal_default_export', `A component cannot have a default export\nhttps://svelte.dev/e/module_illegal_default_export`); } /** * Cannot use `%rune%()` more than once * @param {null | number | NodeLike} node * @param {string} rune * @returns {never} */ export function props_duplicate(node, rune) { e(node, 'props_duplicate', `Cannot use \`${rune}()\` more than once\nhttps://svelte.dev/e/props_duplicate`); } /** * `$props.id()` can only be used at the top level of components as a variable declaration initializer * @param {null | number | NodeLike} node * @returns {never} */ export function props_id_invalid_placement(node) { e(node, 'props_id_invalid_placement', `\`$props.id()\` can only be used at the top level of components as a variable declaration initializer\nhttps://svelte.dev/e/props_id_invalid_placement`); } /** * Declaring or accessing a prop starting with `$$` is illegal (they are reserved for Svelte internals) * @param {null | number | NodeLike} node * @returns {never} */ export function props_illegal_name(node) { e(node, 'props_illegal_name', `Declaring or accessing a prop starting with \`$$\` is illegal (they are reserved for Svelte internals)\nhttps://svelte.dev/e/props_illegal_name`); } /** * `$props()` can only be used with an object destructuring pattern * @param {null | number | NodeLike} node * @returns {never} */ export function props_invalid_identifier(node) { e(node, 'props_invalid_identifier', `\`$props()\` can only be used with an object destructuring pattern\nhttps://svelte.dev/e/props_invalid_identifier`); } /** * `$props()` assignment must not contain nested properties or computed keys * @param {null | number | NodeLike} node * @returns {never} */ export function props_invalid_pattern(node) { e(node, 'props_invalid_pattern', `\`$props()\` assignment must not contain nested properties or computed keys\nhttps://svelte.dev/e/props_invalid_pattern`); } /** * `$props()` can only be used at the top level of components as a variable declaration initializer * @param {null | number | NodeLike} node * @returns {never} */ export function props_invalid_placement(node) { e(node, 'props_invalid_placement', `\`$props()\` can only be used at the top level of components as a variable declaration initializer\nhttps://svelte.dev/e/props_invalid_placement`); } /** * Cyclical dependency detected: %cycle% * @param {null | number | NodeLike} node * @param {string} cycle * @returns {never} */ export function reactive_declaration_cycle(node, cycle) { e(node, 'reactive_declaration_cycle', `Cyclical dependency detected: ${cycle}\nhttps://svelte.dev/e/reactive_declaration_cycle`); } /** * `%rune%` cannot be called with arguments * @param {null | number | NodeLike} node * @param {string} rune * @returns {never} */ export function rune_invalid_arguments(node, rune) { e(node, 'rune_invalid_arguments', `\`${rune}\` cannot be called with arguments\nhttps://svelte.dev/e/rune_invalid_arguments`); } /** * `%rune%` must be called with %args% * @param {null | number | NodeLike} node * @param {string} rune * @param {string} args * @returns {never} */ export function rune_invalid_arguments_length(node, rune, args) { e(node, 'rune_invalid_arguments_length', `\`${rune}\` must be called with ${args}\nhttps://svelte.dev/e/rune_invalid_arguments_length`); } /** * Cannot access a computed property of a rune * @param {null | number | NodeLike} node * @returns {never} */ export function rune_invalid_computed_property(node) { e(node, 'rune_invalid_computed_property', `Cannot access a computed property of a rune\nhttps://svelte.dev/e/rune_invalid_computed_property`); } /** * `%name%` is not a valid rune * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function rune_invalid_name(node, name) { e(node, 'rune_invalid_name', `\`${name}\` is not a valid rune\nhttps://svelte.dev/e/rune_invalid_name`); } /** * `%rune%` cannot be called with a spread argument * @param {null | number | NodeLike} node * @param {string} rune * @returns {never} */ export function rune_invalid_spread(node, rune) { e(node, 'rune_invalid_spread', `\`${rune}\` cannot be called with a spread argument\nhttps://svelte.dev/e/rune_invalid_spread`); } /** * Cannot use `%rune%` rune in non-runes mode * @param {null | number | NodeLike} node * @param {string} rune * @returns {never} */ export function rune_invalid_usage(node, rune) { e(node, 'rune_invalid_usage', `Cannot use \`${rune}\` rune in non-runes mode\nhttps://svelte.dev/e/rune_invalid_usage`); } /** * Cannot use rune without parentheses * @param {null | number | NodeLike} node * @returns {never} */ export function rune_missing_parentheses(node) { e(node, 'rune_missing_parentheses', `Cannot use rune without parentheses\nhttps://svelte.dev/e/rune_missing_parentheses`); } /** * The `%name%` rune has been removed * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function rune_removed(node, name) { e(node, 'rune_removed', `The \`${name}\` rune has been removed\nhttps://svelte.dev/e/rune_removed`); } /** * `%name%` is now `%replacement%` * @param {null | number | NodeLike} node * @param {string} name * @param {string} replacement * @returns {never} */ export function rune_renamed(node, name, replacement) { e(node, 'rune_renamed', `\`${name}\` is now \`${replacement}\`\nhttps://svelte.dev/e/rune_renamed`); } /** * %name% cannot be used in runes mode * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function runes_mode_invalid_import(node, name) { e(node, 'runes_mode_invalid_import', `${name} cannot be used in runes mode\nhttps://svelte.dev/e/runes_mode_invalid_import`); } /** * An exported snippet can only reference things declared in a `<script module>`, or other exportable snippets * @param {null | number | NodeLike} node * @returns {never} */ export function snippet_invalid_export(node) { e(node, 'snippet_invalid_export', `An exported snippet can only reference things declared in a \`<script module>\`, or other exportable snippets\nhttps://svelte.dev/e/snippet_invalid_export`); } /** * Cannot reassign or bind to snippet parameter * @param {null | number | NodeLike} node * @returns {never} */ export function snippet_parameter_assignment(node) { e(node, 'snippet_parameter_assignment', `Cannot reassign or bind to snippet parameter\nhttps://svelte.dev/e/snippet_parameter_assignment`); } /** * `%name%` has already been declared on this class * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function state_field_duplicate(node, name) { e(node, 'state_field_duplicate', `\`${name}\` has already been declared on this class\nhttps://svelte.dev/e/state_field_duplicate`); } /** * Cannot assign to a state field before its declaration * @param {null | number | NodeLike} node * @returns {never} */ export function state_field_invalid_assignment(node) { e(node, 'state_field_invalid_assignment', `Cannot assign to a state field before its declaration\nhttps://svelte.dev/e/state_field_invalid_assignment`); } /** * Cannot export state from a module if it is reassigned. Either export a function returning the state value or only mutate the state value's properties * @param {null | number | NodeLike} node * @returns {never} */ export function state_invalid_export(node) { e(node, 'state_invalid_export', `Cannot export state from a module if it is reassigned. Either export a function returning the state value or only mutate the state value's properties\nhttps://svelte.dev/e/state_invalid_export`); } /** * `%rune%(...)` can only be used as a variable declaration initializer, a class field declaration, or the first assignment to a class field at the top level of the constructor. * @param {null | number | NodeLike} node * @param {string} rune * @returns {never} */ export function state_invalid_placement(node, rune) { e(node, 'state_invalid_placement', `\`${rune}(...)\` can only be used as a variable declaration initializer, a class field declaration, or the first assignment to a class field at the top level of the constructor.\nhttps://svelte.dev/e/state_invalid_placement`); } /** * Cannot subscribe to stores that are not declared at the top level of the component * @param {null | number | NodeLike} node * @returns {never} */ export function store_invalid_scoped_subscription(node) { e(node, 'store_invalid_scoped_subscription', `Cannot subscribe to stores that are not declared at the top level of the component\nhttps://svelte.dev/e/store_invalid_scoped_subscription`); } /** * Cannot reference store value inside `<script module>` * @param {null | number | NodeLike} node * @returns {never} */ export function store_invalid_subscription(node) { e(node, 'store_invalid_subscription', `Cannot reference store value inside \`<script module>\`\nhttps://svelte.dev/e/store_invalid_subscription`); } /** * Cannot reference store value outside a `.svelte` file * @param {null | number | NodeLike} node * @returns {never} */ export function store_invalid_subscription_module(node) { e(node, 'store_invalid_subscription_module', `Cannot reference store value outside a \`.svelte\` file\nhttps://svelte.dev/e/store_invalid_subscription_module`); } /** * TypeScript language features like %feature% are not natively supported, and their use is generally discouraged. Outside of `<script>` tags, these features are not supported. For use within `<script>` tags, you will need to use a preprocessor to convert it to JavaScript before it gets passed to the Svelte compiler. If you are using `vitePreprocess`, make sure to specifically enable preprocessing script tags (`vitePreprocess({ script: true })`) * @param {null | number | NodeLike} node * @param {string} feature * @returns {never} */ export function typescript_invalid_feature(node, feature) { e(node, 'typescript_invalid_feature', `TypeScript language features like ${feature} are not natively supported, and their use is generally discouraged. Outside of \`<script>\` tags, these features are not supported. For use within \`<script>\` tags, you will need to use a preprocessor to convert it to JavaScript before it gets passed to the Svelte compiler. If you are using \`vitePreprocess\`, make sure to specifically enable preprocessing script tags (\`vitePreprocess({ script: true })\`)\nhttps://svelte.dev/e/typescript_invalid_feature`); } /** * Declaration cannot be empty * @param {null | number | NodeLike} node * @returns {never} */ export function css_empty_declaration(node) { e(node, 'css_empty_declaration', `Declaration cannot be empty\nhttps://svelte.dev/e/css_empty_declaration`); } /** * Expected a valid CSS identifier * @param {null | number | NodeLike} node * @returns {never} */ export function css_expected_identifier(node) { e(node, 'css_expected_identifier', `Expected a valid CSS identifier\nhttps://svelte.dev/e/css_expected_identifier`); } /** * A `:global` selector cannot follow a `%name%` combinator * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function css_global_block_invalid_combinator(node, name) { e(node, 'css_global_block_invalid_combinator', `A \`:global\` selector cannot follow a \`${name}\` combinator\nhttps://svelte.dev/e/css_global_block_invalid_combinator`); } /** * A top-level `:global {...}` block can only contain rules, not declarations * @param {null | number | NodeLike} node * @returns {never} */ export function css_global_block_invalid_declaration(node) { e(node, 'css_global_block_invalid_declaration', `A top-level \`:global {...}\` block can only contain rules, not declarations\nhttps://svelte.dev/e/css_global_block_invalid_declaration`); } /** * A `:global` selector cannot be part of a selector list with entries that don't contain `:global` * @param {null | number | NodeLike} node * @returns {never} */ export function css_global_block_invalid_list(node) { e(node, 'css_global_block_invalid_list', `A \`:global\` selector cannot be part of a selector list with entries that don't contain \`:global\`\nhttps://svelte.dev/e/css_global_block_invalid_list`); } /** * A `:global` selector cannot modify an existing selector * @param {null | number | NodeLike} node * @returns {never} */ export function css_global_block_invalid_modifier(node) { e(node, 'css_global_block_invalid_modifier', `A \`:global\` selector cannot modify an existing selector\nhttps://svelte.dev/e/css_global_block_invalid_modifier`); } /** * A `:global` selector can only be modified if it is a descendant of other selectors * @param {null | number | NodeLike} node * @returns {never} */ export function css_global_block_invalid_modifier_start(node) { e(node, 'css_global_block_invalid_modifier_start', `A \`:global\` selector can only be modified if it is a descendant of other selectors\nhttps://svelte.dev/e/css_global_block_invalid_modifier_start`); } /** * A `:global` selector cannot be inside a pseudoclass * @param {null | number | NodeLike} node * @returns {never} */ export function css_global_block_invalid_placement(node) { e(node, 'css_global_block_invalid_placement', `A \`:global\` selector cannot be inside a pseudoclass\nhttps://svelte.dev/e/css_global_block_invalid_placement`); } /** * `:global(...)` can be at the start or end of a selector sequence, but not in the middle * @param {null | number | NodeLike} node * @returns {never} */ export function css_global_invalid_placement(node) { e(node, 'css_global_invalid_placement', `\`:global(...)\` can be at the start or end of a selector sequence, but not in the middle\nhttps://svelte.dev/e/css_global_invalid_placement`); } /** * `:global(...)` must contain exactly one selector * @param {null | number | NodeLike} node * @returns {never} */ export function css_global_invalid_selector(node) { e(node, 'css_global_invalid_selector', `\`:global(...)\` must contain exactly one selector\nhttps://svelte.dev/e/css_global_invalid_selector`); } /** * `:global(...)` must not contain type or universal selectors when used in a compound selector * @param {null | number | NodeLike} node * @returns {never} */ export function css_global_invalid_selector_list(node) { e(node, 'css_global_invalid_selector_list', `\`:global(...)\` must not contain type or universal selectors when used in a compound selector\nhttps://svelte.dev/e/css_global_invalid_selector_list`); } /** * Nesting selectors can only be used inside a rule or as the first selector inside a lone `:global(...)` * @param {null | number | NodeLike} node * @returns {never} */ export function css_nesting_selector_invalid_placement(node) { e(node, 'css_nesting_selector_invalid_placement', `Nesting selectors can only be used inside a rule or as the first selector inside a lone \`:global(...)\`\nhttps://svelte.dev/e/css_nesting_selector_invalid_placement`); } /** * Invalid selector * @param {null | number | NodeLike} node * @returns {never} */ export function css_selector_invalid(node) { e(node, 'css_selector_invalid', `Invalid selector\nhttps://svelte.dev/e/css_selector_invalid`); } /** * `:global(...)` must not be followed by a type selector * @param {null | number | NodeLike} node * @returns {never} */ export function css_type_selector_invalid_placement(node) { e(node, 'css_type_selector_invalid_placement', `\`:global(...)\` must not be followed by a type selector\nhttps://svelte.dev/e/css_type_selector_invalid_placement`); } /** * An element can only have one 'animate' directive * @param {null | number | NodeLike} node * @returns {never} */ export function animation_duplicate(node) { e(node, 'animation_duplicate', `An element can only have one 'animate' directive\nhttps://svelte.dev/e/animation_duplicate`); } /** * An element that uses the `animate:` directive must be the only child of a keyed `{#each ...}` block * @param {null | number | NodeLike} node * @returns {never} */ export function animation_invalid_placement(node) { e(node, 'animation_invalid_placement', `An element that uses the \`animate:\` directive must be the only child of a keyed \`{#each ...}\` block\nhttps://svelte.dev/e/animation_invalid_placement`); } /** * An element that uses the `animate:` directive must be the only child of a keyed `{#each ...}` block. Did you forget to add a key to your each block? * @param {null | number | NodeLike} node * @returns {never} */ export function animation_missing_key(node) { e(node, 'animation_missing_key', `An element that uses the \`animate:\` directive must be the only child of a keyed \`{#each ...}\` block. Did you forget to add a key to your each block?\nhttps://svelte.dev/e/animation_missing_key`); } /** * 'contenteditable' attribute cannot be dynamic if element uses two-way binding * @param {null | number | NodeLike} node * @returns {never} */ export function attribute_contenteditable_dynamic(node) { e(node, 'attribute_contenteditable_dynamic', `'contenteditable' attribute cannot be dynamic if element uses two-way binding\nhttps://svelte.dev/e/attribute_contenteditable_dynamic`); } /** * 'contenteditable' attribute is required for textContent, innerHTML and innerText two-way bindings * @param {null | number | NodeLike} node * @returns {never} */ export function attribute_contenteditable_missing(node) { e(node, 'attribute_contenteditable_missing', `'contenteditable' attribute is required for textContent, innerHTML and innerText two-way bindings\nhttps://svelte.dev/e/attribute_contenteditable_missing`); } /** * Attributes need to be unique * @param {null | number | NodeLike} node * @returns {never} */ export function attribute_duplicate(node) { e(node, 'attribute_duplicate', `Attributes need to be unique\nhttps://svelte.dev/e/attribute_duplicate`); } /** * Attribute shorthand cannot be empty * @param {null | number | NodeLike} node * @returns {never} */ export function attribute_empty_shorthand(node) { e(node, 'attribute_empty_shorthand', `Attribute shorthand cannot be empty\nhttps://svelte.dev/e/attribute_empty_shorthand`); } /** * Event attribute must be a JavaScript expression, not a string * @param {null | number | NodeLike} node * @returns {never} */ export function attribute_invalid_event_handler(node) { e(node, 'attribute_invalid_event_handler', `Event attribute must be a JavaScript expression, not a string\nhttps://svelte.dev/e/attribute_invalid_event_handler`); } /** * 'multiple' attribute must be static if select uses two-way binding * @param {null | number | NodeLike} node * @returns {never} */ export function attribute_invalid_multiple(node) { e(node, 'attribute_invalid_multiple', `'multiple' attribute must be static if select uses two-way binding\nhttps://svelte.dev/e/attribute_invalid_multiple`); } /** * '%name%' is not a valid attribute name * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function attribute_invalid_name(node, name) { e(node, 'attribute_invalid_name', `'${name}' is not a valid attribute name\nhttps://svelte.dev/e/attribute_invalid_name`); } /** * Sequence expressions are not allowed as attribute/directive values in runes mode, unless wrapped in parentheses * @param {null | number | NodeLike} node * @returns {never} */ export function attribute_invalid_sequence_expression(node) { e(node, 'attribute_invalid_sequence_expression', `Sequence expressions are not allowed as attribute/directive values in runes mode, unless wrapped in parentheses\nhttps://svelte.dev/e/attribute_invalid_sequence_expression`); } /** * 'type' attribute must be a static text value if input uses two-way binding * @param {null | number | NodeLike} node * @returns {never} */ export function attribute_invalid_type(node) { e(node, 'attribute_invalid_type', `'type' attribute must be a static text value if input uses two-way binding\nhttps://svelte.dev/e/attribute_invalid_type`); } /** * Attribute values containing `{...}` must be enclosed in quote marks, unless the value only contains the expression * @param {null | number | NodeLike} node * @returns {never} */ export function attribute_unquoted_sequence(node) { e(node, 'attribute_unquoted_sequence', `Attribute values containing \`{...}\` must be enclosed in quote marks, unless the value only contains the expression\nhttps://svelte.dev/e/attribute_unquoted_sequence`); } /** * `bind:group` can only bind to an Identifier or MemberExpression * @param {null | number | NodeLike} node * @returns {never} */ export function bind_group_invalid_expression(node) { e(node, 'bind_group_invalid_expression', `\`bind:group\` can only bind to an Identifier or MemberExpression\nhttps://svelte.dev/e/bind_group_invalid_expression`); } /** * Cannot `bind:group` to a snippet parameter * @param {null | number | NodeLike} node * @returns {never} */ export function bind_group_invalid_snippet_parameter(node) { e(node, 'bind_group_invalid_snippet_parameter', `Cannot \`bind:group\` to a snippet parameter\nhttps://svelte.dev/e/bind_group_invalid_snippet_parameter`); } /** * Can only bind to an Identifier or MemberExpression or a `{get, set}` pair * @param {null | number | NodeLike} node * @returns {never} */ export function bind_invalid_expression(node) { e(node, 'bind_invalid_expression', `Can only bind to an Identifier or MemberExpression or a \`{get, set}\` pair\nhttps://svelte.dev/e/bind_invalid_expression`); } /** * `bind:%name%` is not a valid binding. %explanation% * @param {null | number | NodeLike} node * @param {string} name * @param {string | undefined | null} [explanation] * @returns {never} */ export function bind_invalid_name(node, name, explanation) { e(node, 'bind_invalid_name', `${explanation ? `\`bind:${name}\` is not a valid binding. ${explanation}` : `\`bind:${name}\` is not a valid binding`}\nhttps://svelte.dev/e/bind_invalid_name`); } /** * `bind:%name%={get, set}` must not have surrounding parentheses * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function bind_invalid_parens(node, name) { e(node, 'bind_invalid_parens', `\`bind:${name}={get, set}\` must not have surrounding parentheses\nhttps://svelte.dev/e/bind_invalid_parens`); } /** * `bind:%name%` can only be used with %elements% * @param {null | number | NodeLike} node * @param {string} name * @param {string} elements * @returns {never} */ export function bind_invalid_target(node, name, elements) { e(node, 'bind_invalid_target', `\`bind:${name}\` can only be used with ${elements}\nhttps://svelte.dev/e/bind_invalid_target`); } /** * Can only bind to state or props * @param {null | number | NodeLike} node * @returns {never} */ export function bind_invalid_value(node) { e(node, 'bind_invalid_value', `Can only bind to state or props\nhttps://svelte.dev/e/bind_invalid_value`); } /** * %name% cannot appear more than once within a block * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function block_duplicate_clause(node, name) { e(node, 'block_duplicate_clause', `${name} cannot appear more than once within a block\nhttps://svelte.dev/e/block_duplicate_clause`); } /** * {:...} block is invalid at this position (did you forget to close the preceding element or block?) * @param {null | number | NodeLike} node * @returns {never} */ export function block_invalid_continuation_placement(node) { e(node, 'block_invalid_continuation_placement', `{:...} block is invalid at this position (did you forget to close the preceding element or block?)\nhttps://svelte.dev/e/block_invalid_continuation_placement`); } /** * 'elseif' should be 'else if' * @param {null | number | NodeLike} node * @returns {never} */ export function block_invalid_elseif(node) { e(node, 'block_invalid_elseif', `'elseif' should be 'else if'\nhttps://svelte.dev/e/block_invalid_elseif`); } /** * {#%name% ...} block cannot be %location% * @param {null | number | NodeLike} node * @param {string} name * @param {string} location * @returns {never} */ export function block_invalid_placement(node, name, location) { e(node, 'block_invalid_placement', `{#${name} ...} block cannot be ${location}\nhttps://svelte.dev/e/block_invalid_placement`); } /** * Block was left open * @param {null | number | NodeLike} node * @returns {never} */ export function block_unclosed(node) { e(node, 'block_unclosed', `Block was left open\nhttps://svelte.dev/e/block_unclosed`); } /** * Expected a `%character%` character immediately following the opening bracket * @param {null | number | NodeLike} node * @param {string} character * @returns {never} */ export function block_unexpected_character(node, character) { e(node, 'block_unexpected_character', `Expected a \`${character}\` character immediately following the opening bracket\nhttps://svelte.dev/e/block_unexpected_character`); } /** * Unexpected block closing tag * @param {null | number | NodeLike} node * @returns {never} */ export function block_unexpected_close(node) { e(node, 'block_unexpected_close', `Unexpected block closing tag\nhttps://svelte.dev/e/block_unexpected_close`); } /** * This type of directive is not valid on components * @param {null | number | NodeLike} node * @returns {never} */ export function component_invalid_directive(node) { e(node, 'component_invalid_directive', `This type of directive is not valid on components\nhttps://svelte.dev/e/component_invalid_directive`); } /** * Cyclical dependency detected: %cycle% * @param {null | number | NodeLike} node * @param {string} cycle * @returns {never} */ export function const_tag_cycle(node, cycle) { e(node, 'const_tag_cycle', `Cyclical dependency detected: ${cycle}\nhttps://svelte.dev/e/const_tag_cycle`); } /** * {@const ...} must consist of a single variable declaration * @param {null | number | NodeLike} node * @returns {never} */ export function const_tag_invalid_expression(node) { e(node, 'const_tag_invalid_expression', `{@const ...} must consist of a single variable declaration\nhttps://svelte.dev/e/const_tag_invalid_expression`); } /** * `{@const}` must be the immediate child of `{#snippet}`, `{#if}`, `{:else if}`, `{:else}`, `{#each}`, `{:then}`, `{:catch}`, `<svelte:fragment>`, `<svelte:boundary` or `<Component>` * @param {null | number | NodeLike} node * @returns {never} */ export function const_tag_invalid_placement(node) { e(node, 'const_tag_invalid_placement', `\`{@const}\` must be the immediate child of \`{#snippet}\`, \`{#if}\`, \`{:else if}\`, \`{:else}\`, \`{#each}\`, \`{:then}\`, \`{:catch}\`, \`<svelte:fragment>\`, \`<svelte:boundary\` or \`<Component>\`\nhttps://svelte.dev/e/const_tag_invalid_placement`); } /** * {@debug ...} arguments must be identifiers, not arbitrary expressions * @param {null | number | NodeLike} node * @returns {never} */ export function debug_tag_invalid_arguments(node) { e(node, 'debug_tag_invalid_arguments', `{@debug ...} arguments must be identifiers, not arbitrary expressions\nhttps://svelte.dev/e/debug_tag_invalid_arguments`); } /** * Directive value must be a JavaScript expression enclosed in curly braces * @param {null | number | NodeLike} node * @returns {never} */ export function directive_invalid_value(node) { e(node, 'directive_invalid_value', `Directive value must be a JavaScript expression enclosed in curly braces\nhttps://svelte.dev/e/directive_invalid_value`); } /** * `%type%` name cannot be empty * @param {null | number | NodeLike} node * @param {string} type * @returns {never} */ export function directive_missing_name(node, type) { e(node, 'directive_missing_name', `\`${type}\` name cannot be empty\nhttps://svelte.dev/e/directive_missing_name`); } /** * `</%name%>` attempted to close an element that was not open * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function element_invalid_closing_tag(node, name) { e(node, 'element_invalid_closing_tag', `\`</${name}>\` attempted to close an element that was not open\nhttps://svelte.dev/e/element_invalid_closing_tag`); } /** * `</%name%>` attempted to close element that was already automatically closed by `<%reason%>` (cannot nest `<%reason%>` inside `<%name%>`) * @param {null | number | NodeLike} node * @param {string} name * @param {string} reason * @returns {never} */ export function element_invalid_closing_tag_autoclosed(node, name, reason) { e(node, 'element_invalid_closing_tag_autoclosed', `\`</${name}>\` attempted to close element that was already automatically closed by \`<${reason}>\` (cannot nest \`<${reason}>\` inside \`<${name}>\`)\nhttps://svelte.dev/e/element_invalid_closing_tag_autoclosed`); } /** * `<%name%>` was left open * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function element_unclosed(node, name) { e(node, 'element_unclosed', `\`<${name}>\` was left open\nhttps://svelte.dev/e/element_unclosed`); } /** * Event modifiers other than 'once' can only be used on DOM elements * @param {null | number | NodeLike} node * @returns {never} */ export function event_handler_invalid_component_modifier(node) { e(node, 'event_handler_invalid_component_modifier', `Event modifiers other than 'once' can only be used on DOM elements\nhttps://svelte.dev/e/event_handler_invalid_component_modifier`); } /** * Valid event modifiers are %list% * @param {null | number | NodeLike} node * @param {string} list * @returns {never} */ export function event_handler_invalid_modifier(node, list) { e(node, 'event_handler_invalid_modifier', `Valid event modifiers are ${list}\nhttps://svelte.dev/e/event_handler_invalid_modifier`); } /** * The '%modifier1%' and '%modifier2%' modifiers cannot be used together * @param {null | number | NodeLike} node * @param {string} modifier1 * @param {string} modifier2 * @returns {never} */ export function event_handler_invalid_modifier_combination(node, modifier1, modifier2) { e(node, 'event_handler_invalid_modifier_combination', `The '${modifier1}' and '${modifier2}' modifiers cannot be used together\nhttps://svelte.dev/e/event_handler_invalid_modifier_combination`); } /** * Expected attribute value * @param {null | number | NodeLike} node * @returns {never} */ export function expected_attribute_value(node) { e(node, 'expected_attribute_value', `Expected attribute value\nhttps://svelte.dev/e/expected_attribute_value`); } /** * Expected 'if', 'each', 'await', 'key' or 'snippet' * @param {null | number | NodeLike} node * @returns {never} */ export function expected_block_type(node) { e(node, 'expected_block_type', `Expected 'if', 'each', 'await', 'key' or 'snippet'\nhttps://svelte.dev/e/expected_block_type`); } /** * Expected an identifier * @param {null | number | NodeLike} node * @returns {never} */ export function expected_identifier(node) { e(node, 'expected_identifier', `Expected an identifier\nhttps://svelte.dev/e/expected_identifier`); } /** * Expected identifier or destructure pattern * @param {null | number | NodeLike} node * @returns {never} */ export function expected_pattern(node) { e(node, 'expected_pattern', `Expected identifier or destructure pattern\nhttps://svelte.dev/e/expected_pattern`); } /** * Expected token %token% * @param {null | number | NodeLike} node * @param {string} token * @returns {never} */ export function expected_token(node, token) { e(node, 'expected_token', `Expected token ${token}\nhttps://svelte.dev/e/expected_token`); } /** * Expected whitespace * @param {null | number | NodeLike} node * @returns {never} */ export function expected_whitespace(node) { e(node, 'expected_whitespace', `Expected whitespace\nhttps://svelte.dev/e/expected_whitespace`); } /** * `<%name%>` does not support non-event attributes or spread attributes * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function illegal_element_attribute(node, name) { e(node, 'illegal_element_attribute', `\`<${name}>\` does not support non-event attributes or spread attributes\nhttps://svelte.dev/e/illegal_element_attribute`); } /** * %message% * @param {null | number | NodeLike} node * @param {string} message * @returns {never} */ export function js_parse_error(node, message) { e(node, 'js_parse_error', `${message}\nhttps://svelte.dev/e/js_parse_error`); } /** * `let:` directive at invalid position * @param {null | number | NodeLike} node * @returns {never} */ export function let_directive_invalid_placement(node) { e(node, 'let_directive_invalid_placement', `\`let:\` directive at invalid position\nhttps://svelte.dev/e/let_directive_invalid_placement`); } /** * Mixing old (on:%name%) and new syntaxes for event handling is not allowed. Use only the on%name% syntax * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function mixed_event_handler_syntaxes(node, name) { e(node, 'mixed_event_handler_syntaxes', `Mixing old (on:${name}) and new syntaxes for event handling is not allowed. Use only the on${name} syntax\nhttps://svelte.dev/e/mixed_event_handler_syntaxes`); } /** * %message%. The browser will 'repair' the HTML (by moving, removing, or inserting elements) which breaks Svelte's assumptions about the structure of your components. * @param {null | number | NodeLike} node * @param {string} message * @returns {never} */ export function node_invalid_placement(node, message) { e(node, 'node_invalid_placement', `${message}. The browser will 'repair' the HTML (by moving, removing, or inserting elements) which breaks Svelte's assumptions about the structure of your components.\nhttps://svelte.dev/e/node_invalid_placement`); } /** * Calling a snippet function using apply, bind or call is not allowed * @param {null | number | NodeLike} node * @returns {never} */ export function render_tag_invalid_call_expression(node) { e(node, 'render_tag_invalid_call_expression', `Calling a snippet function using apply, bind or call is not allowed\nhttps://svelte.dev/e/render_tag_invalid_call_expression`); } /** * `{@render ...}` tags can only contain call expressions * @param {null | number | NodeLike} node * @returns {never} */ export function render_tag_invalid_expression(node) { e(node, 'render_tag_invalid_expression', `\`{@render ...}\` tags can only contain call expressions\nhttps://svelte.dev/e/render_tag_invalid_expression`); } /** * cannot use spread arguments in `{@render ...}` tags * @param {null | number | NodeLike} node * @returns {never} */ export function render_tag_invalid_spread_argument(node) { e(node, 'render_tag_invalid_spread_argument', `cannot use spread arguments in \`{@render ...}\` tags\nhttps://svelte.dev/e/render_tag_invalid_spread_argument`); } /** * A component can have a single top-level `<script>` element and/or a single top-level `<script module>` element * @param {null | number | NodeLike} node * @returns {never} */ export function script_duplicate(node) { e(node, 'script_duplicate', `A component can have a single top-level \`<script>\` element and/or a single top-level \`<script module>\` element\nhttps://svelte.dev/e/script_duplicate`); } /** * If the `%name%` attribute is supplied, it must be a boolean attribute * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function script_invalid_attribute_value(node, name) { e(node, 'script_invalid_attribute_value', `If the \`${name}\` attribute is supplied, it must be a boolean attribute\nhttps://svelte.dev/e/script_invalid_attribute_value`); } /** * If the context attribute is supplied, its value must be "module" * @param {null | number | NodeLike} node * @returns {never} */ export function script_invalid_context(node) { e(node, 'script_invalid_context', `If the context attribute is supplied, its value must be "module"\nhttps://svelte.dev/e/script_invalid_context`); } /** * The `%name%` attribute is reserved and cannot be used * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function script_reserved_attribute(node, name) { e(node, 'script_reserved_attribute', `The \`${name}\` attribute is reserved and cannot be used\nhttps://svelte.dev/e/script_reserved_attribute`); } /** * Duplicate slot name '%name%' in <%component%> * @param {null | number | NodeLike} node * @param {string} name * @param {string} component * @returns {never} */ export function slot_attribute_duplicate(node, name, component) { e(node, 'slot_attribute_duplicate', `Duplicate slot name '${name}' in <${component}>\nhttps://svelte.dev/e/slot_attribute_duplicate`); } /** * slot attribute must be a static value * @param {null | number | NodeLike} node * @returns {never} */ export function slot_attribute_invalid(node) { e(node, 'slot_attribute_invalid', `slot attribute must be a static value\nhttps://svelte.dev/e/slot_attribute_invalid`); } /** * Element with a slot='...' attribute must be a child of a component or a descendant of a custom element * @param {null | number | NodeLike} node * @returns {never} */ export function slot_attribute_invalid_placement(node) { e(node, 'slot_attribute_invalid_placement', `Element with a slot='...' attribute must be a child of a component or a descendant of a custom element\nhttps://svelte.dev/e/slot_attribute_invalid_placement`); } /** * Found default slot content alongside an explicit slot="default" * @param {null | number | NodeLike} node * @returns {never} */ export function slot_default_duplicate(node) { e(node, 'slot_default_duplicate', `Found default slot content alongside an explicit slot="default"\nhttps://svelte.dev/e/slot_default_duplicate`); } /** * `<slot>` can only receive attributes and (optionally) let directives * @param {null | number | NodeLike} node * @returns {never} */ export function slot_element_invalid_attribute(node) { e(node, 'slot_element_invalid_attribute', `\`<slot>\` can only receive attributes and (optionally) let directives\nhttps://svelte.dev/e/slot_element_invalid_attribute`); } /** * slot attribute must be a static value * @param {null | number | NodeLike} node * @returns {never} */ export function slot_element_invalid_name(node) { e(node, 'slot_element_invalid_name', `slot attribute must be a static value\nhttps://svelte.dev/e/slot_element_invalid_name`); } /** * `default` is a reserved word — it cannot be used as a slot name * @param {null | number | NodeLike} node * @returns {never} */ export function slot_element_invalid_name_default(node) { e(node, 'slot_element_invalid_name_default', `\`default\` is a reserved word — it cannot be used as a slot name\nhttps://svelte.dev/e/slot_element_invalid_name_default`); } /** * Cannot use `<slot>` syntax and `{@render ...}` tags in the same component. Migrate towards `{@render ...}` tags completely * @param {null | number | NodeLike} node * @returns {never} */ export function slot_snippet_conflict(node) { e(node, 'slot_snippet_conflict', `Cannot use \`<slot>\` syntax and \`{@render ...}\` tags in the same component. Migrate towards \`{@render ...}\` tags completely\nhttps://svelte.dev/e/slot_snippet_conflict`); } /** * Cannot use explicit children snippet at the same time as implicit children content. Remove either the non-whitespace content or the children snippet block * @param {null | number | NodeLike} node * @returns {never} */ export function snippet_conflict(node) { e(node, 'snippet_conflict', `Cannot use explicit children snippet at the same time as implicit children content. Remove either the non-whitespace content or the children snippet block\nhttps://svelte.dev/e/snippet_conflict`); } /** * Snippets do not support rest parameters; use an array instead * @param {null | number | NodeLike} node * @returns {never} */ export function snippet_invalid_rest_parameter(node) { e(node, 'snippet_invalid_rest_parameter', `Snippets do not support rest parameters; use an array instead\nhttps://svelte.dev/e/snippet_invalid_rest_parameter`); } /** * This snippet is shadowing the prop `%prop%` with the same name * @param {null | number | NodeLike} node * @param {string} prop * @returns {never} */ export function snippet_shadowing_prop(node, prop) { e(node, 'snippet_shadowing_prop', `This snippet is shadowing the prop \`${prop}\` with the same name\nhttps://svelte.dev/e/snippet_shadowing_prop`); } /** * `style:` directive can only use the `important` modifier * @param {null | number | NodeLike} node * @returns {never} */ export function style_directive_invalid_modifier(node) { e(node, 'style_directive_invalid_modifier', `\`style:\` directive can only use the \`important\` modifier\nhttps://svelte.dev/e/style_directive_invalid_modifier`); } /** * A component can have a single top-level `<style>` element * @param {null | number | NodeLike} node * @returns {never} */ export function style_duplicate(node) { e(node, 'style_duplicate', `A component can have a single top-level \`<style>\` element\nhttps://svelte.dev/e/style_duplicate`); } /** * `<svelte:body>` does not support non-event attributes or spread attributes * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_body_illegal_attribute(node) { e(node, 'svelte_body_illegal_attribute', `\`<svelte:body>\` does not support non-event attributes or spread attributes\nhttps://svelte.dev/e/svelte_body_illegal_attribute`); } /** * Valid attributes on `<svelte:boundary>` are `onerror` and `failed` * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_boundary_invalid_attribute(node) { e(node, 'svelte_boundary_invalid_attribute', `Valid attributes on \`<svelte:boundary>\` are \`onerror\` and \`failed\`\nhttps://svelte.dev/e/svelte_boundary_invalid_attribute`); } /** * Attribute value must be a non-string expression * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_boundary_invalid_attribute_value(node) { e(node, 'svelte_boundary_invalid_attribute_value', `Attribute value must be a non-string expression\nhttps://svelte.dev/e/svelte_boundary_invalid_attribute_value`); } /** * Invalid component definition — must be an `{expression}` * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_component_invalid_this(node) { e(node, 'svelte_component_invalid_this', `Invalid component definition — must be an \`{expression}\`\nhttps://svelte.dev/e/svelte_component_invalid_this`); } /** * `<svelte:component>` must have a 'this' attribute * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_component_missing_this(node) { e(node, 'svelte_component_missing_this', `\`<svelte:component>\` must have a 'this' attribute\nhttps://svelte.dev/e/svelte_component_missing_this`); } /** * `<svelte:element>` must have a 'this' attribute with a value * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_element_missing_this(node) { e(node, 'svelte_element_missing_this', `\`<svelte:element>\` must have a 'this' attribute with a value\nhttps://svelte.dev/e/svelte_element_missing_this`); } /** * `<svelte:fragment>` can only have a slot attribute and (optionally) a let: directive * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_fragment_invalid_attribute(node) { e(node, 'svelte_fragment_invalid_attribute', `\`<svelte:fragment>\` can only have a slot attribute and (optionally) a let: directive\nhttps://svelte.dev/e/svelte_fragment_invalid_attribute`); } /** * `<svelte:fragment>` must be the direct child of a component * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_fragment_invalid_placement(node) { e(node, 'svelte_fragment_invalid_placement', `\`<svelte:fragment>\` must be the direct child of a component\nhttps://svelte.dev/e/svelte_fragment_invalid_placement`); } /** * `<svelte:head>` cannot have attributes nor directives * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_head_illegal_attribute(node) { e(node, 'svelte_head_illegal_attribute', `\`<svelte:head>\` cannot have attributes nor directives\nhttps://svelte.dev/e/svelte_head_illegal_attribute`); } /** * A component can only have one `<%name%>` element * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function svelte_meta_duplicate(node, name) { e(node, 'svelte_meta_duplicate', `A component can only have one \`<${name}>\` element\nhttps://svelte.dev/e/svelte_meta_duplicate`); } /** * <%name%> cannot have children * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function svelte_meta_invalid_content(node, name) { e(node, 'svelte_meta_invalid_content', `<${name}> cannot have children\nhttps://svelte.dev/e/svelte_meta_invalid_content`); } /** * `<%name%>` tags cannot be inside elements or blocks * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function svelte_meta_invalid_placement(node, name) { e(node, 'svelte_meta_invalid_placement', `\`<${name}>\` tags cannot be inside elements or blocks\nhttps://svelte.dev/e/svelte_meta_invalid_placement`); } /** * Valid `<svelte:...>` tag names are %list% * @param {null | number | NodeLike} node * @param {string} list * @returns {never} */ export function svelte_meta_invalid_tag(node, list) { e(node, 'svelte_meta_invalid_tag', `Valid \`<svelte:...>\` tag names are ${list}\nhttps://svelte.dev/e/svelte_meta_invalid_tag`); } /** * "tag" option is deprecated — use "customElement" instead * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_options_deprecated_tag(node) { e(node, 'svelte_options_deprecated_tag', `"tag" option is deprecated — use "customElement" instead\nhttps://svelte.dev/e/svelte_options_deprecated_tag`); } /** * `<svelte:options>` can only receive static attributes * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_options_invalid_attribute(node) { e(node, 'svelte_options_invalid_attribute', `\`<svelte:options>\` can only receive static attributes\nhttps://svelte.dev/e/svelte_options_invalid_attribute`); } /** * Value must be %list%, if specified * @param {null | number | NodeLike} node * @param {string} list * @returns {never} */ export function svelte_options_invalid_attribute_value(node, list) { e(node, 'svelte_options_invalid_attribute_value', `Value must be ${list}, if specified\nhttps://svelte.dev/e/svelte_options_invalid_attribute_value`); } /** * "customElement" must be a string literal defining a valid custom element name or an object of the form { tag?: string; shadow?: "open" | "none"; props?: { [key: string]: { attribute?: string; reflect?: boolean; type: .. } } } * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_options_invalid_customelement(node) { e(node, 'svelte_options_invalid_customelement', `"customElement" must be a string literal defining a valid custom element name or an object of the form { tag?: string; shadow?: "open" | "none"; props?: { [key: string]: { attribute?: string; reflect?: boolean; type: .. } } }\nhttps://svelte.dev/e/svelte_options_invalid_customelement`); } /** * "props" must be a statically analyzable object literal of the form "{ [key: string]: { attribute?: string; reflect?: boolean; type?: "String" | "Boolean" | "Number" | "Array" | "Object" }" * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_options_invalid_customelement_props(node) { e(node, 'svelte_options_invalid_customelement_props', `"props" must be a statically analyzable object literal of the form "{ [key: string]: { attribute?: string; reflect?: boolean; type?: "String" | "Boolean" | "Number" | "Array" | "Object" }"\nhttps://svelte.dev/e/svelte_options_invalid_customelement_props`); } /** * "shadow" must be either "open" or "none" * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_options_invalid_customelement_shadow(node) { e(node, 'svelte_options_invalid_customelement_shadow', `"shadow" must be either "open" or "none"\nhttps://svelte.dev/e/svelte_options_invalid_customelement_shadow`); } /** * Tag name must be lowercase and hyphenated * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_options_invalid_tagname(node) { e(node, 'svelte_options_invalid_tagname', `Tag name must be lowercase and hyphenated\nhttps://svelte.dev/e/svelte_options_invalid_tagname`); } /** * Tag name is reserved * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_options_reserved_tagname(node) { e(node, 'svelte_options_reserved_tagname', `Tag name is reserved\nhttps://svelte.dev/e/svelte_options_reserved_tagname`); } /** * `<svelte:options>` unknown attribute '%name%' * @param {null | number | NodeLike} node * @param {string} name * @returns {never} */ export function svelte_options_unknown_attribute(node, name) { e(node, 'svelte_options_unknown_attribute', `\`<svelte:options>\` unknown attribute '${name}'\nhttps://svelte.dev/e/svelte_options_unknown_attribute`); } /** * `<svelte:self>` components can only exist inside `{#if}` blocks, `{#each}` blocks, `{#snippet}` blocks or slots passed to components * @param {null | number | NodeLike} node * @returns {never} */ export function svelte_self_invalid_placement(node) { e(node, 'svelte_self_invalid_placement', `\`<svelte:self>\` components can only exist inside \`{#if}\` blocks, \`{#each}\` blocks, \`{#snippet}\` blocks or slots passed to components\nhttps://svelte.dev/e/svelte_self_invalid_placement`); } /** * Expected a valid element or component name. Components must have a valid variable name or dot notation expression * @param {null | number | NodeLike} node * @returns {never} */ export function tag_invalid_name(node) { e(node, 'tag_invalid_name', `Expected a valid element or component name. Components must have a valid variable name or dot notation expression\nhttps://svelte.dev/e/tag_invalid_name`); } /** * {@%name% ...} tag cannot be %location% * @param {null | number | NodeLike} node * @param {string} name * @param {string} location * @returns {never} */ export function tag_invalid_placement(node, name, location) { e(node, 'tag_invalid_placement', `{@${name} ...} tag cannot be ${location}\nhttps://svelte.dev/e/tag_invalid_placement`); } /** * A `<textarea>` can have either a value attribute or (equivalently) child content, but not both * @param {null | number | NodeLike} node * @returns {never} */ export function textarea_invalid_content(node) { e(node, 'textarea_invalid_content', `A \`<textarea>\` can have either a value attribute or (equivalently) child content, but not both\nhttps://svelte.dev/e/textarea_invalid_content`); } /** * `<title>` cannot have attributes nor directives * @param {null | number | NodeLike} node * @returns {never} */ export function title_illegal_attribute(node) { e(node, 'title_illegal_attribute', `\`<title>\` cannot have attributes nor directives\nhttps://svelte.dev/e/title_illegal_attribute`); } /** * `<title>` can only contain text and {tags} * @param {null | number | NodeLike} node * @returns {never} */ export function title_invalid_content(node) { e(node, 'title_invalid_content', `\`<title>\` can only contain text and {tags}\nhttps://svelte.dev/e/title_invalid_content`); } /** * Cannot use `%type%:` alongside existing `%existing%:` directive * @param {null | number | NodeLike} node * @param {string} type * @param {string} existing * @returns {never} */ export function transition_conflict(node, type, existing) { e(node, 'transition_conflict', `Cannot use \`${type}:\` alongside existing \`${existing}:\` directive\nhttps://svelte.dev/e/transition_conflict`); } /** * Cannot use multiple `%type%:` directives on a single element * @param {null | number | NodeLike} node * @param {string} type * @returns {never} */ export function transition_duplicate(node, type) { e(node, 'transition_duplicate', `Cannot use multiple \`${type}:\` directives on a single element\nhttps://svelte.dev/e/transition_duplicate`); } /** * Unexpected end of input * @param {null | number | NodeLike} node * @returns {never} */ export function unexpected_eof(node) { e(node, 'unexpected_eof', `Unexpected end of input\nhttps://svelte.dev/e/unexpected_eof`); } /** * '%word%' is a reserved word in JavaScript and cannot be used here * @param {null | number | NodeLike} node * @param {string} word * @returns {never} */ export function unexpected_reserved_word(node, word) { e(node, 'unexpected_reserved_word', `'${word}' is a reserved word in JavaScript and cannot be used here\nhttps://svelte.dev/e/unexpected_reserved_word`); } /** * Unterminated string constant * @param {null | number | NodeLike} node * @returns {never} */ export function unterminated_string_constant(node) { e(node, 'unterminated_string_constant', `Unterminated string constant\nhttps://svelte.dev/e/unterminated_string_constant`); } /** * Void elements cannot have children or closing tags * @param {null | number | NodeLike} node * @returns {never} */ export function void_element_invalid_content(node) { e(node, 'void_element_invalid_content', `Void elements cannot have children or closing tags\nhttps://svelte.dev/e/void_element_invalid_content`); }
```

# compiler/index.js

```js
/** @import { LegacyRoot } from './types/legacy-nodes.js' */ /** @import { CompileOptions, CompileResult, ValidatedCompileOptions, ModuleCompileOptions } from '#compiler' */ /** @import { AST } from './public.js' */ import { walk as zimmerframe_walk } from 'zimmerframe'; import { convert } from './legacy.js'; import { parse as _parse } from './phases/1-parse/index.js'; import { remove_typescript_nodes } from './phases/1-parse/remove_typescript_nodes.js'; import { analyze_component, analyze_module } from './phases/2-analyze/index.js'; import { transform_component, transform_module } from './phases/3-transform/index.js'; import { validate_component_options, validate_module_options } from './validate-options.js'; import * as state from './state.js'; export { default as preprocess } from './preprocess/index.js'; /** * `compile` converts your `.svelte` source code into a JavaScript module that exports a component * * @param {string} source The component source code * @param {CompileOptions} options The compiler options * @returns {CompileResult} */ export function compile(source, options) { source = remove_bom(source); state.reset_warnings(options.warningFilter); const validated = validate_component_options(options, ''); let parsed = _parse(source); const { customElement: customElementOptions, ...parsed_options } = parsed.options || {}; /** @type {ValidatedCompileOptions} */ const combined_options = { ...validated, ...parsed_options, customElementOptions }; if (parsed.metadata.ts) { parsed = { ...parsed, fragment: parsed.fragment && remove_typescript_nodes(parsed.fragment), instance: parsed.instance && remove_typescript_nodes(parsed.instance), module: parsed.module && remove_typescript_nodes(parsed.module) }; if (combined_options.customElementOptions?.extend) { combined_options.customElementOptions.extend = remove_typescript_nodes( combined_options.customElementOptions?.extend ); } } const analysis = analyze_component(parsed, source, combined_options); const result = transform_component(analysis, source, combined_options); result.ast = to_public_ast(source, parsed, options.modernAst); return result; } /** * `compileModule` takes your JavaScript source code containing runes, and turns it into a JavaScript module. * * @param {string} source The component source code * @param {ModuleCompileOptions} options * @returns {CompileResult} */ export function compileModule(source, options) { source = remove_bom(source); state.reset_warnings(options.warningFilter); const validated = validate_module_options(options, ''); const analysis = analyze_module(source, validated); return transform_module(analysis, source, validated); } /** * The parse function parses a component, returning only its abstract syntax tree. * * The `modern` option (`false` by default in Svelte 5) makes the parser return a modern AST instead of the legacy AST. * `modern` will become `true` by default in Svelte 6, and the option will be removed in Svelte 7. * * @overload * @param {string} source * @param {{ filename?: string; modern: true; loose?: boolean }} options * @returns {AST.Root} */ /** * The parse function parses a component, returning only its abstract syntax tree. * * The `modern` option (`false` by default in Svelte 5) makes the parser return a modern AST instead of the legacy AST. * `modern` will become `true` by default in Svelte 6, and the option will be removed in Svelte 7. * * @overload * @param {string} source * @param {{ filename?: string; modern?: false; loose?: boolean }} [options] * @returns {Record<string, any>} */ // TODO 6.0 remove unused `filename` /** * The parse function parses a component, returning only its abstract syntax tree. * * The `modern` option (`false` by default in Svelte 5) makes the parser return a modern AST instead of the legacy AST. * `modern` will become `true` by default in Svelte 6, and the option will be removed in Svelte 7. * * The `loose` option, available since 5.13.0, tries to always return an AST even if the input will not successfully compile. * * The `filename` option is unused and will be removed in Svelte 6.0. * * @param {string} source * @param {{ filename?: string; rootDir?: string; modern?: boolean; loose?: boolean }} [options] * @returns {AST.Root | LegacyRoot} */ export function parse(source, { modern, loose } = {}) { source = remove_bom(source); state.reset_warnings(() => false); const ast = _parse(source, loose); return to_public_ast(source, ast, modern); } /** * @param {string} source * @param {AST.Root} ast * @param {boolean | undefined} modern */ function to_public_ast(source, ast, modern) { if (modern) { const clean = (/** @type {any} */ node) => { delete node.metadata; }; ast.options?.attributes.forEach((attribute) => { clean(attribute); clean(attribute.value); if (Array.isArray(attribute.value)) { attribute.value.forEach(clean); } }); // remove things that we don't want to treat as public API return zimmerframe_walk(ast, null, { _(node, { next }) { clean(node); next(); } }); } return convert(source, ast); } /** * Remove the byte order mark from a string if it's present since it would mess with our template generation logic * @param {string} source */ function remove_bom(source) { if (source.charCodeAt(0) === 0xfeff) { return source.slice(1); } return source; } /** * @deprecated Replace this with `import { walk } from 'estree-walker'` * @returns {never} */ export function walk() { throw new Error( `'svelte/compiler' no longer exports a \`walk\` utility — please import it directly from 'estree-walker' instead` ); } export { VERSION } from '../version.js'; export { migrate } from './migrate/index.js';
```

# compiler/legacy.js

```js
/** @import { Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import * as Legacy from './types/legacy-nodes.js' */ import { walk } from 'zimmerframe'; import { regex_ends_with_whitespaces, regex_not_whitespace, regex_starts_with_whitespaces } from './phases/patterns.js'; import { extract_svelte_ignore } from './utils/extract_svelte_ignore.js'; /** * Some of the legacy Svelte AST nodes remove whitespace from the start and end of their children. * @param {AST.TemplateNode[]} nodes */ function remove_surrounding_whitespace_nodes(nodes) { const first = nodes.at(0); const last = nodes.at(-1); if (first?.type === 'Text') { if (!regex_not_whitespace.test(first.data)) { nodes.shift(); } else { first.data = first.data.replace(regex_starts_with_whitespaces, ''); } } if (last?.type === 'Text') { if (!regex_not_whitespace.test(last.data)) { nodes.pop(); } else { last.data = last.data.replace(regex_ends_with_whitespaces, ''); } } } /** * Transform our nice modern AST into the monstrosity emitted by Svelte 4 * @param {string} source * @param {AST.Root} ast * @returns {Legacy.LegacyRoot} */ export function convert(source, ast) { const root = /** @type {AST.SvelteNode | Legacy.LegacySvelteNode} */ (ast); return /** @type {Legacy.LegacyRoot} */ ( walk(root, null, { _(node, { next }) { // @ts-ignore delete node.metadata; next(); }, // @ts-ignore Root(node, { visit }) { const { instance, module, options } = node; // Insert svelte:options back into the root nodes if (/** @type {any} */ (options)?.__raw__) { let idx = node.fragment.nodes.findIndex((node) => options.end <= node.start); if (idx === -1) { idx = node.fragment.nodes.length; } node.fragment.nodes.splice(idx, 0, /** @type {any} */ (options).__raw__); } /** @type {number | null} */ let start = null; /** @type {number | null} */ let end = null; if (node.fragment.nodes.length > 0) { const first = /** @type {AST.BaseNode} */ (node.fragment.nodes.at(0)); const last = /** @type {AST.BaseNode} */ (node.fragment.nodes.at(-1)); start = first.start; end = last.end; while (/\s/.test(source[start])) start += 1; while (/\s/.test(source[end - 1])) end -= 1; } if (instance) { // @ts-ignore delete instance.attributes; } if (module) { // @ts-ignore delete module.attributes; } return { html: { type: 'Fragment', start, end, children: node.fragment.nodes.map((child) => visit(child)) }, instance, module, css: ast.css ? visit(ast.css) : undefined }; }, AnimateDirective(node) { return { ...node, type: 'Animation' }; }, // @ts-ignore AwaitBlock(node, { visit }) { let pendingblock = { type: 'PendingBlock', /** @type {number | null} */ start: null, /** @type {number | null} */ end: null, children: node.pending?.nodes.map((child) => visit(child)) ?? [], skip: true }; let thenblock = { type: 'ThenBlock', /** @type {number | null} */ start: null, /** @type {number | null} */ end: null, children: node.then?.nodes.map((child) => visit(child)) ?? [], skip: true }; let catchblock = { type: 'CatchBlock', /** @type {number | null} */ start: null, /** @type {number | null} */ end: null, children: node.catch?.nodes.map((child) => visit(child)) ?? [], skip: true }; if (node.pending) { const first = node.pending.nodes.at(0); const last = node.pending.nodes.at(-1); pendingblock.start = first?.start ?? source.indexOf('}', node.expression.end) + 1; pendingblock.end = last?.end ?? pendingblock.start; pendingblock.skip = false; } if (node.then) { const first = node.then.nodes.at(0); const last = node.then.nodes.at(-1); thenblock.start = pendingblock.end ?? first?.start ?? source.indexOf('}', node.expression.end) + 1; thenblock.end = last?.end ?? source.lastIndexOf('}', pendingblock.end ?? node.expression.end) + 1; thenblock.skip = false; } if (node.catch) { const first = node.catch.nodes.at(0); const last = node.catch.nodes.at(-1); catchblock.start = thenblock.end ?? pendingblock.end ?? first?.start ?? source.indexOf('}', node.expression.end) + 1; catchblock.end = last?.end ?? source.lastIndexOf('}', thenblock.end ?? pendingblock.end ?? node.expression.end) + 1; catchblock.skip = false; } return { type: 'AwaitBlock', start: node.start, end: node.end, expression: node.expression, value: node.value, error: node.error, pending: pendingblock, then: thenblock, catch: catchblock }; }, BindDirective(node) { return { ...node, type: 'Binding' }; }, ClassDirective(node) { return { ...node, type: 'Class' }; }, Comment(node) { return { ...node, ignores: extract_svelte_ignore(node.start, node.data, false) }; }, ComplexSelector(node, { next }) { next(); // delete inner metadata/parent properties const children = []; for (const child of node.children) { if (child.combinator) { children.push(child.combinator); } children.push(...child.selectors); } return { type: 'Selector', start: node.start, end: node.end, children }; }, Component(node, { visit }) { return { type: 'InlineComponent', start: node.start, end: node.end, name: node.name, attributes: node.attributes.map( (child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child)) ), children: node.fragment.nodes.map( (child) => /** @type {Legacy.LegacyElementLike} */ (visit(child)) ) }; }, // @ts-ignore ConstTag(node) { if (/** @type {Legacy.LegacyConstTag} */ (node).expression !== undefined) { return node; } const modern_node = /** @type {AST.ConstTag} */ (node); const { id: left } = { ...modern_node.declaration.declarations[0] }; // @ts-ignore delete left.typeAnnotation; return { type: 'ConstTag', start: modern_node.start, end: node.end, expression: { type: 'AssignmentExpression', start: (modern_node.declaration.start ?? 0) + 'const '.length, end: modern_node.declaration.end ?? 0, operator: '=', left, right: modern_node.declaration.declarations[0].init } }; }, // @ts-ignore KeyBlock(node, { visit }) { remove_surrounding_whitespace_nodes(node.fragment.nodes); return { type: 'KeyBlock', start: node.start, end: node.end, expression: node.expression, children: node.fragment.nodes.map( (child) => /** @type {Legacy.LegacyElementLike} */ (visit(child)) ) }; }, // @ts-ignore EachBlock(node, { visit }) { let elseblock = undefined; if (node.fallback) { const first = node.fallback.nodes.at(0); const end = source.lastIndexOf('{', /** @type {number} */ (node.end) - 1); const start = first?.start ?? end; remove_surrounding_whitespace_nodes(node.fallback.nodes); elseblock = { type: 'ElseBlock', start, end, children: node.fallback.nodes.map((child) => visit(child)) }; } remove_surrounding_whitespace_nodes(node.body.nodes); return { type: 'EachBlock', start: node.start, end: node.end, children: node.body.nodes.map((child) => visit(child)), context: node.context, expression: node.expression, index: node.index, key: node.key, else: elseblock }; }, ExpressionTag(node, { path }) { const parent = path.at(-1); if (parent?.type === 'Attribute') { if (source[parent.start] === '{') { return { type: 'AttributeShorthand', start: node.start, end: node.end, expression: node.expression }; } } return { type: 'MustacheTag', start: node.start, end: node.end, expression: node.expression }; }, HtmlTag(node) { return { ...node, type: 'RawMustacheTag' }; }, // @ts-ignore IfBlock(node, { visit }) { let elseblock = undefined; if (node.alternate) { let nodes = node.alternate.nodes; if (nodes.length === 1 && nodes[0].type === 'IfBlock' && nodes[0].elseif) { nodes = nodes[0].consequent.nodes; } const end = source.lastIndexOf('{', /** @type {number} */ (node.end) - 1); const start = nodes.at(0)?.start ?? end; remove_surrounding_whitespace_nodes(node.alternate.nodes); elseblock = { type: 'ElseBlock', start, end: end, children: node.alternate.nodes.map( (child) => /** @type {Legacy.LegacyElementLike} */ (visit(child)) ) }; } const start = node.elseif ? node.consequent.nodes[0]?.start ?? source.lastIndexOf('{', /** @type {number} */ (node.end) - 1) : node.start; remove_surrounding_whitespace_nodes(node.consequent.nodes); return { type: 'IfBlock', start, end: node.end, expression: node.test, children: node.consequent.nodes.map( (child) => /** @type {Legacy.LegacyElementLike} */ (visit(child)) ), else: elseblock, elseif: node.elseif ? true : undefined }; }, OnDirective(node) { return { ...node, type: 'EventHandler' }; }, // @ts-expect-error SnippetBlock(node, { visit }) { remove_surrounding_whitespace_nodes(node.body.nodes); return { type: 'SnippetBlock', start: node.start, end: node.end, expression: node.expression, parameters: node.parameters, children: node.body.nodes.map((child) => visit(child)), typeParams: node.typeParams }; }, // @ts-expect-error SvelteBoundary(node, { visit }) { remove_surrounding_whitespace_nodes(node.fragment.nodes); return { type: 'SvelteBoundary', name: 'svelte:boundary', start: node.start, end: node.end, attributes: node.attributes.map( (child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child)) ), children: node.fragment.nodes.map((child) => visit(child)) }; }, RegularElement(node, { visit }) { return { type: 'Element', start: node.start, end: node.end, name: node.name, attributes: node.attributes.map((child) => visit(child)), children: node.fragment.nodes.map((child) => visit(child)) }; }, SlotElement(node, { visit }) { return { type: 'Slot', start: node.start, end: node.end, name: node.name, attributes: node.attributes.map( (child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child)) ), children: node.fragment.nodes.map( (child) => /** @type {Legacy.LegacyElementLike} */ (visit(child)) ) }; }, Attribute(node, { visit, next, path }) { if (node.value !== true && !Array.isArray(node.value)) { path.push(node); const value = /** @type {Legacy.LegacyAttribute['value']} */ ([visit(node.value)]); path.pop(); return { ...node, value }; } else { return next(); } }, StyleDirective(node, { visit, next, path }) { if (node.value !== true && !Array.isArray(node.value)) { path.push(node); const value = /** @type {Legacy.LegacyStyleDirective['value']} */ ([visit(node.value)]); path.pop(); return { ...node, value }; } else { return next(); } }, SpreadAttribute(node) { return { ...node, type: 'Spread' }; }, // @ts-ignore StyleSheet(node, context) { return { ...node, ...context.next(), type: 'Style' }; }, SvelteBody(node, { visit }) { return { type: 'Body', name: 'svelte:body', start: node.start, end: node.end, attributes: node.attributes.map( (child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child)) ), children: node.fragment.nodes.map( (child) => /** @type {Legacy.LegacyElementLike} */ (visit(child)) ) }; }, SvelteComponent(node, { visit }) { return { type: 'InlineComponent', name: 'svelte:component', start: node.start, end: node.end, expression: node.expression, attributes: node.attributes.map( (child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child)) ), children: node.fragment.nodes.map( (child) => /** @type {Legacy.LegacyElementLike} */ (visit(child)) ) }; }, SvelteDocument(node, { visit }) { return { type: 'Document', name: 'svelte:document', start: node.start, end: node.end, attributes: node.attributes.map( (child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child)) ), children: node.fragment.nodes.map( (child) => /** @type {Legacy.LegacyElementLike} */ (visit(child)) ) }; }, SvelteElement(node, { visit }) { /** @type {Expression | string} */ let tag = node.tag; if ( tag.type === 'Literal' && typeof tag.value === 'string' && source[/** @type {number} */ (node.tag.start) - 1] !== '{' ) { tag = tag.value; } return { type: 'Element', name: 'svelte:element', start: node.start, end: node.end, tag, attributes: node.attributes.map((child) => visit(child)), children: node.fragment.nodes.map((child) => visit(child)) }; }, SvelteFragment(node, { visit }) { return { type: 'SlotTemplate', name: 'svelte:fragment', start: node.start, end: node.end, attributes: node.attributes.map( (a) => /** @type {Legacy.LegacyAttributeLike} */ (visit(a)) ), children: node.fragment.nodes.map( (child) => /** @type {Legacy.LegacyElementLike} */ (visit(child)) ) }; }, SvelteHead(node, { visit }) { return { type: 'Head', name: 'svelte:head', start: node.start, end: node.end, attributes: node.attributes.map( (child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child)) ), children: node.fragment.nodes.map( (child) => /** @type {Legacy.LegacyElementLike} */ (visit(child)) ) }; }, SvelteOptions(node, { visit }) { return { type: 'Options', name: 'svelte:options', start: node.start, end: node.end, attributes: node.attributes.map( (child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child)) ) }; }, SvelteSelf(node, { visit }) { return { type: 'InlineComponent', name: 'svelte:self', start: node.start, end: node.end, attributes: node.attributes.map( (child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child)) ), children: node.fragment.nodes.map( (child) => /** @type {Legacy.LegacyElementLike} */ (visit(child)) ) }; }, SvelteWindow(node, { visit }) { return { type: 'Window', name: 'svelte:window', start: node.start, end: node.end, attributes: node.attributes.map( (child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child)) ), children: node.fragment.nodes.map( (child) => /** @type {Legacy.LegacyElementLike} */ (visit(child)) ) }; }, Text(node, { path }) { const parent = path.at(-1); if (parent?.type === 'RegularElement' && parent.name === 'style') { // these text nodes are missing `raw` for some dumb reason return /** @type {AST.Text} */ ({ type: 'Text', start: node.start, end: node.end, data: node.data }); } }, TitleElement(node, { visit }) { return { type: 'Title', name: 'title', start: node.start, end: node.end, attributes: node.attributes.map( (child) => /** @type {Legacy.LegacyAttributeLike} */ (visit(child)) ), children: node.fragment.nodes.map( (child) => /** @type {Legacy.LegacyElementLike} */ (visit(child)) ) }; }, TransitionDirective(node) { return { ...node, type: 'Transition' }; }, UseDirective(node) { return { ...node, type: 'Action' }; }, LetDirective(node) { return { ...node, type: 'Let' }; } }) ); }
```

# compiler/migrate/index.js

```js
/** @import { VariableDeclarator, Node, Identifier, AssignmentExpression, LabeledStatement, ExpressionStatement } from 'estree' */ /** @import { Visitors } from 'zimmerframe' */ /** @import { ComponentAnalysis } from '../phases/types.js' */ /** @import { Scope } from '../phases/scope.js' */ /** @import { AST, Binding, ValidatedCompileOptions } from '#compiler' */ import MagicString from 'magic-string'; import { walk } from 'zimmerframe'; import { parse } from '../phases/1-parse/index.js'; import { regex_valid_component_name } from '../phases/1-parse/state/element.js'; import { analyze_component } from '../phases/2-analyze/index.js'; import { get_rune } from '../phases/scope.js'; import { reset, reset_warnings } from '../state.js'; import { extract_identifiers, extract_all_identifiers_from_expression, is_text_attribute } from '../utils/ast.js'; import { migrate_svelte_ignore } from '../utils/extract_svelte_ignore.js'; import { validate_component_options } from '../validate-options.js'; import { is_reserved, is_svg, is_void } from '../../utils.js'; import { regex_is_valid_identifier } from '../phases/patterns.js'; const regex_style_tags = /(<style[^>]+>)([\S\s]*?)(<\/style>)/g; const style_placeholder = '/*$$__STYLE_CONTENT__$$*/'; let has_migration_task = false; class MigrationError extends Error { /** * @param {string} msg */ constructor(msg) { super(msg); } } /** * * @param {State} state */ function migrate_css(state) { if (!state.analysis.css.ast?.start) return; const css_contents = state.str .snip(state.analysis.css.ast.start, /** @type {number} */ (state.analysis.css.ast?.end)) .toString(); let code = css_contents; let starting = 0; // since we already blank css we can't work directly on `state.str` so we will create a copy that we can update const str = new MagicString(code); while (code) { if ( code.startsWith(':has') || code.startsWith(':is') || code.startsWith(':where') || code.startsWith(':not') ) { let start = code.indexOf('(') + 1; let is_global = false; const global_str = ':global'; const next_global = code.indexOf(global_str); const str_between = code.substring(start, next_global); if (!str_between.trim()) { is_global = true; start += global_str.length; } else { const prev_global = css_contents.lastIndexOf(global_str, starting); if (prev_global > -1) { const end = find_closing_parenthesis(css_contents.indexOf('(', prev_global) + 1, css_contents) - starting; if (end > start) { starting += end; code = code.substring(end); continue; } } } const end = find_closing_parenthesis(start, code); if (start && end) { if (!is_global && !code.startsWith(':not')) { str.prependLeft(starting + start, ':global('); str.appendRight(starting + end - 1, ')'); } starting += end - 1; code = code.substring(end - 1); continue; } } starting++; code = code.substring(1); } state.str.update(state.analysis.css.ast?.start, state.analysis.css.ast?.end, str.toString()); } /** * @param {number} start * @param {string} code */ function find_closing_parenthesis(start, code) { let parenthesis = 1; let end = start; let char = code[end]; // find the closing parenthesis while (parenthesis !== 0 && char) { if (char === '(') parenthesis++; if (char === ')') parenthesis--; end++; char = code[end]; } return end; } /** * Does a best-effort migration of Svelte code towards using runes, event attributes and render tags. * May throw an error if the code is too complex to migrate automatically. * * @param {string} source * @param {{ filename?: string, use_ts?: boolean }} [options] * @returns {{ code: string; }} */ export function migrate(source, { filename, use_ts } = {}) { let og_source = source; try { has_migration_task = false; // Blank CSS, could contain SCSS or similar that needs a preprocessor. // Since we don't care about CSS in this migration, we'll just ignore it. /** @type {Array<[number, string]>} */ const style_contents = []; source = source.replace(regex_style_tags, (_, start, content, end, idx) => { style_contents.push([idx + start.length, content]); return start + style_placeholder + end; }); reset_warnings(() => false); let parsed = parse(source); const { customElement: customElementOptions, ...parsed_options } = parsed.options || {}; /** @type {ValidatedCompileOptions} */ const combined_options = { ...validate_component_options({}, ''), ...parsed_options, customElementOptions, filename: filename ?? '(unknown)', experimental: { async: true } }; const str = new MagicString(source); const analysis = analyze_component(parsed, source, combined_options); const indent = guess_indent(source); str.replaceAll(/(<svelte:options\s.*?\s?)accessors\s?/g, (_, $1) => $1); for (const content of style_contents) { str.overwrite(content[0], content[0] + style_placeholder.length, content[1]); } /** @type {State} */ let state = { scope: analysis.instance.scope, analysis, filename, str, indent, props: [], props_insertion_point: parsed.instance?.content.start ?? 0, has_props_rune: false, has_type_or_fallback: false, end: source.length, names: { props: analysis.root.unique('props').name, rest: analysis.root.unique('rest').name, // event stuff run: analysis.root.unique('run').name, handlers: analysis.root.unique('handlers').name, stopImmediatePropagation: analysis.root.unique('stopImmediatePropagation').name, preventDefault: analysis.root.unique('preventDefault').name, stopPropagation: analysis.root.unique('stopPropagation').name, once: analysis.root.unique('once').name, self: analysis.root.unique('self').name, trusted: analysis.root.unique('trusted').name, createBubbler: analysis.root.unique('createBubbler').name, bubble: analysis.root.unique('bubble').name, passive: analysis.root.unique('passive').name, nonpassive: analysis.root.unique('nonpassive').name }, legacy_imports: new Set(), script_insertions: new Set(), derived_components: new Map(), derived_conflicting_slots: new Map(), derived_labeled_statements: new Set(), has_svelte_self: false, uses_ts: // Some people could use jsdoc but have a tsconfig.json, so double-check file for jsdoc indicators (use_ts && !source.includes('@type {')) || !!parsed.instance?.attributes.some( (attr) => attr.name === 'lang' && /** @type {any} */ (attr).value[0].data === 'ts' ) }; if (parsed.module) { const context = parsed.module.attributes.find((attr) => attr.name === 'context'); if (context) { state.str.update(context.start, context.end, 'module'); } } if (parsed.instance) { walk(parsed.instance.content, state, instance_script); } state = { ...state, scope: analysis.template.scope }; walk(parsed.fragment, state, template); let insertion_point = parsed.instance ? /** @type {number} */ (parsed.instance.content.start) : 0; const need_script = state.legacy_imports.size > 0 || state.derived_components.size > 0 || state.derived_conflicting_slots.size > 0 || state.script_insertions.size > 0 || state.props.length > 0 || analysis.uses_rest_props || analysis.uses_props || state.has_svelte_self; const need_ts_tag = state.uses_ts && (!parsed.instance || !parsed.instance.attributes.some((attr) => attr.name === 'lang')); if (!parsed.instance && need_script) { str.appendRight(0, need_ts_tag ? '<script lang="ts">' : '<script>'); } if (state.has_svelte_self && filename) { const file = filename.split('/').pop(); str.appendRight( insertion_point, `\n${indent}import ${state.analysis.name} from './${file}';` ); } const specifiers = [...state.legacy_imports].map((imported) => { const local = state.names[imported]; return imported === local ? imported : `${imported} as ${local}`; }); const legacy_import = `import { ${specifiers.join(', ')} } from 'svelte/legacy';\n`; if (state.legacy_imports.size > 0) { str.appendRight(insertion_point, `\n${indent}${legacy_import}`); } if (state.script_insertions.size > 0) { str.appendRight( insertion_point, `\n${indent}${[...state.script_insertions].join(`\n${indent}`)}` ); } insertion_point = state.props_insertion_point; /** * @param {"derived"|"props"|"bindable"} rune */ function check_rune_binding(rune) { const has_rune_binding = !!state.scope.get(rune); if (has_rune_binding) { throw new MigrationError( `migrating this component would require adding a \`$${rune}\` rune but there's already a variable named ${rune}.\n Rename the variable and try again or migrate by hand.` ); } } if (state.props.length > 0 || analysis.uses_rest_props || analysis.uses_props) { const has_many_props = state.props.length > 3; const newline_separator = `\n${indent}${indent}`; const props_separator = has_many_props ? newline_separator : ' '; let props = ''; if (analysis.uses_props) { props = `...${state.names.props}`; } else { props = state.props .filter((prop) => !prop.type_only) .map((prop) => { let prop_str = prop.local === prop.exported ? prop.local : `${prop.exported}: ${prop.local}`; if (prop.bindable) { check_rune_binding('bindable'); prop_str += ` = $bindable(${prop.init})`; } else if (prop.init) { prop_str += ` = ${prop.init}`; } return prop_str; }) .join(`,${props_separator}`); if (analysis.uses_rest_props) { props += `${state.props.length > 0 ? `,${props_separator}` : ''}...${state.names.rest}`; } } if (state.has_props_rune) { // some render tags or forwarded event attributes to add str.appendRight(insertion_point, ` ${props},`); } else { const type_name = state.scope.root.unique('Props').name; let type = ''; // Try to infer when we don't want to add types (e.g. user doesn't use types, or this is a zero-types +page.svelte) if (state.has_type_or_fallback || state.props.every((prop) => prop.slot_name)) { if (state.uses_ts) { type = `interface ${type_name} {${newline_separator}${state.props .map((prop) => { const comment = prop.comment ? `${prop.comment}${newline_separator}` : ''; return `${comment}${prop.exported}${prop.optional ? '?' : ''}: ${prop.type};${prop.trailing_comment ? ' ' + prop.trailing_comment : ''}`; }) .join(newline_separator)}`; if (analysis.uses_props || analysis.uses_rest_props) { type += `${state.props.length > 0 ? newline_separator : ''}[key: string]: any`; } type += `\n${indent}}`; } else { type = `/**\n${indent} * @typedef {Object} ${type_name}${state.props .map((prop) => { return `\n${indent} * @property {${prop.type}} ${prop.optional ? `[${prop.exported}]` : prop.exported}${prop.comment ? ` - ${prop.comment}` : ''}${prop.trailing_comment ? ` - ${prop.trailing_comment.trim()}` : ''}`; }) .join(``)}\n${indent} */`; } } let props_declaration = `let {${props_separator}${props}${has_many_props ? `\n${indent}` : ' '}}`; if (state.uses_ts) { if (type) { props_declaration = `${type}\n\n${indent}${props_declaration}`; } check_rune_binding('props'); props_declaration = `${props_declaration}${type ? `: ${type_name}` : ''} = $props();`; } else { if (type) { props_declaration = `${state.props.length > 0 ? `${type}\n\n${indent}` : ''}/** @type {${state.props.length > 0 ? type_name : ''}${analysis.uses_props || analysis.uses_rest_props ? `${state.props.length > 0 ? ' & ' : ''}{ [key: string]: any }` : ''}} */\n${indent}${props_declaration}`; } check_rune_binding('props'); props_declaration = `${props_declaration} = $props();`; } props_declaration = `\n${indent}${props_declaration}`; str.appendRight(insertion_point, props_declaration); } if (parsed.instance && need_ts_tag) { str.appendRight(parsed.instance.start + '<script'.length, ' lang="ts"'); } } /** * If true, then we need to move all reactive statements to the end of the script block, * in their correct order. Svelte 4 reordered reactive statements, $derived/$effect.pre * don't have this behavior. */ let needs_reordering = false; for (const [node, { dependencies }] of state.analysis.reactive_statements) { /** @type {Binding[]} */ let ids = []; if ( node.body.type === 'ExpressionStatement' && node.body.expression.type === 'AssignmentExpression' ) { ids = extract_identifiers(node.body.expression.left) .map((id) => state.scope.get(id.name)) .filter((id) => !!id); } if ( dependencies.some( (dep) => !ids.includes(dep) && (dep.kind === 'prop' || dep.kind === 'bindable_prop' ? state.props_insertion_point : /** @type {number} */ (dep.node.start)) > /** @type {number} */ (node.start) ) ) { needs_reordering = true; break; } } if (needs_reordering) { const nodes = Array.from(state.analysis.reactive_statements.keys()); for (const node of nodes) { const { start, end } = get_node_range(source, node); str.appendLeft(end, '\n'); str.move(start, end, /** @type {number} */ (parsed.instance?.content.end)); str.update(start - (source[start - 2] === '\r' ? 2 : 1), start, ''); } } insertion_point = parsed.instance ? /** @type {number} */ (parsed.instance.content.end) : insertion_point; if (state.derived_components.size > 0) { check_rune_binding('derived'); str.appendRight( insertion_point, `\n${indent}${[...state.derived_components.entries()].map(([init, name]) => `const ${name} = $derived(${init});`).join(`\n${indent}`)}\n` ); } if (state.derived_conflicting_slots.size > 0) { check_rune_binding('derived'); str.appendRight( insertion_point, `\n${indent}${[...state.derived_conflicting_slots.entries()].map(([name, init]) => `const ${name} = $derived(${init});`).join(`\n${indent}`)}\n` ); } if (state.props.length > 0 && state.analysis.accessors) { str.appendRight( insertion_point, `\n${indent}export {${state.props.reduce((acc, prop) => (prop.slot_name || prop.type_only ? acc : `${acc}\n${indent}\t${prop.local},`), '')}\n${indent}}\n` ); } if (!parsed.instance && need_script) { str.appendRight(insertion_point, '\n</script>\n\n'); } migrate_css(state); return { code: str.toString() }; } catch (e) { if (!(e instanceof MigrationError)) { // eslint-disable-next-line no-console console.error('Error while migrating Svelte code', e); } has_migration_task = true; return { code: `<!-- @migration-task Error while migrating Svelte code: ${/** @type {any} */ (e).message} -->\n${og_source}` }; } finally { if (has_migration_task) { // eslint-disable-next-line no-console console.log( `One or more \`@migration-task\` comments were added to ${filename ? `\`${filename}\`` : "a file (unfortunately we don't know the name)"}, please check them and complete the migration manually.` ); } } } /** * @typedef {{ * scope: Scope; * str: MagicString; * analysis: ComponentAnalysis; * filename?: string; * indent: string; * props: Array<{ local: string; exported: string; init: string; bindable: boolean; slot_name?: string; optional: boolean; type: string; comment?: string; trailing_comment?: string; type_only?: boolean; needs_refine_type?: boolean; }>; * props_insertion_point: number; * has_props_rune: boolean; * has_type_or_fallback: boolean; * end: number; * names: Record<string, string>; * legacy_imports: Set<string>; * script_insertions: Set<string>; * derived_components: Map<string, string>; * derived_conflicting_slots: Map<string, string>; * derived_labeled_statements: Set<LabeledStatement>; * has_svelte_self: boolean; * uses_ts: boolean; * }} State */ /** @type {Visitors<AST.SvelteNode, State>} */ const instance_script = { _(node, { state, next }) { // @ts-expect-error const comments = node.leadingComments; if (comments) { for (const comment of comments) { if (comment.type === 'Line') { const migrated = migrate_svelte_ignore(comment.value); if (migrated !== comment.value) { state.str.overwrite(comment.start + '//'.length, comment.end, migrated); } } } } next(); }, Identifier(node, { state, path }) { handle_identifier(node, state, path); }, ImportDeclaration(node, { state }) { state.props_insertion_point = node.end ?? state.props_insertion_point; if (node.source.value === 'svelte') { let illegal_specifiers = []; let removed_specifiers = 0; for (let specifier of node.specifiers) { if ( specifier.type === 'ImportSpecifier' && specifier.imported.type === 'Identifier' && ['beforeUpdate', 'afterUpdate'].includes(specifier.imported.name) ) { const references = state.scope.references.get(specifier.local.name); if (!references) { let end = /** @type {number} */ ( state.str.original.indexOf(',', specifier.end) !== -1 && state.str.original.indexOf(',', specifier.end) < state.str.original.indexOf('}', specifier.end) ? state.str.original.indexOf(',', specifier.end) + 1 : specifier.end ); while (state.str.original[end].trim() === '') end++; state.str.remove(/** @type {number} */ (specifier.start), end); removed_specifiers++; continue; } illegal_specifiers.push(specifier.imported.name); } } if (removed_specifiers === node.specifiers.length) { state.str.remove(/** @type {number} */ (node.start), /** @type {number} */ (node.end)); } if (illegal_specifiers.length > 0) { throw new MigrationError( `Can't migrate code with ${illegal_specifiers.join(' and ')}. Please migrate by hand.` ); } } }, ExportNamedDeclaration(node, { state, next }) { if (node.declaration) { next(); return; } let count_removed = 0; for (const specifier of node.specifiers) { if (specifier.local.type !== 'Identifier') continue; const binding = state.scope.get(specifier.local.name); if (binding?.kind === 'bindable_prop') { state.str.remove( /** @type {number} */ (specifier.start), /** @type {number} */ (specifier.end) ); count_removed++; } } if (count_removed === node.specifiers.length) { state.str.remove(/** @type {number} */ (node.start), /** @type {number} */ (node.end)); } }, VariableDeclaration(node, { state, path, visit, next }) { if (state.scope !== state.analysis.instance.scope) { return; } let nr_of_props = 0; for (let i = 0; i < node.declarations.length; i++) { const declarator = node.declarations[i]; if (state.analysis.runes) { if (get_rune(declarator.init, state.scope) === '$props') { state.props_insertion_point = /** @type {number} */ (declarator.id.start) + 1; state.has_props_rune = true; } continue; } let bindings; try { bindings = state.scope.get_bindings(declarator); } catch (e) { // no bindings, so we can skip this next(); continue; } const has_state = bindings.some((binding) => binding.kind === 'state'); const has_props = bindings.some((binding) => binding.kind === 'bindable_prop'); if (!has_state && !has_props) { next(); continue; } if (has_props) { nr_of_props++; if (declarator.id.type !== 'Identifier') { // TODO invest time in this? throw new MigrationError( 'Encountered an export declaration pattern that is not supported for automigration.' ); // Turn export let into props. It's really really weird because export let { x: foo, z: [bar]} = .. // means that foo and bar are the props (i.e. the leafs are the prop names), not x and z. // const tmp = b.id(state.scope.generate('tmp')); // const paths = extract_paths(declarator.id, tmp); // state.props_pre.push( // b.declaration('const', tmp, visit(declarator.init!) as Expression) // ); // for (const path of paths) { // const name = (path.node as Identifier).name; // const binding = state.scope.get(name)!; // const value = path.expression; // if (binding.kind === 'bindable_prop' || binding.kind === 'rest_prop') { // state.props.push({ // local: name, // exported: binding.prop_alias ? binding.prop_alias : name, // init: value // }); // state.props_insertion_point = /** @type {number} */(declarator.end); // } else { // declarations.push(b.declarator(path.node, value)); // } // } } const name = declarator.id.name; const binding = /** @type {Binding} */ (state.scope.get(name)); if (state.analysis.uses_props && (declarator.init || binding.updated)) { throw new MigrationError( '$$props is used together with named props in a way that cannot be automatically migrated.' ); } const prop = state.props.find((prop) => prop.exported === (binding.prop_alias || name)); if (prop) { next(); // $$Props type was used prop.init = declarator.init ? state.str .snip( /** @type {number} */ (declarator.init.start), /** @type {number} */ (declarator.init.end) ) .toString() : ''; prop.bindable = binding.updated; prop.exported = binding.prop_alias || name; prop.type_only = false; } else { next(); state.props.push({ local: name, exported: binding.prop_alias ? binding.prop_alias : name, init: declarator.init ? state.str .snip( /** @type {number} */ (declarator.init.start), /** @type {number} */ (declarator.init.end) ) .toString() : '', optional: !!declarator.init, bindable: binding.updated, ...extract_type_and_comment(declarator, state, path) }); } let start = /** @type {number} */ (declarator.start); let end = /** @type {number} */ (declarator.end); // handle cases like let a,b,c; where only some are exported if (node.declarations.length > 1) { // move the insertion point after the node itself; state.props_insertion_point = /** @type {number} */ (node.end); // if it's not the first declaration remove from the , of the previous declaration if (i !== 0) { start = state.str.original.indexOf( ',', /** @type {number} */ (node.declarations[i - 1].end) ); } // if it's not the last declaration remove either from up until the // start of the next declaration (if it's the first declaration) or // up until the last index of , from the next declaration if (i !== node.declarations.length - 1) { if (i === 0) { end = /** @type {number} */ (node.declarations[i + 1].start); } else { end = state.str.original.lastIndexOf( ',', /** @type {number} */ (node.declarations[i + 1].start) ); } } } else { state.props_insertion_point = /** @type {number} */ (declarator.end); } state.str.update(start, end, ''); continue; } /** * @param {"state"|"derived"} rune */ function check_rune_binding(rune) { const has_rune_binding = !!state.scope.get(rune); if (has_rune_binding) { throw new MigrationError( `can't migrate \`${state.str.original.substring(/** @type {number} */ (node.start), node.end)}\` to \`$${rune}\` because there's a variable named ${rune}.\n Rename the variable and try again or migrate by hand.` ); } } // state if (declarator.init) { let { start, end } = /** @type {{ start: number, end: number }} */ (declarator.init); if (declarator.init.type === 'SequenceExpression') { while (state.str.original[start] !== '(') start -= 1; while (state.str.original[end - 1] !== ')') end += 1; } check_rune_binding('state'); state.str.prependLeft(start, '$state('); state.str.appendRight(end, ')'); } else { /** * @type {AssignmentExpression | undefined} */ let assignment_in_labeled; /** * @type {LabeledStatement | undefined} */ let labeled_statement; // Analyze declaration bindings to see if they're exclusively updated within a single reactive statement const possible_derived = bindings.every((binding) => binding.references.every((reference) => { const declaration = reference.path.find((el) => el.type === 'VariableDeclaration'); const assignment = reference.path.find((el) => el.type === 'AssignmentExpression'); const update = reference.path.find((el) => el.type === 'UpdateExpression'); const labeled = /** @type {LabeledStatement | undefined} */ ( reference.path.find((el) => el.type === 'LabeledStatement' && el.label.name === '$') ); if ( assignment && labeled && // ensure that $: foo = bar * 2 is not counted as a reassignment of bar (labeled.body.type !== 'ExpressionStatement' || labeled.body.expression !== assignment || (assignment.left.type === 'Identifier' && assignment.left.name === binding.node.name)) ) { if (assignment_in_labeled) return false; assignment_in_labeled = /** @type {AssignmentExpression} */ (assignment); labeled_statement = labeled; } return ( !update && ((declaration && binding.initial) || (labeled && assignment) || (!labeled && !assignment)) ); }) ); const labeled_has_single_assignment = labeled_statement?.body.type === 'BlockStatement' && labeled_statement.body.body.length === 1 && labeled_statement.body.body[0].type === 'ExpressionStatement'; const is_expression_assignment = labeled_statement?.body.type === 'ExpressionStatement' && labeled_statement.body.expression.type === 'AssignmentExpression'; let should_be_state = false; if (is_expression_assignment) { const body = /**@type {ExpressionStatement}*/ (labeled_statement?.body); const expression = /**@type {AssignmentExpression}*/ (body.expression); const [, ids] = extract_all_identifiers_from_expression(expression.right); if (ids.length === 0) { should_be_state = true; state.derived_labeled_statements.add( /** @type {LabeledStatement} */ (labeled_statement) ); } } if ( !should_be_state && possible_derived && assignment_in_labeled && labeled_statement && (labeled_has_single_assignment || is_expression_assignment) ) { const indent = state.str.original.substring( state.str.original.lastIndexOf('\n', /** @type {number} */ (node.start)) + 1, /** @type {number} */ (node.start) ); // transfer all the leading comments if ( labeled_statement.body.type === 'BlockStatement' && labeled_statement.body.body[0].leadingComments ) { for (let comment of labeled_statement.body.body[0].leadingComments) { state.str.prependLeft( /** @type {number} */ (node.start), comment.type === 'Block' ? `/*${comment.value}*/\n${indent}` : `// ${comment.value}\n${indent}` ); } } check_rune_binding('derived'); // Someone wrote a `$: { ... }` statement which we can turn into a `$derived` state.str.appendRight( /** @type {number} */ (declarator.id.typeAnnotation?.end ?? declarator.id.end), ' = $derived(' ); visit(assignment_in_labeled.right); state.str.appendRight( /** @type {number} */ (declarator.id.typeAnnotation?.end ?? declarator.id.end), state.str .snip( /** @type {number} */ (assignment_in_labeled.right.start), /** @type {number} */ (assignment_in_labeled.right.end) ) .toString() ); state.str.remove( /** @type {number} */ (labeled_statement.start), /** @type {number} */ (labeled_statement.end) ); state.str.appendRight( /** @type {number} */ (declarator.id.typeAnnotation?.end ?? declarator.id.end), ')' ); state.derived_labeled_statements.add(labeled_statement); // transfer all the trailing comments if ( labeled_statement.body.type === 'BlockStatement' && labeled_statement.body.body[0].trailingComments ) { for (let comment of labeled_statement.body.body[0].trailingComments) { state.str.appendRight( /** @type {number} */ (declarator.id.typeAnnotation?.end ?? declarator.id.end), comment.type === 'Block' ? `\n${indent}/*${comment.value}*/` : `\n${indent}// ${comment.value}` ); } } } else { check_rune_binding('state'); state.str.prependLeft( /** @type {number} */ (declarator.id.typeAnnotation?.end ?? declarator.id.end), ' = $state(' ); if (should_be_state) { // someone wrote a `$: foo = ...` statement which we can turn into `let foo = $state(...)` state.str.appendRight( /** @type {number} */ (declarator.id.typeAnnotation?.end ?? declarator.id.end), state.str .snip( /** @type {number} */ ( /** @type {AssignmentExpression} */ (assignment_in_labeled).right.start ), /** @type {number} */ ( /** @type {AssignmentExpression} */ (assignment_in_labeled).right.end ) ) .toString() ); state.str.remove( /** @type {number} */ (/** @type {LabeledStatement} */ (labeled_statement).start), /** @type {number} */ (/** @type {LabeledStatement} */ (labeled_statement).end) ); } state.str.appendRight( /** @type {number} */ (declarator.id.typeAnnotation?.end ?? declarator.id.end), ')' ); } } } if (nr_of_props === node.declarations.length) { let start = /** @type {number} */ (node.start); let end = /** @type {number} */ (node.end); const parent = path.at(-1); if (parent?.type === 'ExportNamedDeclaration') { start = /** @type {number} */ (parent.start); end = /** @type {number} */ (parent.end); } while (state.str.original[start] !== '\n') start--; while (state.str.original[end] !== '\n') end++; state.str.update(start, end, ''); } }, BreakStatement(node, { state, path }) { if (path[1].type !== 'LabeledStatement') return; if (node.label?.name !== '$') return; state.str.update( /** @type {number} */ (node.start), /** @type {number} */ (node.end), 'return;' ); }, LabeledStatement(node, { path, state, next }) { if (state.analysis.runes) return; if (path.length > 1) return; if (node.label.name !== '$') return; if (state.derived_labeled_statements.has(node)) return; next(); /** * @param {"state"|"derived"} rune */ function check_rune_binding(rune) { const has_rune_binding = state.scope.get(rune); if (has_rune_binding) { throw new MigrationError( `can't migrate \`$: ${state.str.original.substring(/** @type {number} */ (node.body.start), node.body.end)}\` to \`$${rune}\` because there's a variable named ${rune}.\n Rename the variable and try again or migrate by hand.` ); } } if ( node.body.type === 'ExpressionStatement' && node.body.expression.type === 'AssignmentExpression' ) { const { left, right } = node.body.expression; const ids = extract_identifiers(left); const [, expression_ids] = extract_all_identifiers_from_expression(right); const bindings = ids.map((id) => /** @type {Binding} */ (state.scope.get(id.name))); if (bindings.every((b) => b.kind === 'legacy_reactive')) { if ( right.type !== 'Literal' && bindings.every((b) => b.kind !== 'store_sub') && left.type !== 'MemberExpression' ) { let { start, end } = /** @type {{ start: number, end: number }} */ (right); check_rune_binding('derived'); // $derived state.str.update( /** @type {number} */ (node.start), /** @type {number} */ (node.body.expression.start), 'let ' ); if (right.type === 'SequenceExpression') { while (state.str.original[start] !== '(') start -= 1; while (state.str.original[end - 1] !== ')') end += 1; } state.str.prependRight(start, `$derived(`); // in a case like `$: ({ a } = b())`, there's already a trailing parenthesis. // otherwise, we need to add one if (state.str.original[/** @type {number} */ (node.body.start)] !== '(') { state.str.appendLeft(end, `)`); } return; } for (const binding of bindings) { if (binding.reassigned && (ids.includes(binding.node) || expression_ids.length === 0)) { check_rune_binding('state'); const init = binding.kind === 'state' ? ' = $state()' : expression_ids.length === 0 ? ` = $state(${state.str.original.substring(/** @type {number} */ (right.start), right.end)})` : ''; // implicitly-declared variable which we need to make explicit state.str.prependLeft( /** @type {number} */ (node.start), `let ${binding.node.name}${init};\n${state.indent}` ); } } if (expression_ids.length === 0 && bindings.every((b) => b.kind !== 'store_sub')) { state.str.remove(/** @type {number} */ (node.start), /** @type {number} */ (node.end)); return; } } } state.legacy_imports.add('run'); const is_block_stmt = node.body.type === 'BlockStatement'; const start_end = /** @type {number} */ (node.body.start); // TODO try to find out if we can use $derived.by instead? if (is_block_stmt) { state.str.update( /** @type {number} */ (node.start), start_end + 1, `${state.names.run}(() => {` ); const end = /** @type {number} */ (node.body.end); state.str.update(end - 1, end, '});'); } else { state.str.update( /** @type {number} */ (node.start), start_end, `${state.names.run}(() => {\n${state.indent}` ); state.str.indent(state.indent, { exclude: [ [0, /** @type {number} */ (node.body.start)], [/** @type {number} */ (node.body.end), state.end] ] }); state.str.appendLeft(/** @type {number} */ (node.end), `\n${state.indent}});`); } } }; /** * * @param {State} state * @param {number} start * @param {number} end */ function trim_block(state, start, end) { const original = state.str.snip(start, end).toString(); const without_parens = original.substring(1, original.length - 1); if (without_parens.trim().length !== without_parens.length) { state.str.update(start + 1, end - 1, without_parens.trim()); } } /** @type {Visitors<AST.SvelteNode, State>} */ const template = { Identifier(node, { state, path }) { handle_identifier(node, state, path); }, RegularElement(node, { state, path, next }) { migrate_slot_usage(node, path, state); handle_events(node, state); // Strip off any namespace from the beginning of the node name. const node_name = node.name.replace(/[a-zA-Z-]*:/g, ''); if (state.analysis.source[node.end - 2] === '/' && !is_void(node_name) && !is_svg(node_name)) { let trimmed_position = node.end - 2; while (state.str.original.charAt(trimmed_position - 1) === ' ') trimmed_position--; state.str.remove(trimmed_position, node.end - 1); state.str.appendRight(node.end, `</${node.name}>`); } next(); }, SvelteSelf(node, { state, next }) { const source = state.str.original.substring(node.start, node.end); if (!state.filename) { const indent = guess_indent(source); has_migration_task = true; state.str.prependRight( node.start, `<!-- @migration-task: svelte:self is deprecated, import this Svelte file into itself instead -->\n${indent}` ); next(); return; } // overwrite the open tag state.str.overwrite( node.start + 1, node.start + 1 + 'svelte:self'.length, `${state.analysis.name}` ); // if it has a fragment we need to overwrite the closing tag too if (node.fragment.nodes.length > 0) { state.str.overwrite( state.str.original.lastIndexOf('<', node.end) + 2, node.end - 1, `${state.analysis.name}` ); } else if (!source.endsWith('/>')) { // special case for case `<svelte:self></svelte:self>` it has no fragment but // we still need to overwrite the end tag state.str.overwrite( node.start + source.lastIndexOf('</', node.end) + 2, node.end - 1, `${state.analysis.name}` ); } state.has_svelte_self = true; next(); }, SvelteElement(node, { state, path, next }) { migrate_slot_usage(node, path, state); if (node.tag.type === 'Literal') { let is_static = true; let a = /** @type {number} */ (node.tag.start); let b = /** @type {number} */ (node.tag.end); let quote_mark = state.str.original[a - 1]; while (state.str.original[--a] !== '=') { if (state.str.original[a] === '{') { is_static = false; break; } } if (is_static && state.str.original[b] === quote_mark) { state.str.prependLeft(a + 1, '{'); state.str.appendRight(/** @type {number} */ (node.tag.end) + 1, '}'); } } handle_events(node, state); next(); }, Component(node, { state, path, next }) { next(); migrate_slot_usage(node, path, state); }, SvelteComponent(node, { state, next, path }) { next(); migrate_slot_usage(node, path, state); let expression = state.str .snip( /** @type {number} */ (node.expression.start), /** @type {number} */ (node.expression.end) ) .toString(); if ( (node.expression.type !== 'Identifier' && node.expression.type !== 'MemberExpression') || !regex_valid_component_name.test(expression) ) { let current_expression = expression; expression = state.scope.generate('SvelteComponent'); let needs_derived = true; for (let i = path.length - 1; i >= 0; i--) { const part = path[i]; if ( part.type === 'EachBlock' || part.type === 'AwaitBlock' || part.type === 'IfBlock' || part.type === 'SnippetBlock' || part.type === 'Component' || part.type === 'SvelteComponent' ) { let position = node.start; if (i !== path.length - 1) { for (let modifier = 1; modifier < path.length - i; modifier++) { const path_part = path[i + modifier]; if ('start' in path_part) { position = /** @type {number} */ (path_part.start); break; } } } const indent = state.str.original.substring( state.str.original.lastIndexOf('\n', position) + 1, position ); state.str.appendRight( position, `{@const ${expression} = ${current_expression}}\n${indent}` ); needs_derived = false; break; } } if (needs_derived) { if (state.derived_components.has(current_expression)) { expression = /** @type {string} */ (state.derived_components.get(current_expression)); } else { state.derived_components.set(current_expression, expression); } } } state.str.overwrite(node.start + 1, node.start + node.name.length + 1, expression); if (state.str.original.substring(node.end - node.name.length - 1, node.end - 1) === node.name) { state.str.overwrite(node.end - node.name.length - 1, node.end - 1, expression); } let this_pos = state.str.original.lastIndexOf('this', node.expression.start); while (!state.str.original.charAt(this_pos - 1).trim()) this_pos--; const end_pos = state.str.original.indexOf('}', node.expression.end) + 1; state.str.remove(this_pos, end_pos); }, SvelteFragment(node, { state, path, next }) { migrate_slot_usage(node, path, state); next(); }, SvelteWindow(node, { state, next }) { handle_events(node, state); next(); }, SvelteBody(node, { state, next }) { handle_events(node, state); next(); }, SvelteDocument(node, { state, next }) { handle_events(node, state); next(); }, SlotElement(node, { state, path, next, visit }) { migrate_slot_usage(node, path, state); if (state.analysis.custom_element) return; let name = 'children'; let slot_name = 'default'; let slot_props = '{ '; let aliased_slot_name; for (const attr of node.attributes) { if (attr.type === 'SpreadAttribute') { slot_props += `...${state.str.original.substring(/** @type {number} */ (attr.expression.start), attr.expression.end)}, `; } else if (attr.type === 'Attribute') { if (attr.name === 'slot') { continue; } if (attr.name === 'name') { slot_name = /** @type {any} */ (attr.value)[0].data; // if some of the parents or this node itself har a slot // attribute with the sane name of this slot // we want to create a derived or the migrated snippet // will shadow the slot prop if ( path.some( (parent) => (parent.type === 'RegularElement' || parent.type === 'SvelteElement' || parent.type === 'Component' || parent.type === 'SvelteComponent' || parent.type === 'SvelteFragment') && parent.attributes.some( (attribute) => attribute.type === 'Attribute' && attribute.name === 'slot' && is_text_attribute(attribute) && attribute.value[0].data === slot_name ) ) || node.attributes.some( (attribute) => attribute.type === 'Attribute' && attribute.name === 'slot' && is_text_attribute(attribute) && attribute.value[0].data === slot_name ) ) { aliased_slot_name = `${slot_name}_render`; state.derived_conflicting_slots.set(aliased_slot_name, slot_name); } } else { const attr_value = attr.value === true || Array.isArray(attr.value) ? attr.value : [attr.value]; let value = 'true'; if (attr_value !== true) { const first = attr_value[0]; const last = attr_value[attr_value.length - 1]; for (const attr of attr_value) { visit(attr); } value = state.str .snip( first.type === 'Text' ? first.start - 1 : /** @type {number} */ (first.expression.start), last.type === 'Text' ? last.end + 1 : /** @type {number} */ (last.expression.end) ) .toString(); } slot_props += value === attr.name ? `${value}, ` : `${attr.name}: ${value}, `; } } } slot_props += '}'; if (slot_props === '{ }') { slot_props = ''; } const existing_prop = state.props.find((prop) => prop.slot_name === slot_name); if (existing_prop) { name = existing_prop.local; } else if (slot_name !== 'default') { name = state.scope.generate(slot_name); if (name !== slot_name) { throw new MigrationError( `This migration would change the name of a slot (${slot_name} to ${name}) making the component unusable` ); } } if (!existing_prop) { state.props.push({ local: name, exported: name, init: '', bindable: false, optional: true, slot_name, type: `import('svelte').${slot_props ? 'Snippet<[any]>' : 'Snippet'}` }); } else if (existing_prop.needs_refine_type) { existing_prop.type = `import('svelte').${slot_props ? 'Snippet<[any]>' : 'Snippet'}`; existing_prop.needs_refine_type = false; } if ( slot_name === 'default' && path.some( (parent) => (parent.type === 'SvelteComponent' || parent.type === 'Component' || parent.type === 'RegularElement' || parent.type === 'SvelteElement' || parent.type === 'SvelteFragment') && parent.attributes.some((attr) => attr.type === 'LetDirective') ) ) { aliased_slot_name = `${name}_render`; state.derived_conflicting_slots.set(aliased_slot_name, name); } name = aliased_slot_name ?? name; if (node.fragment.nodes.length > 0) { next(); state.str.update( node.start, node.fragment.nodes[0].start, `{#if ${name}}{@render ${state.analysis.uses_props ? `${state.names.props}.` : ''}${name}(${slot_props})}{:else}` ); state.str.update(node.fragment.nodes[node.fragment.nodes.length - 1].end, node.end, '{/if}'); } else { state.str.update( node.start, node.end, `{@render ${state.analysis.uses_props ? `${state.names.props}.` : ''}${name}?.(${slot_props})}` ); } }, Comment(node, { state }) { const migrated = migrate_svelte_ignore(node.data); if (migrated !== node.data) { state.str.overwrite(node.start + '<!--'.length, node.end - '-->'.length, migrated); } }, HtmlTag(node, { state, next }) { trim_block(state, node.start, node.end); next(); }, ConstTag(node, { state, next }) { trim_block(state, node.start, node.end); next(); }, IfBlock(node, { state, next }) { const start = node.start; const end = state.str.original.indexOf('}', node.test.end) + 1; trim_block(state, start, end); next(); }, AwaitBlock(node, { state, next }) { const start = node.start; const end = state.str.original.indexOf( '}', node.pending !== null ? node.expression.end : node.value?.end ) + 1; trim_block(state, start, end); if (node.pending !== null) { const start = state.str.original.lastIndexOf('{', node.value?.start); const end = state.str.original.indexOf('}', node.value?.end) + 1; trim_block(state, start, end); } if (node.catch !== null) { const start = state.str.original.lastIndexOf('{', node.error?.start); const end = state.str.original.indexOf('}', node.error?.end) + 1; trim_block(state, start, end); } next(); }, KeyBlock(node, { state, next }) { const start = node.start; const end = state.str.original.indexOf('}', node.expression.end) + 1; trim_block(state, start, end); next(); } }; /** * @param {AST.RegularElement | AST.SvelteElement | AST.SvelteComponent | AST.Component | AST.SlotElement | AST.SvelteFragment} node * @param {AST.SvelteNode[]} path * @param {State} state */ function migrate_slot_usage(node, path, state) { const parent = path.at(-2); // Bail on custom element slot usage if ( parent?.type !== 'Component' && parent?.type !== 'SvelteComponent' && node.type !== 'Component' && node.type !== 'SvelteComponent' ) { return; } let snippet_name = 'children'; let snippet_props = []; // if we stop the transform because the name is not correct we don't want to // remove the let directive and they could come before the name let removal_queue = []; for (let attribute of node.attributes) { if ( attribute.type === 'Attribute' && attribute.name === 'slot' && is_text_attribute(attribute) ) { snippet_name = attribute.value[0].data; // the default slot in svelte 4 if what the children slot is for svelte 5 if (snippet_name === 'default') { snippet_name = 'children'; } if (!regex_is_valid_identifier.test(snippet_name) || is_reserved(snippet_name)) { has_migration_task = true; state.str.appendLeft( node.start, `<!-- @migration-task: migrate this slot by hand, \`${snippet_name}\` is an invalid identifier -->\n${state.indent}` ); return; } if (parent?.type === 'Component' || parent?.type === 'SvelteComponent') { for (let attribute of parent.attributes) { if (attribute.type === 'Attribute' || attribute.type === 'BindDirective') { if (attribute.name === snippet_name) { state.str.appendLeft( node.start, `<!-- @migration-task: migrate this slot by hand, \`${snippet_name}\` would shadow a prop on the parent component -->\n${state.indent}` ); return; } } } } // flush the queue after we found the name for (let remove_let of removal_queue) { remove_let(); } state.str.remove(attribute.start, attribute.end); } if (attribute.type === 'LetDirective') { snippet_props.push( attribute.name + (attribute.expression ? `: ${state.str.original.substring(/** @type {number} */ (attribute.expression.start), /** @type {number} */ (attribute.expression.end))}` : '') ); // we just add to the queue to remove them after we found if we need to migrate or we bail removal_queue.push(() => state.str.remove(attribute.start, attribute.end)); } } if (removal_queue.length > 0) { for (let remove_let of removal_queue) { remove_let(); } } if (node.type === 'SvelteFragment' && node.fragment.nodes.length > 0) { // remove node itself, keep content state.str.remove(node.start, node.fragment.nodes[0].start); state.str.remove(node.fragment.nodes[node.fragment.nodes.length - 1].end, node.end); } const props = snippet_props.length > 0 ? `{ ${snippet_props.join(', ')} }` : ''; if (snippet_name === 'children' && node.type !== 'SvelteFragment') { if (snippet_props.length === 0) return; // nothing to do let inner_start = 0; let inner_end = 0; for (let i = 0; i < node.fragment.nodes.length; i++) { const inner = node.fragment.nodes[i]; const is_empty_text = inner.type === 'Text' && !inner.data.trim(); if ( (inner.type === 'RegularElement' || inner.type === 'SvelteElement' || inner.type === 'Component' || inner.type === 'SvelteComponent' || inner.type === 'SlotElement' || inner.type === 'SvelteFragment') && inner.attributes.some((attr) => attr.type === 'Attribute' && attr.name === 'slot') ) { if (inner_start && !inner_end) { // End of default slot content inner_end = inner.start; } } else if (!inner_start && !is_empty_text) { // Start of default slot content inner_start = inner.start; } else if (inner_end && !is_empty_text) { // There was default slot content before, then some named slot content, now some default slot content again. // We're moving the last character back by one to avoid the closing {/snippet} tag inserted afterwards // to come before the opening {#snippet} tag of the named slot. state.str.update(inner_end - 1, inner_end, ''); state.str.prependLeft(inner_end - 1, state.str.original[inner_end - 1]); state.str.move(inner.start, inner.end, inner_end - 1); } } if (!inner_end) { inner_end = node.fragment.nodes[node.fragment.nodes.length - 1].end; } state.str.appendLeft( inner_start, `{#snippet ${snippet_name}(${props})}\n${state.indent.repeat(path.length)}` ); state.str.indent(state.indent, { exclude: [ [0, inner_start], [inner_end, state.str.original.length] ] }); if (inner_end < node.fragment.nodes[node.fragment.nodes.length - 1].end) { // Named slots coming afterwards state.str.prependLeft(inner_end, `{/snippet}\n${state.indent.repeat(path.length)}`); } else { // No named slots coming afterwards state.str.prependLeft( inner_end, `${state.indent.repeat(path.length)}{/snippet}\n${state.indent.repeat(path.length - 1)}` ); } } else { // Named slot or `svelte:fragment`: wrap element itself in a snippet state.str.prependLeft( node.start, `{#snippet ${snippet_name}(${props})}\n${state.indent.repeat(path.length - 2)}` ); state.str.indent(state.indent, { exclude: [ [0, node.start], [node.end, state.str.original.length] ] }); const str = `\n${state.indent.repeat(path.length - 2)}{/snippet}`; if (node.type === 'SlotElement') { state.str.appendRight(node.end, str); } else { state.str.appendLeft(node.end, str); } } } /** * @param {VariableDeclarator} declarator * @param {State} state * @param {AST.SvelteNode[]} path */ function extract_type_and_comment(declarator, state, path) { const str = state.str; const parent = path.at(-1); // Try to find jsdoc above the declaration let comment_node = /** @type {Node} */ (parent)?.leadingComments?.at(-1); const comment_start = /** @type {any} */ (comment_node)?.start; const comment_end = /** @type {any} */ (comment_node)?.end; let comment = comment_node && str.original.substring(comment_start, comment_end); if (comment_node) { str.update(comment_start, comment_end, ''); } // Find trailing comments const trailing_comment_node = /** @type {Node} */ (parent)?.trailingComments?.at(0); const trailing_comment_start = /** @type {any} */ (trailing_comment_node)?.start; const trailing_comment_end = /** @type {any} */ (trailing_comment_node)?.end; let trailing_comment = trailing_comment_node && str.original.substring(trailing_comment_start, trailing_comment_end); if (trailing_comment_node) { str.update(trailing_comment_start, trailing_comment_end, ''); } if (declarator.id.typeAnnotation) { state.has_type_or_fallback = true; let start = declarator.id.typeAnnotation.start + 1; // skip the colon while (str.original[start] === ' ') { start++; } return { type: str.original.substring(start, declarator.id.typeAnnotation.end), comment, trailing_comment }; } let cleaned_comment_arr = comment ?.split('\n') .map((line) => line .trim() // replace `// ` for one liners .replace(/^\/\/\s*/g, '') // replace `\**` for the initial JSDoc .replace(/^\/\*\*?\s*/g, '') // migrate `*/` for the end of JSDoc .replace(/\s*\*\/$/g, '') // remove any initial `* ` to clean the comment .replace(/^\*\s*/g, '') ) .filter(Boolean); const first_at_comment = cleaned_comment_arr?.findIndex((line) => line.startsWith('@')); let cleaned_comment = cleaned_comment_arr ?.slice(0, first_at_comment !== -1 ? first_at_comment : cleaned_comment_arr.length) .join('\n'); let cleaned_comment_arr_trailing = trailing_comment ?.split('\n') .map((line) => line .trim() // replace `// ` for one liners .replace(/^\/\/\s*/g, '') // replace `\**` for the initial JSDoc .replace(/^\/\*\*?\s*/g, '') // migrate `*/` for the end of JSDoc .replace(/\s*\*\/$/g, '') // remove any initial `* ` to clean the comment .replace(/^\*\s*/g, '') ) .filter(Boolean); const first_at_comment_trailing = cleaned_comment_arr_trailing?.findIndex((line) => line.startsWith('@') ); let cleaned_comment_trailing = cleaned_comment_arr_trailing ?.slice( 0, first_at_comment_trailing !== -1 ? first_at_comment_trailing : cleaned_comment_arr_trailing.length ) .join('\n'); // try to find a comment with a type annotation, hinting at jsdoc if (parent?.type === 'ExportNamedDeclaration' && comment_node) { state.has_type_or_fallback = true; const match = /@type {(.+)}/.exec(comment_node.value); if (match) { // try to find JSDoc comments after a hyphen `-` const jsdoc_comment = /@type {.+} (?:\w+|\[.*?\]) - (.+)/.exec(comment_node.value); if (jsdoc_comment) { cleaned_comment += jsdoc_comment[1]?.trim(); } return { type: match[1], comment: cleaned_comment, trailing_comment: cleaned_comment_trailing }; } } // try to infer it from the init if (declarator.init?.type === 'Literal') { state.has_type_or_fallback = true; // only assume type if it's trivial to infer - else someone would've added a type annotation const type = typeof declarator.init.value; if (type === 'string' || type === 'number' || type === 'boolean') { return { type, comment: state.uses_ts ? comment : cleaned_comment, trailing_comment: state.uses_ts ? trailing_comment : cleaned_comment_trailing }; } } return { type: 'any', comment: state.uses_ts ? comment : cleaned_comment, trailing_comment: state.uses_ts ? trailing_comment : cleaned_comment_trailing }; } // Ensure modifiers are applied in the same order as Svelte 4 const modifier_order = [ 'preventDefault', 'stopPropagation', 'stopImmediatePropagation', 'self', 'trusted', 'once' ]; /** * @param {AST.RegularElement | AST.SvelteElement | AST.SvelteWindow | AST.SvelteDocument | AST.SvelteBody} element * @param {State} state */ function handle_events(element, state) { /** @type {Map<string, AST.OnDirective[]>} */ const handlers = new Map(); for (const attribute of element.attributes) { if (attribute.type !== 'OnDirective') continue; let name = `on${attribute.name}`; if (attribute.modifiers.includes('capture')) { name += 'capture'; } const nodes = handlers.get(name) || []; nodes.push(attribute); handlers.set(name, nodes); } for (const [name, nodes] of handlers) { const handlers = []; let first = null; for (const node of nodes) { /** @type {string} */ let body; if (node.expression) { body = state.str.original.substring( /** @type {number} */ (node.expression.start), /** @type {number} */ (node.expression.end) ); } else { body = `${state.names.bubble}('${node.name}')`; state.legacy_imports.add('createBubbler'); state.script_insertions.add( `const ${state.names.bubble} = ${state.names.createBubbler}();` ); } const has_passive = node.modifiers.includes('passive'); const has_nonpassive = node.modifiers.includes('nonpassive'); const modifiers = modifier_order.filter((modifier) => node.modifiers.includes(modifier)); for (const modifier of modifiers) { state.legacy_imports.add(modifier); body = `${state.names[modifier]}(${body})`; } if (has_passive || has_nonpassive) { const action = has_passive ? 'passive' : 'nonpassive'; state.legacy_imports.add(action); state.str.overwrite( node.start, node.end, `use:${state.names[action]}={['${node.name}', () => ${body}]}` ); } else { if (first) { let start = node.start; let end = node.end; while (/[\s\n]/.test(state.str.original[start - 1])) start -= 1; state.str.remove(start, end); } else { first = node; } handlers.push(body); } } if (first) { /** @type {string} */ let replacement; if (handlers.length > 1) { state.legacy_imports.add('handlers'); replacement = `${name}={${state.names.handlers}(${handlers.join(', ')})}`; } else { const handler = handlers[0]; replacement = handler === name ? `{${handler}}` : `${name}={${handler}}`; } state.str.overwrite(first.start, first.end, replacement); } } } /** * Returns start and end of the node. If the start is preceeded with white-space-only before a line break, * the start will be the start of the line. * @param {string} source * @param {LabeledStatement} node */ function get_node_range(source, node) { const first_leading_comment = node.leadingComments?.[0]; const last_trailing_comment = node.trailingComments?.[node.trailingComments.length - 1]; // @ts-expect-error the type of `Comment` seems to be wrong...the node actually contains // start and end but the type seems to only contain a `range` (which doesn't actually exists) let start = /** @type {number} */ (first_leading_comment?.start ?? node.start); // @ts-expect-error the type of `Comment` seems to be wrong...the node actually contains // start and end but the type seems to only contain a `range` (which doesn't actually exists) let end = /** @type {number} */ (last_trailing_comment?.end ?? node.end); let idx = start; while (source[idx - 1] !== '\n' && source[idx - 1] !== '\r') { idx--; if (source[idx] !== ' ' && source[idx] !== '\t') { idx = start; break; } } start = idx; return { start, end }; } /** * @param {Identifier} node * @param {State} state * @param {any[]} path */ function handle_identifier(node, state, path) { const parent = path.at(-1); if (parent?.type === 'MemberExpression' && parent.property === node) return; if (state.analysis.uses_props && node.name !== '$$slots') { if (node.name === '$$props' || node.name === '$$restProps') { // not 100% correct for $$restProps but it'll do state.str.update( /** @type {number} */ (node.start), /** @type {number} */ (node.end), state.names.props ); } else { const binding = state.scope.get(node.name); if (binding?.kind === 'bindable_prop' && binding.node !== node) { state.str.prependLeft(/** @type {number} */ (node.start), `${state.names.props}.`); } } } else if (node.name === '$$restProps' && state.analysis.uses_rest_props) { state.str.update( /** @type {number} */ (node.start), /** @type {number} */ (node.end), state.names.rest ); } else if (node.name === '$$slots' && state.analysis.uses_slots) { if (parent?.type === 'MemberExpression') { if (state.analysis.custom_element) return; let name = parent.property.type === 'Literal' ? parent.property.value : parent.property.name; let slot_name = name; const existing_prop = state.props.find((prop) => prop.slot_name === name); if (existing_prop) { name = existing_prop.local; } else if (name !== 'default') { let new_name = state.scope.generate(name); if (new_name !== name) { throw new MigrationError( `This migration would change the name of a slot (${name} to ${new_name}) making the component unusable` ); } } name = name === 'default' ? 'children' : name; if (!existing_prop) { state.props.push({ local: name, exported: name, init: '', bindable: false, optional: true, slot_name, // if it's the first time we encounter this slot // we start with any and delegate to when the slot // is actually rendered (it might not happen in that case) // any is still a safe bet type: `import('svelte').Snippet<[any]>`, needs_refine_type: true }); } state.str.update( /** @type {number} */ (node.start), parent.property.start, state.analysis.uses_props ? `${state.names.props}.` : '' ); state.str.update(parent.property.start, parent.end, name); } // else passed as identifier, we don't know what to do here, so let it error } else if ( parent?.type === 'TSInterfaceDeclaration' || parent?.type === 'TSTypeAliasDeclaration' ) { const members = parent.type === 'TSInterfaceDeclaration' ? parent.body.body : parent.typeAnnotation?.members; if (Array.isArray(members)) { if (node.name === '$$Props') { state.has_type_or_fallback = true; for (const member of members) { const prop = state.props.find((prop) => prop.exported === member.key.name); const type = state.str.original.substring( member.typeAnnotation.typeAnnotation.start, member.typeAnnotation.typeAnnotation.end ); let comment; const comment_node = member.leadingComments?.at(-1); if (comment_node?.type === 'Block') { comment = state.str.original.substring(comment_node.start, comment_node.end); } const trailing_comment = member.trailingComments?.at(0)?.value; if (prop) { prop.type = type; prop.optional = member.optional; prop.comment = comment ?? prop.comment; prop.trailing_comment = trailing_comment ?? prop.trailing_comment; } else { state.props.push({ local: member.key.name, exported: member.key.name, init: '', bindable: false, optional: member.optional, type, comment, trailing_comment, type_only: true }); } } state.str.remove(parent.start, parent.end); } } } } /** @param {string} content */ function guess_indent(content) { const lines = content.split('\n'); const tabbed = lines.filter((line) => /^\t+/.test(line)); const spaced = lines.filter((line) => /^ {2,}/.test(line)); if (tabbed.length === 0 && spaced.length === 0) { return '\t'; } // More lines tabbed than spaced? Assume tabs, and // default to tabs in the case of a tie (or nothing // to go on) if (tabbed.length >= spaced.length) { return '\t'; } // Otherwise, we need to guess the multiple const min = spaced.reduce((previous, current) => { const count = /^ +/.exec(current)?.[0].length ?? 0; return Math.min(count, previous); }, Infinity); return ' '.repeat(min); }
```

# compiler/phases/1-parse/acorn.js

```js
/** @import { Comment, Program } from 'estree' */ /** @import { AST } from '#compiler' */ import * as acorn from 'acorn'; import { walk } from 'zimmerframe'; import { tsPlugin } from '@sveltejs/acorn-typescript'; const ParserWithTS = acorn.Parser.extend(tsPlugin()); /** * @typedef {Comment & { * start: number; * end: number; * }} CommentWithLocation */ /** * @param {string} source * @param {AST.JSComment[]} comments * @param {boolean} typescript * @param {boolean} [is_script] */ export function parse(source, comments, typescript, is_script) { const parser = typescript ? ParserWithTS : acorn.Parser; const { onComment, add_comments } = get_comment_handlers( source, /** @type {CommentWithLocation[]} */ (comments) ); // @ts-ignore const parse_statement = parser.prototype.parseStatement; // If we're dealing with a <script> then it might contain an export // for something that doesn't exist directly inside but is inside the // component instead, so we need to ensure that Acorn doesn't throw // an error in these cases if (is_script) { // @ts-ignore parser.prototype.parseStatement = function (...args) { const v = parse_statement.call(this, ...args); // @ts-ignore this.undefinedExports = {}; return v; }; } let ast; try { ast = parser.parse(source, { onComment, sourceType: 'module', ecmaVersion: 16, locations: true }); } finally { if (is_script) { // @ts-ignore parser.prototype.parseStatement = parse_statement; } } add_comments(ast); return /** @type {Program} */ (ast); } /** * @param {string} source * @param {Comment[]} comments * @param {boolean} typescript * @param {number} index * @returns {acorn.Expression & { leadingComments?: CommentWithLocation[]; trailingComments?: CommentWithLocation[]; }} */ export function parse_expression_at(source, comments, typescript, index) { const parser = typescript ? ParserWithTS : acorn.Parser; const { onComment, add_comments } = get_comment_handlers( source, /** @type {CommentWithLocation[]} */ (comments), index ); const ast = parser.parseExpressionAt(source, index, { onComment, sourceType: 'module', ecmaVersion: 16, locations: true }); add_comments(ast); return ast; } /** * Acorn doesn't add comments to the AST by itself. This factory returns the capabilities * to add them after the fact. They are needed in order to support `svelte-ignore` comments * in JS code and so that `prettier-plugin-svelte` doesn't remove all comments when formatting. * @param {string} source * @param {CommentWithLocation[]} comments * @param {number} index */ function get_comment_handlers(source, comments, index = 0) { return { /** * @param {boolean} block * @param {string} value * @param {number} start * @param {number} end * @param {import('acorn').Position} [start_loc] * @param {import('acorn').Position} [end_loc] */ onComment: (block, value, start, end, start_loc, end_loc) => { if (block && /\n/.test(value)) { let a = start; while (a > 0 && source[a - 1] !== '\n') a -= 1; let b = a; while (/[ \t]/.test(source[b])) b += 1; const indentation = source.slice(a, b); value = value.replace(new RegExp(`^${indentation}`, 'gm'), ''); } comments.push({ type: block ? 'Block' : 'Line', value, start, end, loc: { start: /** @type {import('acorn').Position} */ (start_loc), end: /** @type {import('acorn').Position} */ (end_loc) } }); }, /** @param {acorn.Node & { leadingComments?: CommentWithLocation[]; trailingComments?: CommentWithLocation[]; }} ast */ add_comments(ast) { if (comments.length === 0) return; comments = comments .filter((comment) => comment.start >= index) .map(({ type, value, start, end }) => ({ type, value, start, end })); walk(ast, null, { _(node, { next, path }) { let comment; while (comments[0] && comments[0].start < node.start) { comment = /** @type {CommentWithLocation} */ (comments.shift()); (node.leadingComments ||= []).push(comment); } next(); if (comments[0]) { const parent = /** @type {any} */ (path.at(-1)); if (parent === undefined || node.end !== parent.end) { const slice = source.slice(node.end, comments[0].start); const is_last_in_body = ((parent?.type === 'BlockStatement' || parent?.type === 'Program') && parent.body.indexOf(node) === parent.body.length - 1) || (parent?.type === 'ArrayExpression' && parent.elements.indexOf(node) === parent.elements.length - 1) || (parent?.type === 'ObjectExpression' && parent.properties.indexOf(node) === parent.properties.length - 1); if (is_last_in_body) { // Special case: There can be multiple trailing comments after the last node in a block, // and they can be separated by newlines let end = node.end; while (comments.length) { const comment = comments[0]; if (parent && comment.start >= parent.end) break; (node.trailingComments ||= []).push(comment); comments.shift(); end = comment.end; } } else if (node.end <= comments[0].start && /^[,) \t]*$/.test(slice)) { node.trailingComments = [/** @type {CommentWithLocation} */ (comments.shift())]; } } } } }); // Special case: Trailing comments after the root node (which can only happen for expression tags or for Program nodes). // Adding them ensures that we can later detect the end of the expression tag correctly. if (comments.length > 0 && (comments[0].start >= ast.end || ast.type === 'Program')) { (ast.trailingComments ||= []).push(...comments.splice(0)); } } }; }
```

# compiler/phases/1-parse/index.js

```js
/** @import { AST } from '#compiler' */ /** @import { Comment } from 'estree' */ // @ts-expect-error acorn type definitions are borked in the release we use import { isIdentifierStart, isIdentifierChar } from 'acorn'; import fragment from './state/fragment.js'; import { regex_whitespace } from '../patterns.js'; import * as e from '../../errors.js'; import { create_fragment } from './utils/create.js'; import read_options from './read/options.js'; import { is_reserved } from '../../../utils.js'; import { disallow_children } from '../2-analyze/visitors/shared/special-element.js'; import * as state from '../../state.js'; const regex_position_indicator = / \(\d+:\d+\)$/; const regex_lang_attribute = /<!--[^]*?-->|<script\s+(?:[^>]*|(?:[^=>'"/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)\s+)*)lang=(["'])?([^"' >]+)\1[^>]*>/g; export class Parser { /** * @readonly * @type {string} */ template; /** * @readonly * @type {string} */ template_untrimmed; /** * Whether or not we're in loose parsing mode, in which * case we try to continue parsing as much as possible * @type {boolean} */ loose; /** */ index = 0; /** Whether we're parsing in TypeScript mode */ ts = false; /** @type {AST.TemplateNode[]} */ stack = []; /** @type {AST.Fragment[]} */ fragments = []; /** @type {AST.Root} */ root; /** @type {Record<string, boolean>} */ meta_tags = {}; /** @type {LastAutoClosedTag | undefined} */ last_auto_closed_tag; /** * @param {string} template * @param {boolean} loose */ constructor(template, loose) { if (typeof template !== 'string') { throw new TypeError('Template must be a string'); } this.loose = loose; this.template_untrimmed = template; this.template = template.trimEnd(); let match_lang; do match_lang = regex_lang_attribute.exec(template); while (match_lang && match_lang[0][1] !== 's'); // ensure it starts with '<s' to match script tags regex_lang_attribute.lastIndex = 0; // reset matched index to pass tests - otherwise declare the regex inside the constructor this.ts = match_lang?.[2] === 'ts'; this.root = { css: null, js: [], // @ts-ignore start: null, // @ts-ignore end: null, type: 'Root', fragment: create_fragment(), options: null, comments: [], metadata: { ts: this.ts } }; this.stack.push(this.root); this.fragments.push(this.root.fragment); /** @type {ParserState} */ let state = fragment; while (this.index < this.template.length) { state = state(this) || fragment; } if (this.stack.length > 1) { const current = this.current(); if (this.loose) { current.end = this.template.length; } else if (current.type === 'RegularElement') { current.end = current.start + 1; e.element_unclosed(current, current.name); } else { current.end = current.start + 1; e.block_unclosed(current); } } if (state !== fragment) { e.unexpected_eof(this.index); } if (this.root.fragment.nodes.length) { let start = /** @type {number} */ (this.root.fragment.nodes[0].start); while (regex_whitespace.test(template[start])) start += 1; let end = /** @type {number} */ ( this.root.fragment.nodes[this.root.fragment.nodes.length - 1].end ); while (regex_whitespace.test(template[end - 1])) end -= 1; this.root.start = start; this.root.end = end; } else { // @ts-ignore this.root.start = this.root.end = null; } const options_index = this.root.fragment.nodes.findIndex( /** @param {any} thing */ (thing) => thing.type === 'SvelteOptions' ); if (options_index !== -1) { const options = /** @type {AST.SvelteOptionsRaw} */ (this.root.fragment.nodes[options_index]); this.root.fragment.nodes.splice(options_index, 1); this.root.options = read_options(options); disallow_children(options); // We need this for the old AST format Object.defineProperty(this.root.options, '__raw__', { value: options, enumerable: false }); } } current() { return this.stack[this.stack.length - 1]; } /** * @param {any} err * @returns {never} */ acorn_error(err) { e.js_parse_error(err.pos, err.message.replace(regex_position_indicator, '')); } /** * @param {string} str * @param {boolean} required * @param {boolean} required_in_loose */ eat(str, required = false, required_in_loose = true) { if (this.match(str)) { this.index += str.length; return true; } if (required && (!this.loose || required_in_loose)) { e.expected_token(this.index, str); } return false; } /** @param {string} str */ match(str) { const length = str.length; if (length === 1) { // more performant than slicing return this.template[this.index] === str; } return this.template.slice(this.index, this.index + length) === str; } /** * Match a regex at the current index * @param {RegExp} pattern Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance */ match_regex(pattern) { const match = pattern.exec(this.template.slice(this.index)); if (!match || match.index !== 0) return null; return match[0]; } allow_whitespace() { while (this.index < this.template.length && regex_whitespace.test(this.template[this.index])) { this.index++; } } /** * Search for a regex starting at the current index and return the result if it matches * @param {RegExp} pattern Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance */ read(pattern) { const result = this.match_regex(pattern); if (result) this.index += result.length; return result; } /** @param {any} allow_reserved */ read_identifier(allow_reserved = false) { const start = this.index; let i = this.index; const code = /** @type {number} */ (this.template.codePointAt(i)); if (!isIdentifierStart(code, true)) return null; i += code <= 0xffff ? 1 : 2; while (i < this.template.length) { const code = /** @type {number} */ (this.template.codePointAt(i)); if (!isIdentifierChar(code, true)) break; i += code <= 0xffff ? 1 : 2; } const identifier = this.template.slice(this.index, (this.index = i)); if (!allow_reserved && is_reserved(identifier)) { e.unexpected_reserved_word(start, identifier); } return identifier; } /** @param {RegExp} pattern */ read_until(pattern) { if (this.index >= this.template.length) { if (this.loose) return ''; e.unexpected_eof(this.template.length); } const start = this.index; const match = pattern.exec(this.template.slice(start)); if (match) { this.index = start + match.index; return this.template.slice(start, this.index); } this.index = this.template.length; return this.template.slice(start); } require_whitespace() { if (!regex_whitespace.test(this.template[this.index])) { e.expected_whitespace(this.index); } this.allow_whitespace(); } pop() { this.fragments.pop(); return this.stack.pop(); } /** * @template {AST.Fragment['nodes'][number]} T * @param {T} node * @returns {T} */ append(node) { this.fragments.at(-1)?.nodes.push(node); return node; } } /** * @param {string} template * @param {boolean} [loose] * @returns {AST.Root} */ export function parse(template, loose = false) { state.set_source(template); const parser = new Parser(template, loose); return parser.root; } /** @typedef {(parser: Parser) => ParserState | void} ParserState */ /** @typedef {Object} LastAutoClosedTag * @property {string} tag * @property {string} reason * @property {number} depth */
```

# compiler/phases/1-parse/read/context.js

```js
/** @import { Location } from 'locate-character' */ /** @import { Pattern } from 'estree' */ /** @import { Parser } from '../index.js' */ import { match_bracket } from '../utils/bracket.js'; import { parse_expression_at } from '../acorn.js'; import { regex_not_newline_characters } from '../../patterns.js'; import * as e from '../../../errors.js'; import { locator } from '../../../state.js'; /** * @param {Parser} parser * @returns {Pattern} */ export default function read_pattern(parser) { const start = parser.index; let i = parser.index; const name = parser.read_identifier(); if (name !== null) { const annotation = read_type_annotation(parser); return { type: 'Identifier', name, start, loc: { start: /** @type {Location} */ (locator(start)), end: /** @type {Location} */ (locator(parser.index)) }, end: parser.index, typeAnnotation: annotation }; } const char = parser.template[i]; if (char !== '{' && char !== '[') { e.expected_pattern(i); } i = match_bracket(parser, start); parser.index = i; const pattern_string = parser.template.slice(start, i); try { // the length of the `space_with_newline` has to be start - 1 // because we added a `(` in front of the pattern_string, // which shifted the entire string to right by 1 // so we offset it by removing 1 character in the `space_with_newline` // to achieve that, we remove the 1st space encountered, // so it will not affect the `column` of the node let space_with_newline = parser.template .slice(0, start) .replace(regex_not_newline_characters, ' '); const first_space = space_with_newline.indexOf(' '); space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1); const expression = /** @type {any} */ ( parse_expression_at( `${space_with_newline}(${pattern_string} = 1)`, parser.root.comments, parser.ts, start - 1 ) ).left; expression.typeAnnotation = read_type_annotation(parser); if (expression.typeAnnotation) { expression.end = expression.typeAnnotation.end; } return expression; } catch (error) { parser.acorn_error(error); } } /** * @param {Parser} parser * @returns {any} */ function read_type_annotation(parser) { const start = parser.index; parser.allow_whitespace(); if (!parser.eat(':')) { parser.index = start; return undefined; } // we need to trick Acorn into parsing the type annotation const insert = '_ as '; let a = parser.index - insert.length; const template = parser.template.slice(0, a).replace(/[^\n]/g, ' ') + insert + // If this is a type annotation for a function parameter, Acorn-TS will treat subsequent // parameters as part of a sequence expression instead, and will then error on optional // parameters (`?:`). Therefore replace that sequence with something that will not error. parser.template.slice(parser.index).replace(/\?\s*:/g, ':'); let expression = parse_expression_at(template, parser.root.comments, parser.ts, a); // `foo: bar = baz` gets mangled — fix it if (expression.type === 'AssignmentExpression') { let b = expression.right.start; while (template[b] !== '=') b -= 1; expression = parse_expression_at(template.slice(0, b), parser.root.comments, parser.ts, a); } // `array as item: string, index` becomes `string, index`, which is mistaken as a sequence expression - fix that if (expression.type === 'SequenceExpression') { expression = expression.expressions[0]; } parser.index = /** @type {number} */ (expression.end); return { type: 'TSTypeAnnotation', start, end: parser.index, typeAnnotation: /** @type {any} */ (expression).typeAnnotation }; }
```

# compiler/phases/1-parse/read/expression.js

```js
/** @import { Expression } from 'estree' */ /** @import { Parser } from '../index.js' */ import { parse_expression_at } from '../acorn.js'; import { regex_whitespace } from '../../patterns.js'; import * as e from '../../../errors.js'; import { find_matching_bracket } from '../utils/bracket.js'; /** * @param {Parser} parser * @param {string} [opening_token] * @returns {Expression | undefined} */ export function get_loose_identifier(parser, opening_token) { // Find the next } and treat it as the end of the expression const end = find_matching_bracket(parser.template, parser.index, opening_token ?? '{'); if (end) { const start = parser.index; parser.index = end; // We don't know what the expression is and signal this by returning an empty identifier return { type: 'Identifier', start, end, name: '' }; } } /** * @param {Parser} parser * @param {string} [opening_token] * @param {boolean} [disallow_loose] * @returns {Expression} */ export default function read_expression(parser, opening_token, disallow_loose) { try { let comment_index = parser.root.comments.length; const node = parse_expression_at( parser.template, parser.root.comments, parser.ts, parser.index ); let num_parens = 0; let i = parser.root.comments.length; while (i-- > comment_index) { const comment = parser.root.comments[i]; if (comment.end < node.start) { parser.index = comment.end; break; } } for (let i = parser.index; i < /** @type {number} */ (node.start); i += 1) { if (parser.template[i] === '(') num_parens += 1; } let index = /** @type {number} */ (node.end); const last_comment = parser.root.comments.at(-1); if (last_comment && last_comment.end > index) index = last_comment.end; while (num_parens > 0) { const char = parser.template[index]; if (char === ')') { num_parens -= 1; } else if (!regex_whitespace.test(char)) { e.expected_token(index, ')'); } index += 1; } parser.index = index; return /** @type {Expression} */ (node); } catch (err) { // If we are in an each loop we need the error to be thrown in cases like // `as { y = z }` so we still throw and handle the error there if (parser.loose && !disallow_loose) { const expression = get_loose_identifier(parser, opening_token); if (expression) { return expression; } } parser.acorn_error(err); } }
```

# compiler/phases/1-parse/read/options.js

```js
/** @import { ObjectExpression } from 'estree' */ /** @import { AST } from '#compiler' */ import { NAMESPACE_MATHML, NAMESPACE_SVG } from '../../../../constants.js'; import * as e from '../../../errors.js'; /** * @param {AST.SvelteOptionsRaw} node * @returns {AST.Root['options']} */ export default function read_options(node) { /** @type {AST.SvelteOptions} */ const component_options = { start: node.start, end: node.end, // @ts-ignore attributes: node.attributes }; if (!node) { return component_options; } for (const attribute of node.attributes) { if (attribute.type !== 'Attribute') { e.svelte_options_invalid_attribute(attribute); } const { name } = attribute; switch (name) { case 'runes': { component_options.runes = get_boolean_value(attribute); break; } case 'tag': { e.svelte_options_deprecated_tag(attribute); break; // eslint doesn't know this is unnecessary } case 'customElement': { /** @type {AST.SvelteOptions['customElement']} */ const ce = {}; const { value: v } = attribute; const value = v === true || Array.isArray(v) ? v : [v]; if (value === true) { e.svelte_options_invalid_customelement(attribute); } else if (value[0].type === 'Text') { const tag = get_static_value(attribute); validate_tag(attribute, tag); ce.tag = tag; component_options.customElement = ce; break; } else if (value[0].expression.type !== 'ObjectExpression') { // Before Svelte 4 it was necessary to explicitly set customElement to null or else you'd get a warning. // This is no longer necessary, but for backwards compat just skip in this case now. if (value[0].expression.type === 'Literal' && value[0].expression.value === null) { break; } e.svelte_options_invalid_customelement(attribute); } /** @type {Array<[string, any]>} */ const properties = []; for (const property of value[0].expression.properties) { if ( property.type !== 'Property' || property.computed || property.key.type !== 'Identifier' ) { e.svelte_options_invalid_customelement(attribute); } properties.push([property.key.name, property.value]); } const tag = properties.find(([name]) => name === 'tag'); if (tag) { const tag_value = tag[1]?.value; validate_tag(tag, tag_value); ce.tag = tag_value; } const props = properties.find(([name]) => name === 'props')?.[1]; if (props) { if (props.type !== 'ObjectExpression') { e.svelte_options_invalid_customelement_props(attribute); } ce.props = {}; for (const property of /** @type {ObjectExpression} */ (props).properties) { if ( property.type !== 'Property' || property.computed || property.key.type !== 'Identifier' || property.value.type !== 'ObjectExpression' ) { e.svelte_options_invalid_customelement_props(attribute); } ce.props[property.key.name] = {}; for (const prop of property.value.properties) { if ( prop.type !== 'Property' || prop.computed || prop.key.type !== 'Identifier' || prop.value.type !== 'Literal' ) { e.svelte_options_invalid_customelement_props(attribute); } if (prop.key.name === 'type') { if ( ['String', 'Number', 'Boolean', 'Array', 'Object'].indexOf( /** @type {string} */ (prop.value.value) ) === -1 ) { e.svelte_options_invalid_customelement_props(attribute); } ce.props[property.key.name].type = /** @type {any} */ (prop.value.value); } else if (prop.key.name === 'reflect') { if (typeof prop.value.value !== 'boolean') { e.svelte_options_invalid_customelement_props(attribute); } ce.props[property.key.name].reflect = prop.value.value; } else if (prop.key.name === 'attribute') { if (typeof prop.value.value !== 'string') { e.svelte_options_invalid_customelement_props(attribute); } ce.props[property.key.name].attribute = prop.value.value; } else { e.svelte_options_invalid_customelement_props(attribute); } } } } const shadow = properties.find(([name]) => name === 'shadow')?.[1]; if (shadow) { const shadowdom = shadow?.value; if (shadowdom !== 'open' && shadowdom !== 'none') { e.svelte_options_invalid_customelement_shadow(shadow); } ce.shadow = shadowdom; } const extend = properties.find(([name]) => name === 'extend')?.[1]; if (extend) { ce.extend = extend; } component_options.customElement = ce; break; } case 'namespace': { const value = get_static_value(attribute); if (value === NAMESPACE_SVG) { component_options.namespace = 'svg'; } else if (value === NAMESPACE_MATHML) { component_options.namespace = 'mathml'; } else if (value === 'html' || value === 'mathml' || value === 'svg') { component_options.namespace = value; } else { e.svelte_options_invalid_attribute_value(attribute, `"html", "mathml" or "svg"`); } break; } case 'css': { const value = get_static_value(attribute); if (value === 'injected') { component_options.css = value; } else { e.svelte_options_invalid_attribute_value(attribute, `"injected"`); } break; } case 'immutable': { component_options.immutable = get_boolean_value(attribute); break; } case 'preserveWhitespace': { component_options.preserveWhitespace = get_boolean_value(attribute); break; } case 'accessors': { component_options.accessors = get_boolean_value(attribute); break; } default: e.svelte_options_unknown_attribute(attribute, name); } } return component_options; } /** * @param {any} attribute */ function get_static_value(attribute) { const { value } = attribute; if (value === true) return true; const chunk = Array.isArray(value) ? value[0] : value; if (!chunk) return true; if (value.length > 1) { return null; } if (chunk.type === 'Text') return chunk.data; if (chunk.expression.type !== 'Literal') { return null; } return chunk.expression.value; } /** * @param {any} attribute */ function get_boolean_value(attribute) { const value = get_static_value(attribute); if (typeof value !== 'boolean') { e.svelte_options_invalid_attribute_value(attribute, 'true or false'); } return value; } // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name const tag_name_char = '[a-z0-9_.\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u{10000}-\u{EFFFF}-]'; const regex_valid_tag_name = new RegExp(`^[a-z]${tag_name_char}*-${tag_name_char}*$`, 'u'); const reserved_tag_names = [ 'annotation-xml', 'color-profile', 'font-face', 'font-face-src', 'font-face-uri', 'font-face-format', 'font-face-name', 'missing-glyph' ]; /** * @param {any} attribute * @param {string | null} tag * @returns {asserts tag is string} */ function validate_tag(attribute, tag) { if (typeof tag !== 'string') { e.svelte_options_invalid_tagname(attribute); } if (tag) { if (!regex_valid_tag_name.test(tag)) { e.svelte_options_invalid_tagname(attribute); } else if (reserved_tag_names.includes(tag)) { e.svelte_options_reserved_tagname(attribute); } } }
```

# compiler/phases/1-parse/read/script.js

```js
/** @import { Program } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { Parser } from '../index.js' */ import * as acorn from '../acorn.js'; import { regex_not_newline_characters } from '../../patterns.js'; import * as e from '../../../errors.js'; import * as w from '../../../warnings.js'; import { is_text_attribute } from '../../../utils/ast.js'; const regex_closing_script_tag = /<\/script\s*>/; const regex_starts_with_closing_script_tag = /^<\/script\s*>/; const RESERVED_ATTRIBUTES = ['server', 'client', 'worker', 'test', 'default']; const ALLOWED_ATTRIBUTES = ['context', 'generics', 'lang', 'module']; /** * @param {Parser} parser * @param {number} start * @param {Array<AST.Attribute | AST.SpreadAttribute | AST.Directive | AST.AttachTag>} attributes * @returns {AST.Script} */ export function read_script(parser, start, attributes) { const script_start = parser.index; const data = parser.read_until(regex_closing_script_tag); if (parser.index >= parser.template.length) { e.element_unclosed(parser.template.length, 'script'); } const source = parser.template.slice(0, script_start).replace(regex_not_newline_characters, ' ') + data; parser.read(regex_starts_with_closing_script_tag); /** @type {Program} */ let ast; try { ast = acorn.parse(source, parser.root.comments, parser.ts, true); } catch (err) { parser.acorn_error(err); } // TODO is this necessary? ast.start = script_start; /** @type {'default' | 'module'} */ let context = 'default'; for (const attribute of /** @type {AST.Attribute[]} */ (attributes)) { if (RESERVED_ATTRIBUTES.includes(attribute.name)) { e.script_reserved_attribute(attribute, attribute.name); } if (!ALLOWED_ATTRIBUTES.includes(attribute.name)) { w.script_unknown_attribute(attribute); } if (attribute.name === 'module') { if (attribute.value !== true) { // Deliberately a generic code to future-proof for potential other attributes e.script_invalid_attribute_value(attribute, attribute.name); } context = 'module'; } if (attribute.name === 'context') { if (attribute.value === true || !is_text_attribute(attribute)) { e.script_invalid_context(attribute); } const value = attribute.value[0].data; if (value !== 'module') { e.script_invalid_context(attribute); } context = 'module'; } } return { type: 'Script', start, end: parser.index, context, content: ast, // @ts-ignore attributes }; }
```

# compiler/phases/1-parse/read/style.js

```js
/** @import { AST } from '#compiler' */ /** @import { Parser } from '../index.js' */ import * as e from '../../../errors.js'; const REGEX_MATCHER = /^[~^$*|]?=/; const REGEX_CLOSING_BRACKET = /[\s\]]/; const REGEX_ATTRIBUTE_FLAGS = /^[a-zA-Z]+/; // only `i` and `s` are valid today, but make it future-proof const REGEX_COMBINATOR = /^(\+|~|>|\|\|)/; const REGEX_PERCENTAGE = /^\d+(\.\d+)?%/; const REGEX_NTH_OF = /^(even|odd|\+?(\d+|\d*n(\s*[+-]\s*\d+)?)|-\d*n(\s*\+\s*\d+))((?=\s*[,)])|\s+of\s+)/; const REGEX_WHITESPACE_OR_COLON = /[\s:]/; const REGEX_LEADING_HYPHEN_OR_DIGIT = /-?\d/; const REGEX_VALID_IDENTIFIER_CHAR = /[a-zA-Z0-9_-]/; const REGEX_UNICODE_SEQUENCE = /^\\[0-9a-fA-F]{1,6}(\r\n|\s)?/; const REGEX_COMMENT_CLOSE = /\*\//; const REGEX_HTML_COMMENT_CLOSE = /-->/; /** * @param {Parser} parser * @param {number} start * @param {Array<AST.Attribute | AST.SpreadAttribute | AST.Directive | AST.AttachTag>} attributes * @returns {AST.CSS.StyleSheet} */ export default function read_style(parser, start, attributes) { const content_start = parser.index; const children = read_body(parser, '</style'); const content_end = parser.index; parser.read(/^<\/style\s*>/); return { type: 'StyleSheet', start, end: parser.index, attributes, children, content: { start: content_start, end: content_end, styles: parser.template.slice(content_start, content_end), comment: null } }; } /** * @param {Parser} parser * @param {string} close * @returns {any[]} */ function read_body(parser, close) { /** @type {Array<AST.CSS.Rule | AST.CSS.Atrule>} */ const children = []; while (parser.index < parser.template.length) { allow_comment_or_whitespace(parser); if (parser.match(close)) { return children; } if (parser.match('@')) { children.push(read_at_rule(parser)); } else { children.push(read_rule(parser)); } } e.expected_token(parser.template.length, close); } /** * @param {Parser} parser * @returns {AST.CSS.Atrule} */ function read_at_rule(parser) { const start = parser.index; parser.eat('@', true); const name = read_identifier(parser); const prelude = read_value(parser); /** @type {AST.CSS.Block | null} */ let block = null; if (parser.match('{')) { // e.g. `@media (...) {...}` block = read_block(parser); } else { // e.g. `@import '...'` parser.eat(';', true); } return { type: 'Atrule', start, end: parser.index, name, prelude, block }; } /** * @param {Parser} parser * @returns {AST.CSS.Rule} */ function read_rule(parser) { const start = parser.index; return { type: 'Rule', prelude: read_selector_list(parser), block: read_block(parser), start, end: parser.index, metadata: { parent_rule: null, has_local_selectors: false, has_global_selectors: false, is_global_block: false } }; } /** * @param {Parser} parser * @param {boolean} [inside_pseudo_class] * @returns {AST.CSS.SelectorList} */ function read_selector_list(parser, inside_pseudo_class = false) { /** @type {AST.CSS.ComplexSelector[]} */ const children = []; allow_comment_or_whitespace(parser); const start = parser.index; while (parser.index < parser.template.length) { children.push(read_selector(parser, inside_pseudo_class)); const end = parser.index; allow_comment_or_whitespace(parser); if (inside_pseudo_class ? parser.match(')') : parser.match('{')) { return { type: 'SelectorList', start, end, children }; } else { parser.eat(',', true); allow_comment_or_whitespace(parser); } } e.unexpected_eof(parser.template.length); } /** * @param {Parser} parser * @param {boolean} [inside_pseudo_class] * @returns {AST.CSS.ComplexSelector} */ function read_selector(parser, inside_pseudo_class = false) { const list_start = parser.index; /** @type {AST.CSS.RelativeSelector[]} */ const children = []; /** * @param {AST.CSS.Combinator | null} combinator * @param {number} start * @returns {AST.CSS.RelativeSelector} */ function create_selector(combinator, start) { return { type: 'RelativeSelector', combinator, selectors: [], start, end: -1, metadata: { is_global: false, is_global_like: false, scoped: false } }; } /** @type {AST.CSS.RelativeSelector} */ let relative_selector = create_selector(null, parser.index); while (parser.index < parser.template.length) { let start = parser.index; if (parser.eat('&')) { relative_selector.selectors.push({ type: 'NestingSelector', name: '&', start, end: parser.index }); } else if (parser.eat('*')) { let name = '*'; if (parser.eat('|')) { // * is the namespace (which we ignore) name = read_identifier(parser); } relative_selector.selectors.push({ type: 'TypeSelector', name, start, end: parser.index }); } else if (parser.eat('#')) { relative_selector.selectors.push({ type: 'IdSelector', name: read_identifier(parser), start, end: parser.index }); } else if (parser.eat('.')) { relative_selector.selectors.push({ type: 'ClassSelector', name: read_identifier(parser), start, end: parser.index }); } else if (parser.eat('::')) { relative_selector.selectors.push({ type: 'PseudoElementSelector', name: read_identifier(parser), start, end: parser.index }); // We read the inner selectors of a pseudo element to ensure it parses correctly, // but we don't do anything with the result. if (parser.eat('(')) { read_selector_list(parser, true); parser.eat(')', true); } } else if (parser.eat(':')) { const name = read_identifier(parser); /** @type {null | AST.CSS.SelectorList} */ let args = null; if (parser.eat('(')) { args = read_selector_list(parser, true); parser.eat(')', true); } relative_selector.selectors.push({ type: 'PseudoClassSelector', name, args, start, end: parser.index }); } else if (parser.eat('[')) { parser.allow_whitespace(); const name = read_identifier(parser); parser.allow_whitespace(); /** @type {string | null} */ let value = null; const matcher = parser.read(REGEX_MATCHER); if (matcher) { parser.allow_whitespace(); value = read_attribute_value(parser); } parser.allow_whitespace(); const flags = parser.read(REGEX_ATTRIBUTE_FLAGS); parser.allow_whitespace(); parser.eat(']', true); relative_selector.selectors.push({ type: 'AttributeSelector', start, end: parser.index, name, matcher, value, flags }); } else if (inside_pseudo_class && parser.match_regex(REGEX_NTH_OF)) { // nth of matcher must come before combinator matcher to prevent collision else the '+' in '+2n-1' would be parsed as a combinator relative_selector.selectors.push({ type: 'Nth', value: /**@type {string} */ (parser.read(REGEX_NTH_OF)), start, end: parser.index }); } else if (parser.match_regex(REGEX_PERCENTAGE)) { relative_selector.selectors.push({ type: 'Percentage', value: /** @type {string} */ (parser.read(REGEX_PERCENTAGE)), start, end: parser.index }); } else if (!parser.match_regex(REGEX_COMBINATOR)) { let name = read_identifier(parser); if (parser.eat('|')) { // we ignore the namespace when trying to find matching element classes name = read_identifier(parser); } relative_selector.selectors.push({ type: 'TypeSelector', name, start, end: parser.index }); } const index = parser.index; allow_comment_or_whitespace(parser); if (parser.match(',') || (inside_pseudo_class ? parser.match(')') : parser.match('{'))) { // rewind, so we know whether to continue building the selector list parser.index = index; relative_selector.end = index; children.push(relative_selector); return { type: 'ComplexSelector', start: list_start, end: index, children, metadata: { rule: null, is_global: false, used: false } }; } parser.index = index; const combinator = read_combinator(parser); if (combinator) { if (relative_selector.selectors.length > 0) { relative_selector.end = index; children.push(relative_selector); } // ...and start a new one relative_selector = create_selector(combinator, combinator.start); parser.allow_whitespace(); if (parser.match(',') || (inside_pseudo_class ? parser.match(')') : parser.match('{'))) { e.css_selector_invalid(parser.index); } } } e.unexpected_eof(parser.template.length); } /** * @param {Parser} parser * @returns {AST.CSS.Combinator | null} */ function read_combinator(parser) { const start = parser.index; parser.allow_whitespace(); const index = parser.index; const name = parser.read(REGEX_COMBINATOR); if (name) { const end = parser.index; parser.allow_whitespace(); return { type: 'Combinator', name, start: index, end }; } if (parser.index !== start) { return { type: 'Combinator', name: ' ', start, end: parser.index }; } return null; } /** * @param {Parser} parser * @returns {AST.CSS.Block} */ function read_block(parser) { const start = parser.index; parser.eat('{', true); /** @type {Array<AST.CSS.Declaration | AST.CSS.Rule | AST.CSS.Atrule>} */ const children = []; while (parser.index < parser.template.length) { allow_comment_or_whitespace(parser); if (parser.match('}')) { break; } else { children.push(read_block_item(parser)); } } parser.eat('}', true); return { type: 'Block', start, end: parser.index, children }; } /** * Reads a declaration, rule or at-rule * * @param {Parser} parser * @returns {AST.CSS.Declaration | AST.CSS.Rule | AST.CSS.Atrule} */ function read_block_item(parser) { if (parser.match('@')) { return read_at_rule(parser); } // read ahead to understand whether we're dealing with a declaration or a nested rule. // this involves some duplicated work, but avoids a try-catch that would disguise errors const start = parser.index; read_value(parser); const char = parser.template[parser.index]; parser.index = start; return char === '{' ? read_rule(parser) : read_declaration(parser); } /** * @param {Parser} parser * @returns {AST.CSS.Declaration} */ function read_declaration(parser) { const start = parser.index; const property = parser.read_until(REGEX_WHITESPACE_OR_COLON); parser.allow_whitespace(); parser.eat(':'); let index = parser.index; parser.allow_whitespace(); const value = read_value(parser); if (!value && !property.startsWith('--')) { e.css_empty_declaration({ start, end: index }); } const end = parser.index; if (!parser.match('}')) { parser.eat(';', true); } return { type: 'Declaration', start, end, property, value }; } /** * @param {Parser} parser * @returns {string} */ function read_value(parser) { let value = ''; let escaped = false; let in_url = false; /** @type {null | '"' | "'"} */ let quote_mark = null; while (parser.index < parser.template.length) { const char = parser.template[parser.index]; if (escaped) { value += '\\' + char; escaped = false; } else if (char === '\\') { escaped = true; } else if (char === quote_mark) { quote_mark = null; } else if (char === ')') { in_url = false; } else if (quote_mark === null && (char === '"' || char === "'")) { quote_mark = char; } else if (char === '(' && value.slice(-3) === 'url') { in_url = true; } else if ((char === ';' || char === '{' || char === '}') && !in_url && !quote_mark) { return value.trim(); } value += char; parser.index++; } e.unexpected_eof(parser.template.length); } /** * Read a property that may or may not be quoted, e.g. * `foo` or `'foo bar'` or `"foo bar"` * @param {Parser} parser */ function read_attribute_value(parser) { let value = ''; let escaped = false; const quote_mark = parser.eat('"') ? '"' : parser.eat("'") ? "'" : null; while (parser.index < parser.template.length) { const char = parser.template[parser.index]; if (escaped) { value += '\\' + char; escaped = false; } else if (char === '\\') { escaped = true; } else if (quote_mark ? char === quote_mark : REGEX_CLOSING_BRACKET.test(char)) { if (quote_mark) { parser.eat(quote_mark, true); } return value.trim(); } else { value += char; } parser.index++; } e.unexpected_eof(parser.template.length); } /** * https://www.w3.org/TR/css-syntax-3/#ident-token-diagram * @param {Parser} parser */ function read_identifier(parser) { const start = parser.index; let identifier = ''; if (parser.match_regex(REGEX_LEADING_HYPHEN_OR_DIGIT)) { e.css_expected_identifier(start); } while (parser.index < parser.template.length) { const char = parser.template[parser.index]; if (char === '\\') { const sequence = parser.match_regex(REGEX_UNICODE_SEQUENCE); if (sequence) { identifier += String.fromCodePoint(parseInt(sequence.slice(1), 16)); parser.index += sequence.length; } else { identifier += '\\' + parser.template[parser.index + 1]; parser.index += 2; } } else if ( /** @type {number} */ (char.codePointAt(0)) >= 160 || REGEX_VALID_IDENTIFIER_CHAR.test(char) ) { identifier += char; parser.index++; } else { break; } } if (identifier === '') { e.css_expected_identifier(start); } return identifier; } /** @param {Parser} parser */ function allow_comment_or_whitespace(parser) { parser.allow_whitespace(); while (parser.match('/*') || parser.match('<!--')) { if (parser.eat('/*')) { parser.read_until(REGEX_COMMENT_CLOSE); parser.eat('*/', true); } if (parser.eat('<!--')) { parser.read_until(REGEX_HTML_COMMENT_CLOSE); parser.eat('-->', true); } parser.allow_whitespace(); } }
```

# compiler/phases/1-parse/remove_typescript_nodes.js

```js
/** @import { Context, Visitors } from 'zimmerframe' */ /** @import { FunctionExpression, FunctionDeclaration } from 'estree' */ import { walk } from 'zimmerframe'; import * as b from '#compiler/builders'; import * as e from '../../errors.js'; /** * @param {FunctionExpression | FunctionDeclaration} node * @param {Context<any, any>} context */ function remove_this_param(node, context) { if (node.params[0]?.type === 'Identifier' && node.params[0].name === 'this') { node.params.shift(); } return context.next(); } /** @type {Visitors<any, null>} */ const visitors = { _(node, context) { const n = context.next() ?? node; // TODO there may come a time when we decide to preserve type annotations. // until that day comes, we just delete them so they don't confuse esrap delete n.typeAnnotation; delete n.typeParameters; delete n.typeArguments; delete n.returnType; delete n.accessibility; }, Decorator(node) { e.typescript_invalid_feature(node, 'decorators (related TSC proposal is not stage 4 yet)'); }, ImportDeclaration(node) { if (node.importKind === 'type') return b.empty; if (node.specifiers?.length > 0) { const specifiers = node.specifiers.filter((/** @type {any} */ s) => s.importKind !== 'type'); if (specifiers.length === 0) return b.empty; return { ...node, specifiers }; } return node; }, ExportNamedDeclaration(node, context) { if (node.exportKind === 'type') return b.empty; if (node.declaration) { const result = context.next(); if (result?.declaration?.type === 'EmptyStatement') { return b.empty; } return result; } if (node.specifiers) { const specifiers = node.specifiers.filter((/** @type {any} */ s) => s.exportKind !== 'type'); if (specifiers.length === 0) return b.empty; return { ...node, specifiers }; } return node; }, ExportDefaultDeclaration(node) { if (node.exportKind === 'type') return b.empty; return node; }, ExportAllDeclaration(node) { if (node.exportKind === 'type') return b.empty; return node; }, PropertyDefinition(node, { next }) { if (node.accessor) { e.typescript_invalid_feature( node, 'accessor fields (related TSC proposal is not stage 4 yet)' ); } return next(); }, TSAsExpression(node, context) { return context.visit(node.expression); }, TSSatisfiesExpression(node, context) { return context.visit(node.expression); }, TSNonNullExpression(node, context) { return context.visit(node.expression); }, TSInterfaceDeclaration() { return b.empty; }, TSTypeAliasDeclaration() { return b.empty; }, TSTypeAssertion(node, context) { return context.visit(node.expression); }, TSEnumDeclaration(node) { e.typescript_invalid_feature(node, 'enums'); }, TSParameterProperty(node, context) { if ((node.readonly || node.accessibility) && context.path.at(-2)?.kind === 'constructor') { e.typescript_invalid_feature(node, 'accessibility modifiers on constructor parameters'); } return context.visit(node.parameter); }, TSInstantiationExpression(node, context) { return context.visit(node.expression); }, FunctionExpression: remove_this_param, FunctionDeclaration: remove_this_param, TSDeclareFunction() { return b.empty; }, ClassBody(node, context) { const body = []; for (const _child of node.body) { const child = context.visit(_child); if (child.type !== 'PropertyDefinition' || !child.declare) { body.push(child); } } return { ...node, body }; }, ClassDeclaration(node, context) { if (node.declare) { return b.empty; } delete node.implements; return context.next(); }, MethodDefinition(node, context) { if (node.abstract) { return b.empty; } return context.next(); }, VariableDeclaration(node, context) { if (node.declare) { return b.empty; } return context.next(); }, TSModuleDeclaration(node, context) { if (!node.body) return b.empty; // namespaces can contain non-type nodes const cleaned = /** @type {any[]} */ (node.body.body).map((entry) => context.visit(entry)); if (cleaned.some((entry) => entry !== b.empty)) { e.typescript_invalid_feature(node, 'namespaces with non-type nodes'); } return b.empty; } }; /** * @template T * @param {T} ast * @returns {T} */ export function remove_typescript_nodes(ast) { return walk(ast, null, visitors); }
```

# compiler/phases/1-parse/state/element.js

```js
/** @import { Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { Parser } from '../index.js' */ import { is_void } from '../../../../utils.js'; import read_expression from '../read/expression.js'; import { read_script } from '../read/script.js'; import read_style from '../read/style.js'; import { decode_character_references } from '../utils/html.js'; import * as e from '../../../errors.js'; import * as w from '../../../warnings.js'; import { create_fragment } from '../utils/create.js'; import { create_attribute, create_expression_metadata, is_element_node } from '../../nodes.js'; import { get_attribute_expression, is_expression_attribute } from '../../../utils/ast.js'; import { closing_tag_omitted } from '../../../../html-tree-validation.js'; import { list } from '../../../utils/string.js'; import { regex_whitespace } from '../../patterns.js'; const regex_invalid_unquoted_attribute_value = /^(\/>|[\s"'=<>`])/; const regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i; const regex_closing_comment = /-->/; const regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/; const regex_token_ending_character = /[\s=/>"']/; const regex_starts_with_quote_characters = /^["']/; const regex_attribute_value = /^(?:"([^"]*)"|'([^'])*'|([^>\s]+))/; const regex_valid_element_name = /^(?:![a-zA-Z]+|[a-zA-Z](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?|[a-zA-Z][a-zA-Z0-9]*:[a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])$/; export const regex_valid_component_name = // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers adjusted for our needs // (must start with uppercase letter if no dots, can contain dots) /^(?:\p{Lu}[$\u200c\u200d\p{ID_Continue}.]*|\p{ID_Start}[$\u200c\u200d\p{ID_Continue}]*(?:\.[$\u200c\u200d\p{ID_Continue}]+)+)$/u; /** @type {Map<string, AST.ElementLike['type']>} */ const root_only_meta_tags = new Map([ ['svelte:head', 'SvelteHead'], ['svelte:options', 'SvelteOptions'], ['svelte:window', 'SvelteWindow'], ['svelte:document', 'SvelteDocument'], ['svelte:body', 'SvelteBody'] ]); /** @type {Map<string, AST.ElementLike['type']>} */ const meta_tags = new Map([ ...root_only_meta_tags, ['svelte:element', 'SvelteElement'], ['svelte:component', 'SvelteComponent'], ['svelte:self', 'SvelteSelf'], ['svelte:fragment', 'SvelteFragment'], ['svelte:boundary', 'SvelteBoundary'] ]); /** @param {Parser} parser */ export default function element(parser) { const start = parser.index++; let parent = parser.current(); if (parser.eat('!--')) { const data = parser.read_until(regex_closing_comment); parser.eat('-->', true); parser.append({ type: 'Comment', start, end: parser.index, data }); return; } const is_closing_tag = parser.eat('/'); const name = parser.read_until(regex_whitespace_or_slash_or_closing_tag); if (is_closing_tag) { parser.allow_whitespace(); parser.eat('>', true); if (is_void(name)) { e.void_element_invalid_content(start); } // close any elements that don't have their own closing tags, e.g. <div><p></div> while (/** @type {AST.RegularElement} */ (parent).name !== name) { if (parser.loose) { // If the previous element did interpret the next opening tag as an attribute, backtrack if (is_element_node(parent)) { const last = parent.attributes.at(-1); if (last?.type === 'Attribute' && last.name === `<${name}`) { parser.index = last.start; parent.attributes.pop(); break; } } } if (parent.type === 'RegularElement') { if (!parser.last_auto_closed_tag || parser.last_auto_closed_tag.tag !== name) { const end = parent.fragment.nodes[0]?.start ?? start; w.element_implicitly_closed( { start: parent.start, end }, `</${name}>`, `</${parent.name}>` ); } } else if (!parser.loose) { if (parser.last_auto_closed_tag && parser.last_auto_closed_tag.tag === name) { e.element_invalid_closing_tag_autoclosed(start, name, parser.last_auto_closed_tag.reason); } else { e.element_invalid_closing_tag(start, name); } } parent.end = start; parser.pop(); parent = parser.current(); } parent.end = parser.index; parser.pop(); if (parser.last_auto_closed_tag && parser.stack.length < parser.last_auto_closed_tag.depth) { parser.last_auto_closed_tag = undefined; } return; } if (name.startsWith('svelte:') && !meta_tags.has(name)) { const bounds = { start: start + 1, end: start + 1 + name.length }; e.svelte_meta_invalid_tag(bounds, list(Array.from(meta_tags.keys()))); } if (!regex_valid_element_name.test(name) && !regex_valid_component_name.test(name)) { // <div. -> in the middle of typing -> allow in loose mode if (!parser.loose || !name.endsWith('.')) { const bounds = { start: start + 1, end: start + 1 + name.length }; e.tag_invalid_name(bounds); } } if (root_only_meta_tags.has(name)) { if (name in parser.meta_tags) { e.svelte_meta_duplicate(start, name); } if (parent.type !== 'Root') { e.svelte_meta_invalid_placement(start, name); } parser.meta_tags[name] = true; } const type = meta_tags.has(name) ? meta_tags.get(name) : regex_valid_component_name.test(name) || (parser.loose && name.endsWith('.')) ? 'Component' : name === 'title' && parent_is_head(parser.stack) ? 'TitleElement' : // TODO Svelte 6/7: once slots are removed in favor of snippets, always keep slot as a regular element name === 'slot' && !parent_is_shadowroot_template(parser.stack) ? 'SlotElement' : 'RegularElement'; /** @type {AST.ElementLike} */ const element = type === 'RegularElement' ? { type, start, end: -1, name, attributes: [], fragment: create_fragment(true), metadata: { svg: false, mathml: false, scoped: false, has_spread: false, path: [] } } : /** @type {AST.ElementLike} */ ({ type, start, end: -1, name, attributes: [], fragment: create_fragment(true), metadata: { // unpopulated at first, differs between types } }); parser.allow_whitespace(); if (parent.type === 'RegularElement' && closing_tag_omitted(parent.name, name)) { const end = parent.fragment.nodes[0]?.start ?? start; w.element_implicitly_closed({ start: parent.start, end }, `<${name}>`, `</${parent.name}>`); parent.end = start; parser.pop(); parser.last_auto_closed_tag = { tag: parent.name, reason: name, depth: parser.stack.length }; } /** @type {string[]} */ const unique_names = []; const current = parser.current(); const is_top_level_script_or_style = (name === 'script' || name === 'style') && current.type === 'Root'; const read = is_top_level_script_or_style ? read_static_attribute : read_attribute; let attribute; while ((attribute = read(parser))) { // animate and transition can only be specified once per element so no need // to check here, use can be used multiple times, same for the on directive // finally let already has error handling in case of duplicate variable names if ( attribute.type === 'Attribute' || attribute.type === 'BindDirective' || attribute.type === 'StyleDirective' || attribute.type === 'ClassDirective' ) { // `bind:attribute` and `attribute` are just the same but `class:attribute`, // `style:attribute` and `attribute` are different and should be allowed together // so we concatenate the type while normalizing the type for BindDirective const type = attribute.type === 'BindDirective' ? 'Attribute' : attribute.type; if (unique_names.includes(type + attribute.name)) { e.attribute_duplicate(attribute); // <svelte:element bind:this this=..> is allowed } else if (attribute.name !== 'this') { unique_names.push(type + attribute.name); } } element.attributes.push(attribute); parser.allow_whitespace(); } if (element.type === 'SvelteComponent') { const index = element.attributes.findIndex( /** @param {any} attr */ (attr) => attr.type === 'Attribute' && attr.name === 'this' ); if (index === -1) { e.svelte_component_missing_this(start); } const definition = /** @type {AST.Attribute} */ (element.attributes.splice(index, 1)[0]); if (!is_expression_attribute(definition)) { e.svelte_component_invalid_this(definition.start); } element.expression = get_attribute_expression(definition); } if (element.type === 'SvelteElement') { const index = element.attributes.findIndex( /** @param {any} attr */ (attr) => attr.type === 'Attribute' && attr.name === 'this' ); if (index === -1) { e.svelte_element_missing_this(start); } const definition = /** @type {AST.Attribute} */ (element.attributes.splice(index, 1)[0]); if (definition.value === true) { e.svelte_element_missing_this(definition); } if (!is_expression_attribute(definition)) { w.svelte_element_invalid_this(definition); // note that this is wrong, in the case of e.g. `this="h{n}"` — it will result in `<h>`. // it would be much better to just error here, but we are preserving the existing buggy // Svelte 4 behaviour out of an overabundance of caution regarding breaking changes. // TODO in 6.0, error const chunk = /** @type {Array<AST.ExpressionTag | AST.Text>} */ (definition.value)[0]; element.tag = chunk.type === 'Text' ? { type: 'Literal', value: chunk.data, raw: `'${chunk.raw}'`, start: chunk.start, end: chunk.end } : chunk.expression; } else { element.tag = get_attribute_expression(definition); } element.metadata.expression = create_expression_metadata(); } if (is_top_level_script_or_style) { parser.eat('>', true); /** @type {AST.Comment | null} */ let prev_comment = null; for (let i = current.fragment.nodes.length - 1; i >= 0; i--) { const node = current.fragment.nodes[i]; if (i === current.fragment.nodes.length - 1 && node.end !== start) { break; } if (node.type === 'Comment') { prev_comment = node; break; } else if (node.type !== 'Text' || node.data.trim()) { break; } } if (name === 'script') { const content = read_script(parser, start, element.attributes); if (prev_comment) { // We take advantage of the fact that the root will never have leadingComments set, // and set the previous comment to it so that the warning mechanism can later // inspect the root and see if there was a html comment before it silencing specific warnings. content.content.leadingComments = [{ type: 'Line', value: prev_comment.data }]; } if (content.context === 'module') { if (current.module) e.script_duplicate(start); current.module = content; } else { if (current.instance) e.script_duplicate(start); current.instance = content; } } else { const content = read_style(parser, start, element.attributes); content.content.comment = prev_comment; if (current.css) e.style_duplicate(start); current.css = content; } return; } parser.append(element); const self_closing = parser.eat('/') || is_void(name); const closed = parser.eat('>', true, false); // Loose parsing mode if (!closed) { // We may have eaten an opening `<` of the next element and treated it as an attribute... const last = element.attributes.at(-1); if (last?.type === 'Attribute' && last.name === '<') { parser.index = last.start; element.attributes.pop(); } else { // ... or we may have eaten part of a following block ... const prev_1 = parser.template[parser.index - 1]; const prev_2 = parser.template[parser.index - 2]; const current = parser.template[parser.index]; if (prev_2 === '{' && prev_1 === '/') { parser.index -= 2; } else if (prev_1 === '{' && (current === '#' || current === '@' || current === ':')) { parser.index -= 1; } else { // ... or we're followed by whitespace, for example near the end of the template, // which we want to take in so that language tools has more room to work with parser.allow_whitespace(); if (parser.index === parser.template.length) { while ( parser.index < parser.template_untrimmed.length && regex_whitespace.test(parser.template_untrimmed[parser.index]) ) { parser.index++; } } } } } if (self_closing || !closed) { // don't push self-closing elements onto the stack element.end = parser.index; } else if (name === 'textarea') { // special case element.fragment.nodes = read_sequence( parser, () => regex_closing_textarea_tag.test(parser.template.slice(parser.index)), 'inside <textarea>' ); parser.read(regex_closing_textarea_tag); element.end = parser.index; } else if (name === 'script' || name === 'style') { // special case const start = parser.index; const data = parser.read_until(new RegExp(`</${name}>`)); const end = parser.index; /** @type {AST.Text} */ const node = { start, end, type: 'Text', data, raw: data }; element.fragment.nodes.push(node); parser.eat(`</${name}>`, true); element.end = parser.index; } else { parser.stack.push(element); parser.fragments.push(element.fragment); } } /** @param {AST.TemplateNode[]} stack */ function parent_is_head(stack) { let i = stack.length; while (i--) { const { type } = stack[i]; if (type === 'SvelteHead') return true; if (type === 'RegularElement' || type === 'Component') return false; } return false; } /** @param {AST.TemplateNode[]} stack */ function parent_is_shadowroot_template(stack) { // https://developer.chrome.com/docs/css-ui/declarative-shadow-dom#building_a_declarative_shadow_root let i = stack.length; while (i--) { if ( stack[i].type === 'RegularElement' && /** @type {AST.RegularElement} */ (stack[i]).attributes.some( (a) => a.type === 'Attribute' && a.name === 'shadowrootmode' ) ) { return true; } } return false; } /** * @param {Parser} parser * @returns {AST.Attribute | null} */ function read_static_attribute(parser) { const start = parser.index; const name = parser.read_until(regex_token_ending_character); if (!name) return null; /** @type {true | Array<AST.Text | AST.ExpressionTag>} */ let value = true; if (parser.eat('=')) { parser.allow_whitespace(); let raw = parser.match_regex(regex_attribute_value); if (!raw) { e.expected_attribute_value(parser.index); } parser.index += raw.length; const quoted = raw[0] === '"' || raw[0] === "'"; if (quoted) { raw = raw.slice(1, -1); } value = [ { start: parser.index - raw.length - (quoted ? 1 : 0), end: quoted ? parser.index - 1 : parser.index, type: 'Text', raw: raw, data: decode_character_references(raw, true) } ]; } if (parser.match_regex(regex_starts_with_quote_characters)) { e.expected_token(parser.index, '='); } return create_attribute(name, start, parser.index, value); } /** * @param {Parser} parser * @returns {AST.Attribute | AST.SpreadAttribute | AST.Directive | AST.AttachTag | null} */ function read_attribute(parser) { const start = parser.index; if (parser.eat('{')) { parser.allow_whitespace(); if (parser.eat('@attach')) { parser.require_whitespace(); const expression = read_expression(parser); parser.allow_whitespace(); parser.eat('}', true); /** @type {AST.AttachTag} */ const attachment = { type: 'AttachTag', start, end: parser.index, expression, metadata: { expression: create_expression_metadata() } }; return attachment; } if (parser.eat('...')) { const expression = read_expression(parser); parser.allow_whitespace(); parser.eat('}', true); /** @type {AST.SpreadAttribute} */ const spread = { type: 'SpreadAttribute', start, end: parser.index, expression, metadata: { expression: create_expression_metadata() } }; return spread; } else { const value_start = parser.index; let name = parser.read_identifier(); if (name === null) { if ( parser.loose && (parser.match('#') || parser.match('/') || parser.match('@') || parser.match(':')) ) { // We're likely in an unclosed opening tag and did read part of a block. // Return null to not crash the parser so it can continue with closing the tag. return null; } else if (parser.loose && parser.match('}')) { // Likely in the middle of typing, just created the shorthand name = ''; } else { e.attribute_empty_shorthand(start); } } parser.allow_whitespace(); parser.eat('}', true); /** @type {AST.ExpressionTag} */ const expression = { type: 'ExpressionTag', start: value_start, end: value_start + name.length, expression: { start: value_start, end: value_start + name.length, type: 'Identifier', name }, metadata: { expression: create_expression_metadata() } }; return create_attribute(name, start, parser.index, expression); } } const name = parser.read_until(regex_token_ending_character); if (!name) return null; let end = parser.index; parser.allow_whitespace(); const colon_index = name.indexOf(':'); const type = colon_index !== -1 && get_directive_type(name.slice(0, colon_index)); /** @type {true | AST.ExpressionTag | Array<AST.Text | AST.ExpressionTag>} */ let value = true; if (parser.eat('=')) { parser.allow_whitespace(); if (parser.template[parser.index] === '/' && parser.template[parser.index + 1] === '>') { const char_start = parser.index; parser.index++; // consume '/' value = [ { start: char_start, end: char_start + 1, type: 'Text', raw: '/', data: '/' } ]; end = parser.index; } else { value = read_attribute_value(parser); end = parser.index; } } else if (parser.match_regex(regex_starts_with_quote_characters)) { e.expected_token(parser.index, '='); } if (type) { const [directive_name, ...modifiers] = name.slice(colon_index + 1).split('|'); if (directive_name === '') { e.directive_missing_name({ start, end: start + colon_index + 1 }, name); } if (type === 'StyleDirective') { return { start, end, type, name: directive_name, modifiers: /** @type {Array<'important'>} */ (modifiers), value, metadata: { expression: create_expression_metadata() } }; } const first_value = value === true ? undefined : Array.isArray(value) ? value[0] : value; /** @type {Expression | null} */ let expression = null; if (first_value) { const attribute_contains_text = /** @type {any[]} */ (value).length > 1 || first_value.type === 'Text'; if (attribute_contains_text) { e.directive_invalid_value(/** @type {number} */ (first_value.start)); } else { // TODO throw a parser error in a future version here if this `[ExpressionTag]` instead of `ExpressionTag`, // which means stringified value, which isn't allowed for some directives? expression = first_value.expression; } } /** @type {AST.Directive} */ const directive = { start, end, type, name: directive_name, expression, metadata: { expression: create_expression_metadata() } }; // @ts-expect-error we do this separately from the declaration to avoid upsetting typescript directive.modifiers = modifiers; if (directive.type === 'TransitionDirective') { const direction = name.slice(0, colon_index); directive.intro = direction === 'in' || direction === 'transition'; directive.outro = direction === 'out' || direction === 'transition'; } // Directive name is expression, e.g. <p class:isRed /> if ( (directive.type === 'BindDirective' || directive.type === 'ClassDirective') && !directive.expression ) { directive.expression = /** @type {any} */ ({ start: start + colon_index + 1, end, type: 'Identifier', name: directive.name }); } return directive; } return create_attribute(name, start, end, value); } /** * @param {string} name * @returns {any} */ function get_directive_type(name) { if (name === 'use') return 'UseDirective'; if (name === 'animate') return 'AnimateDirective'; if (name === 'bind') return 'BindDirective'; if (name === 'class') return 'ClassDirective'; if (name === 'style') return 'StyleDirective'; if (name === 'on') return 'OnDirective'; if (name === 'let') return 'LetDirective'; if (name === 'in' || name === 'out' || name === 'transition') return 'TransitionDirective'; return false; } /** * @param {Parser} parser * @return {AST.ExpressionTag | Array<AST.ExpressionTag | AST.Text>} */ function read_attribute_value(parser) { const quote_mark = parser.eat("'") ? "'" : parser.eat('"') ? '"' : null; if (quote_mark && parser.eat(quote_mark)) { return [ { start: parser.index - 1, end: parser.index - 1, type: 'Text', raw: '', data: '' } ]; } /** @type {Array<AST.ExpressionTag | AST.Text>} */ let value; try { value = read_sequence( parser, () => { // handle common case of quote marks existing outside of regex for performance reasons if (quote_mark) return parser.match(quote_mark); return !!parser.match_regex(regex_invalid_unquoted_attribute_value); }, 'in attribute value' ); } catch (/** @type {any} */ error) { if (error.code === 'js_parse_error') { // if the attribute value didn't close + self-closing tag // eg: `<Component test={{a:1} />` // acorn may throw a `Unterminated regular expression` because of `/>` const pos = error.position?.[0]; if (pos !== undefined && parser.template.slice(pos - 1, pos + 1) === '/>') { parser.index = pos; e.expected_token(pos, quote_mark || '}'); } } throw error; } if (value.length === 0 && !quote_mark) { e.expected_attribute_value(parser.index); } if (quote_mark) parser.index += 1; if (quote_mark || value.length > 1 || value[0].type === 'Text') { return value; } else { return value[0]; } } /** * @param {Parser} parser * @param {() => boolean} done * @param {string} location * @returns {any[]} */ function read_sequence(parser, done, location) { /** @type {AST.Text} */ let current_chunk = { start: parser.index, end: -1, type: 'Text', raw: '', data: '' }; /** @type {Array<AST.Text | AST.ExpressionTag>} */ const chunks = []; /** @param {number} end */ function flush(end) { if (current_chunk.raw) { current_chunk.data = decode_character_references(current_chunk.raw, true); current_chunk.end = end; chunks.push(current_chunk); } } while (parser.index < parser.template.length) { const index = parser.index; if (done()) { flush(parser.index); return chunks; } else if (parser.eat('{')) { if (parser.match('#')) { const index = parser.index - 1; parser.eat('#'); const name = parser.read_until(/[^a-z]/); e.block_invalid_placement(index, name, location); } else if (parser.match('@')) { const index = parser.index - 1; parser.eat('@'); const name = parser.read_until(/[^a-z]/); e.tag_invalid_placement(index, name, location); } flush(parser.index - 1); parser.allow_whitespace(); const expression = read_expression(parser); parser.allow_whitespace(); parser.eat('}', true); /** @type {AST.ExpressionTag} */ const chunk = { type: 'ExpressionTag', start: index, end: parser.index, expression, metadata: { expression: create_expression_metadata() } }; chunks.push(chunk); current_chunk = { start: parser.index, end: -1, type: 'Text', raw: '', data: '' }; } else { current_chunk.raw += parser.template[parser.index++]; } } if (parser.loose) { return chunks; } else { e.unexpected_eof(parser.template.length); } }
```

# compiler/phases/1-parse/state/fragment.js

```js
/** @import { Parser } from '../index.js' */ import element from './element.js'; import tag from './tag.js'; import text from './text.js'; /** @param {Parser} parser */ export default function fragment(parser) { if (parser.match('<')) { return element; } if (parser.match('{')) { return tag; } return text; }
```

# compiler/phases/1-parse/state/tag.js

```js
/** @import { ArrowFunctionExpression, Expression, Identifier, Pattern } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { Parser } from '../index.js' */ import { walk } from 'zimmerframe'; import * as e from '../../../errors.js'; import { create_expression_metadata } from '../../nodes.js'; import { parse_expression_at } from '../acorn.js'; import read_pattern from '../read/context.js'; import read_expression, { get_loose_identifier } from '../read/expression.js'; import { create_fragment } from '../utils/create.js'; import { match_bracket } from '../utils/bracket.js'; const regex_whitespace_with_closing_curly_brace = /^\s*}/; const pointy_bois = { '<': '>' }; /** @param {Parser} parser */ export default function tag(parser) { const start = parser.index; parser.index += 1; parser.allow_whitespace(); if (parser.eat('#')) return open(parser); if (parser.eat(':')) return next(parser); if (parser.eat('@')) return special(parser); if (parser.match('/')) { if (!parser.match('/*') && !parser.match('//')) { parser.eat('/'); return close(parser); } } const expression = read_expression(parser); parser.allow_whitespace(); parser.eat('}', true); parser.append({ type: 'ExpressionTag', start, end: parser.index, expression, metadata: { expression: create_expression_metadata() } }); } /** @param {Parser} parser */ function open(parser) { let start = parser.index - 2; while (parser.template[start] !== '{') start -= 1; if (parser.eat('if')) { parser.require_whitespace(); /** @type {AST.IfBlock} */ const block = parser.append({ type: 'IfBlock', elseif: false, start, end: -1, test: read_expression(parser), consequent: create_fragment(), alternate: null, metadata: { expression: create_expression_metadata() } }); parser.allow_whitespace(); parser.eat('}', true); parser.stack.push(block); parser.fragments.push(block.consequent); return; } if (parser.eat('each')) { parser.require_whitespace(); const template = parser.template; let end = parser.template.length; /** @type {Expression | undefined} */ let expression; // we have to do this loop because `{#each x as { y = z }}` fails to parse — // the `as { y = z }` is treated as an Expression but it's actually a Pattern. // the 'fix' is to backtrack and hide everything from the `as` onwards, until // we get a valid expression while (!expression) { try { expression = read_expression(parser, undefined, true); } catch (err) { end = /** @type {any} */ (err).position[0] - 2; while (end > start && parser.template.slice(end, end + 2) !== 'as') { end -= 1; } if (end <= start) { if (parser.loose) { expression = get_loose_identifier(parser); if (expression) { break; } } throw err; } // @ts-expect-error parser.template is meant to be readonly, this is a special case parser.template = template.slice(0, end); } } // @ts-expect-error parser.template = template; parser.allow_whitespace(); // {#each} blocks must declare a context – {#each list as item} if (!parser.match('as')) { // this could be a TypeScript assertion that was erroneously eaten. if (expression.type === 'SequenceExpression') { expression = expression.expressions[0]; } let assertion = null; let end = expression.end; expression = walk(expression, null, { // @ts-expect-error TSAsExpression(node, context) { if (node.end === /** @type {Expression} */ (expression).end) { assertion = node; end = node.expression.end; return node.expression; } context.next(); } }); expression.end = end; if (assertion) { // we can't reset `parser.index` to `expression.expression.end` because // it will ignore any parentheses — we need to jump through this hoop let end = /** @type {any} */ (/** @type {any} */ (assertion).typeAnnotation).start - 2; while (parser.template.slice(end, end + 2) !== 'as') end -= 1; parser.index = end; } } /** @type {Pattern | null} */ let context = null; let index; let key; if (parser.eat('as')) { parser.require_whitespace(); context = read_pattern(parser); } else { // {#each Array.from({ length: 10 }), i} is read as a sequence expression, // which is set back above - we now gotta reset the index as a consequence // to properly read the , i part parser.index = /** @type {number} */ (expression.end); } parser.allow_whitespace(); if (parser.eat(',')) { parser.allow_whitespace(); index = parser.read_identifier(); if (!index) { e.expected_identifier(parser.index); } parser.allow_whitespace(); } if (parser.eat('(')) { parser.allow_whitespace(); key = read_expression(parser, '('); parser.allow_whitespace(); parser.eat(')', true); parser.allow_whitespace(); } const matches = parser.eat('}', true, false); if (!matches) { // Parser may have read the `as` as part of the expression (e.g. in `{#each foo. as x}`) if (parser.template.slice(parser.index - 4, parser.index) === ' as ') { const prev_index = parser.index; context = read_pattern(parser); parser.eat('}', true); expression = { type: 'Identifier', name: '', start: expression.start, end: prev_index - 4 }; } else { parser.eat('}', true); // rerun to produce the parser error } } /** @type {AST.EachBlock} */ const block = parser.append({ type: 'EachBlock', start, end: -1, expression, body: create_fragment(), context, index, key, metadata: /** @type {any} */ (null) // filled in later }); parser.stack.push(block); parser.fragments.push(block.body); return; } if (parser.eat('await')) { parser.require_whitespace(); const expression = read_expression(parser); parser.allow_whitespace(); /** @type {AST.AwaitBlock} */ const block = parser.append({ type: 'AwaitBlock', start, end: -1, expression, value: null, error: null, pending: null, then: null, catch: null, metadata: { expression: create_expression_metadata() } }); if (parser.eat('then')) { if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) { parser.allow_whitespace(); } else { parser.require_whitespace(); block.value = read_pattern(parser); parser.allow_whitespace(); } block.then = create_fragment(); parser.fragments.push(block.then); } else if (parser.eat('catch')) { if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) { parser.allow_whitespace(); } else { parser.require_whitespace(); block.error = read_pattern(parser); parser.allow_whitespace(); } block.catch = create_fragment(); parser.fragments.push(block.catch); } else { block.pending = create_fragment(); parser.fragments.push(block.pending); } const matches = parser.eat('}', true, false); // Parser may have read the `then/catch` as part of the expression (e.g. in `{#await foo. then x}`) if (!matches) { if (parser.template.slice(parser.index - 6, parser.index) === ' then ') { const prev_index = parser.index; block.value = read_pattern(parser); parser.eat('}', true); block.expression = { type: 'Identifier', name: '', start: expression.start, end: prev_index - 6 }; block.then = block.pending; block.pending = null; } else if (parser.template.slice(parser.index - 7, parser.index) === ' catch ') { const prev_index = parser.index; block.error = read_pattern(parser); parser.eat('}', true); block.expression = { type: 'Identifier', name: '', start: expression.start, end: prev_index - 7 }; block.catch = block.pending; block.pending = null; } else { parser.eat('}', true); // rerun to produce the parser error } } parser.stack.push(block); return; } if (parser.eat('key')) { parser.require_whitespace(); const expression = read_expression(parser); parser.allow_whitespace(); parser.eat('}', true); /** @type {AST.KeyBlock} */ const block = parser.append({ type: 'KeyBlock', start, end: -1, expression, fragment: create_fragment(), metadata: { expression: create_expression_metadata() } }); parser.stack.push(block); parser.fragments.push(block.fragment); return; } if (parser.eat('snippet')) { parser.require_whitespace(); const name_start = parser.index; let name = parser.read_identifier(); const name_end = parser.index; if (name === null) { if (parser.loose) { name = ''; } else { e.expected_identifier(parser.index); } } parser.allow_whitespace(); const params_start = parser.index; // snippets could have a generic signature, e.g. `#snippet foo<T>(...)` /** @type {string | undefined} */ let type_params; // if we match a generic opening if (parser.ts && parser.match('<')) { const start = parser.index; const end = match_bracket(parser, start, pointy_bois); type_params = parser.template.slice(start + 1, end - 1); parser.index = end; } parser.allow_whitespace(); const matched = parser.eat('(', true, false); if (matched) { let parentheses = 1; while (parser.index < parser.template.length && (!parser.match(')') || parentheses !== 1)) { if (parser.match('(')) parentheses++; if (parser.match(')')) parentheses--; parser.index += 1; } parser.eat(')', true); } const prelude = parser.template.slice(0, params_start).replace(/\S/g, ' '); const params = parser.template.slice(params_start, parser.index); let function_expression = matched ? /** @type {ArrowFunctionExpression} */ ( parse_expression_at( prelude + `${params} => {}`, parser.root.comments, parser.ts, params_start ) ) : { params: [] }; parser.allow_whitespace(); parser.eat('}', true); /** @type {AST.SnippetBlock} */ const block = parser.append({ type: 'SnippetBlock', start, end: -1, expression: { type: 'Identifier', start: name_start, end: name_end, name }, typeParams: type_params, parameters: function_expression.params, body: create_fragment(), metadata: { can_hoist: false, sites: new Set() } }); parser.stack.push(block); parser.fragments.push(block.body); return; } e.expected_block_type(parser.index); } /** @param {Parser} parser */ function next(parser) { const start = parser.index - 1; const block = parser.current(); // TODO type should not be TemplateNode, that's much too broad if (block.type === 'IfBlock') { if (!parser.eat('else')) e.expected_token(start, '{:else} or {:else if}'); if (parser.eat('if')) e.block_invalid_elseif(start); parser.allow_whitespace(); parser.fragments.pop(); block.alternate = create_fragment(); parser.fragments.push(block.alternate); // :else if if (parser.eat('if')) { parser.require_whitespace(); const expression = read_expression(parser); parser.allow_whitespace(); parser.eat('}', true); let elseif_start = start - 1; while (parser.template[elseif_start] !== '{') elseif_start -= 1; /** @type {AST.IfBlock} */ const child = parser.append({ start: elseif_start, end: -1, type: 'IfBlock', elseif: true, test: expression, consequent: create_fragment(), alternate: null, metadata: { expression: create_expression_metadata() } }); parser.stack.push(child); parser.fragments.pop(); parser.fragments.push(child.consequent); } else { // :else parser.allow_whitespace(); parser.eat('}', true); } return; } if (block.type === 'EachBlock') { if (!parser.eat('else')) e.expected_token(start, '{:else}'); parser.allow_whitespace(); parser.eat('}', true); block.fallback = create_fragment(); parser.fragments.pop(); parser.fragments.push(block.fallback); return; } if (block.type === 'AwaitBlock') { if (parser.eat('then')) { if (block.then) { e.block_duplicate_clause(start, '{:then}'); } if (!parser.eat('}')) { parser.require_whitespace(); block.value = read_pattern(parser); parser.allow_whitespace(); parser.eat('}', true); } block.then = create_fragment(); parser.fragments.pop(); parser.fragments.push(block.then); return; } if (parser.eat('catch')) { if (block.catch) { e.block_duplicate_clause(start, '{:catch}'); } if (!parser.eat('}')) { parser.require_whitespace(); block.error = read_pattern(parser); parser.allow_whitespace(); parser.eat('}', true); } block.catch = create_fragment(); parser.fragments.pop(); parser.fragments.push(block.catch); return; } e.expected_token(start, '{:then ...} or {:catch ...}'); } e.block_invalid_continuation_placement(start); } /** @param {Parser} parser */ function close(parser) { const start = parser.index - 1; let block = parser.current(); /** Only relevant/reached for loose parsing mode */ let matched; switch (block.type) { case 'IfBlock': matched = parser.eat('if', true, false); if (!matched) { block.end = start - 1; parser.pop(); close(parser); return; } parser.allow_whitespace(); parser.eat('}', true); while (block.elseif) { block.end = parser.index; parser.stack.pop(); block = /** @type {AST.IfBlock} */ (parser.current()); } block.end = parser.index; parser.pop(); return; case 'EachBlock': matched = parser.eat('each', true, false); break; case 'KeyBlock': matched = parser.eat('key', true, false); break; case 'AwaitBlock': matched = parser.eat('await', true, false); break; case 'SnippetBlock': matched = parser.eat('snippet', true, false); break; case 'RegularElement': if (parser.loose) { matched = false; } else { // TODO handle implicitly closed elements e.block_unexpected_close(start); } break; default: e.block_unexpected_close(start); } if (!matched) { block.end = start - 1; parser.pop(); close(parser); return; } parser.allow_whitespace(); parser.eat('}', true); block.end = parser.index; parser.pop(); } /** @param {Parser} parser */ function special(parser) { let start = parser.index; while (parser.template[start] !== '{') start -= 1; if (parser.eat('html')) { // {@html content} tag parser.require_whitespace(); const expression = read_expression(parser); parser.allow_whitespace(); parser.eat('}', true); parser.append({ type: 'HtmlTag', start, end: parser.index, expression, metadata: { expression: create_expression_metadata() } }); return; } if (parser.eat('debug')) { /** @type {Identifier[]} */ let identifiers; // Implies {@debug} which indicates "debug all" if (parser.read(regex_whitespace_with_closing_curly_brace)) { identifiers = []; } else { const expression = read_expression(parser); identifiers = expression.type === 'SequenceExpression' ? /** @type {Identifier[]} */ (expression.expressions) : [/** @type {Identifier} */ (expression)]; identifiers.forEach( /** @param {any} node */ (node) => { if (node.type !== 'Identifier') { e.debug_tag_invalid_arguments(/** @type {number} */ (node.start)); } } ); parser.allow_whitespace(); parser.eat('}', true); } parser.append({ type: 'DebugTag', start, end: parser.index, identifiers }); return; } if (parser.eat('const')) { parser.require_whitespace(); const id = read_pattern(parser); parser.allow_whitespace(); parser.eat('=', true); parser.allow_whitespace(); const expression_start = parser.index; const init = read_expression(parser); if ( init.type === 'SequenceExpression' && !parser.template.substring(expression_start, init.start).includes('(') ) { // const a = (b, c) is allowed but a = b, c = d is not; e.const_tag_invalid_expression(init); } parser.allow_whitespace(); parser.eat('}', true); parser.append({ type: 'ConstTag', start, end: parser.index, declaration: { type: 'VariableDeclaration', kind: 'const', declarations: [{ type: 'VariableDeclarator', id, init, start: id.start, end: init.end }], start: start + 2, // start at const, not at @const end: parser.index - 1 }, metadata: { expression: create_expression_metadata() } }); } if (parser.eat('render')) { // {@render foo(...)} parser.require_whitespace(); const expression = read_expression(parser); if ( expression.type !== 'CallExpression' && (expression.type !== 'ChainExpression' || expression.expression.type !== 'CallExpression') ) { e.render_tag_invalid_expression(expression); } parser.allow_whitespace(); parser.eat('}', true); parser.append({ type: 'RenderTag', start, end: parser.index, expression: /** @type {AST.RenderTag['expression']} */ (expression), metadata: { expression: create_expression_metadata(), dynamic: false, arguments: [], path: [], snippets: new Set() } }); } }
```

# compiler/phases/1-parse/state/text.js

```js
/** @import { AST } from '#compiler' */ /** @import { Parser } from '../index.js' */ import { decode_character_references } from '../utils/html.js'; /** @param {Parser} parser */ export default function text(parser) { const start = parser.index; let data = ''; while (parser.index < parser.template.length && !parser.match('<') && !parser.match('{')) { data += parser.template[parser.index++]; } /** @type {AST.Text} */ parser.append({ type: 'Text', start, end: parser.index, raw: data, data: decode_character_references(data, false) }); }
```

# compiler/phases/1-parse/utils/bracket.js

```js
/** @import { Parser } from '../index.js' */ import * as e from '../../../errors.js'; /** * @param {number} num * @returns {number} Infinity if {@link num} is negative, else {@link num}. */ function infinity_if_negative(num) { if (num < 0) { return Infinity; } return num; } /** * @param {string} string The string to search. * @param {number} search_start_index The index to start searching at. * @param {"'" | '"' | '`'} string_start_char The character that started this string. * @returns {number} The index of the end of this string expression, or `Infinity` if not found. */ function find_string_end(string, search_start_index, string_start_char) { let string_to_search; if (string_start_char === '`') { string_to_search = string; } else { // we could slice at the search start index, but this way the index remains valid string_to_search = string.slice( 0, infinity_if_negative(string.indexOf('\n', search_start_index)) ); } return find_unescaped_char(string_to_search, search_start_index, string_start_char); } /** * @param {string} string The string to search. * @param {number} search_start_index The index to start searching at. * @returns {number} The index of the end of this regex expression, or `Infinity` if not found. */ function find_regex_end(string, search_start_index) { return find_unescaped_char(string, search_start_index, '/'); } /** * * @param {string} string The string to search. * @param {number} search_start_index The index to begin the search at. * @param {string} char The character to search for. * @returns {number} The index of the first unescaped instance of {@link char}, or `Infinity` if not found. */ function find_unescaped_char(string, search_start_index, char) { let i = search_start_index; while (true) { const found_index = string.indexOf(char, i); if (found_index === -1) { return Infinity; } if (count_leading_backslashes(string, found_index - 1) % 2 === 0) { return found_index; } i = found_index + 1; } } /** * Count consecutive leading backslashes before {@link search_start_index}. * * @example * \`\`\`js * count_leading_backslashes('\\\\\\foo', 2); // 3 (the backslashes have to be escaped in the string literal, there are three in reality) * \`\`\` * * @param {string} string The string to search. * @param {number} search_start_index The index to begin the search at. */ function count_leading_backslashes(string, search_start_index) { let i = search_start_index; let count = 0; while (string[i] === '\\') { count++; i--; } return count; } /** * Finds the corresponding closing bracket, ignoring brackets found inside comments, strings, or regex expressions. * @param {string} template The string to search. * @param {number} index The index to begin the search at. * @param {string} open The opening bracket (ex: `'{'` will search for `'}'`). * @returns {number | undefined} The index of the closing bracket, or undefined if not found. */ export function find_matching_bracket(template, index, open) { const close = default_brackets[open]; let brackets = 1; let i = index; while (brackets > 0 && i < template.length) { const char = template[i]; switch (char) { case "'": case '"': case '`': i = find_string_end(template, i + 1, char) + 1; continue; case '/': { const next_char = template[i + 1]; if (!next_char) continue; if (next_char === '/') { i = infinity_if_negative(template.indexOf('\n', i + 1)) + '\n'.length; continue; } if (next_char === '*') { i = infinity_if_negative(template.indexOf('*/', i + 1)) + '*/'.length; continue; } i = find_regex_end(template, i + 1) + '/'.length; continue; } default: { const char = template[i]; if (char === open) { brackets++; } else if (char === close) { brackets--; } if (brackets === 0) { return i; } i++; } } } return undefined; } /** @type {Record<string, string>} */ const default_brackets = { '{': '}', '(': ')', '[': ']' }; /** * @param {Parser} parser * @param {number} start * @param {Record<string, string>} brackets */ export function match_bracket(parser, start, brackets = default_brackets) { const close = Object.values(brackets); const bracket_stack = []; let i = start; while (i < parser.template.length) { let char = parser.template[i++]; if (char === "'" || char === '"' || char === '`') { i = match_quote(parser, i, char); continue; } if (char in brackets) { bracket_stack.push(char); } else if (close.includes(char)) { const popped = /** @type {string} */ (bracket_stack.pop()); const expected = /** @type {string} */ (brackets[popped]); if (char !== expected) { e.expected_token(i - 1, expected); } if (bracket_stack.length === 0) { return i; } } } e.unexpected_eof(parser.template.length); } /** * @param {Parser} parser * @param {number} start * @param {string} quote */ function match_quote(parser, start, quote) { let is_escaped = false; let i = start; while (i < parser.template.length) { const char = parser.template[i++]; if (is_escaped) { is_escaped = false; continue; } if (char === quote) { return i; } if (char === '\\') { is_escaped = true; } if (quote === '`' && char === '$' && parser.template[i] === '{') { i = match_bracket(parser, i); } } e.unterminated_string_constant(start); }
```

# compiler/phases/1-parse/utils/create.js

```js
/** @import { AST } from '#compiler' */ /** * @param {any} transparent * @returns {AST.Fragment} */ export function create_fragment(transparent = false) { return { type: 'Fragment', nodes: [], metadata: { transparent, dynamic: false } }; }
```

# compiler/phases/1-parse/utils/entities.js

```js
// https://html.spec.whatwg.org/entities.json from https://dev.w3.org/html5/html-author/charref export default { 'CounterClockwiseContourIntegral;': 8755, 'ClockwiseContourIntegral;': 8754, 'DoubleLongLeftRightArrow;': 10234, 'NotNestedGreaterGreater;': 10914, 'DiacriticalDoubleAcute;': 733, 'NotSquareSupersetEqual;': 8931, 'CloseCurlyDoubleQuote;': 8221, 'DoubleContourIntegral;': 8751, 'FilledVerySmallSquare;': 9642, 'NegativeVeryThinSpace;': 8203, 'NotPrecedesSlantEqual;': 8928, 'NotRightTriangleEqual;': 8941, 'NotSucceedsSlantEqual;': 8929, 'CapitalDifferentialD;': 8517, 'DoubleLeftRightArrow;': 8660, 'DoubleLongRightArrow;': 10233, 'EmptyVerySmallSquare;': 9643, 'NestedGreaterGreater;': 8811, 'NotDoubleVerticalBar;': 8742, 'NotGreaterSlantEqual;': 10878, 'NotLeftTriangleEqual;': 8940, 'NotSquareSubsetEqual;': 8930, 'OpenCurlyDoubleQuote;': 8220, 'ReverseUpEquilibrium;': 10607, 'DoubleLongLeftArrow;': 10232, 'DownLeftRightVector;': 10576, 'LeftArrowRightArrow;': 8646, 'NegativeMediumSpace;': 8203, 'NotGreaterFullEqual;': 8807, 'NotRightTriangleBar;': 10704, 'RightArrowLeftArrow;': 8644, 'SquareSupersetEqual;': 8850, 'leftrightsquigarrow;': 8621, 'DownRightTeeVector;': 10591, 'DownRightVectorBar;': 10583, 'LongLeftRightArrow;': 10231, 'Longleftrightarrow;': 10234, 'NegativeThickSpace;': 8203, 'NotLeftTriangleBar;': 10703, 'PrecedesSlantEqual;': 8828, 'ReverseEquilibrium;': 8651, 'RightDoubleBracket;': 10215, 'RightDownTeeVector;': 10589, 'RightDownVectorBar;': 10581, 'RightTriangleEqual;': 8885, 'SquareIntersection;': 8851, 'SucceedsSlantEqual;': 8829, 'blacktriangleright;': 9656, 'longleftrightarrow;': 10231, 'DoubleUpDownArrow;': 8661, 'DoubleVerticalBar;': 8741, 'DownLeftTeeVector;': 10590, 'DownLeftVectorBar;': 10582, 'FilledSmallSquare;': 9724, 'GreaterSlantEqual;': 10878, 'LeftDoubleBracket;': 10214, 'LeftDownTeeVector;': 10593, 'LeftDownVectorBar;': 10585, 'LeftTriangleEqual;': 8884, 'NegativeThinSpace;': 8203, 'NotGreaterGreater;': 8811, 'NotLessSlantEqual;': 10877, 'NotNestedLessLess;': 10913, 'NotReverseElement;': 8716, 'NotSquareSuperset;': 8848, 'NotTildeFullEqual;': 8775, 'RightAngleBracket;': 10217, 'RightUpDownVector;': 10575, 'SquareSubsetEqual;': 8849, 'VerticalSeparator;': 10072, 'blacktriangledown;': 9662, 'blacktriangleleft;': 9666, 'leftrightharpoons;': 8651, 'rightleftharpoons;': 8652, 'twoheadrightarrow;': 8608, 'DiacriticalAcute;': 180, 'DiacriticalGrave;': 96, 'DiacriticalTilde;': 732, 'DoubleRightArrow;': 8658, 'DownArrowUpArrow;': 8693, 'EmptySmallSquare;': 9723, 'GreaterEqualLess;': 8923, 'GreaterFullEqual;': 8807, 'LeftAngleBracket;': 10216, 'LeftUpDownVector;': 10577, 'LessEqualGreater;': 8922, 'NonBreakingSpace;': 160, 'NotPrecedesEqual;': 10927, 'NotRightTriangle;': 8939, 'NotSucceedsEqual;': 10928, 'NotSucceedsTilde;': 8831, 'NotSupersetEqual;': 8841, 'RightTriangleBar;': 10704, 'RightUpTeeVector;': 10588, 'RightUpVectorBar;': 10580, 'UnderParenthesis;': 9181, 'UpArrowDownArrow;': 8645, 'circlearrowright;': 8635, 'downharpoonright;': 8642, 'ntrianglerighteq;': 8941, 'rightharpoondown;': 8641, 'rightrightarrows;': 8649, 'twoheadleftarrow;': 8606, 'vartriangleright;': 8883, 'CloseCurlyQuote;': 8217, 'ContourIntegral;': 8750, 'DoubleDownArrow;': 8659, 'DoubleLeftArrow;': 8656, 'DownRightVector;': 8641, 'LeftRightVector;': 10574, 'LeftTriangleBar;': 10703, 'LeftUpTeeVector;': 10592, 'LeftUpVectorBar;': 10584, 'LowerRightArrow;': 8600, 'NotGreaterEqual;': 8817, 'NotGreaterTilde;': 8821, 'NotHumpDownHump;': 8782, 'NotLeftTriangle;': 8938, 'NotSquareSubset;': 8847, 'OverParenthesis;': 9180, 'RightDownVector;': 8642, 'ShortRightArrow;': 8594, 'UpperRightArrow;': 8599, 'bigtriangledown;': 9661, 'circlearrowleft;': 8634, 'curvearrowright;': 8631, 'downharpoonleft;': 8643, 'leftharpoondown;': 8637, 'leftrightarrows;': 8646, 'nLeftrightarrow;': 8654, 'nleftrightarrow;': 8622, 'ntrianglelefteq;': 8940, 'rightleftarrows;': 8644, 'rightsquigarrow;': 8605, 'rightthreetimes;': 8908, 'straightepsilon;': 1013, 'trianglerighteq;': 8885, 'vartriangleleft;': 8882, 'DiacriticalDot;': 729, 'DoubleRightTee;': 8872, 'DownLeftVector;': 8637, 'GreaterGreater;': 10914, 'HorizontalLine;': 9472, 'InvisibleComma;': 8291, 'InvisibleTimes;': 8290, 'LeftDownVector;': 8643, 'LeftRightArrow;': 8596, 'Leftrightarrow;': 8660, 'LessSlantEqual;': 10877, 'LongRightArrow;': 10230, 'Longrightarrow;': 10233, 'LowerLeftArrow;': 8601, 'NestedLessLess;': 8810, 'NotGreaterLess;': 8825, 'NotLessGreater;': 8824, 'NotSubsetEqual;': 8840, 'NotVerticalBar;': 8740, 'OpenCurlyQuote;': 8216, 'ReverseElement;': 8715, 'RightTeeVector;': 10587, 'RightVectorBar;': 10579, 'ShortDownArrow;': 8595, 'ShortLeftArrow;': 8592, 'SquareSuperset;': 8848, 'TildeFullEqual;': 8773, 'UpperLeftArrow;': 8598, 'ZeroWidthSpace;': 8203, 'curvearrowleft;': 8630, 'doublebarwedge;': 8966, 'downdownarrows;': 8650, 'hookrightarrow;': 8618, 'leftleftarrows;': 8647, 'leftrightarrow;': 8596, 'leftthreetimes;': 8907, 'longrightarrow;': 10230, 'looparrowright;': 8620, 'nshortparallel;': 8742, 'ntriangleright;': 8939, 'rightarrowtail;': 8611, 'rightharpoonup;': 8640, 'trianglelefteq;': 8884, 'upharpoonright;': 8638, 'ApplyFunction;': 8289, 'DifferentialD;': 8518, 'DoubleLeftTee;': 10980, 'DoubleUpArrow;': 8657, 'LeftTeeVector;': 10586, 'LeftVectorBar;': 10578, 'LessFullEqual;': 8806, 'LongLeftArrow;': 10229, 'Longleftarrow;': 10232, 'NotEqualTilde;': 8770, 'NotTildeEqual;': 8772, 'NotTildeTilde;': 8777, 'Poincareplane;': 8460, 'PrecedesEqual;': 10927, 'PrecedesTilde;': 8830, 'RightArrowBar;': 8677, 'RightTeeArrow;': 8614, 'RightTriangle;': 8883, 'RightUpVector;': 8638, 'SucceedsEqual;': 10928, 'SucceedsTilde;': 8831, 'SupersetEqual;': 8839, 'UpEquilibrium;': 10606, 'VerticalTilde;': 8768, 'VeryThinSpace;': 8202, 'bigtriangleup;': 9651, 'blacktriangle;': 9652, 'divideontimes;': 8903, 'fallingdotseq;': 8786, 'hookleftarrow;': 8617, 'leftarrowtail;': 8610, 'leftharpoonup;': 8636, 'longleftarrow;': 10229, 'looparrowleft;': 8619, 'measuredangle;': 8737, 'ntriangleleft;': 8938, 'shortparallel;': 8741, 'smallsetminus;': 8726, 'triangleright;': 9657, 'upharpoonleft;': 8639, 'varsubsetneqq;': 10955, 'varsupsetneqq;': 10956, 'DownArrowBar;': 10515, 'DownTeeArrow;': 8615, 'ExponentialE;': 8519, 'GreaterEqual;': 8805, 'GreaterTilde;': 8819, 'HilbertSpace;': 8459, 'HumpDownHump;': 8782, 'Intersection;': 8898, 'LeftArrowBar;': 8676, 'LeftTeeArrow;': 8612, 'LeftTriangle;': 8882, 'LeftUpVector;': 8639, 'NotCongruent;': 8802, 'NotHumpEqual;': 8783, 'NotLessEqual;': 8816, 'NotLessTilde;': 8820, 'Proportional;': 8733, 'RightCeiling;': 8969, 'RoundImplies;': 10608, 'ShortUpArrow;': 8593, 'SquareSubset;': 8847, 'UnderBracket;': 9141, 'VerticalLine;': 124, 'blacklozenge;': 10731, 'exponentiale;': 8519, 'risingdotseq;': 8787, 'triangledown;': 9663, 'triangleleft;': 9667, 'varsubsetneq;': 8842, 'varsupsetneq;': 8843, 'CircleMinus;': 8854, 'CircleTimes;': 8855, 'Equilibrium;': 8652, 'GreaterLess;': 8823, 'LeftCeiling;': 8968, 'LessGreater;': 8822, 'MediumSpace;': 8287, 'NotLessLess;': 8810, 'NotPrecedes;': 8832, 'NotSucceeds;': 8833, 'NotSuperset;': 8835, 'OverBracket;': 9140, 'RightVector;': 8640, 'Rrightarrow;': 8667, 'RuleDelayed;': 10740, 'SmallCircle;': 8728, 'SquareUnion;': 8852, 'SubsetEqual;': 8838, 'UpDownArrow;': 8597, 'Updownarrow;': 8661, 'VerticalBar;': 8739, 'backepsilon;': 1014, 'blacksquare;': 9642, 'circledcirc;': 8858, 'circleddash;': 8861, 'curlyeqprec;': 8926, 'curlyeqsucc;': 8927, 'diamondsuit;': 9830, 'eqslantless;': 10901, 'expectation;': 8496, 'nRightarrow;': 8655, 'nrightarrow;': 8603, 'preccurlyeq;': 8828, 'precnapprox;': 10937, 'quaternions;': 8461, 'straightphi;': 981, 'succcurlyeq;': 8829, 'succnapprox;': 10938, 'thickapprox;': 8776, 'updownarrow;': 8597, 'Bernoullis;': 8492, 'CirclePlus;': 8853, 'EqualTilde;': 8770, 'Fouriertrf;': 8497, 'ImaginaryI;': 8520, 'Laplacetrf;': 8466, 'LeftVector;': 8636, 'Lleftarrow;': 8666, 'NotElement;': 8713, 'NotGreater;': 8815, 'Proportion;': 8759, 'RightArrow;': 8594, 'RightFloor;': 8971, 'Rightarrow;': 8658, 'ThickSpace;': 8287, 'TildeEqual;': 8771, 'TildeTilde;': 8776, 'UnderBrace;': 9183, 'UpArrowBar;': 10514, 'UpTeeArrow;': 8613, 'circledast;': 8859, 'complement;': 8705, 'curlywedge;': 8911, 'eqslantgtr;': 10902, 'gtreqqless;': 10892, 'lessapprox;': 10885, 'lesseqqgtr;': 10891, 'lmoustache;': 9136, 'longmapsto;': 10236, 'mapstodown;': 8615, 'mapstoleft;': 8612, 'nLeftarrow;': 8653, 'nleftarrow;': 8602, 'nsubseteqq;': 10949, 'nsupseteqq;': 10950, 'precapprox;': 10935, 'rightarrow;': 8594, 'rmoustache;': 9137, 'sqsubseteq;': 8849, 'sqsupseteq;': 8850, 'subsetneqq;': 10955, 'succapprox;': 10936, 'supsetneqq;': 10956, 'upuparrows;': 8648, 'varepsilon;': 1013, 'varnothing;': 8709, 'Backslash;': 8726, 'CenterDot;': 183, 'CircleDot;': 8857, 'Congruent;': 8801, 'Coproduct;': 8720, 'DoubleDot;': 168, 'DownArrow;': 8595, 'DownBreve;': 785, 'Downarrow;': 8659, 'HumpEqual;': 8783, 'LeftArrow;': 8592, 'LeftFloor;': 8970, 'Leftarrow;': 8656, 'LessTilde;': 8818, 'Mellintrf;': 8499, 'MinusPlus;': 8723, 'NotCupCap;': 8813, 'NotExists;': 8708, 'NotSubset;': 8834, 'OverBrace;': 9182, 'PlusMinus;': 177, 'Therefore;': 8756, 'ThinSpace;': 8201, 'TripleDot;': 8411, 'UnionPlus;': 8846, 'backprime;': 8245, 'backsimeq;': 8909, 'bigotimes;': 10754, 'centerdot;': 183, 'checkmark;': 10003, 'complexes;': 8450, 'dotsquare;': 8865, 'downarrow;': 8595, 'gtrapprox;': 10886, 'gtreqless;': 8923, 'gvertneqq;': 8809, 'heartsuit;': 9829, 'leftarrow;': 8592, 'lesseqgtr;': 8922, 'lvertneqq;': 8808, 'ngeqslant;': 10878, 'nleqslant;': 10877, 'nparallel;': 8742, 'nshortmid;': 8740, 'nsubseteq;': 8840, 'nsupseteq;': 8841, 'pitchfork;': 8916, 'rationals;': 8474, 'spadesuit;': 9824, 'subseteqq;': 10949, 'subsetneq;': 8842, 'supseteqq;': 10950, 'supsetneq;': 8843, 'therefore;': 8756, 'triangleq;': 8796, 'varpropto;': 8733, 'DDotrahd;': 10513, 'DotEqual;': 8784, 'Integral;': 8747, 'LessLess;': 10913, 'NotEqual;': 8800, 'NotTilde;': 8769, 'PartialD;': 8706, 'Precedes;': 8826, 'RightTee;': 8866, 'Succeeds;': 8827, 'SuchThat;': 8715, 'Superset;': 8835, 'Uarrocir;': 10569, 'UnderBar;': 95, 'andslope;': 10840, 'angmsdaa;': 10664, 'angmsdab;': 10665, 'angmsdac;': 10666, 'angmsdad;': 10667, 'angmsdae;': 10668, 'angmsdaf;': 10669, 'angmsdag;': 10670, 'angmsdah;': 10671, 'angrtvbd;': 10653, 'approxeq;': 8778, 'awconint;': 8755, 'backcong;': 8780, 'barwedge;': 8965, 'bbrktbrk;': 9142, 'bigoplus;': 10753, 'bigsqcup;': 10758, 'biguplus;': 10756, 'bigwedge;': 8896, 'boxminus;': 8863, 'boxtimes;': 8864, 'bsolhsub;': 10184, 'capbrcup;': 10825, 'circledR;': 174, 'circledS;': 9416, 'cirfnint;': 10768, 'clubsuit;': 9827, 'cupbrcap;': 10824, 'curlyvee;': 8910, 'cwconint;': 8754, 'doteqdot;': 8785, 'dotminus;': 8760, 'drbkarow;': 10512, 'dzigrarr;': 10239, 'elinters;': 9191, 'emptyset;': 8709, 'eqvparsl;': 10725, 'fpartint;': 10765, 'geqslant;': 10878, 'gesdotol;': 10884, 'gnapprox;': 10890, 'hksearow;': 10533, 'hkswarow;': 10534, 'imagline;': 8464, 'imagpart;': 8465, 'infintie;': 10717, 'integers;': 8484, 'intercal;': 8890, 'intlarhk;': 10775, 'laemptyv;': 10676, 'ldrushar;': 10571, 'leqslant;': 10877, 'lesdotor;': 10883, 'llcorner;': 8990, 'lnapprox;': 10889, 'lrcorner;': 8991, 'lurdshar;': 10570, 'mapstoup;': 8613, 'multimap;': 8888, 'naturals;': 8469, 'ncongdot;': 10861, 'notindot;': 8949, 'otimesas;': 10806, 'parallel;': 8741, 'plusacir;': 10787, 'pointint;': 10773, 'precneqq;': 10933, 'precnsim;': 8936, 'profalar;': 9006, 'profline;': 8978, 'profsurf;': 8979, 'raemptyv;': 10675, 'realpart;': 8476, 'rppolint;': 10770, 'rtriltri;': 10702, 'scpolint;': 10771, 'setminus;': 8726, 'shortmid;': 8739, 'smeparsl;': 10724, 'sqsubset;': 8847, 'sqsupset;': 8848, 'subseteq;': 8838, 'succneqq;': 10934, 'succnsim;': 8937, 'supseteq;': 8839, 'thetasym;': 977, 'thicksim;': 8764, 'timesbar;': 10801, 'triangle;': 9653, 'triminus;': 10810, 'trpezium;': 9186, 'ulcorner;': 8988, 'urcorner;': 8989, 'varkappa;': 1008, 'varsigma;': 962, 'vartheta;': 977, 'Because;': 8757, 'Cayleys;': 8493, 'Cconint;': 8752, 'Cedilla;': 184, 'Diamond;': 8900, 'DownTee;': 8868, 'Element;': 8712, 'Epsilon;': 917, 'Implies;': 8658, 'LeftTee;': 8867, 'NewLine;': 10, 'NoBreak;': 8288, 'NotLess;': 8814, 'Omicron;': 927, 'OverBar;': 8254, 'Product;': 8719, 'UpArrow;': 8593, 'Uparrow;': 8657, 'Upsilon;': 933, 'alefsym;': 8501, 'angrtvb;': 8894, 'angzarr;': 9084, 'asympeq;': 8781, 'backsim;': 8765, 'because;': 8757, 'bemptyv;': 10672, 'between;': 8812, 'bigcirc;': 9711, 'bigodot;': 10752, 'bigstar;': 9733, 'bnequiv;': 8801, 'boxplus;': 8862, 'ccupssm;': 10832, 'cemptyv;': 10674, 'cirscir;': 10690, 'coloneq;': 8788, 'congdot;': 10861, 'cudarrl;': 10552, 'cudarrr;': 10549, 'cularrp;': 10557, 'curarrm;': 10556, 'dbkarow;': 10511, 'ddagger;': 8225, 'ddotseq;': 10871, 'demptyv;': 10673, 'diamond;': 8900, 'digamma;': 989, 'dotplus;': 8724, 'dwangle;': 10662, 'epsilon;': 949, 'eqcolon;': 8789, 'equivDD;': 10872, 'gesdoto;': 10882, 'gtquest;': 10876, 'gtrless;': 8823, 'harrcir;': 10568, 'intprod;': 10812, 'isindot;': 8949, 'larrbfs;': 10527, 'larrsim;': 10611, 'lbrksld;': 10639, 'lbrkslu;': 10637, 'ldrdhar;': 10599, 'lesdoto;': 10881, 'lessdot;': 8918, 'lessgtr;': 8822, 'lesssim;': 8818, 'lotimes;': 10804, 'lozenge;': 9674, 'ltquest;': 10875, 'luruhar;': 10598, 'maltese;': 10016, 'minusdu;': 10794, 'napprox;': 8777, 'natural;': 9838, 'nearrow;': 8599, 'nexists;': 8708, 'notinva;': 8713, 'notinvb;': 8951, 'notinvc;': 8950, 'notniva;': 8716, 'notnivb;': 8958, 'notnivc;': 8957, 'npolint;': 10772, 'npreceq;': 10927, 'nsqsube;': 8930, 'nsqsupe;': 8931, 'nsubset;': 8834, 'nsucceq;': 10928, 'nsupset;': 8835, 'nvinfin;': 10718, 'nvltrie;': 8884, 'nvrtrie;': 8885, 'nwarrow;': 8598, 'olcross;': 10683, 'omicron;': 959, 'orderof;': 8500, 'orslope;': 10839, 'pertenk;': 8241, 'planckh;': 8462, 'pluscir;': 10786, 'plussim;': 10790, 'plustwo;': 10791, 'precsim;': 8830, 'quatint;': 10774, 'questeq;': 8799, 'rarrbfs;': 10528, 'rarrsim;': 10612, 'rbrksld;': 10638, 'rbrkslu;': 10640, 'rdldhar;': 10601, 'realine;': 8475, 'rotimes;': 10805, 'ruluhar;': 10600, 'searrow;': 8600, 'simplus;': 10788, 'simrarr;': 10610, 'subedot;': 10947, 'submult;': 10945, 'subplus;': 10943, 'subrarr;': 10617, 'succsim;': 8831, 'supdsub;': 10968, 'supedot;': 10948, 'suphsol;': 10185, 'suphsub;': 10967, 'suplarr;': 10619, 'supmult;': 10946, 'supplus;': 10944, 'swarrow;': 8601, 'topfork;': 10970, 'triplus;': 10809, 'tritime;': 10811, 'uparrow;': 8593, 'upsilon;': 965, 'uwangle;': 10663, 'vzigzag;': 10650, 'zigrarr;': 8669, 'Aacute;': 193, 'Abreve;': 258, 'Agrave;': 192, 'Assign;': 8788, 'Atilde;': 195, 'Barwed;': 8966, 'Bumpeq;': 8782, 'Cacute;': 262, 'Ccaron;': 268, 'Ccedil;': 199, 'Colone;': 10868, 'Conint;': 8751, 'CupCap;': 8781, 'Dagger;': 8225, 'Dcaron;': 270, 'DotDot;': 8412, 'Dstrok;': 272, 'Eacute;': 201, 'Ecaron;': 282, 'Egrave;': 200, 'Exists;': 8707, 'ForAll;': 8704, 'Gammad;': 988, 'Gbreve;': 286, 'Gcedil;': 290, 'HARDcy;': 1066, 'Hstrok;': 294, 'Iacute;': 205, 'Igrave;': 204, 'Itilde;': 296, 'Jsercy;': 1032, 'Kcedil;': 310, 'Lacute;': 313, 'Lambda;': 923, 'Lcaron;': 317, 'Lcedil;': 315, 'Lmidot;': 319, 'Lstrok;': 321, 'Nacute;': 323, 'Ncaron;': 327, 'Ncedil;': 325, 'Ntilde;': 209, 'Oacute;': 211, 'Odblac;': 336, 'Ograve;': 210, 'Oslash;': 216, 'Otilde;': 213, 'Otimes;': 10807, 'Racute;': 340, 'Rarrtl;': 10518, 'Rcaron;': 344, 'Rcedil;': 342, 'SHCHcy;': 1065, 'SOFTcy;': 1068, 'Sacute;': 346, 'Scaron;': 352, 'Scedil;': 350, 'Square;': 9633, 'Subset;': 8912, 'Supset;': 8913, 'Tcaron;': 356, 'Tcedil;': 354, 'Tstrok;': 358, 'Uacute;': 218, 'Ubreve;': 364, 'Udblac;': 368, 'Ugrave;': 217, 'Utilde;': 360, 'Vdashl;': 10982, 'Verbar;': 8214, 'Vvdash;': 8874, 'Yacute;': 221, 'Zacute;': 377, 'Zcaron;': 381, 'aacute;': 225, 'abreve;': 259, 'agrave;': 224, 'andand;': 10837, 'angmsd;': 8737, 'angsph;': 8738, 'apacir;': 10863, 'approx;': 8776, 'atilde;': 227, 'barvee;': 8893, 'barwed;': 8965, 'becaus;': 8757, 'bernou;': 8492, 'bigcap;': 8898, 'bigcup;': 8899, 'bigvee;': 8897, 'bkarow;': 10509, 'bottom;': 8869, 'bowtie;': 8904, 'boxbox;': 10697, 'bprime;': 8245, 'brvbar;': 166, 'bullet;': 8226, 'bumpeq;': 8783, 'cacute;': 263, 'capand;': 10820, 'capcap;': 10827, 'capcup;': 10823, 'capdot;': 10816, 'ccaron;': 269, 'ccedil;': 231, 'circeq;': 8791, 'cirmid;': 10991, 'colone;': 8788, 'commat;': 64, 'compfn;': 8728, 'conint;': 8750, 'coprod;': 8720, 'copysr;': 8471, 'cularr;': 8630, 'cupcap;': 10822, 'cupcup;': 10826, 'cupdot;': 8845, 'curarr;': 8631, 'curren;': 164, 'cylcty;': 9005, 'dagger;': 8224, 'daleth;': 8504, 'dcaron;': 271, 'dfisht;': 10623, 'divide;': 247, 'divonx;': 8903, 'dlcorn;': 8990, 'dlcrop;': 8973, 'dollar;': 36, 'drcorn;': 8991, 'drcrop;': 8972, 'dstrok;': 273, 'eacute;': 233, 'easter;': 10862, 'ecaron;': 283, 'ecolon;': 8789, 'egrave;': 232, 'egsdot;': 10904, 'elsdot;': 10903, 'emptyv;': 8709, 'emsp13;': 8196, 'emsp14;': 8197, 'eparsl;': 10723, 'eqcirc;': 8790, 'equals;': 61, 'equest;': 8799, 'female;': 9792, 'ffilig;': 64259, 'ffllig;': 64260, 'forall;': 8704, 'frac12;': 189, 'frac13;': 8531, 'frac14;': 188, 'frac15;': 8533, 'frac16;': 8537, 'frac18;': 8539, 'frac23;': 8532, 'frac25;': 8534, 'frac34;': 190, 'frac35;': 8535, 'frac38;': 8540, 'frac45;': 8536, 'frac56;': 8538, 'frac58;': 8541, 'frac78;': 8542, 'gacute;': 501, 'gammad;': 989, 'gbreve;': 287, 'gesdot;': 10880, 'gesles;': 10900, 'gtlPar;': 10645, 'gtrarr;': 10616, 'gtrdot;': 8919, 'gtrsim;': 8819, 'hairsp;': 8202, 'hamilt;': 8459, 'hardcy;': 1098, 'hearts;': 9829, 'hellip;': 8230, 'hercon;': 8889, 'homtht;': 8763, 'horbar;': 8213, 'hslash;': 8463, 'hstrok;': 295, 'hybull;': 8259, 'hyphen;': 8208, 'iacute;': 237, 'igrave;': 236, 'iiiint;': 10764, 'iinfin;': 10716, 'incare;': 8453, 'inodot;': 305, 'intcal;': 8890, 'iquest;': 191, 'isinsv;': 8947, 'itilde;': 297, 'jsercy;': 1112, 'kappav;': 1008, 'kcedil;': 311, 'kgreen;': 312, 'lAtail;': 10523, 'lacute;': 314, 'lagran;': 8466, 'lambda;': 955, 'langle;': 10216, 'larrfs;': 10525, 'larrhk;': 8617, 'larrlp;': 8619, 'larrpl;': 10553, 'larrtl;': 8610, 'latail;': 10521, 'lbrace;': 123, 'lbrack;': 91, 'lcaron;': 318, 'lcedil;': 316, 'ldquor;': 8222, 'lesdot;': 10879, 'lesges;': 10899, 'lfisht;': 10620, 'lfloor;': 8970, 'lharul;': 10602, 'llhard;': 10603, 'lmidot;': 320, 'lmoust;': 9136, 'loplus;': 10797, 'lowast;': 8727, 'lowbar;': 95, 'lparlt;': 10643, 'lrhard;': 10605, 'lsaquo;': 8249, 'lsquor;': 8218, 'lstrok;': 322, 'lthree;': 8907, 'ltimes;': 8905, 'ltlarr;': 10614, 'ltrPar;': 10646, 'mapsto;': 8614, 'marker;': 9646, 'mcomma;': 10793, 'midast;': 42, 'midcir;': 10992, 'middot;': 183, 'minusb;': 8863, 'minusd;': 8760, 'mnplus;': 8723, 'models;': 8871, 'mstpos;': 8766, 'nVDash;': 8879, 'nVdash;': 8878, 'nacute;': 324, 'nbumpe;': 8783, 'ncaron;': 328, 'ncedil;': 326, 'nearhk;': 10532, 'nequiv;': 8802, 'nesear;': 10536, 'nexist;': 8708, 'nltrie;': 8940, 'notinE;': 8953, 'nparsl;': 11005, 'nprcue;': 8928, 'nrarrc;': 10547, 'nrarrw;': 8605, 'nrtrie;': 8941, 'nsccue;': 8929, 'nsimeq;': 8772, 'ntilde;': 241, 'numero;': 8470, 'nvDash;': 8877, 'nvHarr;': 10500, 'nvdash;': 8876, 'nvlArr;': 10498, 'nvrArr;': 10499, 'nwarhk;': 10531, 'nwnear;': 10535, 'oacute;': 243, 'odblac;': 337, 'odsold;': 10684, 'ograve;': 242, 'ominus;': 8854, 'origof;': 8886, 'oslash;': 248, 'otilde;': 245, 'otimes;': 8855, 'parsim;': 10995, 'percnt;': 37, 'period;': 46, 'permil;': 8240, 'phmmat;': 8499, 'planck;': 8463, 'plankv;': 8463, 'plusdo;': 8724, 'plusdu;': 10789, 'plusmn;': 177, 'preceq;': 10927, 'primes;': 8473, 'prnsim;': 8936, 'propto;': 8733, 'prurel;': 8880, 'puncsp;': 8200, 'qprime;': 8279, 'rAtail;': 10524, 'racute;': 341, 'rangle;': 10217, 'rarrap;': 10613, 'rarrfs;': 10526, 'rarrhk;': 8618, 'rarrlp;': 8620, 'rarrpl;': 10565, 'rarrtl;': 8611, 'ratail;': 10522, 'rbrace;': 125, 'rbrack;': 93, 'rcaron;': 345, 'rcedil;': 343, 'rdquor;': 8221, 'rfisht;': 10621, 'rfloor;': 8971, 'rharul;': 10604, 'rmoust;': 9137, 'roplus;': 10798, 'rpargt;': 10644, 'rsaquo;': 8250, 'rsquor;': 8217, 'rthree;': 8908, 'rtimes;': 8906, 'sacute;': 347, 'scaron;': 353, 'scedil;': 351, 'scnsim;': 8937, 'searhk;': 10533, 'seswar;': 10537, 'sfrown;': 8994, 'shchcy;': 1097, 'sigmaf;': 962, 'sigmav;': 962, 'simdot;': 10858, 'smashp;': 10803, 'softcy;': 1100, 'solbar;': 9023, 'spades;': 9824, 'sqcaps;': 8851, 'sqcups;': 8852, 'sqsube;': 8849, 'sqsupe;': 8850, 'square;': 9633, 'squarf;': 9642, 'ssetmn;': 8726, 'ssmile;': 8995, 'sstarf;': 8902, 'subdot;': 10941, 'subset;': 8834, 'subsim;': 10951, 'subsub;': 10965, 'subsup;': 10963, 'succeq;': 10928, 'supdot;': 10942, 'supset;': 8835, 'supsim;': 10952, 'supsub;': 10964, 'supsup;': 10966, 'swarhk;': 10534, 'swnwar;': 10538, 'target;': 8982, 'tcaron;': 357, 'tcedil;': 355, 'telrec;': 8981, 'there4;': 8756, 'thetav;': 977, 'thinsp;': 8201, 'thksim;': 8764, 'timesb;': 8864, 'timesd;': 10800, 'topbot;': 9014, 'topcir;': 10993, 'tprime;': 8244, 'tridot;': 9708, 'tstrok;': 359, 'uacute;': 250, 'ubreve;': 365, 'udblac;': 369, 'ufisht;': 10622, 'ugrave;': 249, 'ulcorn;': 8988, 'ulcrop;': 8975, 'urcorn;': 8989, 'urcrop;': 8974, 'utilde;': 361, 'vangrt;': 10652, 'varphi;': 981, 'varrho;': 1009, 'veebar;': 8891, 'vellip;': 8942, 'verbar;': 124, 'vsubnE;': 10955, 'vsubne;': 8842, 'vsupnE;': 10956, 'vsupne;': 8843, 'wedbar;': 10847, 'wedgeq;': 8793, 'weierp;': 8472, 'wreath;': 8768, 'xoplus;': 10753, 'xotime;': 10754, 'xsqcup;': 10758, 'xuplus;': 10756, 'xwedge;': 8896, 'yacute;': 253, 'zacute;': 378, 'zcaron;': 382, 'zeetrf;': 8488, 'AElig;': 198, Aacute: 193, 'Acirc;': 194, Agrave: 192, 'Alpha;': 913, 'Amacr;': 256, 'Aogon;': 260, 'Aring;': 197, Atilde: 195, 'Breve;': 728, Ccedil: 199, 'Ccirc;': 264, 'Colon;': 8759, 'Cross;': 10799, 'Dashv;': 10980, 'Delta;': 916, Eacute: 201, 'Ecirc;': 202, Egrave: 200, 'Emacr;': 274, 'Eogon;': 280, 'Equal;': 10869, 'Gamma;': 915, 'Gcirc;': 284, 'Hacek;': 711, 'Hcirc;': 292, 'IJlig;': 306, Iacute: 205, 'Icirc;': 206, Igrave: 204, 'Imacr;': 298, 'Iogon;': 302, 'Iukcy;': 1030, 'Jcirc;': 308, 'Jukcy;': 1028, 'Kappa;': 922, Ntilde: 209, 'OElig;': 338, Oacute: 211, 'Ocirc;': 212, Ograve: 210, 'Omacr;': 332, 'Omega;': 937, Oslash: 216, Otilde: 213, 'Prime;': 8243, 'RBarr;': 10512, 'Scirc;': 348, 'Sigma;': 931, 'THORN;': 222, 'TRADE;': 8482, 'TSHcy;': 1035, 'Theta;': 920, 'Tilde;': 8764, Uacute: 218, 'Ubrcy;': 1038, 'Ucirc;': 219, Ugrave: 217, 'Umacr;': 362, 'Union;': 8899, 'Uogon;': 370, 'UpTee;': 8869, 'Uring;': 366, 'VDash;': 8875, 'Vdash;': 8873, 'Wcirc;': 372, 'Wedge;': 8896, Yacute: 221, 'Ycirc;': 374, aacute: 225, 'acirc;': 226, 'acute;': 180, 'aelig;': 230, agrave: 224, 'aleph;': 8501, 'alpha;': 945, 'amacr;': 257, 'amalg;': 10815, 'angle;': 8736, 'angrt;': 8735, 'angst;': 197, 'aogon;': 261, 'aring;': 229, 'asymp;': 8776, atilde: 227, 'awint;': 10769, 'bcong;': 8780, 'bdquo;': 8222, 'bepsi;': 1014, 'blank;': 9251, 'blk12;': 9618, 'blk14;': 9617, 'blk34;': 9619, 'block;': 9608, 'boxDL;': 9559, 'boxDR;': 9556, 'boxDl;': 9558, 'boxDr;': 9555, 'boxHD;': 9574, 'boxHU;': 9577, 'boxHd;': 9572, 'boxHu;': 9575, 'boxUL;': 9565, 'boxUR;': 9562, 'boxUl;': 9564, 'boxUr;': 9561, 'boxVH;': 9580, 'boxVL;': 9571, 'boxVR;': 9568, 'boxVh;': 9579, 'boxVl;': 9570, 'boxVr;': 9567, 'boxdL;': 9557, 'boxdR;': 9554, 'boxdl;': 9488, 'boxdr;': 9484, 'boxhD;': 9573, 'boxhU;': 9576, 'boxhd;': 9516, 'boxhu;': 9524, 'boxuL;': 9563, 'boxuR;': 9560, 'boxul;': 9496, 'boxur;': 9492, 'boxvH;': 9578, 'boxvL;': 9569, 'boxvR;': 9566, 'boxvh;': 9532, 'boxvl;': 9508, 'boxvr;': 9500, 'breve;': 728, brvbar: 166, 'bsemi;': 8271, 'bsime;': 8909, 'bsolb;': 10693, 'bumpE;': 10926, 'bumpe;': 8783, 'caret;': 8257, 'caron;': 711, 'ccaps;': 10829, ccedil: 231, 'ccirc;': 265, 'ccups;': 10828, 'cedil;': 184, 'check;': 10003, 'clubs;': 9827, 'colon;': 58, 'comma;': 44, 'crarr;': 8629, 'cross;': 10007, 'csube;': 10961, 'csupe;': 10962, 'ctdot;': 8943, 'cuepr;': 8926, 'cuesc;': 8927, 'cupor;': 10821, curren: 164, 'cuvee;': 8910, 'cuwed;': 8911, 'cwint;': 8753, 'dashv;': 8867, 'dblac;': 733, 'ddarr;': 8650, 'delta;': 948, 'dharl;': 8643, 'dharr;': 8642, 'diams;': 9830, 'disin;': 8946, divide: 247, 'doteq;': 8784, 'dtdot;': 8945, 'dtrif;': 9662, 'duarr;': 8693, 'duhar;': 10607, 'eDDot;': 10871, eacute: 233, 'ecirc;': 234, 'efDot;': 8786, egrave: 232, 'emacr;': 275, 'empty;': 8709, 'eogon;': 281, 'eplus;': 10865, 'epsiv;': 1013, 'eqsim;': 8770, 'equiv;': 8801, 'erDot;': 8787, 'erarr;': 10609, 'esdot;': 8784, 'exist;': 8707, 'fflig;': 64256, 'filig;': 64257, 'fjlig;': 102, 'fllig;': 64258, 'fltns;': 9649, 'forkv;': 10969, frac12: 189, frac14: 188, frac34: 190, 'frasl;': 8260, 'frown;': 8994, 'gamma;': 947, 'gcirc;': 285, 'gescc;': 10921, 'gimel;': 8503, 'gneqq;': 8809, 'gnsim;': 8935, 'grave;': 96, 'gsime;': 10894, 'gsiml;': 10896, 'gtcir;': 10874, 'gtdot;': 8919, 'harrw;': 8621, 'hcirc;': 293, 'hoarr;': 8703, iacute: 237, 'icirc;': 238, 'iexcl;': 161, igrave: 236, 'iiint;': 8749, 'iiota;': 8489, 'ijlig;': 307, 'imacr;': 299, 'image;': 8465, 'imath;': 305, 'imped;': 437, 'infin;': 8734, 'iogon;': 303, 'iprod;': 10812, iquest: 191, 'isinE;': 8953, 'isins;': 8948, 'isinv;': 8712, 'iukcy;': 1110, 'jcirc;': 309, 'jmath;': 567, 'jukcy;': 1108, 'kappa;': 954, 'lAarr;': 8666, 'lBarr;': 10510, 'langd;': 10641, 'laquo;': 171, 'larrb;': 8676, 'lates;': 10925, 'lbarr;': 10508, 'lbbrk;': 10098, 'lbrke;': 10635, 'lceil;': 8968, 'ldquo;': 8220, 'lescc;': 10920, 'lhard;': 8637, 'lharu;': 8636, 'lhblk;': 9604, 'llarr;': 8647, 'lltri;': 9722, 'lneqq;': 8808, 'lnsim;': 8934, 'loang;': 10220, 'loarr;': 8701, 'lobrk;': 10214, 'lopar;': 10629, 'lrarr;': 8646, 'lrhar;': 8651, 'lrtri;': 8895, 'lsime;': 10893, 'lsimg;': 10895, 'lsquo;': 8216, 'ltcir;': 10873, 'ltdot;': 8918, 'ltrie;': 8884, 'ltrif;': 9666, 'mDDot;': 8762, 'mdash;': 8212, 'micro;': 181, middot: 183, 'minus;': 8722, 'mumap;': 8888, 'nabla;': 8711, 'napid;': 8779, 'napos;': 329, 'natur;': 9838, 'nbump;': 8782, 'ncong;': 8775, 'ndash;': 8211, 'neArr;': 8663, 'nearr;': 8599, 'nedot;': 8784, 'nesim;': 8770, 'ngeqq;': 8807, 'ngsim;': 8821, 'nhArr;': 8654, 'nharr;': 8622, 'nhpar;': 10994, 'nlArr;': 8653, 'nlarr;': 8602, 'nleqq;': 8806, 'nless;': 8814, 'nlsim;': 8820, 'nltri;': 8938, 'notin;': 8713, 'notni;': 8716, 'npart;': 8706, 'nprec;': 8832, 'nrArr;': 8655, 'nrarr;': 8603, 'nrtri;': 8939, 'nsime;': 8772, 'nsmid;': 8740, 'nspar;': 8742, 'nsubE;': 10949, 'nsube;': 8840, 'nsucc;': 8833, 'nsupE;': 10950, 'nsupe;': 8841, ntilde: 241, 'numsp;': 8199, 'nvsim;': 8764, 'nwArr;': 8662, 'nwarr;': 8598, oacute: 243, 'ocirc;': 244, 'odash;': 8861, 'oelig;': 339, 'ofcir;': 10687, ograve: 242, 'ohbar;': 10677, 'olarr;': 8634, 'olcir;': 10686, 'oline;': 8254, 'omacr;': 333, 'omega;': 969, 'operp;': 10681, 'oplus;': 8853, 'orarr;': 8635, 'order;': 8500, oslash: 248, otilde: 245, 'ovbar;': 9021, 'parsl;': 11005, 'phone;': 9742, 'plusb;': 8862, 'pluse;': 10866, plusmn: 177, 'pound;': 163, 'prcue;': 8828, 'prime;': 8242, 'prnap;': 10937, 'prsim;': 8830, 'quest;': 63, 'rAarr;': 8667, 'rBarr;': 10511, 'radic;': 8730, 'rangd;': 10642, 'range;': 10661, 'raquo;': 187, 'rarrb;': 8677, 'rarrc;': 10547, 'rarrw;': 8605, 'ratio;': 8758, 'rbarr;': 10509, 'rbbrk;': 10099, 'rbrke;': 10636, 'rceil;': 8969, 'rdquo;': 8221, 'reals;': 8477, 'rhard;': 8641, 'rharu;': 8640, 'rlarr;': 8644, 'rlhar;': 8652, 'rnmid;': 10990, 'roang;': 10221, 'roarr;': 8702, 'robrk;': 10215, 'ropar;': 10630, 'rrarr;': 8649, 'rsquo;': 8217, 'rtrie;': 8885, 'rtrif;': 9656, 'sbquo;': 8218, 'sccue;': 8829, 'scirc;': 349, 'scnap;': 10938, 'scsim;': 8831, 'sdotb;': 8865, 'sdote;': 10854, 'seArr;': 8664, 'searr;': 8600, 'setmn;': 8726, 'sharp;': 9839, 'sigma;': 963, 'simeq;': 8771, 'simgE;': 10912, 'simlE;': 10911, 'simne;': 8774, 'slarr;': 8592, 'smile;': 8995, 'smtes;': 10924, 'sqcap;': 8851, 'sqcup;': 8852, 'sqsub;': 8847, 'sqsup;': 8848, 'srarr;': 8594, 'starf;': 9733, 'strns;': 175, 'subnE;': 10955, 'subne;': 8842, 'supnE;': 10956, 'supne;': 8843, 'swArr;': 8665, 'swarr;': 8601, 'szlig;': 223, 'theta;': 952, 'thkap;': 8776, 'thorn;': 254, 'tilde;': 732, 'times;': 215, 'trade;': 8482, 'trisb;': 10701, 'tshcy;': 1115, 'twixt;': 8812, uacute: 250, 'ubrcy;': 1118, 'ucirc;': 251, 'udarr;': 8645, 'udhar;': 10606, ugrave: 249, 'uharl;': 8639, 'uharr;': 8638, 'uhblk;': 9600, 'ultri;': 9720, 'umacr;': 363, 'uogon;': 371, 'uplus;': 8846, 'upsih;': 978, 'uring;': 367, 'urtri;': 9721, 'utdot;': 8944, 'utrif;': 9652, 'uuarr;': 8648, 'vBarv;': 10985, 'vDash;': 8872, 'varpi;': 982, 'vdash;': 8866, 'veeeq;': 8794, 'vltri;': 8882, 'vnsub;': 8834, 'vnsup;': 8835, 'vprop;': 8733, 'vrtri;': 8883, 'wcirc;': 373, 'wedge;': 8743, 'xcirc;': 9711, 'xdtri;': 9661, 'xhArr;': 10234, 'xharr;': 10231, 'xlArr;': 10232, 'xlarr;': 10229, 'xodot;': 10752, 'xrArr;': 10233, 'xrarr;': 10230, 'xutri;': 9651, yacute: 253, 'ycirc;': 375, AElig: 198, Acirc: 194, 'Aopf;': 120120, Aring: 197, 'Ascr;': 119964, 'Auml;': 196, 'Barv;': 10983, 'Beta;': 914, 'Bopf;': 120121, 'Bscr;': 8492, 'CHcy;': 1063, 'COPY;': 169, 'Cdot;': 266, 'Copf;': 8450, 'Cscr;': 119966, 'DJcy;': 1026, 'DScy;': 1029, 'DZcy;': 1039, 'Darr;': 8609, 'Dopf;': 120123, 'Dscr;': 119967, Ecirc: 202, 'Edot;': 278, 'Eopf;': 120124, 'Escr;': 8496, 'Esim;': 10867, 'Euml;': 203, 'Fopf;': 120125, 'Fscr;': 8497, 'GJcy;': 1027, 'Gdot;': 288, 'Gopf;': 120126, 'Gscr;': 119970, 'Hopf;': 8461, 'Hscr;': 8459, 'IEcy;': 1045, 'IOcy;': 1025, Icirc: 206, 'Idot;': 304, 'Iopf;': 120128, 'Iota;': 921, 'Iscr;': 8464, 'Iuml;': 207, 'Jopf;': 120129, 'Jscr;': 119973, 'KHcy;': 1061, 'KJcy;': 1036, 'Kopf;': 120130, 'Kscr;': 119974, 'LJcy;': 1033, 'Lang;': 10218, 'Larr;': 8606, 'Lopf;': 120131, 'Lscr;': 8466, 'Mopf;': 120132, 'Mscr;': 8499, 'NJcy;': 1034, 'Nopf;': 8469, 'Nscr;': 119977, Ocirc: 212, 'Oopf;': 120134, 'Oscr;': 119978, 'Ouml;': 214, 'Popf;': 8473, 'Pscr;': 119979, 'QUOT;': 34, 'Qopf;': 8474, 'Qscr;': 119980, 'Rang;': 10219, 'Rarr;': 8608, 'Ropf;': 8477, 'Rscr;': 8475, 'SHcy;': 1064, 'Sopf;': 120138, 'Sqrt;': 8730, 'Sscr;': 119982, 'Star;': 8902, THORN: 222, 'TScy;': 1062, 'Topf;': 120139, 'Tscr;': 119983, 'Uarr;': 8607, Ucirc: 219, 'Uopf;': 120140, 'Upsi;': 978, 'Uscr;': 119984, 'Uuml;': 220, 'Vbar;': 10987, 'Vert;': 8214, 'Vopf;': 120141, 'Vscr;': 119985, 'Wopf;': 120142, 'Wscr;': 119986, 'Xopf;': 120143, 'Xscr;': 119987, 'YAcy;': 1071, 'YIcy;': 1031, 'YUcy;': 1070, 'Yopf;': 120144, 'Yscr;': 119988, 'Yuml;': 376, 'ZHcy;': 1046, 'Zdot;': 379, 'Zeta;': 918, 'Zopf;': 8484, 'Zscr;': 119989, acirc: 226, acute: 180, aelig: 230, 'andd;': 10844, 'andv;': 10842, 'ange;': 10660, 'aopf;': 120146, 'apid;': 8779, 'apos;': 39, aring: 229, 'ascr;': 119990, 'auml;': 228, 'bNot;': 10989, 'bbrk;': 9141, 'beta;': 946, 'beth;': 8502, 'bnot;': 8976, 'bopf;': 120147, 'boxH;': 9552, 'boxV;': 9553, 'boxh;': 9472, 'boxv;': 9474, 'bscr;': 119991, 'bsim;': 8765, 'bsol;': 92, 'bull;': 8226, 'bump;': 8782, 'caps;': 8745, 'cdot;': 267, cedil: 184, 'cent;': 162, 'chcy;': 1095, 'cirE;': 10691, 'circ;': 710, 'cire;': 8791, 'comp;': 8705, 'cong;': 8773, 'copf;': 120148, 'copy;': 169, 'cscr;': 119992, 'csub;': 10959, 'csup;': 10960, 'cups;': 8746, 'dArr;': 8659, 'dHar;': 10597, 'darr;': 8595, 'dash;': 8208, 'diam;': 8900, 'djcy;': 1106, 'dopf;': 120149, 'dscr;': 119993, 'dscy;': 1109, 'dsol;': 10742, 'dtri;': 9663, 'dzcy;': 1119, 'eDot;': 8785, 'ecir;': 8790, ecirc: 234, 'edot;': 279, 'emsp;': 8195, 'ensp;': 8194, 'eopf;': 120150, 'epar;': 8917, 'epsi;': 949, 'escr;': 8495, 'esim;': 8770, 'euml;': 235, 'euro;': 8364, 'excl;': 33, 'flat;': 9837, 'fnof;': 402, 'fopf;': 120151, 'fork;': 8916, 'fscr;': 119995, 'gdot;': 289, 'geqq;': 8807, 'gesl;': 8923, 'gjcy;': 1107, 'gnap;': 10890, 'gneq;': 10888, 'gopf;': 120152, 'gscr;': 8458, 'gsim;': 8819, 'gtcc;': 10919, 'gvnE;': 8809, 'hArr;': 8660, 'half;': 189, 'harr;': 8596, 'hbar;': 8463, 'hopf;': 120153, 'hscr;': 119997, icirc: 238, 'iecy;': 1077, iexcl: 161, 'imof;': 8887, 'iocy;': 1105, 'iopf;': 120154, 'iota;': 953, 'iscr;': 119998, 'isin;': 8712, 'iuml;': 239, 'jopf;': 120155, 'jscr;': 119999, 'khcy;': 1093, 'kjcy;': 1116, 'kopf;': 120156, 'kscr;': 120000, 'lArr;': 8656, 'lHar;': 10594, 'lang;': 10216, laquo: 171, 'larr;': 8592, 'late;': 10925, 'lcub;': 123, 'ldca;': 10550, 'ldsh;': 8626, 'leqq;': 8806, 'lesg;': 8922, 'ljcy;': 1113, 'lnap;': 10889, 'lneq;': 10887, 'lopf;': 120157, 'lozf;': 10731, 'lpar;': 40, 'lscr;': 120001, 'lsim;': 8818, 'lsqb;': 91, 'ltcc;': 10918, 'ltri;': 9667, 'lvnE;': 8808, 'macr;': 175, 'male;': 9794, 'malt;': 10016, micro: 181, 'mlcp;': 10971, 'mldr;': 8230, 'mopf;': 120158, 'mscr;': 120002, 'nGtv;': 8811, 'nLtv;': 8810, 'nang;': 8736, 'napE;': 10864, 'nbsp;': 160, 'ncap;': 10819, 'ncup;': 10818, 'ngeq;': 8817, 'nges;': 10878, 'ngtr;': 8815, 'nisd;': 8954, 'njcy;': 1114, 'nldr;': 8229, 'nleq;': 8816, 'nles;': 10877, 'nmid;': 8740, 'nopf;': 120159, 'npar;': 8742, 'npre;': 10927, 'nsce;': 10928, 'nscr;': 120003, 'nsim;': 8769, 'nsub;': 8836, 'nsup;': 8837, 'ntgl;': 8825, 'ntlg;': 8824, 'nvap;': 8781, 'nvge;': 8805, 'nvgt;': 62, 'nvle;': 8804, 'nvlt;': 60, 'oast;': 8859, 'ocir;': 8858, ocirc: 244, 'odiv;': 10808, 'odot;': 8857, 'ogon;': 731, 'oint;': 8750, 'omid;': 10678, 'oopf;': 120160, 'opar;': 10679, 'ordf;': 170, 'ordm;': 186, 'oror;': 10838, 'oscr;': 8500, 'osol;': 8856, 'ouml;': 246, 'para;': 182, 'part;': 8706, 'perp;': 8869, 'phiv;': 981, 'plus;': 43, 'popf;': 120161, pound: 163, 'prap;': 10935, 'prec;': 8826, 'prnE;': 10933, 'prod;': 8719, 'prop;': 8733, 'pscr;': 120005, 'qint;': 10764, 'qopf;': 120162, 'qscr;': 120006, 'quot;': 34, 'rArr;': 8658, 'rHar;': 10596, 'race;': 8765, 'rang;': 10217, raquo: 187, 'rarr;': 8594, 'rcub;': 125, 'rdca;': 10551, 'rdsh;': 8627, 'real;': 8476, 'rect;': 9645, 'rhov;': 1009, 'ring;': 730, 'ropf;': 120163, 'rpar;': 41, 'rscr;': 120007, 'rsqb;': 93, 'rtri;': 9657, 'scap;': 10936, 'scnE;': 10934, 'sdot;': 8901, 'sect;': 167, 'semi;': 59, 'sext;': 10038, 'shcy;': 1096, 'sime;': 8771, 'simg;': 10910, 'siml;': 10909, 'smid;': 8739, 'smte;': 10924, 'solb;': 10692, 'sopf;': 120164, 'spar;': 8741, 'squf;': 9642, 'sscr;': 120008, 'star;': 9734, 'subE;': 10949, 'sube;': 8838, 'succ;': 8827, 'sung;': 9834, 'sup1;': 185, 'sup2;': 178, 'sup3;': 179, 'supE;': 10950, 'supe;': 8839, szlig: 223, 'tbrk;': 9140, 'tdot;': 8411, thorn: 254, times: 215, 'tint;': 8749, 'toea;': 10536, 'topf;': 120165, 'tosa;': 10537, 'trie;': 8796, 'tscr;': 120009, 'tscy;': 1094, 'uArr;': 8657, 'uHar;': 10595, 'uarr;': 8593, ucirc: 251, 'uopf;': 120166, 'upsi;': 965, 'uscr;': 120010, 'utri;': 9653, 'uuml;': 252, 'vArr;': 8661, 'vBar;': 10984, 'varr;': 8597, 'vert;': 124, 'vopf;': 120167, 'vscr;': 120011, 'wopf;': 120168, 'wscr;': 120012, 'xcap;': 8898, 'xcup;': 8899, 'xmap;': 10236, 'xnis;': 8955, 'xopf;': 120169, 'xscr;': 120013, 'xvee;': 8897, 'yacy;': 1103, 'yicy;': 1111, 'yopf;': 120170, 'yscr;': 120014, 'yucy;': 1102, 'yuml;': 255, 'zdot;': 380, 'zeta;': 950, 'zhcy;': 1078, 'zopf;': 120171, 'zscr;': 120015, 'zwnj;': 8204, 'AMP;': 38, 'Acy;': 1040, 'Afr;': 120068, 'And;': 10835, Auml: 196, 'Bcy;': 1041, 'Bfr;': 120069, COPY: 169, 'Cap;': 8914, 'Cfr;': 8493, 'Chi;': 935, 'Cup;': 8915, 'Dcy;': 1044, 'Del;': 8711, 'Dfr;': 120071, 'Dot;': 168, 'ENG;': 330, 'ETH;': 208, 'Ecy;': 1069, 'Efr;': 120072, 'Eta;': 919, Euml: 203, 'Fcy;': 1060, 'Ffr;': 120073, 'Gcy;': 1043, 'Gfr;': 120074, 'Hat;': 94, 'Hfr;': 8460, 'Icy;': 1048, 'Ifr;': 8465, 'Int;': 8748, Iuml: 207, 'Jcy;': 1049, 'Jfr;': 120077, 'Kcy;': 1050, 'Kfr;': 120078, 'Lcy;': 1051, 'Lfr;': 120079, 'Lsh;': 8624, 'Map;': 10501, 'Mcy;': 1052, 'Mfr;': 120080, 'Ncy;': 1053, 'Nfr;': 120081, 'Not;': 10988, 'Ocy;': 1054, 'Ofr;': 120082, Ouml: 214, 'Pcy;': 1055, 'Pfr;': 120083, 'Phi;': 934, 'Psi;': 936, QUOT: 34, 'Qfr;': 120084, 'REG;': 174, 'Rcy;': 1056, 'Rfr;': 8476, 'Rho;': 929, 'Rsh;': 8625, 'Scy;': 1057, 'Sfr;': 120086, 'Sub;': 8912, 'Sum;': 8721, 'Sup;': 8913, 'Tab;': 9, 'Tau;': 932, 'Tcy;': 1058, 'Tfr;': 120087, 'Ucy;': 1059, 'Ufr;': 120088, Uuml: 220, 'Vcy;': 1042, 'Vee;': 8897, 'Vfr;': 120089, 'Wfr;': 120090, 'Xfr;': 120091, 'Ycy;': 1067, 'Yfr;': 120092, 'Zcy;': 1047, 'Zfr;': 8488, 'acE;': 8766, 'acd;': 8767, 'acy;': 1072, 'afr;': 120094, 'amp;': 38, 'and;': 8743, 'ang;': 8736, 'apE;': 10864, 'ape;': 8778, 'ast;': 42, auml: 228, 'bcy;': 1073, 'bfr;': 120095, 'bne;': 61, 'bot;': 8869, 'cap;': 8745, cent: 162, 'cfr;': 120096, 'chi;': 967, 'cir;': 9675, copy: 169, 'cup;': 8746, 'dcy;': 1076, 'deg;': 176, 'dfr;': 120097, 'die;': 168, 'div;': 247, 'dot;': 729, 'ecy;': 1101, 'efr;': 120098, 'egs;': 10902, 'ell;': 8467, 'els;': 10901, 'eng;': 331, 'eta;': 951, 'eth;': 240, euml: 235, 'fcy;': 1092, 'ffr;': 120099, 'gEl;': 10892, 'gap;': 10886, 'gcy;': 1075, 'gel;': 8923, 'geq;': 8805, 'ges;': 10878, 'gfr;': 120100, 'ggg;': 8921, 'glE;': 10898, 'gla;': 10917, 'glj;': 10916, 'gnE;': 8809, 'gne;': 10888, 'hfr;': 120101, 'icy;': 1080, 'iff;': 8660, 'ifr;': 120102, 'int;': 8747, iuml: 239, 'jcy;': 1081, 'jfr;': 120103, 'kcy;': 1082, 'kfr;': 120104, 'lEg;': 10891, 'lap;': 10885, 'lat;': 10923, 'lcy;': 1083, 'leg;': 8922, 'leq;': 8804, 'les;': 10877, 'lfr;': 120105, 'lgE;': 10897, 'lnE;': 8808, 'lne;': 10887, 'loz;': 9674, 'lrm;': 8206, 'lsh;': 8624, macr: 175, 'map;': 8614, 'mcy;': 1084, 'mfr;': 120106, 'mho;': 8487, 'mid;': 8739, 'nGg;': 8921, 'nGt;': 8811, 'nLl;': 8920, 'nLt;': 8810, 'nap;': 8777, nbsp: 160, 'ncy;': 1085, 'nfr;': 120107, 'ngE;': 8807, 'nge;': 8817, 'ngt;': 8815, 'nis;': 8956, 'niv;': 8715, 'nlE;': 8806, 'nle;': 8816, 'nlt;': 8814, 'not;': 172, 'npr;': 8832, 'nsc;': 8833, 'num;': 35, 'ocy;': 1086, 'ofr;': 120108, 'ogt;': 10689, 'ohm;': 937, 'olt;': 10688, 'ord;': 10845, ordf: 170, ordm: 186, 'orv;': 10843, ouml: 246, 'par;': 8741, para: 182, 'pcy;': 1087, 'pfr;': 120109, 'phi;': 966, 'piv;': 982, 'prE;': 10931, 'pre;': 10927, 'psi;': 968, 'qfr;': 120110, quot: 34, 'rcy;': 1088, 'reg;': 174, 'rfr;': 120111, 'rho;': 961, 'rlm;': 8207, 'rsh;': 8625, 'scE;': 10932, 'sce;': 10928, 'scy;': 1089, sect: 167, 'sfr;': 120112, 'shy;': 173, 'sim;': 8764, 'smt;': 10922, 'sol;': 47, 'squ;': 9633, 'sub;': 8834, 'sum;': 8721, sup1: 185, sup2: 178, sup3: 179, 'sup;': 8835, 'tau;': 964, 'tcy;': 1090, 'tfr;': 120113, 'top;': 8868, 'ucy;': 1091, 'ufr;': 120114, 'uml;': 168, uuml: 252, 'vcy;': 1074, 'vee;': 8744, 'vfr;': 120115, 'wfr;': 120116, 'xfr;': 120117, 'ycy;': 1099, 'yen;': 165, 'yfr;': 120118, yuml: 255, 'zcy;': 1079, 'zfr;': 120119, 'zwj;': 8205, AMP: 38, 'DD;': 8517, ETH: 208, 'GT;': 62, 'Gg;': 8921, 'Gt;': 8811, 'Im;': 8465, 'LT;': 60, 'Ll;': 8920, 'Lt;': 8810, 'Mu;': 924, 'Nu;': 925, 'Or;': 10836, 'Pi;': 928, 'Pr;': 10939, REG: 174, 'Re;': 8476, 'Sc;': 10940, 'Xi;': 926, 'ac;': 8766, 'af;': 8289, amp: 38, 'ap;': 8776, 'dd;': 8518, deg: 176, 'ee;': 8519, 'eg;': 10906, 'el;': 10905, eth: 240, 'gE;': 8807, 'ge;': 8805, 'gg;': 8811, 'gl;': 8823, 'gt;': 62, 'ic;': 8291, 'ii;': 8520, 'in;': 8712, 'it;': 8290, 'lE;': 8806, 'le;': 8804, 'lg;': 8822, 'll;': 8810, 'lt;': 60, 'mp;': 8723, 'mu;': 956, 'ne;': 8800, 'ni;': 8715, not: 172, 'nu;': 957, 'oS;': 9416, 'or;': 8744, 'pi;': 960, 'pm;': 177, 'pr;': 8826, reg: 174, 'rx;': 8478, 'sc;': 8827, shy: 173, uml: 168, 'wp;': 8472, 'wr;': 8768, 'xi;': 958, yen: 165, GT: 62, LT: 60, gt: 62, lt: 60 };
```

# compiler/phases/1-parse/utils/fuzzymatch.js

```js
/** * @param {string} name * @param {string[]} names * @returns {string | null} */ export default function fuzzymatch(name, names) { if (names.length === 0) return null; const set = new FuzzySet(names); const matches = set.get(name); return matches && matches[0][0] > 0.7 ? matches[0][1] : null; } // adapted from https://github.com/Glench/fuzzyset.js/blob/master/lib/fuzzyset.js in 2016 // BSD Licensed (see https://github.com/Glench/fuzzyset.js/issues/10) const GRAM_SIZE_LOWER = 2; const GRAM_SIZE_UPPER = 3; // return an edit distance from 0 to 1 /** * @param {string} str1 * @param {string} str2 */ function _distance(str1, str2) { if (str1 === null && str2 === null) { throw 'Trying to compare two null values'; } if (str1 === null || str2 === null) return 0; str1 = String(str1); str2 = String(str2); const distance = levenshtein(str1, str2); return 1 - distance / Math.max(str1.length, str2.length); } // helper functions /** * @param {string} str1 * @param {string} str2 */ function levenshtein(str1, str2) { /** @type {number[]} */ const current = []; let prev = 0; let value = 0; for (let i = 0; i <= str2.length; i++) { for (let j = 0; j <= str1.length; j++) { if (i && j) { if (str1.charAt(j - 1) === str2.charAt(i - 1)) { value = prev; } else { value = Math.min(current[j], current[j - 1], prev) + 1; } } else { value = i + j; } prev = current[j]; current[j] = value; } } return /** @type {number} */ (current.pop()); } const non_word_regex = /[^\w, ]+/; /** * @param {string} value * @param {any} gram_size */ function iterate_grams(value, gram_size = 2) { const simplified = '-' + value.toLowerCase().replace(non_word_regex, '') + '-'; const len_diff = gram_size - simplified.length; const results = []; if (len_diff > 0) { for (let i = 0; i < len_diff; ++i) { value += '-'; } } for (let i = 0; i < simplified.length - gram_size + 1; ++i) { results.push(simplified.slice(i, i + gram_size)); } return results; } /** * @param {string} value * @param {any} gram_size */ function gram_counter(value, gram_size = 2) { // return an object where key=gram, value=number of occurrences /** @type {Record<string, number>} */ const result = {}; const grams = iterate_grams(value, gram_size); let i = 0; for (i; i < grams.length; ++i) { if (grams[i] in result) { result[grams[i]] += 1; } else { result[grams[i]] = 1; } } return result; } /** * @param {MatchTuple} a * @param {MatchTuple} b */ function sort_descending(a, b) { return b[0] - a[0]; } class FuzzySet { /** @type {Record<string, string>} */ exact_set = {}; /** @type {Record<string, [number, number][]>} */ match_dict = {}; /** @type {Record<string, number[]>} */ items = {}; /** @param {string[]} arr */ constructor(arr) { // initialisation for (let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i) { this.items[i] = []; } // add all the items to the set for (let i = 0; i < arr.length; ++i) { this.add(arr[i]); } } /** @param {string} value */ add(value) { const normalized_value = value.toLowerCase(); if (normalized_value in this.exact_set) { return false; } let i = GRAM_SIZE_LOWER; for (i; i < GRAM_SIZE_UPPER + 1; ++i) { this._add(value, i); } } /** * @param {string} value * @param {number} gram_size */ _add(value, gram_size) { const normalized_value = value.toLowerCase(); const items = this.items[gram_size] || []; const index = items.length; items.push(0); const gram_counts = gram_counter(normalized_value, gram_size); let sum_of_square_gram_counts = 0; let gram; let gram_count; for (gram in gram_counts) { gram_count = gram_counts[gram]; sum_of_square_gram_counts += Math.pow(gram_count, 2); if (gram in this.match_dict) { this.match_dict[gram].push([index, gram_count]); } else { this.match_dict[gram] = [[index, gram_count]]; } } const vector_normal = Math.sqrt(sum_of_square_gram_counts); // @ts-ignore no idea what this code is doing items[index] = [vector_normal, normalized_value]; this.items[gram_size] = items; this.exact_set[normalized_value] = value; } /** @param {string} value */ get(value) { const normalized_value = value.toLowerCase(); const result = this.exact_set[normalized_value]; if (result) { return /** @type {MatchTuple[]} */ ([[1, result]]); } // start with high gram size and if there are no results, go to lower gram sizes for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) { const results = this.__get(value, gram_size); if (results.length > 0) return results; } return null; } /** * @param {string} value * @param {number} gram_size * @returns {MatchTuple[]} */ __get(value, gram_size) { const normalized_value = value.toLowerCase(); /** @type {Record<string, number>} */ const matches = {}; const gram_counts = gram_counter(normalized_value, gram_size); const items = this.items[gram_size]; let sum_of_square_gram_counts = 0; let gram; let gram_count; let i; let index; let other_gram_count; for (gram in gram_counts) { gram_count = gram_counts[gram]; sum_of_square_gram_counts += Math.pow(gram_count, 2); if (gram in this.match_dict) { for (i = 0; i < this.match_dict[gram].length; ++i) { index = this.match_dict[gram][i][0]; other_gram_count = this.match_dict[gram][i][1]; if (index in matches) { matches[index] += gram_count * other_gram_count; } else { matches[index] = gram_count * other_gram_count; } } } } const vector_normal = Math.sqrt(sum_of_square_gram_counts); /** @type {MatchTuple[]} */ let results = []; let match_score; // build a results list of [score, str] for (const match_index in matches) { match_score = matches[match_index]; // @ts-ignore no idea what this code is doing results.push([match_score / (vector_normal * items[match_index][0]), items[match_index][1]]); } results.sort(sort_descending); /** @type {MatchTuple[]} */ let new_results = []; const end_index = Math.min(50, results.length); // truncate somewhat arbitrarily to 50 for (let i = 0; i < end_index; ++i) { // @ts-ignore no idea what this code is doing new_results.push([_distance(results[i][1], normalized_value), results[i][1]]); } results = new_results; results.sort(sort_descending); new_results = []; for (let i = 0; i < results.length; ++i) { if (results[i][0] === results[0][0]) { // @ts-ignore no idea what this code is doing new_results.push([results[i][0], this.exact_set[results[i][1]]]); } } return new_results; } } /** @typedef {[score: number, match: string]} MatchTuple */
```

# compiler/phases/1-parse/utils/html.js

```js
import entities from './entities.js'; const windows_1252 = [ 8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376 ]; /** * @param {string} entity_name * @param {boolean} is_attribute_value */ function reg_exp_entity(entity_name, is_attribute_value) { // https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state // doesn't decode the html entity which not ends with ; and next character is =, number or alphabet in attribute value. if (is_attribute_value && !entity_name.endsWith(';')) { return `${entity_name}\\b(?!=)`; } return entity_name; } /** @param {boolean} is_attribute_value */ function get_entity_pattern(is_attribute_value) { const reg_exp_num = '#(?:x[a-fA-F\\d]+|\\d+)(?:;)?'; const reg_exp_entities = Object.keys(entities).map( /** @param {any} entity_name */ (entity_name) => reg_exp_entity(entity_name, is_attribute_value) ); const entity_pattern = new RegExp(`&(${reg_exp_num}|${reg_exp_entities.join('|')})`, 'g'); return entity_pattern; } const entity_pattern_content = get_entity_pattern(false); const entity_pattern_attr_value = get_entity_pattern(true); /** * @param {string} html * @param {boolean} is_attribute_value */ export function decode_character_references(html, is_attribute_value) { const entity_pattern = is_attribute_value ? entity_pattern_attr_value : entity_pattern_content; return html.replace( entity_pattern, /** * @param {any} match * @param {keyof typeof entities} entity */ (match, entity) => { let code; // Handle named entities if (entity[0] !== '#') { code = entities[entity]; } else if (entity[1] === 'x') { code = parseInt(entity.substring(2), 16); } else { code = parseInt(entity.substring(1), 10); } if (!code) { return match; } return String.fromCodePoint(validate_code(code)); } ); } const NUL = 0; // some code points are verboten. If we were inserting HTML, the browser would replace the illegal // code points with alternatives in some cases - since we're bypassing that mechanism, we need // to replace them ourselves // // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters // Also see: https://en.wikipedia.org/wiki/Plane_(Unicode) // Also see: https://html.spec.whatwg.org/multipage/parsing.html#preprocessing-the-input-stream /** @param {number} code */ function validate_code(code) { // line feed becomes generic whitespace if (code === 10) { return 32; } // ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...) if (code < 128) { return code; } // code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need // to correct the mistake or we'll end up with missing € signs and so on if (code <= 159) { return windows_1252[code - 128]; } // basic multilingual plane if (code < 55296) { return code; } // UTF-16 surrogate halves if (code <= 57343) { return NUL; } // rest of the basic multilingual plane if (code <= 65535) { return code; } // supplementary multilingual plane 0x10000 - 0x1ffff if (code >= 65536 && code <= 131071) { return code; } // supplementary ideographic plane 0x20000 - 0x2ffff if (code >= 131072 && code <= 196607) { return code; } // supplementary special-purpose plane 0xe0000 - 0xe07f and 0xe0100 - 0xe01ef if ((code >= 917504 && code <= 917631) || (code >= 917760 && code <= 917999)) { return code; } return NUL; }
```

# compiler/phases/2-analyze/css/css-analyze.js

```js
/** @import { ComponentAnalysis } from '../../types.js' */ /** @import { AST } from '#compiler' */ /** @import { Visitors } from 'zimmerframe' */ import { walk } from 'zimmerframe'; import * as e from '../../../errors.js'; import { is_keyframes_node } from '../../css.js'; import { is_global, is_unscoped_pseudo_class } from './utils.js'; /** * @typedef {{ * keyframes: string[]; * rule: AST.CSS.Rule | null; * analysis: ComponentAnalysis; * }} CssState */ /** * @typedef {Visitors<AST.CSS.Node, CssState>} CssVisitors */ /** * True if is `:global` * @param {AST.CSS.SimpleSelector} simple_selector */ function is_global_block_selector(simple_selector) { return ( simple_selector.type === 'PseudoClassSelector' && simple_selector.name === 'global' && simple_selector.args === null ); } /** * @param {AST.SvelteNode[]} path */ function is_unscoped(path) { return path .filter((node) => node.type === 'Rule') .every((node) => node.metadata.has_global_selectors); } /** * * @param {Array<AST.CSS.Node>} path */ function is_in_global_block(path) { return path.some((node) => node.type === 'Rule' && node.metadata.is_global_block); } /** @type {CssVisitors} */ const css_visitors = { Atrule(node, context) { if (is_keyframes_node(node)) { if (!node.prelude.startsWith('-global-') && !is_in_global_block(context.path)) { context.state.keyframes.push(node.prelude); } else if (node.prelude.startsWith('-global-')) { // we don't check if the block.children.length because the keyframe is still added even if empty context.state.analysis.css.has_global ||= is_unscoped(context.path); } } context.next(); }, ComplexSelector(node, context) { context.next(); // analyse relevant selectors first { const global = node.children.find(is_global); if (global) { const is_nested = context.path.at(-2)?.type === 'PseudoClassSelector'; if (is_nested && !global.selectors[0].args) { e.css_global_block_invalid_placement(global.selectors[0]); } const idx = node.children.indexOf(global); if (global.selectors[0].args !== null && idx !== 0 && idx !== node.children.length - 1) { // ensure `:global(...)` is not used in the middle of a selector (but multiple `global(...)` in sequence are ok) for (let i = idx + 1; i < node.children.length; i++) { if (!is_global(node.children[i])) { e.css_global_invalid_placement(global.selectors[0]); } } } } } // ensure `:global(...)` do not lead to invalid css after `:global()` is removed for (const relative_selector of node.children) { for (let i = 0; i < relative_selector.selectors.length; i++) { const selector = relative_selector.selectors[i]; if (selector.type === 'PseudoClassSelector' && selector.name === 'global') { const child = selector.args?.children[0].children[0]; // ensure `:global(element)` to be at the first position in a compound selector if (child?.selectors[0].type === 'TypeSelector' && i !== 0) { e.css_global_invalid_selector_list(selector); } // ensure `:global(.class)` is not followed by a type selector, eg: `:global(.class)element` if (relative_selector.selectors[i + 1]?.type === 'TypeSelector') { e.css_type_selector_invalid_placement(relative_selector.selectors[i + 1]); } // ensure `:global(...)`contains a single selector // (standalone :global() with multiple selectors is OK) if ( selector.args !== null && selector.args.children.length > 1 && (node.children.length > 1 || relative_selector.selectors.length > 1) ) { e.css_global_invalid_selector(selector); } } } } node.metadata.rule = context.state.rule; node.metadata.is_global = node.children.every( ({ metadata }) => metadata.is_global || metadata.is_global_like ); node.metadata.used ||= node.metadata.is_global; if ( node.metadata.rule?.metadata.parent_rule && node.children[0]?.selectors[0]?.type === 'NestingSelector' ) { const first = node.children[0]?.selectors[1]; const no_nesting_scope = first?.type !== 'PseudoClassSelector' || is_unscoped_pseudo_class(first); const parent_is_global = node.metadata.rule.metadata.parent_rule.prelude.children.some( (child) => child.children.length === 1 && child.children[0].metadata.is_global ); // mark `&:hover` in `:global(.foo) { &:hover { color: green }}` as used if (no_nesting_scope && parent_is_global) { node.metadata.used = true; } } }, RelativeSelector(node, context) { const parent = /** @type {AST.CSS.ComplexSelector} */ (context.path.at(-1)); if ( node.combinator != null && !context.state.rule?.metadata.parent_rule && parent.children[0] === node && context.path.at(-3)?.type !== 'PseudoClassSelector' ) { e.css_selector_invalid(node.combinator); } node.metadata.is_global = node.selectors.length >= 1 && is_global(node); if ( node.selectors.length >= 1 && node.selectors.every( (selector) => selector.type === 'PseudoClassSelector' || selector.type === 'PseudoElementSelector' ) ) { const first = node.selectors[0]; node.metadata.is_global_like ||= (first.type === 'PseudoClassSelector' && first.name === 'host') || (first.type === 'PseudoElementSelector' && [ 'view-transition', 'view-transition-group', 'view-transition-old', 'view-transition-new', 'view-transition-image-pair' ].includes(first.name)); } node.metadata.is_global_like ||= node.selectors.some( (child) => child.type === 'PseudoClassSelector' && child.name === 'root' ) && // :root.y:has(.x) is not a global selector because while .y is unscoped, .x inside `:has(...)` should be scoped !node.selectors.some((child) => child.type === 'PseudoClassSelector' && child.name === 'has'); if (node.metadata.is_global_like || node.metadata.is_global) { // So that nested selectors like `:root:not(.x)` are not marked as unused for (const child of node.selectors) { walk(/** @type {AST.CSS.Node} */ (child), null, { ComplexSelector(node, context) { node.metadata.used = true; context.next(); } }); } } context.next(); }, Rule(node, context) { node.metadata.parent_rule = context.state.rule; // We gotta allow :global x, :global y because CSS preprocessors might generate that from :global { x, y {...} } for (const complex_selector of node.prelude.children) { let is_global_block = false; for (let selector_idx = 0; selector_idx < complex_selector.children.length; selector_idx++) { const child = complex_selector.children[selector_idx]; const idx = child.selectors.findIndex(is_global_block_selector); if (is_global_block) { // All selectors after :global are unscoped child.metadata.is_global_like = true; } if (idx === 0) { if ( child.selectors.length > 1 && selector_idx === 0 && node.metadata.parent_rule === null ) { e.css_global_block_invalid_modifier_start(child.selectors[1]); } else { // `child` starts with `:global` node.metadata.is_global_block = is_global_block = true; for (let i = 1; i < child.selectors.length; i++) { walk(/** @type {AST.CSS.Node} */ (child.selectors[i]), null, { ComplexSelector(node) { node.metadata.used = true; } }); } if (child.combinator && child.combinator.name !== ' ') { e.css_global_block_invalid_combinator(child, child.combinator.name); } const declaration = node.block.children.find((child) => child.type === 'Declaration'); const is_lone_global = complex_selector.children.length === 1 && complex_selector.children[0].selectors.length === 1; // just `:global`, not e.g. `:global x` if (is_lone_global && node.prelude.children.length > 1) { // `:global, :global x { z { ... } }` would become `x { z { ... } }` which means `z` is always // constrained by `x`, which is not what the user intended e.css_global_block_invalid_list(node.prelude); } if ( declaration && // :global { color: red; } is invalid, but foo :global { color: red; } is valid node.prelude.children.length === 1 && is_lone_global ) { e.css_global_block_invalid_declaration(declaration); } } } else if (idx !== -1) { e.css_global_block_invalid_modifier(child.selectors[idx]); } } if (node.metadata.is_global_block && !is_global_block) { e.css_global_block_invalid_list(node.prelude); } } const state = { ...context.state, rule: node }; // visit selector list first, to populate child selector metadata context.visit(node.prelude, state); for (const selector of node.prelude.children) { node.metadata.has_global_selectors ||= selector.metadata.is_global; node.metadata.has_local_selectors ||= !selector.metadata.is_global; } // if this rule has a ComplexSelector whose RelativeSelector children are all // `:global(...)`, and the rule contains declarations (rather than just // nested rules) then the component as a whole includes global CSS context.state.analysis.css.has_global ||= node.metadata.has_global_selectors && node.block.children.filter((child) => child.type === 'Declaration').length > 0 && is_unscoped(context.path); // visit block list, so parent rule metadata is populated context.visit(node.block, state); }, NestingSelector(node, context) { const rule = /** @type {AST.CSS.Rule} */ (context.state.rule); const parent_rule = rule.metadata.parent_rule; if (!parent_rule) { // https://developer.mozilla.org/en-US/docs/Web/CSS/Nesting_selector#using_outside_nested_rule const children = rule.prelude.children; const selectors = children[0].children[0].selectors; if ( children.length > 1 || selectors.length > 1 || selectors[0].type !== 'PseudoClassSelector' || selectors[0].name !== 'global' || selectors[0].args?.children[0]?.children[0].selectors[0] !== node ) { e.css_nesting_selector_invalid_placement(node); } } else if ( // :global { &.foo { ... } } is invalid parent_rule.metadata.is_global_block && !parent_rule.metadata.parent_rule && parent_rule.prelude.children[0].children.length === 1 && parent_rule.prelude.children[0].children[0].selectors.length === 1 ) { e.css_global_block_invalid_modifier_start(node); } context.next(); } }; /** * @param {AST.CSS.StyleSheet} stylesheet * @param {ComponentAnalysis} analysis */ export function analyze_css(stylesheet, analysis) { /** @type {CssState} */ const css_state = { keyframes: analysis.css.keyframes, rule: null, analysis }; walk(stylesheet, css_state, css_visitors); }
```

# compiler/phases/2-analyze/css/css-prune.js

```js
/** @import * as Compiler from '#compiler' */ import { walk } from 'zimmerframe'; import { get_parent_rules, get_possible_values, is_outer_global, is_unscoped_pseudo_class } from './utils.js'; import { regex_ends_with_whitespace, regex_starts_with_whitespace } from '../../patterns.js'; import { get_attribute_chunks, is_text_attribute } from '../../../utils/ast.js'; /** @typedef {NODE_PROBABLY_EXISTS | NODE_DEFINITELY_EXISTS} NodeExistsValue */ /** @typedef {FORWARD | BACKWARD} Direction */ const NODE_PROBABLY_EXISTS = 0; const NODE_DEFINITELY_EXISTS = 1; const FORWARD = 0; const BACKWARD = 1; const whitelist_attribute_selector = new Map([ ['details', ['open']], ['dialog', ['open']] ]); /** @type {Compiler.AST.CSS.Combinator} */ const descendant_combinator = { type: 'Combinator', name: ' ', start: -1, end: -1 }; /** @type {Compiler.AST.CSS.RelativeSelector} */ const nesting_selector = { type: 'RelativeSelector', start: -1, end: -1, combinator: null, selectors: [ { type: 'NestingSelector', name: '&', start: -1, end: -1 } ], metadata: { is_global: false, is_global_like: false, scoped: false } }; /** @type {Compiler.AST.CSS.RelativeSelector} */ const any_selector = { type: 'RelativeSelector', start: -1, end: -1, combinator: null, selectors: [ { type: 'TypeSelector', name: '*', start: -1, end: -1 } ], metadata: { is_global: false, is_global_like: false, scoped: false } }; /** * Snippets encountered already (avoids infinite loops) * @type {Set<Compiler.AST.SnippetBlock>} */ const seen = new Set(); /** * * @param {Compiler.AST.CSS.StyleSheet} stylesheet * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement} element */ export function prune(stylesheet, element) { walk(/** @type {Compiler.AST.CSS.Node} */ (stylesheet), null, { Rule(node, context) { if (node.metadata.is_global_block) { context.visit(node.prelude); } else { context.next(); } }, ComplexSelector(node) { const selectors = get_relative_selectors(node); seen.clear(); if ( apply_selector( selectors, /** @type {Compiler.AST.CSS.Rule} */ (node.metadata.rule), element, BACKWARD ) ) { node.metadata.used = true; } // note: we don't call context.next() here, we only recurse into // selectors that don't belong to rules (i.e. inside `:is(...)` etc) // when we encounter them below } }); } /** * Retrieves the relative selectors (minus the trailing globals) from a complex selector. * Also searches them for any existing `&` selectors and adds one if none are found. * This ensures we traverse up to the parent rule when the inner selectors match and we're * trying to see if the parent rule also matches. * @param {Compiler.AST.CSS.ComplexSelector} node */ function get_relative_selectors(node) { const selectors = truncate(node); if (node.metadata.rule?.metadata.parent_rule && selectors.length > 0) { let has_explicit_nesting_selector = false; // nesting could be inside pseudo classes like :is, :has or :where for (let selector of selectors) { walk(selector, null, { // @ts-ignore NestingSelector() { has_explicit_nesting_selector = true; } }); // if we found one we can break from the others if (has_explicit_nesting_selector) break; } if (!has_explicit_nesting_selector) { if (selectors[0].combinator === null) { selectors[0] = { ...selectors[0], combinator: descendant_combinator }; } selectors.unshift(nesting_selector); } } return selectors; } /** * Discard trailing `:global(...)` selectors, these are unused for scoping purposes * @param {Compiler.AST.CSS.ComplexSelector} node */ function truncate(node) { const i = node.children.findLastIndex(({ metadata, selectors }) => { const first = selectors[0]; return ( // not after a :global selector !metadata.is_global_like && !(first.type === 'PseudoClassSelector' && first.name === 'global' && first.args === null) && // not a :global(...) without a :has/is/where(...) modifier that is scoped !metadata.is_global ); }); return node.children.slice(0, i + 1).map((child) => { // In case of `:root.y:has(...)`, `y` is unscoped, but everything in `:has(...)` should be scoped (if not global). // To properly accomplish that, we gotta filter out all selector types except `:has`. const root = child.selectors.find((s) => s.type === 'PseudoClassSelector' && s.name === 'root'); if (!root || child.metadata.is_global_like) return child; return { ...child, selectors: child.selectors.filter((s) => s.type === 'PseudoClassSelector' && s.name === 'has') }; }); } /** * @param {Compiler.AST.CSS.RelativeSelector[]} relative_selectors * @param {Compiler.AST.CSS.Rule} rule * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement} element * @param {Direction} direction * @returns {boolean} */ function apply_selector(relative_selectors, rule, element, direction) { const rest_selectors = relative_selectors.slice(); const relative_selector = direction === FORWARD ? rest_selectors.shift() : rest_selectors.pop(); const matched = !!relative_selector && relative_selector_might_apply_to_node(relative_selector, rule, element, direction) && apply_combinator(relative_selector, rest_selectors, rule, element, direction); if (matched) { if (!is_outer_global(relative_selector)) { relative_selector.metadata.scoped = true; } element.metadata.scoped = true; } return matched; } /** * @param {Compiler.AST.CSS.RelativeSelector} relative_selector * @param {Compiler.AST.CSS.RelativeSelector[]} rest_selectors * @param {Compiler.AST.CSS.Rule} rule * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement | Compiler.AST.RenderTag | Compiler.AST.Component | Compiler.AST.SvelteComponent | Compiler.AST.SvelteSelf} node * @param {Direction} direction * @returns {boolean} */ function apply_combinator(relative_selector, rest_selectors, rule, node, direction) { const combinator = direction == FORWARD ? rest_selectors[0]?.combinator : relative_selector.combinator; if (!combinator) return true; switch (combinator.name) { case ' ': case '>': { const is_adjacent = combinator.name === '>'; const parents = direction === FORWARD ? get_descendant_elements(node, is_adjacent) : get_ancestor_elements(node, is_adjacent); let parent_matched = false; for (const parent of parents) { if (apply_selector(rest_selectors, rule, parent, direction)) { parent_matched = true; } } return ( parent_matched || (direction === BACKWARD && (!is_adjacent || parents.length === 0) && rest_selectors.every((selector) => is_global(selector, rule))) ); } case '+': case '~': { const siblings = get_possible_element_siblings(node, direction, combinator.name === '+'); let sibling_matched = false; for (const possible_sibling of siblings.keys()) { if ( possible_sibling.type === 'RenderTag' || possible_sibling.type === 'SlotElement' || possible_sibling.type === 'Component' ) { // `{@render foo()}<p>foo</p>` with `:global(.x) + p` is a match if (rest_selectors.length === 1 && rest_selectors[0].metadata.is_global) { sibling_matched = true; } } else if (apply_selector(rest_selectors, rule, possible_sibling, direction)) { sibling_matched = true; } } return ( sibling_matched || (direction === BACKWARD && get_element_parent(node) === null && rest_selectors.every((selector) => is_global(selector, rule))) ); } default: // TODO other combinators return true; } } /** * Returns `true` if the relative selector is global, meaning * it's a `:global(...)` or unscopeable selector, or * is an `:is(...)` or `:where(...)` selector that contains * a global selector * @param {Compiler.AST.CSS.RelativeSelector} selector * @param {Compiler.AST.CSS.Rule} rule * @returns {boolean} */ function is_global(selector, rule) { if (selector.metadata.is_global || selector.metadata.is_global_like) { return true; } let explicitly_global = false; for (const s of selector.selectors) { /** @type {Compiler.AST.CSS.SelectorList | null} */ let selector_list = null; let can_be_global = false; let owner = rule; if (s.type === 'PseudoClassSelector') { if ((s.name === 'is' || s.name === 'where') && s.args) { selector_list = s.args; } else { can_be_global = is_unscoped_pseudo_class(s); } } if (s.type === 'NestingSelector') { owner = /** @type {Compiler.AST.CSS.Rule} */ (rule.metadata.parent_rule); selector_list = owner.prelude; } const has_global_selectors = !!selector_list?.children.some((complex_selector) => { return complex_selector.children.every((relative_selector) => is_global(relative_selector, owner) ); }); explicitly_global ||= has_global_selectors; if (!has_global_selectors && !can_be_global) { return false; } } return explicitly_global || selector.selectors.length === 0; } const regex_backslash_and_following_character = /\\(.)/g; /** * Ensure that `element` satisfies each simple selector in `relative_selector` * * @param {Compiler.AST.CSS.RelativeSelector} relative_selector * @param {Compiler.AST.CSS.Rule} rule * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement} element * @param {Direction} direction * @returns {boolean} */ function relative_selector_might_apply_to_node(relative_selector, rule, element, direction) { // Sort :has(...) selectors in one bucket and everything else into another const has_selectors = []; const other_selectors = []; for (const selector of relative_selector.selectors) { if (selector.type === 'PseudoClassSelector' && selector.name === 'has' && selector.args) { has_selectors.push(selector); } else { other_selectors.push(selector); } } // If we're called recursively from a :has(...) selector, we're on the way of checking if the other selectors match. // In that case ignore this check (because we just came from this) to avoid an infinite loop. if (has_selectors.length > 0) { // If this is a :has inside a global selector, we gotta include the element itself, too, // because the global selector might be for an element that's outside the component, // e.g. :root:has(.scoped), :global(.foo):has(.scoped), or :root { &:has(.scoped) {} } const rules = get_parent_rules(rule); const include_self = rules.some((r) => r.prelude.children.some((c) => c.children.some((s) => is_global(s, r)))) || rules[rules.length - 1].prelude.children.some((c) => c.children.some((r) => r.selectors.some( (s) => s.type === 'PseudoClassSelector' && (s.name === 'root' || (s.name === 'global' && s.args)) ) ) ); // :has(...) is special in that it means "look downwards in the CSS tree". Since our matching algorithm goes // upwards and back-to-front, we need to first check the selectors inside :has(...), then check the rest of the // selector in a way that is similar to ancestor matching. In a sense, we're treating `.x:has(.y)` as `.x .y`. for (const has_selector of has_selectors) { const complex_selectors = /** @type {Compiler.AST.CSS.SelectorList} */ (has_selector.args) .children; let matched = false; for (const complex_selector of complex_selectors) { const [first, ...rest] = truncate(complex_selector); // if it was just a :global(...) if (!first) { complex_selector.metadata.used = true; matched = true; continue; } if (include_self) { const selector_including_self = [ first.combinator ? { ...first, combinator: null } : first, ...rest ]; if (apply_selector(selector_including_self, rule, element, FORWARD)) { complex_selector.metadata.used = true; matched = true; } } const selector_excluding_self = [ any_selector, first.combinator ? first : { ...first, combinator: descendant_combinator }, ...rest ]; if (apply_selector(selector_excluding_self, rule, element, FORWARD)) { complex_selector.metadata.used = true; matched = true; } } if (!matched) { return false; } } } for (const selector of other_selectors) { if (selector.type === 'Percentage' || selector.type === 'Nth') continue; const name = selector.name.replace(regex_backslash_and_following_character, '$1'); switch (selector.type) { case 'PseudoClassSelector': { if (name === 'host' || name === 'root') return false; if ( name === 'global' && selector.args !== null && relative_selector.selectors.length === 1 ) { const args = selector.args; const complex_selector = args.children[0]; return apply_selector(complex_selector.children, rule, element, BACKWARD); } // We came across a :global, everything beyond it is global and therefore a potential match if (name === 'global' && selector.args === null) return true; // :not(...) contents should stay unscoped. Scoping them would achieve the opposite of what we want, // because they are then _more_ likely to bleed out of the component. The exception is complex selectors // with descendants, in which case we scope them all. if (name === 'not' && selector.args) { for (const complex_selector of selector.args.children) { walk(complex_selector, null, { ComplexSelector(node, context) { node.metadata.used = true; context.next(); } }); const relative = truncate(complex_selector); if (complex_selector.children.length > 1) { // foo:not(bar foo) means that bar is an ancestor of foo (side note: ending with foo is the only way the selector make sense). // We can't fully check if that actually matches with our current algorithm, so we just assume it does. // The result may not match a real element, so the only drawback is the missing prune. for (const selector of relative) { selector.metadata.scoped = true; } /** @type {Compiler.AST.RegularElement | Compiler.AST.SvelteElement | null} */ let el = element; while (el) { el.metadata.scoped = true; el = get_element_parent(el); } } } break; } if ((name === 'is' || name === 'where') && selector.args) { let matched = false; for (const complex_selector of selector.args.children) { const relative = truncate(complex_selector); const is_global = relative.length === 0; if (is_global) { complex_selector.metadata.used = true; matched = true; } else if (apply_selector(relative, rule, element, BACKWARD)) { complex_selector.metadata.used = true; matched = true; } else if (complex_selector.children.length > 1 && (name == 'is' || name == 'where')) { // foo :is(bar baz) can also mean that bar is an ancestor of foo, and baz a descendant. // We can't fully check if that actually matches with our current algorithm, so we just assume it does. // The result may not match a real element, so the only drawback is the missing prune. complex_selector.metadata.used = true; matched = true; for (const selector of relative) { selector.metadata.scoped = true; } } } if (!matched) { return false; } } break; } case 'PseudoElementSelector': { break; } case 'AttributeSelector': { const whitelisted = whitelist_attribute_selector.get(element.name.toLowerCase()); if ( !whitelisted?.includes(selector.name.toLowerCase()) && !attribute_matches( element, selector.name, selector.value && unquote(selector.value), selector.matcher, selector.flags?.includes('i') ?? false ) ) { return false; } break; } case 'ClassSelector': { if (!attribute_matches(element, 'class', name, '~=', false)) { return false; } break; } case 'IdSelector': { if (!attribute_matches(element, 'id', name, '=', false)) { return false; } break; } case 'TypeSelector': { if ( element.name.toLowerCase() !== name.toLowerCase() && name !== '*' && element.type !== 'SvelteElement' ) { return false; } break; } case 'NestingSelector': { let matched = false; const parent = /** @type {Compiler.AST.CSS.Rule} */ (rule.metadata.parent_rule); for (const complex_selector of parent.prelude.children) { if ( apply_selector(get_relative_selectors(complex_selector), parent, element, direction) || complex_selector.children.every((s) => is_global(s, parent)) ) { complex_selector.metadata.used = true; matched = true; } } if (!matched) { return false; } break; } } } // possible match return true; } /** * @param {any} operator * @param {any} expected_value * @param {any} case_insensitive * @param {any} value */ function test_attribute(operator, expected_value, case_insensitive, value) { if (case_insensitive) { expected_value = expected_value.toLowerCase(); value = value.toLowerCase(); } switch (operator) { case '=': return value === expected_value; case '~=': return value.split(/\s/).includes(expected_value); case '|=': return `${value}-`.startsWith(`${expected_value}-`); case '^=': return value.startsWith(expected_value); case '$=': return value.endsWith(expected_value); case '*=': return value.includes(expected_value); default: throw new Error("this shouldn't happen"); } } /** * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement} node * @param {string} name * @param {string | null} expected_value * @param {string | null} operator * @param {boolean} case_insensitive */ function attribute_matches(node, name, expected_value, operator, case_insensitive) { for (const attribute of node.attributes) { if (attribute.type === 'SpreadAttribute') return true; if (attribute.type === 'BindDirective' && attribute.name === name) return true; const name_lower = name.toLowerCase(); // match attributes against the corresponding directive but bail out on exact matching if (attribute.type === 'StyleDirective' && name_lower === 'style') return true; if (attribute.type === 'ClassDirective' && name_lower === 'class') { if (operator === '~=') { if (attribute.name === expected_value) return true; } else { return true; } } if (attribute.type !== 'Attribute') continue; if (attribute.name.toLowerCase() !== name_lower) continue; if (attribute.value === true) return operator === null; if (expected_value === null) return true; if (is_text_attribute(attribute)) { const matches = test_attribute( operator, expected_value, case_insensitive, attribute.value[0].data ); // continue if we still may match against a class/style directive if (!matches && (name_lower === 'class' || name_lower === 'style')) continue; return matches; } const chunks = get_attribute_chunks(attribute.value); const possible_values = new Set(); /** @type {string[]} */ let prev_values = []; for (const chunk of chunks) { const current_possible_values = get_possible_values(chunk, name_lower === 'class'); // impossible to find out all combinations if (!current_possible_values) return true; if (prev_values.length > 0) { /** @type {string[]} */ const start_with_space = []; /** @type {string[]} */ const remaining = []; current_possible_values.forEach((current_possible_value) => { if (regex_starts_with_whitespace.test(current_possible_value)) { start_with_space.push(current_possible_value); } else { remaining.push(current_possible_value); } }); if (remaining.length > 0) { if (start_with_space.length > 0) { prev_values.forEach((prev_value) => possible_values.add(prev_value)); } /** @type {string[]} */ const combined = []; prev_values.forEach((prev_value) => { remaining.forEach((value) => { combined.push(prev_value + value); }); }); prev_values = combined; start_with_space.forEach((value) => { if (regex_ends_with_whitespace.test(value)) { possible_values.add(value); } else { prev_values.push(value); } }); continue; } else { prev_values.forEach((prev_value) => possible_values.add(prev_value)); prev_values = []; } } current_possible_values.forEach((current_possible_value) => { if (regex_ends_with_whitespace.test(current_possible_value)) { possible_values.add(current_possible_value); } else { prev_values.push(current_possible_value); } }); if (prev_values.length < current_possible_values.length) { prev_values.push(' '); } if (prev_values.length > 20) { // might grow exponentially, bail out return true; } } prev_values.forEach((prev_value) => possible_values.add(prev_value)); for (const value of possible_values) { if (test_attribute(operator, expected_value, case_insensitive, value)) return true; } } return false; } /** @param {string} str */ function unquote(str) { if ((str[0] === str[str.length - 1] && str[0] === "'") || str[0] === '"') { return str.slice(1, str.length - 1); } return str; } /** * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement | Compiler.AST.RenderTag | Compiler.AST.Component | Compiler.AST.SvelteComponent | Compiler.AST.SvelteSelf} node * @param {boolean} adjacent_only * @param {Set<Compiler.AST.SnippetBlock>} seen */ function get_ancestor_elements(node, adjacent_only, seen = new Set()) { /** @type {Array<Compiler.AST.RegularElement | Compiler.AST.SvelteElement>} */ const ancestors = []; const path = node.metadata.path; let i = path.length; while (i--) { const parent = path[i]; if (parent.type === 'SnippetBlock') { if (!seen.has(parent)) { seen.add(parent); for (const site of parent.metadata.sites) { ancestors.push(...get_ancestor_elements(site, adjacent_only, seen)); } } break; } if (parent.type === 'RegularElement' || parent.type === 'SvelteElement') { ancestors.push(parent); if (adjacent_only) { break; } } } return ancestors; } /** * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement | Compiler.AST.RenderTag | Compiler.AST.Component | Compiler.AST.SvelteComponent | Compiler.AST.SvelteSelf} node * @param {boolean} adjacent_only * @param {Set<Compiler.AST.SnippetBlock>} seen */ function get_descendant_elements(node, adjacent_only, seen = new Set()) { /** @type {Array<Compiler.AST.RegularElement | Compiler.AST.SvelteElement>} */ const descendants = []; /** * @param {Compiler.AST.SvelteNode} node */ function walk_children(node) { walk(node, null, { _(node, context) { if (node.type === 'RegularElement' || node.type === 'SvelteElement') { descendants.push(node); if (!adjacent_only) { context.next(); } } else if (node.type === 'RenderTag') { for (const snippet of node.metadata.snippets) { if (seen.has(snippet)) continue; seen.add(snippet); walk_children(snippet.body); } } else { context.next(); } } }); } walk_children(node.type === 'RenderTag' ? node : node.fragment); return descendants; } /** * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement | Compiler.AST.RenderTag | Compiler.AST.Component | Compiler.AST.SvelteComponent | Compiler.AST.SvelteSelf} node * @returns {Compiler.AST.RegularElement | Compiler.AST.SvelteElement | null} */ function get_element_parent(node) { let path = node.metadata.path; let i = path.length; while (i--) { const parent = path[i]; if (parent.type === 'RegularElement' || parent.type === 'SvelteElement') { return parent; } } return null; } /** * @param {Compiler.AST.RegularElement | Compiler.AST.SvelteElement | Compiler.AST.RenderTag | Compiler.AST.Component | Compiler.AST.SvelteComponent | Compiler.AST.SvelteSelf} node * @param {Direction} direction * @param {boolean} adjacent_only * @param {Set<Compiler.AST.SnippetBlock>} seen * @returns {Map<Compiler.AST.RegularElement | Compiler.AST.SvelteElement | Compiler.AST.SlotElement | Compiler.AST.RenderTag | Compiler.AST.Component, NodeExistsValue>} */ function get_possible_element_siblings(node, direction, adjacent_only, seen = new Set()) { /** @type {Map<Compiler.AST.RegularElement | Compiler.AST.SvelteElement | Compiler.AST.SlotElement | Compiler.AST.RenderTag | Compiler.AST.Component, NodeExistsValue>} */ const result = new Map(); const path = node.metadata.path; /** @type {Compiler.AST.SvelteNode} */ let current = node; let i = path.length; while (i--) { const fragment = /** @type {Compiler.AST.Fragment} */ (path[i--]); let j = fragment.nodes.indexOf(current) + (direction === FORWARD ? 1 : -1); while (j >= 0 && j < fragment.nodes.length) { const node = fragment.nodes[j]; if (node.type === 'RegularElement') { const has_slot_attribute = node.attributes.some( (attr) => attr.type === 'Attribute' && attr.name.toLowerCase() === 'slot' ); if (!has_slot_attribute) { result.set(node, NODE_DEFINITELY_EXISTS); if (adjacent_only) { return result; } } // Special case: slots, render tags and svelte:element tags could resolve to no siblings, // so we want to continue until we find a definite sibling even with the adjacent-only combinator } else if (is_block(node) || node.type === 'Component') { if (node.type === 'SlotElement' || node.type === 'Component') { result.set(node, NODE_PROBABLY_EXISTS); } const possible_last_child = get_possible_nested_siblings(node, direction, adjacent_only); add_to_map(possible_last_child, result); if ( adjacent_only && node.type !== 'Component' && has_definite_elements(possible_last_child) ) { return result; } } else if (node.type === 'SvelteElement') { result.set(node, NODE_PROBABLY_EXISTS); } else if (node.type === 'RenderTag') { result.set(node, NODE_PROBABLY_EXISTS); for (const snippet of node.metadata.snippets) { add_to_map(get_possible_nested_siblings(snippet, direction, adjacent_only), result); } } j = direction === FORWARD ? j + 1 : j - 1; } current = path[i]; if (!current) break; if ( current.type === 'Component' || current.type === 'SvelteComponent' || current.type === 'SvelteSelf' ) { continue; } if (current.type === 'SnippetBlock') { if (seen.has(current)) break; seen.add(current); for (const site of current.metadata.sites) { const siblings = get_possible_element_siblings(site, direction, adjacent_only, seen); add_to_map(siblings, result); if (adjacent_only && current.metadata.sites.size === 1 && has_definite_elements(siblings)) { return result; } } } if (!is_block(current)) break; if (current.type === 'EachBlock' && fragment === current.body) { // `{#each ...}<a /><b />{/each}` — `<b>` can be previous sibling of `<a />` add_to_map(get_possible_nested_siblings(current, direction, adjacent_only), result); } } return result; } /** * @param {Compiler.AST.EachBlock | Compiler.AST.IfBlock | Compiler.AST.AwaitBlock | Compiler.AST.KeyBlock | Compiler.AST.SlotElement | Compiler.AST.SnippetBlock | Compiler.AST.Component} node * @param {Direction} direction * @param {boolean} adjacent_only * @param {Set<Compiler.AST.SnippetBlock>} seen * @returns {Map<Compiler.AST.RegularElement | Compiler.AST.SvelteElement, NodeExistsValue>} */ function get_possible_nested_siblings(node, direction, adjacent_only, seen = new Set()) { /** @type {Array<Compiler.AST.Fragment | undefined | null>} */ let fragments = []; switch (node.type) { case 'EachBlock': fragments.push(node.body, node.fallback); break; case 'IfBlock': fragments.push(node.consequent, node.alternate); break; case 'AwaitBlock': fragments.push(node.pending, node.then, node.catch); break; case 'KeyBlock': case 'SlotElement': fragments.push(node.fragment); break; case 'SnippetBlock': if (seen.has(node)) { return new Map(); } seen.add(node); fragments.push(node.body); break; case 'Component': fragments.push(node.fragment, ...[...node.metadata.snippets].map((s) => s.body)); break; } /** @type {Map<Compiler.AST.RegularElement | Compiler.AST.SvelteElement, NodeExistsValue>} NodeMap */ const result = new Map(); let exhaustive = node.type !== 'SlotElement' && node.type !== 'SnippetBlock'; for (const fragment of fragments) { if (fragment == null) { exhaustive = false; continue; } const map = loop_child(fragment.nodes, direction, adjacent_only, seen); exhaustive &&= has_definite_elements(map); add_to_map(map, result); } if (!exhaustive) { for (const key of result.keys()) { result.set(key, NODE_PROBABLY_EXISTS); } } return result; } /** * @param {Map<unknown, NodeExistsValue>} result * @returns {boolean} */ function has_definite_elements(result) { if (result.size === 0) return false; for (const exist of result.values()) { if (exist === NODE_DEFINITELY_EXISTS) { return true; } } return false; } /** * @template T2 * @template {T2} T1 * @param {Map<T1, NodeExistsValue>} from * @param {Map<T2, NodeExistsValue>} to * @returns {void} */ function add_to_map(from, to) { from.forEach((exist, element) => { to.set(element, higher_existence(exist, to.get(element))); }); } /** * @param {NodeExistsValue} exist1 * @param {NodeExistsValue | undefined} exist2 * @returns {NodeExistsValue} */ function higher_existence(exist1, exist2) { if (exist2 === undefined) return exist1; return exist1 > exist2 ? exist1 : exist2; } /** * @param {Compiler.AST.SvelteNode[]} children * @param {Direction} direction * @param {boolean} adjacent_only * @param {Set<Compiler.AST.SnippetBlock>} seen */ function loop_child(children, direction, adjacent_only, seen) { /** @type {Map<Compiler.AST.RegularElement | Compiler.AST.SvelteElement, NodeExistsValue>} */ const result = new Map(); let i = direction === FORWARD ? 0 : children.length - 1; while (i >= 0 && i < children.length) { const child = children[i]; if (child.type === 'RegularElement') { result.set(child, NODE_DEFINITELY_EXISTS); if (adjacent_only) { break; } } else if (child.type === 'SvelteElement') { result.set(child, NODE_PROBABLY_EXISTS); } else if (child.type === 'RenderTag') { for (const snippet of child.metadata.snippets) { add_to_map(get_possible_nested_siblings(snippet, direction, adjacent_only, seen), result); } } else if (is_block(child)) { const child_result = get_possible_nested_siblings(child, direction, adjacent_only, seen); add_to_map(child_result, result); if (adjacent_only && has_definite_elements(child_result)) { break; } } i = direction === FORWARD ? i + 1 : i - 1; } return result; } /** * @param {Compiler.AST.SvelteNode} node * @returns {node is Compiler.AST.IfBlock | Compiler.AST.EachBlock | Compiler.AST.AwaitBlock | Compiler.AST.KeyBlock | Compiler.AST.SlotElement} */ function is_block(node) { return ( node.type === 'IfBlock' || node.type === 'EachBlock' || node.type === 'AwaitBlock' || node.type === 'KeyBlock' || node.type === 'SlotElement' ); }
```

# compiler/phases/2-analyze/css/css-warn.js

```js
/** @import { Visitors } from 'zimmerframe' */ /** @import { AST } from '#compiler' */ import { walk } from 'zimmerframe'; import * as w from '../../../warnings.js'; import { is_keyframes_node } from '../../css.js'; /** * @param {AST.CSS.StyleSheet} stylesheet */ export function warn_unused(stylesheet) { walk(stylesheet, { stylesheet }, visitors); } /** @type {Visitors<AST.CSS.Node, { stylesheet: AST.CSS.StyleSheet }>} */ const visitors = { Atrule(node, context) { if (!is_keyframes_node(node)) { context.next(); } }, PseudoClassSelector(node, context) { if (node.name === 'is' || node.name === 'where') { context.next(); } }, ComplexSelector(node, context) { if ( !node.metadata.used && // prevent double-marking of `.unused:is(.unused)` (context.path.at(-2)?.type !== 'PseudoClassSelector' || /** @type {AST.CSS.ComplexSelector} */ (context.path.at(-4))?.metadata.used) ) { const content = context.state.stylesheet.content; const text = content.styles.substring(node.start - content.start, node.end - content.start); w.css_unused_selector(node, text); } context.next(); }, Rule(node, context) { if (node.metadata.is_global_block) { context.visit(node.prelude); } else { context.next(); } } };
```

# compiler/phases/2-analyze/css/utils.js

```js
/** @import { AST } from '#compiler' */ /** @import { Node } from 'estree' */ const UNKNOWN = {}; /** * @param {Node} node * @param {boolean} is_class * @param {Set<any>} set * @param {boolean} is_nested */ function gather_possible_values(node, is_class, set, is_nested = false) { if (set.has(UNKNOWN)) { // no point traversing any further return; } if (node.type === 'Literal') { set.add(String(node.value)); } else if (node.type === 'ConditionalExpression') { gather_possible_values(node.consequent, is_class, set, is_nested); gather_possible_values(node.alternate, is_class, set, is_nested); } else if (node.type === 'LogicalExpression') { if (node.operator === '&&') { // && is a special case, because the only way the left // hand value can be included is if it's falsy. this is // a bit of extra work but it's worth it because // `class={[condition && 'blah']}` is common, // and we don't want to deopt on `condition` const left = new Set(); gather_possible_values(node.left, is_class, left, is_nested); if (left.has(UNKNOWN)) { // add all non-nullish falsy values, unless this is a `class` attribute that // will be processed by cslx, in which case falsy values are removed, unless // they're not inside an array/object (TODO 6.0 remove that last part) if (!is_class || !is_nested) { set.add(''); set.add(false); set.add(NaN); set.add(0); // -0 and 0n are also falsy, but stringify to '0' } } else { for (const value of left) { if (!value && value != undefined && (!is_class || !is_nested)) { set.add(value); } } } gather_possible_values(node.right, is_class, set, is_nested); } else { gather_possible_values(node.left, is_class, set, is_nested); gather_possible_values(node.right, is_class, set, is_nested); } } else if (is_class && node.type === 'ArrayExpression') { for (const entry of node.elements) { if (entry) { gather_possible_values(entry, is_class, set, true); } } } else if (is_class && node.type === 'ObjectExpression') { for (const property of node.properties) { if ( property.type === 'Property' && !property.computed && (property.key.type === 'Identifier' || property.key.type === 'Literal') ) { set.add( property.key.type === 'Identifier' ? property.key.name : String(property.key.value) ); } else { set.add(UNKNOWN); } } } else { set.add(UNKNOWN); } } /** * @param {AST.Text | AST.ExpressionTag} chunk * @param {boolean} is_class * @returns {string[] | null} */ export function get_possible_values(chunk, is_class) { const values = new Set(); if (chunk.type === 'Text') { values.add(chunk.data); } else { gather_possible_values(chunk.expression, is_class, values); } if (values.has(UNKNOWN)) return null; return [...values].map((value) => String(value)); } /** * Returns all parent rules; root is last * @param {AST.CSS.Rule | null} rule */ export function get_parent_rules(rule) { const rules = []; while (rule) { rules.push(rule); rule = rule.metadata.parent_rule; } return rules; } /** * True if is `:global(...)` or `:global` and no pseudo class that is scoped. * @param {AST.CSS.RelativeSelector} relative_selector * @returns {relative_selector is AST.CSS.RelativeSelector & { selectors: [AST.CSS.PseudoClassSelector, ...Array<AST.CSS.PseudoClassSelector | AST.CSS.PseudoElementSelector>] }} */ export function is_global(relative_selector) { const first = relative_selector.selectors[0]; return ( first.type === 'PseudoClassSelector' && first.name === 'global' && (first.args === null || // Only these two selector types keep the whole selector global, because e.g. // :global(button).x means that the selector is still scoped because of the .x relative_selector.selectors.every( (selector) => is_unscoped_pseudo_class(selector) || selector.type === 'PseudoElementSelector' )) ); } /** * `true` if is a pseudo class that cannot be or is not scoped * @param {AST.CSS.SimpleSelector} selector */ export function is_unscoped_pseudo_class(selector) { return ( selector.type === 'PseudoClassSelector' && // These make the selector scoped ((selector.name !== 'has' && selector.name !== 'is' && selector.name !== 'where' && // Not is special because we want to scope as specific as possible, but because :not // inverses the result, we want to leave the unscoped, too. The exception is more than // one selector in the :not (.e.g :not(.x .y)), then .x and .y should be scoped (selector.name !== 'not' || selector.args === null || selector.args.children.every((c) => c.children.length === 1))) || // selectors with has/is/where/not can also be global if all their children are global selector.args === null || selector.args.children.every((c) => c.children.every((r) => is_global(r)))) ); } /** * True if is `:global(...)` or `:global`, irrespective of whether or not there are any pseudo classes that are scoped. * Difference to `is_global`: `:global(x):has(y)` is `true` for `is_outer_global` but `false` for `is_global`. * @param {AST.CSS.RelativeSelector} relative_selector * @returns {relative_selector is AST.CSS.RelativeSelector & { selectors: [AST.CSS.PseudoClassSelector, ...Array<AST.CSS.PseudoClassSelector | AST.CSS.PseudoElementSelector>] }} */ export function is_outer_global(relative_selector) { const first = relative_selector.selectors[0]; return ( first.type === 'PseudoClassSelector' && first.name === 'global' && (first.args === null || // Only these two selector types can keep the whole selector global, because e.g. // :global(button).x means that the selector is still scoped because of the .x relative_selector.selectors.every( (selector) => selector.type === 'PseudoClassSelector' || selector.type === 'PseudoElementSelector' )) ); }
```

# compiler/phases/2-analyze/index.js

```js
/** @import { Expression, Node, Program } from 'estree' */ /** @import { Binding, AST, ValidatedCompileOptions, ValidatedModuleCompileOptions } from '#compiler' */ /** @import { AnalysisState, Visitors } from './types' */ /** @import { Analysis, ComponentAnalysis, Js, ReactiveStatement, Template } from '../types' */ import { walk } from 'zimmerframe'; import { parse } from '../1-parse/acorn.js'; import * as e from '../../errors.js'; import * as w from '../../warnings.js'; import { extract_identifiers } from '../../utils/ast.js'; import * as b from '#compiler/builders'; import { Scope, ScopeRoot, create_scopes, get_rune, set_scope } from '../scope.js'; import check_graph_for_cycles from './utils/check_graph_for_cycles.js'; import { create_attribute, is_custom_element_node } from '../nodes.js'; import { analyze_css } from './css/css-analyze.js'; import { prune } from './css/css-prune.js'; import { hash, is_rune } from '../../../utils.js'; import { warn_unused } from './css/css-warn.js'; import { extract_svelte_ignore } from '../../utils/extract_svelte_ignore.js'; import { ignore_map, ignore_stack, pop_ignore, push_ignore } from '../../state.js'; import { ArrowFunctionExpression } from './visitors/ArrowFunctionExpression.js'; import { AssignmentExpression } from './visitors/AssignmentExpression.js'; import { AttachTag } from './visitors/AttachTag.js'; import { Attribute } from './visitors/Attribute.js'; import { AwaitBlock } from './visitors/AwaitBlock.js'; import { AwaitExpression } from './visitors/AwaitExpression.js'; import { BindDirective } from './visitors/BindDirective.js'; import { CallExpression } from './visitors/CallExpression.js'; import { ClassBody } from './visitors/ClassBody.js'; import { ClassDeclaration } from './visitors/ClassDeclaration.js'; import { ClassDirective } from './visitors/ClassDirective.js'; import { Component } from './visitors/Component.js'; import { ConstTag } from './visitors/ConstTag.js'; import { DebugTag } from './visitors/DebugTag.js'; import { EachBlock } from './visitors/EachBlock.js'; import { ExportDefaultDeclaration } from './visitors/ExportDefaultDeclaration.js'; import { ExportNamedDeclaration } from './visitors/ExportNamedDeclaration.js'; import { ExportSpecifier } from './visitors/ExportSpecifier.js'; import { ExpressionStatement } from './visitors/ExpressionStatement.js'; import { ExpressionTag } from './visitors/ExpressionTag.js'; import { FunctionDeclaration } from './visitors/FunctionDeclaration.js'; import { FunctionExpression } from './visitors/FunctionExpression.js'; import { HtmlTag } from './visitors/HtmlTag.js'; import { Identifier } from './visitors/Identifier.js'; import { IfBlock } from './visitors/IfBlock.js'; import { ImportDeclaration } from './visitors/ImportDeclaration.js'; import { KeyBlock } from './visitors/KeyBlock.js'; import { LabeledStatement } from './visitors/LabeledStatement.js'; import { LetDirective } from './visitors/LetDirective.js'; import { Literal } from './visitors/Literal.js'; import { MemberExpression } from './visitors/MemberExpression.js'; import { NewExpression } from './visitors/NewExpression.js'; import { OnDirective } from './visitors/OnDirective.js'; import { PropertyDefinition } from './visitors/PropertyDefinition.js'; import { RegularElement } from './visitors/RegularElement.js'; import { RenderTag } from './visitors/RenderTag.js'; import { SlotElement } from './visitors/SlotElement.js'; import { SnippetBlock } from './visitors/SnippetBlock.js'; import { SpreadAttribute } from './visitors/SpreadAttribute.js'; import { SpreadElement } from './visitors/SpreadElement.js'; import { StyleDirective } from './visitors/StyleDirective.js'; import { SvelteBody } from './visitors/SvelteBody.js'; import { SvelteComponent } from './visitors/SvelteComponent.js'; import { SvelteDocument } from './visitors/SvelteDocument.js'; import { SvelteElement } from './visitors/SvelteElement.js'; import { SvelteFragment } from './visitors/SvelteFragment.js'; import { SvelteHead } from './visitors/SvelteHead.js'; import { SvelteSelf } from './visitors/SvelteSelf.js'; import { SvelteWindow } from './visitors/SvelteWindow.js'; import { SvelteBoundary } from './visitors/SvelteBoundary.js'; import { TaggedTemplateExpression } from './visitors/TaggedTemplateExpression.js'; import { TemplateElement } from './visitors/TemplateElement.js'; import { Text } from './visitors/Text.js'; import { TitleElement } from './visitors/TitleElement.js'; import { TransitionDirective } from './visitors/TransitionDirective.js'; import { UpdateExpression } from './visitors/UpdateExpression.js'; import { UseDirective } from './visitors/UseDirective.js'; import { VariableDeclarator } from './visitors/VariableDeclarator.js'; import is_reference from 'is-reference'; import { mark_subtree_dynamic } from './visitors/shared/fragment.js'; import * as state from '../../state.js'; /** * @type {Visitors} */ const visitors = { _(node, { state, next, path }) { const parent = path.at(-1); /** @type {string[]} */ const ignores = []; if (parent?.type === 'Fragment' && node.type !== 'Comment' && node.type !== 'Text') { const idx = parent.nodes.indexOf(/** @type {any} */ (node)); for (let i = idx - 1; i >= 0; i--) { const prev = parent.nodes[i]; if (prev.type === 'Comment') { ignores.push( ...extract_svelte_ignore( prev.start + 4 /* '<!--'.length */, prev.data, state.analysis.runes ) ); } else if (prev.type !== 'Text') { break; } } } else { const comments = /** @type {any} */ (node).leadingComments; if (comments) { for (const comment of comments) { ignores.push( ...extract_svelte_ignore( comment.start + 2 /* '//'.length */, comment.value, state.analysis.runes ) ); } } } if (ignores.length > 0) { push_ignore(ignores); } ignore_map.set(node, structuredClone(ignore_stack)); const scope = state.scopes.get(node); next(scope !== undefined && scope !== state.scope ? { ...state, scope } : state); if (ignores.length > 0) { pop_ignore(); } }, ArrowFunctionExpression, AssignmentExpression, AttachTag, Attribute, AwaitBlock, AwaitExpression, BindDirective, CallExpression, ClassBody, ClassDeclaration, ClassDirective, Component, ConstTag, DebugTag, EachBlock, ExportDefaultDeclaration, ExportNamedDeclaration, ExportSpecifier, ExpressionStatement, ExpressionTag, FunctionDeclaration, FunctionExpression, HtmlTag, Identifier, IfBlock, ImportDeclaration, KeyBlock, LabeledStatement, LetDirective, Literal, MemberExpression, NewExpression, OnDirective, PropertyDefinition, RegularElement, RenderTag, SlotElement, SnippetBlock, SpreadAttribute, SpreadElement, StyleDirective, SvelteBody, SvelteComponent, SvelteDocument, SvelteElement, SvelteFragment, SvelteHead, SvelteSelf, SvelteWindow, SvelteBoundary, TaggedTemplateExpression, TemplateElement, Text, TransitionDirective, TitleElement, UpdateExpression, UseDirective, VariableDeclarator }; /** * @param {AST.Script | null} script * @param {ScopeRoot} root * @param {boolean} allow_reactive_declarations * @param {Scope | null} parent * @returns {Js} */ function js(script, root, allow_reactive_declarations, parent) { /** @type {Program} */ const ast = script?.content ?? { type: 'Program', sourceType: 'module', start: -1, end: -1, body: [] }; const { scope, scopes, has_await } = create_scopes( ast, root, allow_reactive_declarations, parent ); return { ast, scope, scopes, has_await }; } /** * @param {string} filename */ function get_component_name(filename) { const parts = filename.split(/[/\\]/); const basename = /** @type {string} */ (parts.pop()); const last_dir = /** @type {string} */ (parts.at(-1)); let name = basename.replace('.svelte', ''); if (name === 'index' && last_dir && last_dir !== 'src') { name = last_dir; } return name[0].toUpperCase() + name.slice(1); } const RESERVED = ['$$props', '$$restProps', '$$slots']; /** * @param {string} source * @param {ValidatedModuleCompileOptions} options * @returns {Analysis} */ export function analyze_module(source, options) { /** @type {AST.JSComment[]} */ const comments = []; state.set_source(source); const ast = parse(source, comments, false, false); const { scope, scopes, has_await } = create_scopes(ast, new ScopeRoot(), false, null); for (const [name, references] of scope.references) { if (name[0] !== '$' || RESERVED.includes(name)) continue; if (name === '$' || name[1] === '$') { e.global_reference_invalid(references[0].node, name); } const binding = scope.get(name.slice(1)); if (binding !== null && !is_rune(name)) { e.store_invalid_subscription_module(references[0].node); } } /** @type {Analysis} */ const analysis = { module: { ast, scope, scopes, has_await }, name: options.filename, accessors: false, runes: true, immutable: true, tracing: false, async_deriveds: new Set(), comments, classes: new Map() }; state.reset({ dev: options.dev, filename: options.filename, rootDir: options.rootDir, runes: true }); walk( /** @type {Node} */ (ast), { scope, scopes, analysis: /** @type {ComponentAnalysis} */ (analysis), state_fields: new Map(), // TODO the following are not needed for modules, but we have to pass them in order to avoid type error, // and reducing the type would result in a lot of tedious type casts elsewhere - find a good solution one day ast_type: /** @type {any} */ (null), component_slots: new Set(), expression: null, function_depth: 0, has_props_rune: false, options: /** @type {ValidatedCompileOptions} */ (options), parent_element: null, reactive_statement: null }, visitors ); return analysis; } /** * @param {AST.Root} root * @param {string} source * @param {ValidatedCompileOptions} options * @returns {ComponentAnalysis} */ export function analyze_component(root, source, options) { const scope_root = new ScopeRoot(); const module = js(root.module, scope_root, false, null); const instance = js(root.instance, scope_root, true, module.scope); const { scope, scopes, has_await } = create_scopes( root.fragment, scope_root, false, instance.scope ); /** @type {Template} */ const template = { ast: root.fragment, scope, scopes }; let synthetic_stores_legacy_check = []; // create synthetic bindings for store subscriptions for (const [name, references] of module.scope.references) { if (name[0] !== '$' || RESERVED.includes(name)) continue; if (name === '$' || name[1] === '$') { e.global_reference_invalid(references[0].node, name); } const store_name = name.slice(1); const declaration = instance.scope.get(store_name); const init = /** @type {Node | undefined} */ (declaration?.initial); // If we're not in legacy mode through the compiler option, assume the user // is referencing a rune and not a global store. if ( options.runes === false || !is_rune(name) || (declaration !== null && // const state = $state(0) is valid (get_rune(init, instance.scope) === null || // rune-line names received as props are valid too (but we have to protect against $props as store) (store_name !== 'props' && get_rune(init, instance.scope) === '$props')) && // allow `import { derived } from 'svelte/store'` in the same file as `const x = $derived(..)` because one is not a subscription to the other !( name === '$derived' && declaration.initial?.type === 'ImportDeclaration' && declaration.initial.source.value === 'svelte/store' )) ) { let is_nested_store_subscription_node = undefined; search: for (const reference of references) { for (let i = reference.path.length - 1; i >= 0; i--) { const scope = scopes.get(reference.path[i]) || module.scopes.get(reference.path[i]) || instance.scopes.get(reference.path[i]); if (scope) { const owner = scope?.owner(store_name); if (!!owner && owner !== module.scope && owner !== instance.scope) { is_nested_store_subscription_node = reference.node; break search; } break; } } } if (is_nested_store_subscription_node) { e.store_invalid_scoped_subscription(is_nested_store_subscription_node); } if (options.runes !== false) { if (declaration === null && /[a-z]/.test(store_name[0])) { e.global_reference_invalid(references[0].node, name); } else if (declaration !== null && is_rune(name)) { for (const { node, path } of references) { if (path.at(-1)?.type === 'CallExpression') { w.store_rune_conflict(node, store_name); } } } } if (module.ast) { for (const { node, path } of references) { // if the reference is inside module, error. this is a bit hacky but it works if ( /** @type {number} */ (node.start) > /** @type {number} */ (module.ast.start) && /** @type {number} */ (node.end) < /** @type {number} */ (module.ast.end) && // const state = $state(0) is valid get_rune(/** @type {Node} */ (path.at(-1)), module.scope) === null ) { e.store_invalid_subscription(node); } } } // we push to the array because at this moment in time we can't be sure if we are in legacy // mode yet because we are still changing the module scope synthetic_stores_legacy_check.push(() => { // if we are creating a synthetic binding for a let declaration we should also declare // the declaration as state in case it's reassigned and we are not in runes mode (the function will // not be called if we are not in runes mode, that's why there's no !runes check here) if ( declaration !== null && declaration.kind === 'normal' && declaration.declaration_kind === 'let' && declaration.reassigned ) { declaration.kind = 'state'; } }); const binding = instance.scope.declare(b.id(name), 'store_sub', 'synthetic'); binding.references = references; instance.scope.references.set(name, references); module.scope.references.delete(name); } } const component_name = get_component_name(options.filename); const runes = options.runes ?? (has_await || instance.has_await || Array.from(module.scope.references.keys()).some(is_rune)); if (!runes) { for (let check of synthetic_stores_legacy_check) { check(); } } if (runes && root.module) { const context = root.module.attributes.find((attribute) => attribute.name === 'context'); if (context) { w.script_context_deprecated(context); } } // TODO remove all the ?? stuff, we don't need it now that we're validating the config /** @type {ComponentAnalysis} */ const analysis = { name: module.scope.generate(options.name ?? component_name), root: scope_root, module, instance, template, comments: root.comments, elements: [], runes, // if we are not in runes mode but we have no reserved references ($$props, $$restProps) // and no `export let` we might be in a wannabe runes component that is using runes in an external // module...we need to fallback to the runic behavior maybe_runes: !runes && // if they explicitly disabled runes, use the legacy behavior options.runes !== false && ![...module.scope.references.keys()].some((name) => ['$$props', '$$restProps'].includes(name) ) && !instance.ast.body.some( (node) => node.type === 'LabeledStatement' || (node.type === 'ExportNamedDeclaration' && ((node.declaration && node.declaration.type === 'VariableDeclaration' && node.declaration.kind === 'let') || node.specifiers.some( (specifier) => specifier.local.type === 'Identifier' && instance.scope.get(specifier.local.name)?.declaration_kind === 'let' ))) ), tracing: false, classes: new Map(), immutable: runes || options.immutable, exports: [], uses_props: false, props_id: null, uses_rest_props: false, uses_slots: false, uses_component_bindings: false, uses_render_tags: false, needs_context: false, needs_mutation_validation: false, needs_props: false, event_directive_node: null, uses_event_attributes: false, custom_element: options.customElementOptions ?? options.customElement, inject_styles: options.css === 'injected' || options.customElement, accessors: options.customElement ? true : (runes ? false : !!options.accessors) || // because $set method needs accessors options.compatibility?.componentApi === 4, reactive_statements: new Map(), binding_groups: new Map(), slot_names: new Map(), css: { ast: root.css, hash: root.css ? options.cssHash({ css: root.css.content.styles, filename: options.filename, name: component_name, hash }) : '', keyframes: [], has_global: false }, source, undefined_exports: new Map(), snippet_renderers: new Map(), snippets: new Set(), async_deriveds: new Set() }; state.reset({ component_name: analysis.name, dev: options.dev, filename: options.filename, rootDir: options.rootDir, runes: true }); if (!runes) { // every exported `let` or `var` declaration becomes a prop, everything else becomes an export for (const node of instance.ast.body) { if (node.type !== 'ExportNamedDeclaration') continue; analysis.needs_props = true; if (node.declaration) { if ( node.declaration.type === 'FunctionDeclaration' || node.declaration.type === 'ClassDeclaration' ) { analysis.exports.push({ name: /** @type {import('estree').Identifier} */ (node.declaration.id).name, alias: null }); } else if (node.declaration.type === 'VariableDeclaration') { if (node.declaration.kind === 'const') { for (const declarator of node.declaration.declarations) { for (const node of extract_identifiers(declarator.id)) { analysis.exports.push({ name: node.name, alias: null }); } } } else { for (const declarator of node.declaration.declarations) { for (const id of extract_identifiers(declarator.id)) { const binding = /** @type {Binding} */ (instance.scope.get(id.name)); binding.kind = 'bindable_prop'; } } } } } else { for (const specifier of node.specifiers) { if (specifier.local.type !== 'Identifier' || specifier.exported.type !== 'Identifier') { continue; } const binding = instance.scope.get(specifier.local.name); if ( binding && (binding.declaration_kind === 'var' || binding.declaration_kind === 'let') ) { binding.kind = 'bindable_prop'; if (specifier.exported.name !== specifier.local.name) { binding.prop_alias = specifier.exported.name; } } else { analysis.exports.push({ name: specifier.local.name, alias: specifier.exported.name }); } } } } // if reassigned/mutated bindings are referenced in `$:` blocks // or the template, turn them into state for (const binding of instance.scope.declarations.values()) { if (binding.kind !== 'normal') continue; for (const { node, path } of binding.references) { if (node === binding.node) continue; if (binding.updated) { if ( path[path.length - 1].type === 'StyleDirective' || path.some((node) => node.type === 'Fragment') || (path[1].type === 'LabeledStatement' && path[1].label.name === '$') ) { binding.kind = 'state'; } } } } // more legacy nonsense: if an `each` binding is reassigned/mutated, // treat the expression as being mutated as well walk(/** @type {AST.SvelteNode} */ (template.ast), null, { EachBlock(node) { const scope = /** @type {Scope} */ (template.scopes.get(node)); for (const binding of scope.declarations.values()) { if (binding.updated) { const state = { scope: /** @type {Scope} */ (scope.parent), scopes: template.scopes }; walk(node.expression, state, { // @ts-expect-error _: set_scope, Identifier(node, context) { const parent = /** @type {Expression} */ (context.path.at(-1)); if (is_reference(node, parent)) { const binding = context.state.scope.get(node.name); if ( binding && binding.kind === 'normal' && binding.declaration_kind !== 'import' ) { binding.kind = 'state'; binding.mutated = true; } } } }); break; } } } }); } if (root.options) { for (const attribute of root.options.attributes) { if (attribute.name === 'accessors' && analysis.runes) { w.options_deprecated_accessors(attribute); } if (attribute.name === 'customElement' && !options.customElement) { w.options_missing_custom_element(attribute); } if (attribute.name === 'immutable' && analysis.runes) { w.options_deprecated_immutable(attribute); } } } if (analysis.runes) { const props_refs = module.scope.references.get('$$props'); if (props_refs) { e.legacy_props_invalid(props_refs[0].node); } const rest_props_refs = module.scope.references.get('$$restProps'); if (rest_props_refs) { e.legacy_rest_props_invalid(rest_props_refs[0].node); } for (const { ast, scope, scopes } of [module, instance, template]) { /** @type {AnalysisState} */ const state = { scope, scopes, analysis, options, ast_type: ast === instance.ast ? 'instance' : ast === template.ast ? 'template' : 'module', parent_element: null, has_props_rune: false, component_slots: new Set(), expression: null, state_fields: new Map(), function_depth: scope.function_depth, reactive_statement: null }; walk(/** @type {AST.SvelteNode} */ (ast), state, visitors); } // warn on any nonstate declarations that are a) reassigned and b) referenced in the template for (const scope of [module.scope, instance.scope]) { outer: for (const [name, binding] of scope.declarations) { if (binding.kind === 'normal' && binding.reassigned) { inner: for (const { path } of binding.references) { if (path[0].type !== 'Fragment') continue; for (let i = 1; i < path.length; i += 1) { const type = path[i].type; if ( type === 'FunctionDeclaration' || type === 'FunctionExpression' || type === 'ArrowFunctionExpression' ) { continue inner; } // bind:this doesn't need to be a state reference if it will never change if ( type === 'BindDirective' && /** @type {AST.BindDirective} */ (path[i]).name === 'this' ) { for (let j = i - 1; j >= 0; j -= 1) { const type = path[j].type; if ( type === 'IfBlock' || type === 'EachBlock' || type === 'AwaitBlock' || type === 'KeyBlock' ) { w.non_reactive_update(binding.node, name); continue outer; } } continue inner; } } w.non_reactive_update(binding.node, name); continue outer; } } } } } else { instance.scope.declare(b.id('$$props'), 'rest_prop', 'synthetic'); instance.scope.declare(b.id('$$restProps'), 'rest_prop', 'synthetic'); for (const { ast, scope, scopes } of [module, instance, template]) { /** @type {AnalysisState} */ const state = { scope, scopes, analysis, options, parent_element: null, has_props_rune: false, ast_type: ast === instance.ast ? 'instance' : ast === template.ast ? 'template' : 'module', reactive_statement: null, component_slots: new Set(), expression: null, state_fields: new Map(), function_depth: scope.function_depth }; walk(/** @type {AST.SvelteNode} */ (ast), state, visitors); } for (const [name, binding] of instance.scope.declarations) { if ( (binding.kind === 'prop' || binding.kind === 'bindable_prop') && binding.node.name !== '$$props' ) { const references = binding.references.filter( (r) => r.node !== binding.node && r.path.at(-1)?.type !== 'ExportSpecifier' ); if (!references.length && !instance.scope.declarations.has(`$${name}`)) { w.export_let_unused(binding.node, name); } } } analysis.reactive_statements = order_reactive_statements(analysis.reactive_statements); } for (const node of analysis.module.ast.body) { if (node.type === 'ExportNamedDeclaration' && node.specifiers !== null && node.source == null) { for (const specifier of node.specifiers) { if (specifier.local.type !== 'Identifier') continue; const binding = analysis.module.scope.get(specifier.local.name); if (!binding) e.export_undefined(specifier, specifier.local.name); } } } if (analysis.event_directive_node && analysis.uses_event_attributes) { e.mixed_event_handler_syntaxes( analysis.event_directive_node, analysis.event_directive_node.name ); } for (const [node, resolved] of analysis.snippet_renderers) { if (!resolved) { node.metadata.snippets = analysis.snippets; } for (const snippet of node.metadata.snippets) { snippet.metadata.sites.add(node); } } if ( analysis.uses_render_tags && (analysis.uses_slots || (!analysis.custom_element && analysis.slot_names.size > 0)) ) { const pos = analysis.slot_names.values().next().value ?? analysis.source.indexOf('$$slot'); e.slot_snippet_conflict(pos); } if (analysis.css.ast) { analyze_css(analysis.css.ast, analysis); // mark nodes as scoped/unused/empty etc for (const node of analysis.elements) { prune(analysis.css.ast, node); } const { comment } = analysis.css.ast.content; const should_ignore_unused = comment && extract_svelte_ignore(comment.start, comment.data, analysis.runes).includes( 'css_unused_selector' ); if (!should_ignore_unused) { warn_unused(analysis.css.ast); } } for (const node of analysis.elements) { if (node.metadata.scoped && is_custom_element_node(node)) { mark_subtree_dynamic(node.metadata.path); } let has_class = false; let has_style = false; let has_spread = false; let has_class_directive = false; let has_style_directive = false; for (const attribute of node.attributes) { // The spread method appends the hash to the end of the class attribute on its own if (attribute.type === 'SpreadAttribute') { has_spread = true; break; } else if (attribute.type === 'Attribute') { has_class ||= attribute.name.toLowerCase() === 'class'; has_style ||= attribute.name.toLowerCase() === 'style'; } else if (attribute.type === 'ClassDirective') { has_class_directive = true; } else if (attribute.type === 'StyleDirective') { has_style_directive = true; } } // We need an empty class to generate the set_class() or class="" correctly if (!has_spread && !has_class && (node.metadata.scoped || has_class_directive)) { node.attributes.push( create_attribute('class', -1, -1, [ { type: 'Text', data: '', raw: '', start: -1, end: -1 } ]) ); } // We need an empty style to generate the set_style() correctly if (!has_spread && !has_style && has_style_directive) { node.attributes.push( create_attribute('style', -1, -1, [ { type: 'Text', data: '', raw: '', start: -1, end: -1 } ]) ); } } // TODO // analysis.stylesheet.warn_on_unused_selectors(analysis); return analysis; } /** * @param {Map<import('estree').LabeledStatement, ReactiveStatement>} unsorted_reactive_declarations */ function order_reactive_statements(unsorted_reactive_declarations) { /** @typedef {[import('estree').LabeledStatement, ReactiveStatement]} Tuple */ /** @type {Map<string, Array<Tuple>>} */ const lookup = new Map(); for (const [node, declaration] of unsorted_reactive_declarations) { for (const binding of declaration.assignments) { const statements = lookup.get(binding.node.name) ?? []; statements.push([node, declaration]); lookup.set(binding.node.name, statements); } } /** @type {Array<[string, string]>} */ const edges = []; for (const [, { assignments, dependencies }] of unsorted_reactive_declarations) { for (const assignment of assignments) { for (const dependency of dependencies) { if (!assignments.has(dependency)) { edges.push([assignment.node.name, dependency.node.name]); } } } } const cycle = check_graph_for_cycles(edges); if (cycle?.length) { const declaration = /** @type {Tuple[]} */ (lookup.get(cycle[0]))[0]; e.reactive_declaration_cycle(declaration[0], cycle.join(' → ')); } // We use a map and take advantage of the fact that the spec says insertion order is preserved when iterating /** @type {Map<import('estree').LabeledStatement, ReactiveStatement>} */ const reactive_declarations = new Map(); /** * * @param {import('estree').LabeledStatement} node * @param {ReactiveStatement} declaration * @returns */ const add_declaration = (node, declaration) => { if ([...reactive_declarations.values()].includes(declaration)) return; for (const binding of declaration.dependencies) { if (declaration.assignments.has(binding)) continue; for (const [node, earlier] of lookup.get(binding.node.name) ?? []) { add_declaration(node, earlier); } } reactive_declarations.set(node, declaration); }; for (const [node, declaration] of unsorted_reactive_declarations) { add_declaration(node, declaration); } return reactive_declarations; }
```

# compiler/phases/2-analyze/types.d.ts

```ts
import type { Scope } from '../scope.js'; import type { ComponentAnalysis, ReactiveStatement } from '../types.js'; import type { AST, ExpressionMetadata, StateField, ValidatedCompileOptions } from '#compiler'; export interface AnalysisState { scope: Scope; scopes: Map<AST.SvelteNode, Scope>; analysis: ComponentAnalysis; options: ValidatedCompileOptions; ast_type: 'instance' | 'template' | 'module'; /** * Tag name of the parent element. `null` if the parent is `svelte:element`, `#snippet`, a component or the root. * Parent doesn't necessarily mean direct path predecessor because there could be `#each`, `#if` etc in-between. */ parent_element: string | null; has_props_rune: boolean; /** Which slots the current parent component has */ component_slots: Set<string>; /** Information about the current expression/directive/block value */ expression: ExpressionMetadata | null; /** Used to analyze class state */ state_fields: Map<string, StateField>; function_depth: number; // legacy stuff reactive_statement: null | ReactiveStatement; } export type Context<State extends AnalysisState = AnalysisState> = import('zimmerframe').Context< AST.SvelteNode, State >; export type Visitors<State extends AnalysisState = AnalysisState> = import('zimmerframe').Visitors< AST.SvelteNode, State >;
```

# compiler/phases/2-analyze/utils/check_graph_for_cycles.js

```js
/** * @template T * @param {Array<[T, T]>} edges * @returns {Array<T>|undefined} */ export default function check_graph_for_cycles(edges) { /** @type {Map<T, T[]>} */ const graph = edges.reduce((g, edge) => { const [u, v] = edge; if (!g.has(u)) g.set(u, []); if (!g.has(v)) g.set(v, []); g.get(u).push(v); return g; }, new Map()); const visited = new Set(); const on_stack = new Set(); /** @type {Array<Array<T>>} */ const cycles = []; /** * @param {T} v */ function visit(v) { visited.add(v); on_stack.add(v); graph.get(v)?.forEach((w) => { if (!visited.has(w)) { visit(w); } else if (on_stack.has(w)) { cycles.push([...on_stack, w]); } }); on_stack.delete(v); } graph.forEach((_, v) => { if (!visited.has(v)) { visit(v); } }); return cycles[0]; }
```

# compiler/phases/2-analyze/visitors/ArrowFunctionExpression.js

```js
/** @import { ArrowFunctionExpression } from 'estree' */ /** @import { Context } from '../types' */ import { visit_function } from './shared/function.js'; /** * @param {ArrowFunctionExpression} node * @param {Context} context */ export function ArrowFunctionExpression(node, context) { visit_function(node, context); }
```

# compiler/phases/2-analyze/visitors/AssignmentExpression.js

```js
/** @import { AssignmentExpression } from 'estree' */ /** @import { Context } from '../types' */ import { extract_identifiers, object } from '../../../utils/ast.js'; import { validate_assignment } from './shared/utils.js'; /** * @param {AssignmentExpression} node * @param {Context} context */ export function AssignmentExpression(node, context) { validate_assignment(node, node.left, context); if (context.state.reactive_statement) { const id = node.left.type === 'MemberExpression' ? object(node.left) : node.left; if (id !== null) { for (const id of extract_identifiers(node.left)) { const binding = context.state.scope.get(id.name); if (binding) { context.state.reactive_statement.assignments.add(binding); } } } } if (context.state.expression) { context.state.expression.has_assignment = true; } context.next(); }
```

# compiler/phases/2-analyze/visitors/AttachTag.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { mark_subtree_dynamic } from './shared/fragment.js'; /** * @param {AST.AttachTag} node * @param {Context} context */ export function AttachTag(node, context) { mark_subtree_dynamic(context.path); context.next({ ...context.state, expression: node.metadata.expression }); }
```

# compiler/phases/2-analyze/visitors/Attribute.js

```js
/** @import { ArrowFunctionExpression, Expression, FunctionDeclaration, FunctionExpression } from 'estree' */ /** @import { AST, DelegatedEvent } from '#compiler' */ /** @import { Context } from '../types' */ import { cannot_be_set_statically, is_capture_event, is_delegated } from '../../../../utils.js'; import { get_attribute_chunks, get_attribute_expression, is_event_attribute } from '../../../utils/ast.js'; import { mark_subtree_dynamic } from './shared/fragment.js'; /** * @param {AST.Attribute} node * @param {Context} context */ export function Attribute(node, context) { context.next(); const parent = /** @type {AST.SvelteNode} */ (context.path.at(-1)); if (parent.type === 'RegularElement') { // special case <option value="" /> if (node.name === 'value' && parent.name === 'option') { mark_subtree_dynamic(context.path); } } if (is_event_attribute(node)) { mark_subtree_dynamic(context.path); } if (cannot_be_set_statically(node.name)) { mark_subtree_dynamic(context.path); } // class={[...]} or class={{...}} or `class={x}` need clsx to resolve the classes if ( node.name === 'class' && !Array.isArray(node.value) && node.value !== true && node.value.expression.type !== 'Literal' && node.value.expression.type !== 'TemplateLiteral' && node.value.expression.type !== 'BinaryExpression' ) { mark_subtree_dynamic(context.path); node.metadata.needs_clsx = true; } if (node.value !== true) { for (const chunk of get_attribute_chunks(node.value)) { if (chunk.type !== 'ExpressionTag') continue; if ( chunk.expression.type === 'FunctionExpression' || chunk.expression.type === 'ArrowFunctionExpression' ) { continue; } } if (is_event_attribute(node)) { const parent = context.path.at(-1); if (parent?.type === 'RegularElement' || parent?.type === 'SvelteElement') { context.state.analysis.uses_event_attributes = true; } const expression = get_attribute_expression(node); const delegated_event = get_delegated_event(node.name.slice(2), expression, context); if (delegated_event !== null) { if (delegated_event.hoisted) { delegated_event.function.metadata.hoisted = true; } node.metadata.delegated = delegated_event; } } } } /** @type {DelegatedEvent} */ const unhoisted = { hoisted: false }; /** * Checks if given event attribute can be delegated/hoisted and returns the corresponding info if so * @param {string} event_name * @param {Expression | null} handler * @param {Context} context * @returns {null | DelegatedEvent} */ function get_delegated_event(event_name, handler, context) { // Handle delegated event handlers. Bail out if not a delegated event. if (!handler || !is_delegated(event_name)) { return null; } // If we are not working with a RegularElement, then bail out. const element = context.path.at(-1); if (element?.type !== 'RegularElement') { return null; } /** @type {FunctionExpression | FunctionDeclaration | ArrowFunctionExpression | null} */ let target_function = null; let binding = null; if (element.metadata.has_spread) { // event attribute becomes part of the dynamic spread array return unhoisted; } if (handler.type === 'ArrowFunctionExpression' || handler.type === 'FunctionExpression') { target_function = handler; } else if (handler.type === 'Identifier') { binding = context.state.scope.get(handler.name); if (context.state.analysis.module.scope.references.has(handler.name)) { // If a binding with the same name is referenced in the module scope (even if not declared there), bail out return unhoisted; } if (binding != null) { for (const { path } of binding.references) { const parent = path.at(-1); if (parent === undefined) return unhoisted; const grandparent = path.at(-2); /** @type {AST.RegularElement | null} */ let element = null; /** @type {string | null} */ let event_name = null; if (parent.type === 'OnDirective') { element = /** @type {AST.RegularElement} */ (grandparent); event_name = parent.name; } else if ( parent.type === 'ExpressionTag' && grandparent?.type === 'Attribute' && is_event_attribute(grandparent) ) { element = /** @type {AST.RegularElement} */ (path.at(-3)); const attribute = /** @type {AST.Attribute} */ (grandparent); event_name = get_attribute_event_name(attribute.name); } if (element && event_name) { if ( element.type !== 'RegularElement' || element.metadata.has_spread || !is_delegated(event_name) ) { return unhoisted; } } else if (parent.type !== 'FunctionDeclaration' && parent.type !== 'VariableDeclarator') { return unhoisted; } } } // If the binding is exported, bail out if (context.state.analysis.exports.find((node) => node.name === handler.name)) { return unhoisted; } if (binding?.is_function()) { target_function = binding.initial; } } // If we can't find a function, or the function has multiple parameters, bail out if (target_function == null || target_function.params.length > 1) { return unhoisted; } const visited_references = new Set(); const scope = target_function.metadata.scope; for (const [reference] of scope.references) { // Bail out if the arguments keyword is used or $host is referenced if (reference === 'arguments' || reference === '$host') return unhoisted; // Bail out if references a store subscription if (scope.get(`$${reference}`)?.kind === 'store_sub') return unhoisted; const binding = scope.get(reference); const local_binding = context.state.scope.get(reference); // if the function access a snippet that can't be hoisted we bail out if ( local_binding !== null && local_binding.initial?.type === 'SnippetBlock' && !local_binding.initial.metadata.can_hoist ) { return unhoisted; } // If we are referencing a binding that is shadowed in another scope then bail out. if (local_binding !== null && binding !== null && local_binding.node !== binding.node) { return unhoisted; } // If we have multiple references to the same store using $ prefix, bail out. if ( binding !== null && binding.kind === 'store_sub' && visited_references.has(reference.slice(1)) ) { return unhoisted; } // If we reference the index within an each block, then bail out. if (binding !== null && binding.initial?.type === 'EachBlock') return unhoisted; if ( binding !== null && // Bail out if the binding is a rest param (binding.declaration_kind === 'rest_param' || // Bail out if we reference anything from the EachBlock (for now) that mutates in non-runes mode, (((!context.state.analysis.runes && binding.kind === 'each') || // or any normal not reactive bindings that are mutated. binding.kind === 'normal') && binding.updated)) ) { return unhoisted; } visited_references.add(reference); } return { hoisted: true, function: target_function }; } /** * @param {string} event_name */ function get_attribute_event_name(event_name) { event_name = event_name.slice(2); if (is_capture_event(event_name)) { event_name = event_name.slice(0, -7); } return event_name; }
```

# compiler/phases/2-analyze/visitors/AwaitBlock.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { validate_block_not_empty, validate_opening_tag } from './shared/utils.js'; import * as e from '../../../errors.js'; import { mark_subtree_dynamic } from './shared/fragment.js'; /** * @param {AST.AwaitBlock} node * @param {Context} context */ export function AwaitBlock(node, context) { validate_block_not_empty(node.pending, context); validate_block_not_empty(node.then, context); validate_block_not_empty(node.catch, context); if (context.state.analysis.runes) { validate_opening_tag(node, context.state, '#'); if (node.value) { const start = /** @type {number} */ (node.value.start); const match = context.state.analysis.source .substring(start - 10, start) .match(/{(\s*):then\s+$/); if (match && match[1] !== '') { e.block_unexpected_character({ start: start - 10, end: start }, ':'); } } if (node.error) { const start = /** @type {number} */ (node.error.start); const match = context.state.analysis.source .substring(start - 10, start) .match(/{(\s*):catch\s+$/); if (match && match[1] !== '') { e.block_unexpected_character({ start: start - 10, end: start }, ':'); } } } mark_subtree_dynamic(context.path); context.visit(node.expression, { ...context.state, expression: node.metadata.expression }); if (node.pending) context.visit(node.pending); if (node.then) context.visit(node.then); if (node.catch) context.visit(node.catch); }
```

# compiler/phases/2-analyze/visitors/AwaitExpression.js

```js
/** @import { AwaitExpression } from 'estree' */ /** @import { Context } from '../types' */ import * as e from '../../../errors.js'; /** * @param {AwaitExpression} node * @param {Context} context */ export function AwaitExpression(node, context) { let suspend = context.state.ast_type === 'instance' && context.state.function_depth === 1; if (context.state.expression) { context.state.expression.has_await = true; suspend = true; } // disallow top-level `await` or `await` in template expressions // unless a) in runes mode and b) opted into `experimental.async` if (suspend) { if (!context.state.options.experimental.async) { e.experimental_async(node); } if (!context.state.analysis.runes) { e.legacy_await_invalid(node); } } context.next(); }
```

# compiler/phases/2-analyze/visitors/BindDirective.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { extract_all_identifiers_from_expression, is_text_attribute, object } from '../../../utils/ast.js'; import { validate_assignment } from './shared/utils.js'; import * as e from '../../../errors.js'; import * as w from '../../../warnings.js'; import { binding_properties } from '../../bindings.js'; import fuzzymatch from '../../1-parse/utils/fuzzymatch.js'; import { is_content_editable_binding, is_svg } from '../../../../utils.js'; import { mark_subtree_dynamic } from './shared/fragment.js'; /** * @param {AST.BindDirective} node * @param {Context} context */ export function BindDirective(node, context) { const parent = context.path.at(-1); if ( parent?.type === 'RegularElement' || parent?.type === 'SvelteElement' || parent?.type === 'SvelteWindow' || parent?.type === 'SvelteDocument' || parent?.type === 'SvelteBody' ) { if (node.name in binding_properties) { const property = binding_properties[node.name]; if (property.valid_elements && !property.valid_elements.includes(parent.name)) { e.bind_invalid_target( node, node.name, property.valid_elements.map((valid_element) => `<${valid_element}>`).join(', ') ); } if (property.invalid_elements && property.invalid_elements.includes(parent.name)) { const valid_bindings = Object.entries(binding_properties) .filter(([_, binding_property]) => { return ( binding_property.valid_elements?.includes(parent.name) || (!binding_property.valid_elements && !binding_property.invalid_elements?.includes(parent.name)) ); }) .map(([property_name]) => property_name) .sort(); e.bind_invalid_name( node, node.name, `Possible bindings for <${parent.name}> are ${valid_bindings.join(', ')}` ); } if (parent.name === 'input' && node.name !== 'this') { const type = /** @type {AST.Attribute | undefined} */ ( parent.attributes.find((a) => a.type === 'Attribute' && a.name === 'type') ); if (type && !is_text_attribute(type)) { if (node.name !== 'value' || type.value === true) { e.attribute_invalid_type(type); } } else { if (node.name === 'checked' && type?.value[0].data !== 'checkbox') { e.bind_invalid_target(node, node.name, '<input type="checkbox">'); } if (node.name === 'files' && type?.value[0].data !== 'file') { e.bind_invalid_target(node, node.name, '<input type="file">'); } } } if (parent.name === 'select' && node.name !== 'this') { const multiple = parent.attributes.find( (a) => a.type === 'Attribute' && a.name === 'multiple' && !is_text_attribute(a) && a.value !== true ); if (multiple) { e.attribute_invalid_multiple(multiple); } } if (node.name === 'offsetWidth' && is_svg(parent.name)) { e.bind_invalid_target( node, node.name, `non-<svg> elements. Use 'clientWidth' for <svg> instead` ); } if (is_content_editable_binding(node.name)) { const contenteditable = /** @type {AST.Attribute} */ ( parent.attributes.find((a) => a.type === 'Attribute' && a.name === 'contenteditable') ); if (!contenteditable) { e.attribute_contenteditable_missing(node); } else if (!is_text_attribute(contenteditable) && contenteditable.value !== true) { e.attribute_contenteditable_dynamic(contenteditable); } } } else { const match = fuzzymatch(node.name, Object.keys(binding_properties)); if (match) { const property = binding_properties[match]; if (!property.valid_elements || property.valid_elements.includes(parent.name)) { e.bind_invalid_name(node, node.name, `Did you mean '${match}'?`); } } e.bind_invalid_name(node, node.name); } } // When dealing with bind getters/setters skip the specific binding validation // Group bindings aren't supported for getter/setters so we don't need to handle // the metadata if (node.expression.type === 'SequenceExpression') { if (node.name === 'group') { e.bind_group_invalid_expression(node); } let i = /** @type {number} */ (node.expression.start); let leading_comments_start = /**@type {any}*/ (node.expression.leadingComments?.at(0))?.start; let leading_comments_end = /**@type {any}*/ (node.expression.leadingComments?.at(-1))?.end; while (context.state.analysis.source[--i] !== '{') { if ( context.state.analysis.source[i] === '(' && // if the parenthesis is in a leading comment we don't need to throw the error !( leading_comments_start && leading_comments_end && i <= leading_comments_end && i >= leading_comments_start ) ) { e.bind_invalid_parens(node, node.name); } } if (node.expression.expressions.length !== 2) { e.bind_invalid_expression(node); } mark_subtree_dynamic(context.path); return; } validate_assignment(node, node.expression, context); const assignee = node.expression; const left = object(assignee); if (left === null) { e.bind_invalid_expression(node); } const binding = context.state.scope.get(left.name); if (assignee.type === 'Identifier') { // reassignment if ( node.name !== 'this' && // bind:this also works for regular variables (!binding || (binding.kind !== 'state' && binding.kind !== 'raw_state' && binding.kind !== 'prop' && binding.kind !== 'bindable_prop' && binding.kind !== 'each' && binding.kind !== 'store_sub' && !binding.updated)) // TODO wut? ) { e.bind_invalid_value(node.expression); } } if (node.name === 'group') { if (!binding) { throw new Error('Cannot find declaration for bind:group'); } if (binding.kind === 'snippet') { e.bind_group_invalid_snippet_parameter(node); } // Traverse the path upwards and find all EachBlocks who are (indirectly) contributing to bind:group, // i.e. one of their declarations is referenced in the binding. This allows group bindings to work // correctly when referencing a variable declared in an EachBlock by using the index of the each block // entries as keys. const each_blocks = []; const [keypath, expression_ids] = extract_all_identifiers_from_expression(node.expression); let ids = expression_ids; let i = context.path.length; while (i--) { const parent = context.path[i]; if (parent.type === 'EachBlock') { const references = ids.filter((id) => parent.metadata.declarations.has(id.name)); if (references.length > 0) { parent.metadata.contains_group_binding = true; each_blocks.push(parent); ids = ids.filter((id) => !references.includes(id)); ids.push(...extract_all_identifiers_from_expression(parent.expression)[1]); } } } // The identifiers that make up the binding expression form they key for the binding group. // If the same identifiers in the same order are used in another bind:group, they will be in the same group. // (there's an edge case where `bind:group={a[i]}` will be in a different group than `bind:group={a[j]}` even when i == j, // but this is a limitation of the current static analysis we do; it also never worked in Svelte 4) const bindings = expression_ids.map((id) => context.state.scope.get(id.name)); let group_name; outer: for (const [[key, b], group] of context.state.analysis.binding_groups) { if (b.length !== bindings.length || key !== keypath) continue; for (let i = 0; i < bindings.length; i++) { if (bindings[i] !== b[i]) continue outer; } group_name = group; } if (!group_name) { group_name = context.state.scope.root.unique('binding_group'); context.state.analysis.binding_groups.set([keypath, bindings], group_name); } node.metadata = { binding_group_name: group_name, parent_each_blocks: each_blocks }; } if (binding?.kind === 'each' && binding.metadata?.inside_rest) { w.bind_invalid_each_rest(binding.node, binding.node.name); } context.next(); }
```

# compiler/phases/2-analyze/visitors/CallExpression.js

```js
/** @import { ArrowFunctionExpression, CallExpression, Expression, FunctionDeclaration, FunctionExpression, Identifier, VariableDeclarator } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { get_rune } from '../../scope.js'; import * as e from '../../../errors.js'; import { get_parent } from '../../../utils/ast.js'; import { is_pure, is_safe_identifier } from './shared/utils.js'; import { dev, locate_node, source } from '../../../state.js'; import * as b from '#compiler/builders'; import { create_expression_metadata } from '../../nodes.js'; /** * @param {CallExpression} node * @param {Context} context */ export function CallExpression(node, context) { const parent = /** @type {AST.SvelteNode} */ (get_parent(context.path, -1)); const rune = get_rune(node, context.state.scope); if (rune && rune !== '$inspect') { for (const arg of node.arguments) { if (arg.type === 'SpreadElement') { e.rune_invalid_spread(node, rune); } } } switch (rune) { case null: if (!is_safe_identifier(node.callee, context.state.scope)) { context.state.analysis.needs_context = true; } break; case '$bindable': if (node.arguments.length > 1) { e.rune_invalid_arguments_length(node, '$bindable', 'zero or one arguments'); } if ( parent.type !== 'AssignmentPattern' || context.path.at(-3)?.type !== 'ObjectPattern' || context.path.at(-4)?.type !== 'VariableDeclarator' || get_rune( /** @type {VariableDeclarator} */ (context.path.at(-4)).init, context.state.scope ) !== '$props' ) { e.bindable_invalid_location(node); } // We need context in case the bound prop is stale context.state.analysis.needs_context = true; break; case '$host': if (node.arguments.length > 0) { e.rune_invalid_arguments(node, '$host'); } else if (context.state.ast_type === 'module' || !context.state.analysis.custom_element) { e.host_invalid_placement(node); } break; case '$props': if (context.state.has_props_rune) { e.props_duplicate(node, rune); } context.state.has_props_rune = true; if ( parent.type !== 'VariableDeclarator' || context.state.ast_type !== 'instance' || context.state.scope !== context.state.analysis.instance.scope ) { e.props_invalid_placement(node); } if (node.arguments.length > 0) { e.rune_invalid_arguments(node, rune); } break; case '$props.id': { const grand_parent = get_parent(context.path, -2); if (context.state.analysis.props_id) { e.props_duplicate(node, rune); } if ( parent.type !== 'VariableDeclarator' || parent.id.type !== 'Identifier' || context.state.ast_type !== 'instance' || context.state.scope !== context.state.analysis.instance.scope || grand_parent.type !== 'VariableDeclaration' ) { e.props_id_invalid_placement(node); } if (node.arguments.length > 0) { e.rune_invalid_arguments(node, rune); } context.state.analysis.props_id = parent.id; break; } case '$state': case '$state.raw': case '$derived': case '$derived.by': { const valid = is_variable_declaration(parent, context) || is_class_property_definition(parent) || is_class_property_assignment_at_constructor_root(parent, context); if (!valid) { e.state_invalid_placement(node, rune); } if ((rune === '$derived' || rune === '$derived.by') && node.arguments.length !== 1) { e.rune_invalid_arguments_length(node, rune, 'exactly one argument'); } else if (node.arguments.length > 1) { e.rune_invalid_arguments_length(node, rune, 'zero or one arguments'); } break; } case '$effect': case '$effect.pre': if (parent.type !== 'ExpressionStatement') { e.effect_invalid_placement(node); } if (node.arguments.length !== 1) { e.rune_invalid_arguments_length(node, rune, 'exactly one argument'); } // `$effect` needs context because Svelte needs to know whether it should re-run // effects that invalidate themselves, and that's determined by whether we're in runes mode context.state.analysis.needs_context = true; break; case '$effect.tracking': if (node.arguments.length !== 0) { e.rune_invalid_arguments(node, rune); } break; case '$effect.root': if (node.arguments.length !== 1) { e.rune_invalid_arguments_length(node, rune, 'exactly one argument'); } break; case '$effect.pending': if (context.state.expression) { context.state.expression.has_state = true; } break; case '$inspect': if (node.arguments.length < 1) { e.rune_invalid_arguments_length(node, rune, 'one or more arguments'); } break; case '$inspect().with': if (node.arguments.length !== 1) { e.rune_invalid_arguments_length(node, rune, 'exactly one argument'); } break; case '$inspect.trace': { if (node.arguments.length > 1) { e.rune_invalid_arguments_length(node, rune, 'zero or one arguments'); } const grand_parent = context.path.at(-2); const fn = context.path.at(-3); if ( parent.type !== 'ExpressionStatement' || grand_parent?.type !== 'BlockStatement' || !( fn?.type === 'FunctionDeclaration' || fn?.type === 'FunctionExpression' || fn?.type === 'ArrowFunctionExpression' ) || grand_parent.body[0] !== parent ) { e.inspect_trace_invalid_placement(node); } if (fn.generator) { e.inspect_trace_generator(node); } if (dev) { if (node.arguments[0]) { context.state.scope.tracing = b.thunk(/** @type {Expression} */ (node.arguments[0])); } else { const label = get_function_label(context.path.slice(0, -2)) ?? 'trace'; const loc = `(${locate_node(fn)})`; context.state.scope.tracing = b.thunk(b.literal(label + ' ' + loc)); } context.state.analysis.tracing = true; } break; } case '$state.snapshot': if (node.arguments.length !== 1) { e.rune_invalid_arguments_length(node, rune, 'exactly one argument'); } break; } // `$inspect(foo)` or `$derived(foo) should not trigger the `static-state-reference` warning if (rune === '$derived') { const expression = create_expression_metadata(); context.next({ ...context.state, function_depth: context.state.function_depth + 1, expression }); if (expression.has_await) { context.state.analysis.async_deriveds.add(node); } } else if (rune === '$inspect') { context.next({ ...context.state, function_depth: context.state.function_depth + 1 }); } else { context.next(); } if (context.state.expression) { // TODO We assume that any dependencies are stateful, which isn't necessarily the case — see // https://github.com/sveltejs/svelte/issues/13266. This check also includes dependencies // outside the call expression itself (e.g. `{blah && pure()}`) resulting in additional // false positives, but for now we accept that trade-off if (!is_pure(node.callee, context) || context.state.expression.dependencies.size > 0) { context.state.expression.has_call = true; context.state.expression.has_state = true; } } } /** * @param {AST.SvelteNode[]} nodes */ function get_function_label(nodes) { const fn = /** @type {FunctionExpression | FunctionDeclaration | ArrowFunctionExpression} */ ( nodes.at(-1) ); if ((fn.type === 'FunctionDeclaration' || fn.type === 'FunctionExpression') && fn.id != null) { return fn.id.name; } const parent = nodes.at(-2); if (!parent) return; if (parent.type === 'CallExpression') { return source.slice(parent.callee.start, parent.callee.end) + '(...)'; } if (parent.type === 'Property' && !parent.computed) { return /** @type {Identifier} */ (parent.key).name; } if (parent.type === 'VariableDeclarator' && parent.id.type === 'Identifier') { return parent.id.name; } } /** * @param {AST.SvelteNode} parent * @param {Context} context */ function is_variable_declaration(parent, context) { return parent.type === 'VariableDeclarator' && get_parent(context.path, -3).type !== 'ConstTag'; } /** * @param {AST.SvelteNode} parent */ function is_class_property_definition(parent) { return parent.type === 'PropertyDefinition' && !parent.static && !parent.computed; } /** * @param {AST.SvelteNode} node * @param {Context} context */ function is_class_property_assignment_at_constructor_root(node, context) { if ( node.type === 'AssignmentExpression' && node.operator === '=' && node.left.type === 'MemberExpression' && node.left.object.type === 'ThisExpression' && ((node.left.property.type === 'Identifier' && !node.left.computed) || node.left.property.type === 'PrivateIdentifier' || node.left.property.type === 'Literal') ) { // MethodDefinition (-5) -> FunctionExpression (-4) -> BlockStatement (-3) -> ExpressionStatement (-2) -> AssignmentExpression (-1) const parent = get_parent(context.path, -5); return parent?.type === 'MethodDefinition' && parent.kind === 'constructor'; } return false; }
```

# compiler/phases/2-analyze/visitors/ClassBody.js

```js
/** @import { AssignmentExpression, CallExpression, ClassBody, PropertyDefinition, Expression, PrivateIdentifier, MethodDefinition } from 'estree' */ /** @import { StateField } from '#compiler' */ /** @import { Context } from '../types' */ import * as b from '#compiler/builders'; import { get_rune } from '../../scope.js'; import * as e from '../../../errors.js'; import { is_state_creation_rune } from '../../../../utils.js'; import { get_name } from '../../nodes.js'; import { regex_invalid_identifier_chars } from '../../patterns.js'; /** * @param {ClassBody} node * @param {Context} context */ export function ClassBody(node, context) { if (!context.state.analysis.runes) { context.next(); return; } /** @type {string[]} */ const private_ids = []; for (const prop of node.body) { if ( (prop.type === 'MethodDefinition' || prop.type === 'PropertyDefinition') && prop.key.type === 'PrivateIdentifier' ) { private_ids.push(prop.key.name); } } /** @type {Map<string, StateField>} */ const state_fields = new Map(); context.state.analysis.classes.set(node, state_fields); /** @type {MethodDefinition | null} */ let constructor = null; /** * @param {PropertyDefinition | AssignmentExpression} node * @param {Expression | PrivateIdentifier} key * @param {Expression | null | undefined} value */ function handle(node, key, value) { const name = get_name(key); if (name === null) return; const rune = get_rune(value, context.state.scope); if (rune && is_state_creation_rune(rune)) { if (state_fields.has(name)) { e.state_field_duplicate(node, name); } state_fields.set(name, { node, type: rune, // @ts-expect-error for public state this is filled out in a moment key: key.type === 'PrivateIdentifier' ? key : null, value: /** @type {CallExpression} */ (value) }); } } for (const child of node.body) { if (child.type === 'PropertyDefinition' && !child.computed && !child.static) { handle(child, child.key, child.value); } if (child.type === 'MethodDefinition' && child.kind === 'constructor') { constructor = child; } } if (constructor) { for (const statement of constructor.value.body.body) { if (statement.type !== 'ExpressionStatement') continue; if (statement.expression.type !== 'AssignmentExpression') continue; const { left, right } = statement.expression; if (left.type !== 'MemberExpression') continue; if (left.object.type !== 'ThisExpression') continue; if (left.computed && left.property.type !== 'Literal') continue; handle(statement.expression, left.property, right); } } for (const [name, field] of state_fields) { if (name[0] === '#') { continue; } let deconflicted = name.replace(regex_invalid_identifier_chars, '_'); while (private_ids.includes(deconflicted)) { deconflicted = '_' + deconflicted; } private_ids.push(deconflicted); field.key = b.private_id(deconflicted); } context.next({ ...context.state, state_fields }); }
```

# compiler/phases/2-analyze/visitors/ClassDeclaration.js

```js
/** @import { ClassDeclaration } from 'estree' */ /** @import { Context } from '../types' */ import * as w from '../../../warnings.js'; import { validate_identifier_name } from './shared/utils.js'; /** * @param {ClassDeclaration} node * @param {Context} context */ export function ClassDeclaration(node, context) { if (context.state.analysis.runes && node.id !== null) { validate_identifier_name(context.state.scope.get(node.id.name)); } // In modules, we allow top-level module scope only, in components, we allow the component scope, // which is function_depth of 1. With the exception of `new class` which is also not allowed at // component scope level either. const allowed_depth = context.state.ast_type === 'module' ? 0 : 1; if (context.state.scope.function_depth > allowed_depth) { w.perf_avoid_nested_class(node); } context.next(); }
```

# compiler/phases/2-analyze/visitors/ClassDirective.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { mark_subtree_dynamic } from './shared/fragment.js'; /** * @param {AST.ClassDirective} node * @param {Context} context */ export function ClassDirective(node, context) { mark_subtree_dynamic(context.path); context.next({ ...context.state, expression: node.metadata.expression }); }
```

# compiler/phases/2-analyze/visitors/Component.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { visit_component } from './shared/component.js'; /** * @param {AST.Component} node * @param {Context} context */ export function Component(node, context) { const binding = context.state.scope.get( node.name.includes('.') ? node.name.slice(0, node.name.indexOf('.')) : node.name ); node.metadata.dynamic = context.state.analysis.runes && // Svelte 4 required you to use svelte:component to switch components binding !== null && (binding.kind !== 'normal' || node.name.includes('.')); visit_component(node, context); }
```

# compiler/phases/2-analyze/visitors/ConstTag.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import * as e from '../../../errors.js'; import { validate_opening_tag } from './shared/utils.js'; /** * @param {AST.ConstTag} node * @param {Context} context */ export function ConstTag(node, context) { if (context.state.analysis.runes) { validate_opening_tag(node, context.state, '@'); } const parent = context.path.at(-1); const grand_parent = context.path.at(-2); if ( parent?.type !== 'Fragment' || (grand_parent?.type !== 'IfBlock' && grand_parent?.type !== 'SvelteFragment' && grand_parent?.type !== 'Component' && grand_parent?.type !== 'SvelteComponent' && grand_parent?.type !== 'EachBlock' && grand_parent?.type !== 'AwaitBlock' && grand_parent?.type !== 'SnippetBlock' && grand_parent?.type !== 'SvelteBoundary' && grand_parent?.type !== 'KeyBlock' && ((grand_parent?.type !== 'RegularElement' && grand_parent?.type !== 'SvelteElement') || !grand_parent.attributes.some((a) => a.type === 'Attribute' && a.name === 'slot'))) ) { e.const_tag_invalid_placement(node); } const declaration = node.declaration.declarations[0]; context.visit(declaration.id); context.visit(declaration.init, { ...context.state, expression: node.metadata.expression }); }
```

# compiler/phases/2-analyze/visitors/DebugTag.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { validate_opening_tag } from './shared/utils.js'; /** * @param {AST.DebugTag} node * @param {Context} context */ export function DebugTag(node, context) { if (context.state.analysis.runes) { validate_opening_tag(node, context.state, '@'); } context.next(); }
```

# compiler/phases/2-analyze/visitors/EachBlock.js

```js
/** @import { AST, Binding } from '#compiler' */ /** @import { Context } from '../types' */ /** @import { Scope } from '../../scope' */ import * as e from '../../../errors.js'; import { extract_identifiers } from '../../../utils/ast.js'; import { mark_subtree_dynamic } from './shared/fragment.js'; import { validate_block_not_empty, validate_opening_tag } from './shared/utils.js'; /** * @param {AST.EachBlock} node * @param {Context} context */ export function EachBlock(node, context) { validate_opening_tag(node, context.state, '#'); validate_block_not_empty(node.body, context); validate_block_not_empty(node.fallback, context); const id = node.context; if (id?.type === 'Identifier' && (id.name === '$state' || id.name === '$derived')) { // TODO weird that this is necessary e.state_invalid_placement(node, id.name); } if (node.key) { // treat `{#each items as item, i (i)}` as a normal indexed block, everything else as keyed node.metadata.keyed = node.key.type !== 'Identifier' || !node.index || node.key.name !== node.index; } // evaluate expression in parent scope context.visit(node.expression, { ...context.state, expression: node.metadata.expression, scope: /** @type {Scope} */ (context.state.scope.parent) }); context.visit(node.body); if (node.key) context.visit(node.key); if (node.fallback) context.visit(node.fallback); if (!context.state.analysis.runes) { let mutated = !!node.context && extract_identifiers(node.context).some((id) => { const binding = context.state.scope.get(id.name); return !!binding?.mutated; }); // collect transitive dependencies... for (const binding of node.metadata.expression.dependencies) { collect_transitive_dependencies(binding, node.metadata.transitive_deps); } // ...and ensure they are marked as state, so they can be turned // into mutable sources and invalidated if (mutated) { for (const binding of node.metadata.transitive_deps) { if ( binding.kind === 'normal' && (binding.declaration_kind === 'const' || binding.declaration_kind === 'let' || binding.declaration_kind === 'var') ) { binding.kind = 'state'; } } } } mark_subtree_dynamic(context.path); } /** * @param {Binding} binding * @param {Set<Binding>} bindings * @returns {void} */ function collect_transitive_dependencies(binding, bindings) { if (bindings.has(binding)) { return; } bindings.add(binding); if (binding.kind === 'legacy_reactive') { for (const dep of binding.legacy_dependencies) { collect_transitive_dependencies(dep, bindings); } } }
```

# compiler/phases/2-analyze/visitors/ExportDefaultDeclaration.js

```js
/** @import { ExportDefaultDeclaration } from 'estree' */ /** @import { Context } from '../types' */ import * as e from '../../../errors.js'; import { validate_export } from './shared/utils.js'; /** * @param {ExportDefaultDeclaration} node * @param {Context} context */ export function ExportDefaultDeclaration(node, context) { if (!context.state.ast_type /* .svelte.js module */) { if (node.declaration.type === 'Identifier') { validate_export(node, context.state.scope, node.declaration.name); } } else { e.module_illegal_default_export(node); } context.next(); }
```

# compiler/phases/2-analyze/visitors/ExportNamedDeclaration.js

```js
/** @import { ExportNamedDeclaration, Identifier } from 'estree' */ /** @import { Context } from '../types' */ import * as e from '../../../errors.js'; import { extract_identifiers } from '../../../utils/ast.js'; /** * @param {ExportNamedDeclaration} node * @param {Context} context */ export function ExportNamedDeclaration(node, context) { // visit children, so bindings are correctly initialised context.next(); if (node.declaration?.type === 'VariableDeclaration') { // in runes mode, forbid `export let` if ( context.state.analysis.runes && context.state.ast_type === 'instance' && node.declaration.kind === 'let' ) { e.legacy_export_invalid(node); } for (const declarator of node.declaration.declarations) { for (const id of extract_identifiers(declarator.id)) { const binding = context.state.scope.get(id.name); if (!binding) continue; if (binding.kind === 'derived') { e.derived_invalid_export(node); } if ((binding.kind === 'state' || binding.kind === 'raw_state') && binding.reassigned) { e.state_invalid_export(node); } } } } if (context.state.analysis.runes) { if (node.declaration && context.state.ast_type === 'instance') { if ( node.declaration.type === 'FunctionDeclaration' || node.declaration.type === 'ClassDeclaration' ) { context.state.analysis.exports.push({ name: /** @type {Identifier} */ (node.declaration.id).name, alias: null }); } else if (node.declaration.kind === 'const') { for (const declarator of node.declaration.declarations) { for (const node of extract_identifiers(declarator.id)) { context.state.analysis.exports.push({ name: node.name, alias: null }); } } } } } }
```

# compiler/phases/2-analyze/visitors/ExportSpecifier.js

```js
/** @import { ExportSpecifier } from 'estree' */ /** @import { Context } from '../types' */ import { validate_export } from './shared/utils.js'; /** * @param {ExportSpecifier} node * @param {Context} context */ export function ExportSpecifier(node, context) { const local_name = node.local.type === 'Identifier' ? node.local.name : /** @type {string} */ (node.local.value); const exported_name = node.exported.type === 'Identifier' ? node.exported.name : /** @type {string} */ (node.exported.value); if (context.state.ast_type === 'instance') { if (context.state.analysis.runes) { context.state.analysis.exports.push({ name: local_name, alias: exported_name }); const binding = context.state.scope.get(local_name); if (binding) binding.reassigned = true; } } else { validate_export(node, context.state.scope, local_name); } }
```

# compiler/phases/2-analyze/visitors/ExpressionStatement.js

```js
/** @import { ExpressionStatement, ImportDeclaration } from 'estree' */ /** @import { Context } from '../types' */ import * as w from '../../../warnings.js'; /** * @param {ExpressionStatement} node * @param {Context} context */ export function ExpressionStatement(node, context) { // warn on `new Component({ target: ... })` if imported from a `.svelte` file if ( node.expression.type === 'NewExpression' && node.expression.callee.type === 'Identifier' && node.expression.arguments.length === 1 && node.expression.arguments[0].type === 'ObjectExpression' && node.expression.arguments[0].properties.some( (p) => p.type === 'Property' && p.key.type === 'Identifier' && p.key.name === 'target' ) ) { const binding = context.state.scope.get(node.expression.callee.name); if (binding?.kind === 'normal' && binding.declaration_kind === 'import') { const declaration = /** @type {ImportDeclaration} */ (binding.initial); // Theoretically someone could import a class from a `.svelte.js` module, but that's too rare to worry about if ( /** @type {string} */ (declaration.source.value).endsWith('.svelte') && declaration.specifiers.find( (s) => s.local.name === binding.node.name && s.type === 'ImportDefaultSpecifier' ) ) { w.legacy_component_creation(node.expression); } } } context.next(); }
```

# compiler/phases/2-analyze/visitors/ExpressionTag.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { is_tag_valid_with_parent } from '../../../../html-tree-validation.js'; import * as e from '../../../errors.js'; import { mark_subtree_dynamic } from './shared/fragment.js'; /** * @param {AST.ExpressionTag} node * @param {Context} context */ export function ExpressionTag(node, context) { const in_template = context.path.at(-1)?.type === 'Fragment'; if (in_template && context.state.parent_element) { const message = is_tag_valid_with_parent('#text', context.state.parent_element); if (message) { e.node_invalid_placement(node, message); } } // TODO ideally we wouldn't do this here, we'd just do it on encountering // an `Identifier` within the tag. But we currently need to handle `{42}` etc mark_subtree_dynamic(context.path); context.next({ ...context.state, expression: node.metadata.expression }); }
```

# compiler/phases/2-analyze/visitors/FunctionDeclaration.js

```js
/** @import { FunctionDeclaration } from 'estree' */ /** @import { Context } from '../types' */ import { visit_function } from './shared/function.js'; import { validate_identifier_name } from './shared/utils.js'; /** * @param {FunctionDeclaration} node * @param {Context} context */ export function FunctionDeclaration(node, context) { if (context.state.analysis.runes && node.id !== null) { validate_identifier_name(context.state.scope.get(node.id.name)); } visit_function(node, context); }
```

# compiler/phases/2-analyze/visitors/FunctionExpression.js

```js
/** @import { FunctionExpression } from 'estree' */ /** @import { Context } from '../types' */ import { visit_function } from './shared/function.js'; /** * @param {FunctionExpression} node * @param {Context} context */ export function FunctionExpression(node, context) { visit_function(node, context); }
```

# compiler/phases/2-analyze/visitors/HtmlTag.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { mark_subtree_dynamic } from './shared/fragment.js'; import { validate_opening_tag } from './shared/utils.js'; /** * @param {AST.HtmlTag} node * @param {Context} context */ export function HtmlTag(node, context) { if (context.state.analysis.runes) { validate_opening_tag(node, context.state, '@'); } // unfortunately this is necessary in order to fix invalid HTML mark_subtree_dynamic(context.path); context.next({ ...context.state, expression: node.metadata.expression }); }
```

# compiler/phases/2-analyze/visitors/Identifier.js

```js
/** @import { Expression, Identifier } from 'estree' */ /** @import { Context } from '../types' */ import is_reference from 'is-reference'; import { should_proxy } from '../../3-transform/client/utils.js'; import * as e from '../../../errors.js'; import * as w from '../../../warnings.js'; import { is_rune } from '../../../../utils.js'; import { mark_subtree_dynamic } from './shared/fragment.js'; import { get_rune } from '../../scope.js'; /** * @param {Identifier} node * @param {Context} context */ export function Identifier(node, context) { let i = context.path.length; let parent = /** @type {Expression} */ (context.path[--i]); if (!is_reference(node, parent)) { return; } mark_subtree_dynamic(context.path); // If we are using arguments outside of a function, then throw an error if ( node.name === 'arguments' && !context.path.some((n) => n.type === 'FunctionDeclaration' || n.type === 'FunctionExpression') ) { e.invalid_arguments_usage(node); } // `$$slots` exists even in runes mode if (node.name === '$$slots') { context.state.analysis.uses_slots = true; } if (context.state.analysis.runes) { if ( is_rune(node.name) && context.state.scope.get(node.name) === null && context.state.scope.get(node.name.slice(1))?.kind !== 'store_sub' ) { /** @type {Expression} */ let current = node; let name = node.name; while (parent.type === 'MemberExpression') { if (parent.computed) e.rune_invalid_computed_property(parent); name += `.${/** @type {Identifier} */ (parent.property).name}`; current = parent; parent = /** @type {Expression} */ (context.path[--i]); if (!is_rune(name)) { if (name === '$effect.active') { e.rune_renamed(parent, '$effect.active', '$effect.tracking'); } if (name === '$state.frozen') { e.rune_renamed(parent, '$state.frozen', '$state.raw'); } if (name === '$state.is') { e.rune_removed(parent, '$state.is'); } e.rune_invalid_name(parent, name); } } if (parent.type !== 'CallExpression') { e.rune_missing_parentheses(current); } } } let binding = context.state.scope.get(node.name); if (!context.state.analysis.runes) { if (node.name === '$$props') { context.state.analysis.uses_props = true; } if (node.name === '$$restProps') { context.state.analysis.uses_rest_props = true; } } if (binding) { if (context.state.expression) { context.state.expression.dependencies.add(binding); context.state.expression.references.add(binding); context.state.expression.has_state ||= binding.kind !== 'static' && !binding.is_function() && !context.state.scope.evaluate(node).is_known; } if ( context.state.analysis.runes && node !== binding.node && context.state.function_depth === binding.scope.function_depth && // If we have $state that can be proxied or frozen and isn't re-assigned, then that means // it's likely not using a primitive value and thus this warning isn't that helpful. ((binding.kind === 'state' && (binding.reassigned || (binding.initial?.type === 'CallExpression' && binding.initial.arguments.length === 1 && binding.initial.arguments[0].type !== 'SpreadElement' && !should_proxy(binding.initial.arguments[0], context.state.scope)))) || binding.kind === 'raw_state' || binding.kind === 'derived') && // We're only concerned with reads here (parent.type !== 'AssignmentExpression' || parent.left !== node) && parent.type !== 'UpdateExpression' ) { let type = 'closure'; let i = context.path.length; while (i--) { const parent = context.path[i]; if ( parent.type === 'ArrowFunctionExpression' || parent.type === 'FunctionDeclaration' || parent.type === 'FunctionExpression' ) { break; } if ( parent.type === 'CallExpression' && parent.arguments.includes(/** @type {any} */ (context.path[i + 1])) ) { const rune = get_rune(parent, context.state.scope); if (rune === '$state' || rune === '$state.raw') { type = 'derived'; break; } } } w.state_referenced_locally(node, node.name, type); } if ( context.state.reactive_statement && binding.scope === context.state.analysis.module.scope && binding.reassigned ) { w.reactive_declaration_module_script_dependency(node); } } }
```

# compiler/phases/2-analyze/visitors/IfBlock.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { mark_subtree_dynamic } from './shared/fragment.js'; import { validate_block_not_empty, validate_opening_tag } from './shared/utils.js'; /** * @param {AST.IfBlock} node * @param {Context} context */ export function IfBlock(node, context) { validate_block_not_empty(node.consequent, context); validate_block_not_empty(node.alternate, context); if (context.state.analysis.runes) { validate_opening_tag(node, context.state, node.elseif ? ':' : '#'); } mark_subtree_dynamic(context.path); context.visit(node.test, { ...context.state, expression: node.metadata.expression }); context.visit(node.consequent); if (node.alternate) context.visit(node.alternate); }
```

# compiler/phases/2-analyze/visitors/ImportDeclaration.js

```js
/** @import { ImportDeclaration } from 'estree' */ /** @import { Context } from '../types' */ import * as e from '../../../errors.js'; /** * @param {ImportDeclaration} node * @param {Context} context */ export function ImportDeclaration(node, context) { if (context.state.analysis.runes) { const source = /** @type {string} */ (node.source.value); if (source.startsWith('svelte/internal')) { e.import_svelte_internal_forbidden(node); } if (source === 'svelte') { for (const specifier of node.specifiers) { if (specifier.type === 'ImportSpecifier') { if ( specifier.imported.type === 'Identifier' && (specifier.imported.name === 'beforeUpdate' || specifier.imported.name === 'afterUpdate') ) { e.runes_mode_invalid_import(specifier, specifier.imported.name); } } } } } }
```

# compiler/phases/2-analyze/visitors/KeyBlock.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { mark_subtree_dynamic } from './shared/fragment.js'; import { validate_block_not_empty, validate_opening_tag } from './shared/utils.js'; /** * @param {AST.KeyBlock} node * @param {Context} context */ export function KeyBlock(node, context) { validate_block_not_empty(node.fragment, context); if (context.state.analysis.runes) { validate_opening_tag(node, context.state, '#'); } mark_subtree_dynamic(context.path); context.visit(node.expression, { ...context.state, expression: node.metadata.expression }); context.visit(node.fragment); }
```

# compiler/phases/2-analyze/visitors/LabeledStatement.js

```js
/** @import { Expression, LabeledStatement } from 'estree' */ /** @import { AST, ReactiveStatement } from '#compiler' */ /** @import { Context } from '../types' */ import * as e from '../../../errors.js'; import { extract_identifiers, object } from '../../../utils/ast.js'; import * as w from '../../../warnings.js'; /** * @param {LabeledStatement} node * @param {Context} context */ export function LabeledStatement(node, context) { if (node.label.name === '$') { const parent = /** @type {AST.SvelteNode} */ (context.path.at(-1)); const is_reactive_statement = context.state.ast_type === 'instance' && parent.type === 'Program'; if (is_reactive_statement) { if (context.state.analysis.runes) { e.legacy_reactive_statement_invalid(node); } // Find all dependencies of this `$: {...}` statement /** @type {ReactiveStatement} */ const reactive_statement = { assignments: new Set(), dependencies: [] }; context.next({ ...context.state, reactive_statement, function_depth: context.state.scope.function_depth + 1 }); // Every referenced binding becomes a dependency, unless it's on // the left-hand side of an `=` assignment for (const [name, nodes] of context.state.scope.references) { const binding = context.state.scope.get(name); if (binding === null) continue; for (const { node, path } of nodes) { /** @type {Expression} */ let left = node; let i = path.length - 1; let parent = /** @type {Expression} */ (path.at(i)); while (parent.type === 'MemberExpression') { left = parent; parent = /** @type {Expression} */ (path.at(--i)); } if ( parent.type === 'AssignmentExpression' && parent.operator === '=' && parent.left === left ) { continue; } reactive_statement.dependencies.push(binding); break; } } context.state.analysis.reactive_statements.set(node, reactive_statement); if ( node.body.type === 'ExpressionStatement' && node.body.expression.type === 'AssignmentExpression' ) { let ids = extract_identifiers(node.body.expression.left); if (node.body.expression.left.type === 'MemberExpression') { const id = object(node.body.expression.left); if (id !== null) { ids = [id]; } } for (const id of ids) { const binding = context.state.scope.get(id.name); if (binding?.kind === 'legacy_reactive') { // TODO does this include `let double; $: double = x * 2`? binding.legacy_dependencies = Array.from(reactive_statement.dependencies); } } } } else if (!context.state.analysis.runes) { w.reactive_declaration_invalid_placement(node); } } context.next(); }
```

# compiler/phases/2-analyze/visitors/LetDirective.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import * as e from '../../../errors.js'; /** * @param {AST.LetDirective} node * @param {Context} context */ export function LetDirective(node, context) { const parent = context.path.at(-1); if ( parent === undefined || (parent.type !== 'Component' && parent.type !== 'RegularElement' && parent.type !== 'SlotElement' && parent.type !== 'SvelteElement' && parent.type !== 'SvelteComponent' && parent.type !== 'SvelteSelf' && parent.type !== 'SvelteFragment') ) { e.let_directive_invalid_placement(node); } }
```

# compiler/phases/2-analyze/visitors/Literal.js

```js
/** @import { Literal } from 'estree' */ import * as w from '../../../warnings.js'; import { regex_bidirectional_control_characters } from '../../patterns.js'; /** * @param {Literal} node */ export function Literal(node) { if (typeof node.value === 'string') { if (regex_bidirectional_control_characters.test(node.value)) { w.bidirectional_control_characters(node); } } }
```

# compiler/phases/2-analyze/visitors/MemberExpression.js

```js
/** @import { MemberExpression } from 'estree' */ /** @import { Context } from '../types' */ import * as e from '../../../errors.js'; import { is_pure, is_safe_identifier } from './shared/utils.js'; /** * @param {MemberExpression} node * @param {Context} context */ export function MemberExpression(node, context) { if (node.object.type === 'Identifier' && node.property.type === 'Identifier') { const binding = context.state.scope.get(node.object.name); if (binding?.kind === 'rest_prop' && node.property.name.startsWith('$$')) { e.props_illegal_name(node.property); } } if (context.state.expression) { context.state.expression.has_member_expression = true; context.state.expression.has_state ||= !is_pure(node, context); } if (!is_safe_identifier(node, context.state.scope)) { context.state.analysis.needs_context = true; } context.next(); }
```

# compiler/phases/2-analyze/visitors/NewExpression.js

```js
/** @import { NewExpression } from 'estree' */ /** @import { Context } from '../types' */ import * as w from '../../../warnings.js'; /** * @param {NewExpression} node * @param {Context} context */ export function NewExpression(node, context) { if (node.callee.type === 'ClassExpression' && context.state.scope.function_depth > 0) { w.perf_avoid_inline_class(node); } context.state.analysis.needs_context = true; context.next(); }
```

# compiler/phases/2-analyze/visitors/OnDirective.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import * as w from '../../../warnings.js'; import { mark_subtree_dynamic } from './shared/fragment.js'; /** * @param {AST.OnDirective} node * @param {Context} context */ export function OnDirective(node, context) { if (context.state.analysis.runes) { const parent_type = context.path.at(-1)?.type; // Don't warn on component events; these might not be under the author's control so the warning would be unactionable if (parent_type === 'RegularElement' || parent_type === 'SvelteElement') { w.event_directive_deprecated(node, node.name); } } const parent = context.path.at(-1); if (parent?.type === 'SvelteElement' || parent?.type === 'RegularElement') { context.state.analysis.event_directive_node ??= node; } mark_subtree_dynamic(context.path); context.next({ ...context.state, expression: node.metadata.expression }); }
```

# compiler/phases/2-analyze/visitors/PropertyDefinition.js

```js
/** @import { PropertyDefinition } from 'estree' */ /** @import { Context } from '../types' */ import * as e from '../../../errors.js'; import { get_name } from '../../nodes.js'; /** * @param {PropertyDefinition} node * @param {Context} context */ export function PropertyDefinition(node, context) { const name = get_name(node.key); const field = name && context.state.state_fields.get(name); if (field && node !== field.node && node.value) { if (/** @type {number} */ (node.start) < /** @type {number} */ (field.node.start)) { e.state_field_invalid_assignment(node); } } context.next(); }
```

# compiler/phases/2-analyze/visitors/RegularElement.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { is_mathml, is_svg, is_void } from '../../../../utils.js'; import { is_tag_valid_with_ancestor, is_tag_valid_with_parent } from '../../../../html-tree-validation.js'; import * as e from '../../../errors.js'; import * as w from '../../../warnings.js'; import { create_attribute, is_custom_element_node } from '../../nodes.js'; import { regex_starts_with_newline } from '../../patterns.js'; import { check_element } from './shared/a11y/index.js'; import { validate_element } from './shared/element.js'; import { mark_subtree_dynamic } from './shared/fragment.js'; /** * @param {AST.RegularElement} node * @param {Context} context */ export function RegularElement(node, context) { validate_element(node, context); check_element(node, context); node.metadata.path = [...context.path]; context.state.analysis.elements.push(node); // Special case: Move the children of <textarea> into a value attribute if they are dynamic if (node.name === 'textarea' && node.fragment.nodes.length > 0) { for (const attribute of node.attributes) { if (attribute.type === 'Attribute' && attribute.name === 'value') { e.textarea_invalid_content(node); } } if (node.fragment.nodes.length > 1 || node.fragment.nodes[0].type !== 'Text') { const first = node.fragment.nodes[0]; if (first.type === 'Text') { // The leading newline character needs to be stripped because of a qirk: // It is ignored by browsers if the tag and its contents are set through // innerHTML, but we're now setting it through the value property at which // point it is _not_ ignored, so we need to strip it ourselves. // see https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions // see https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element first.data = first.data.replace(regex_starts_with_newline, ''); first.raw = first.raw.replace(regex_starts_with_newline, ''); } node.attributes.push( create_attribute( 'value', /** @type {AST.Text} */ (node.fragment.nodes.at(0)).start, /** @type {AST.Text} */ (node.fragment.nodes.at(-1)).end, // @ts-ignore node.fragment.nodes ) ); node.fragment.nodes = []; } } // Special case: single expression tag child of option element -> add "fake" attribute // to ensure that value types are the same (else for example numbers would be strings) if ( node.name === 'option' && node.fragment.nodes?.length === 1 && node.fragment.nodes[0].type === 'ExpressionTag' && !node.attributes.some( (attribute) => attribute.type === 'Attribute' && attribute.name === 'value' ) ) { const child = node.fragment.nodes[0]; node.attributes.push(create_attribute('value', child.start, child.end, [child])); } const binding = context.state.scope.get(node.name); if ( binding !== null && binding.declaration_kind === 'import' && binding.references.length === 0 ) { w.component_name_lowercase(node, node.name); } node.metadata.has_spread = node.attributes.some( (attribute) => attribute.type === 'SpreadAttribute' ); const is_svg_element = () => { if (is_svg(node.name)) { return true; } if (node.name === 'a' || node.name === 'title') { let i = context.path.length; while (i--) { const ancestor = context.path[i]; if (ancestor.type === 'RegularElement') { return ancestor.metadata.svg; } } } return false; }; node.metadata.svg = is_svg_element(); node.metadata.mathml = is_mathml(node.name); if (is_custom_element_node(node) && node.attributes.length > 0) { // we're setting all attributes on custom elements through properties mark_subtree_dynamic(context.path); } if (context.state.parent_element) { let past_parent = false; let only_warn = false; const ancestors = [context.state.parent_element]; for (let i = context.path.length - 1; i >= 0; i--) { const ancestor = context.path[i]; if ( ancestor.type === 'IfBlock' || ancestor.type === 'EachBlock' || ancestor.type === 'AwaitBlock' || ancestor.type === 'KeyBlock' ) { // We're creating a separate template string inside blocks, which means client-side this would work only_warn = true; } if (!past_parent) { if (ancestor.type === 'RegularElement' && ancestor.name === context.state.parent_element) { const message = is_tag_valid_with_parent(node.name, context.state.parent_element); if (message) { if (only_warn) { w.node_invalid_placement_ssr(node, message); } else { e.node_invalid_placement(node, message); } } past_parent = true; } } else if (ancestor.type === 'RegularElement') { ancestors.push(ancestor.name); const message = is_tag_valid_with_ancestor(node.name, ancestors); if (message) { if (only_warn) { w.node_invalid_placement_ssr(node, message); } else { e.node_invalid_placement(node, message); } } } else if ( ancestor.type === 'Component' || ancestor.type === 'SvelteComponent' || ancestor.type === 'SvelteElement' || ancestor.type === 'SvelteSelf' || ancestor.type === 'SnippetBlock' ) { break; } } } // Strip off any namespace from the beginning of the node name. const node_name = node.name.replace(/[a-zA-Z-]*:/g, ''); if ( context.state.analysis.source[node.end - 2] === '/' && !is_void(node_name) && !is_svg(node_name) && !is_mathml(node_name) ) { w.element_invalid_self_closing_tag(node, node.name); } context.next({ ...context.state, parent_element: node.name }); // Special case: <a> tags are valid in both the SVG and HTML namespace. // If there's no parent, look downwards to see if it's the parent of a SVG or HTML element. if (node.name === 'a' && !context.state.parent_element) { for (const child of node.fragment.nodes) { if (child.type === 'RegularElement') { if (child.metadata.svg && child.name !== 'svg') { node.metadata.svg = true; break; } } } } }
```

# compiler/phases/2-analyze/visitors/RenderTag.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { unwrap_optional } from '../../../utils/ast.js'; import * as e from '../../../errors.js'; import { validate_opening_tag } from './shared/utils.js'; import { mark_subtree_dynamic } from './shared/fragment.js'; import { is_resolved_snippet } from './shared/snippets.js'; import { create_expression_metadata } from '../../nodes.js'; /** * @param {AST.RenderTag} node * @param {Context} context */ export function RenderTag(node, context) { validate_opening_tag(node, context.state, '@'); node.metadata.path = [...context.path]; const expression = unwrap_optional(node.expression); const callee = expression.callee; const binding = callee.type === 'Identifier' ? context.state.scope.get(callee.name) : null; node.metadata.dynamic = binding?.kind !== 'normal'; /** * If we can't unambiguously resolve this to a declaration, we * must assume the worst and link the render tag to every snippet */ let resolved = callee.type === 'Identifier' && is_resolved_snippet(binding); if (binding?.initial?.type === 'SnippetBlock') { // if this render tag unambiguously references a local snippet, our job is easy node.metadata.snippets.add(binding.initial); } context.state.analysis.snippet_renderers.set(node, resolved); context.state.analysis.uses_render_tags = true; const raw_args = unwrap_optional(node.expression).arguments; for (const arg of raw_args) { if (arg.type === 'SpreadElement') { e.render_tag_invalid_spread_argument(arg); } } if ( callee.type === 'MemberExpression' && callee.property.type === 'Identifier' && ['bind', 'apply', 'call'].includes(callee.property.name) ) { e.render_tag_invalid_call_expression(node); } mark_subtree_dynamic(context.path); context.visit(callee, { ...context.state, expression: node.metadata.expression }); for (const arg of expression.arguments) { const metadata = create_expression_metadata(); node.metadata.arguments.push(metadata); context.visit(arg, { ...context.state, expression: metadata }); } }
```

# compiler/phases/2-analyze/visitors/shared/a11y/constants.js

```js
/** @import { ARIARoleRelationConcept } from 'aria-query' */ import { roles as roles_map, elementRoles } from 'aria-query'; // @ts-expect-error package doesn't provide typings import { AXObjects, elementAXObjects } from 'axobject-query'; export const aria_attributes = 'activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext'.split( ' ' ); /** @type {Record<string, string[]>} */ export const a11y_required_attributes = { a: ['href'], area: ['alt', 'aria-label', 'aria-labelledby'], // html-has-lang html: ['lang'], // iframe-has-title iframe: ['title'], img: ['alt'], object: ['title', 'aria-label', 'aria-labelledby'] }; export const a11y_distracting_elements = ['blink', 'marquee']; // this excludes `<a>` and `<button>` because they are handled separately export const a11y_required_content = [ // heading-has-content 'h1', 'h2', 'h3', 'h4', 'h5', 'h6' ]; export const a11y_labelable = [ 'button', 'input', 'keygen', 'meter', 'output', 'progress', 'select', 'textarea' ]; export const a11y_interactive_handlers = [ // Keyboard events 'keypress', 'keydown', 'keyup', // Click events 'click', 'contextmenu', 'dblclick', 'drag', 'dragend', 'dragenter', 'dragexit', 'dragleave', 'dragover', 'dragstart', 'drop', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseout', 'mouseover', 'mouseup' ]; export const a11y_recommended_interactive_handlers = [ 'click', 'mousedown', 'mouseup', 'keypress', 'keydown', 'keyup' ]; export const a11y_nested_implicit_semantics = new Map([ ['header', 'banner'], ['footer', 'contentinfo'] ]); export const a11y_implicit_semantics = new Map([ ['a', 'link'], ['area', 'link'], ['article', 'article'], ['aside', 'complementary'], ['body', 'document'], ['button', 'button'], ['datalist', 'listbox'], ['dd', 'definition'], ['dfn', 'term'], ['dialog', 'dialog'], ['details', 'group'], ['dt', 'term'], ['fieldset', 'group'], ['figure', 'figure'], ['form', 'form'], ['h1', 'heading'], ['h2', 'heading'], ['h3', 'heading'], ['h4', 'heading'], ['h5', 'heading'], ['h6', 'heading'], ['hr', 'separator'], ['img', 'img'], ['li', 'listitem'], ['link', 'link'], ['main', 'main'], ['menu', 'list'], ['meter', 'progressbar'], ['nav', 'navigation'], ['ol', 'list'], ['option', 'option'], ['optgroup', 'group'], ['output', 'status'], ['progress', 'progressbar'], ['section', 'region'], ['summary', 'button'], ['table', 'table'], ['tbody', 'rowgroup'], ['textarea', 'textbox'], ['tfoot', 'rowgroup'], ['thead', 'rowgroup'], ['tr', 'row'], ['ul', 'list'] ]); export const menuitem_type_to_implicit_role = new Map([ ['command', 'menuitem'], ['checkbox', 'menuitemcheckbox'], ['radio', 'menuitemradio'] ]); export const input_type_to_implicit_role = new Map([ ['button', 'button'], ['image', 'button'], ['reset', 'button'], ['submit', 'button'], ['checkbox', 'checkbox'], ['radio', 'radio'], ['range', 'slider'], ['number', 'spinbutton'], ['email', 'textbox'], ['search', 'searchbox'], ['tel', 'textbox'], ['text', 'textbox'], ['url', 'textbox'] ]); /** * Exceptions to the rule which follows common A11y conventions * TODO make this configurable by the user * @type {Record<string, string[]>} */ export const a11y_non_interactive_element_to_interactive_role_exceptions = { ul: ['listbox', 'menu', 'menubar', 'radiogroup', 'tablist', 'tree', 'treegrid'], ol: ['listbox', 'menu', 'menubar', 'radiogroup', 'tablist', 'tree', 'treegrid'], li: ['menuitem', 'option', 'row', 'tab', 'treeitem'], table: ['grid'], td: ['gridcell'], fieldset: ['radiogroup', 'presentation'] }; export const combobox_if_list = ['email', 'search', 'tel', 'text', 'url']; // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofilling-form-controls:-the-autocomplete-attribute export const address_type_tokens = ['shipping', 'billing']; export const autofill_field_name_tokens = [ '', 'on', 'off', 'name', 'honorific-prefix', 'given-name', 'additional-name', 'family-name', 'honorific-suffix', 'nickname', 'username', 'new-password', 'current-password', 'one-time-code', 'organization-title', 'organization', 'street-address', 'address-line1', 'address-line2', 'address-line3', 'address-level4', 'address-level3', 'address-level2', 'address-level1', 'country', 'country-name', 'postal-code', 'cc-name', 'cc-given-name', 'cc-additional-name', 'cc-family-name', 'cc-number', 'cc-exp', 'cc-exp-month', 'cc-exp-year', 'cc-csc', 'cc-type', 'transaction-currency', 'transaction-amount', 'language', 'bday', 'bday-day', 'bday-month', 'bday-year', 'sex', 'url', 'photo' ]; export const contact_type_tokens = ['home', 'work', 'mobile', 'fax', 'pager']; export const autofill_contact_field_name_tokens = [ 'tel', 'tel-country-code', 'tel-national', 'tel-area-code', 'tel-local', 'tel-local-prefix', 'tel-local-suffix', 'tel-extension', 'email', 'impp' ]; export const ElementInteractivity = /** @type {const} */ ({ Interactive: 'interactive', NonInteractive: 'non-interactive', Static: 'static' }); export const invisible_elements = ['meta', 'html', 'script', 'style']; export const aria_roles = roles_map.keys(); export const abstract_roles = aria_roles.filter((role) => roles_map.get(role)?.abstract); const non_abstract_roles = aria_roles.filter((name) => !abstract_roles.includes(name)); export const non_interactive_roles = non_abstract_roles .filter((name) => { const role = roles_map.get(name); return ( // 'toolbar' does not descend from widget, but it does support // aria-activedescendant, thus in practice we treat it as a widget. // focusable tabpanel elements are recommended if any panels in a set contain content where the first element in the panel is not focusable. // 'generic' is meant to have no semantic meaning. // 'cell' is treated as CellRole by the AXObject which is interactive, so we treat 'cell' it as interactive as well. !['toolbar', 'tabpanel', 'generic', 'cell'].includes(name) && !role?.superClass.some((classes) => classes.includes('widget') || classes.includes('window')) ); }) .concat( // The `progressbar` is descended from `widget`, but in practice, its // value is always `readonly`, so we treat it as a non-interactive role. 'progressbar' ); export const interactive_roles = non_abstract_roles.filter( (name) => !non_interactive_roles.includes(name) && // 'generic' is meant to have no semantic meaning. name !== 'generic' ); export const presentation_roles = ['presentation', 'none']; /** @type {ARIARoleRelationConcept[]} */ export const non_interactive_element_role_schemas = []; /** @type {ARIARoleRelationConcept[]} */ export const interactive_element_role_schemas = []; for (const [schema, roles] of elementRoles.entries()) { if ([...roles].every((role) => role !== 'generic' && non_interactive_roles.includes(role))) { non_interactive_element_role_schemas.push(schema); } if ([...roles].every((role) => interactive_roles.includes(role))) { interactive_element_role_schemas.push(schema); } } const interactive_ax_objects = [...AXObjects.keys()].filter( (name) => AXObjects.get(name).type === 'widget' ); /** @type {ARIARoleRelationConcept[]} */ export const interactive_element_ax_object_schemas = []; /** @type {ARIARoleRelationConcept[]} */ export const non_interactive_element_ax_object_schemas = []; const non_interactive_ax_objects = [...AXObjects.keys()].filter((name) => ['windows', 'structure'].includes(AXObjects.get(name).type) ); for (const [schema, ax_object] of elementAXObjects.entries()) { if ([...ax_object].every((role) => interactive_ax_objects.includes(role))) { interactive_element_ax_object_schemas.push(schema); } if ([...ax_object].every((role) => non_interactive_ax_objects.includes(role))) { non_interactive_element_ax_object_schemas.push(schema); } }
```

# compiler/phases/2-analyze/visitors/shared/a11y/index.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../../../types.js' */ /** @import { ARIARoleDefinitionKey, ARIARoleRelationConcept, ARIAProperty, ARIAPropertyDefinition, ARIARoleDefinition } from 'aria-query' */ import { a11y_distracting_elements, a11y_implicit_semantics, a11y_interactive_handlers, a11y_labelable, a11y_nested_implicit_semantics, a11y_non_interactive_element_to_interactive_role_exceptions, a11y_recommended_interactive_handlers, a11y_required_attributes, a11y_required_content, abstract_roles, address_type_tokens, aria_attributes, aria_roles, autofill_contact_field_name_tokens, autofill_field_name_tokens, combobox_if_list, contact_type_tokens, ElementInteractivity, input_type_to_implicit_role, interactive_element_ax_object_schemas, interactive_element_role_schemas, interactive_roles, invisible_elements, menuitem_type_to_implicit_role, non_interactive_element_ax_object_schemas, non_interactive_element_role_schemas, non_interactive_roles, presentation_roles } from './constants.js'; import { roles as roles_map, aria } from 'aria-query'; // @ts-expect-error package doesn't provide typings import { AXObjectRoles, elementAXObjects } from 'axobject-query'; import { regex_heading_tags, regex_js_prefix, regex_not_whitespace, regex_redundant_img_alt, regex_starts_with_vowel, regex_whitespaces } from '../../../../patterns.js'; import { is_event_attribute, is_text_attribute } from '../../../../../utils/ast.js'; import { list } from '../../../../../utils/string.js'; import { walk } from 'zimmerframe'; import fuzzymatch from '../../../../1-parse/utils/fuzzymatch.js'; import { is_content_editable_binding } from '../../../../../../utils.js'; import * as w from '../../../../../warnings.js'; /** * @param {AST.RegularElement | AST.SvelteElement} node * @param {Context} context */ export function check_element(node, context) { /** @type {Map<string, AST.Attribute>} */ const attribute_map = new Map(); /** @type {Set<string>} */ const handlers = new Set(); /** @type {AST.Attribute[]} */ const attributes = []; const is_dynamic_element = node.type === 'SvelteElement'; let has_spread = false; let has_contenteditable_attr = false; let has_contenteditable_binding = false; for (const attribute of node.attributes) { switch (attribute.type) { case 'Attribute': { if (is_event_attribute(attribute)) { handlers.add(attribute.name.slice(2)); } else { attributes.push(attribute); attribute_map.set(attribute.name, attribute); if (attribute.name === 'contenteditable') { has_contenteditable_attr = true; } } break; } case 'SpreadAttribute': { has_spread = true; break; } case 'BindDirective': { if (is_content_editable_binding(attribute.name)) { has_contenteditable_binding = true; } break; } case 'OnDirective': { handlers.add(attribute.name); break; } } } for (const attribute of node.attributes) { if (attribute.type !== 'Attribute') continue; const name = attribute.name.toLowerCase(); // aria-props if (name.startsWith('aria-')) { if (invisible_elements.includes(node.name)) { // aria-unsupported-elements w.a11y_aria_attributes(attribute, node.name); } const type = name.slice(5); if (!aria_attributes.includes(type)) { const match = fuzzymatch(type, aria_attributes); w.a11y_unknown_aria_attribute(attribute, type, match); } if (name === 'aria-hidden' && regex_heading_tags.test(node.name)) { w.a11y_hidden(attribute, node.name); } // aria-proptypes let value = get_static_value(attribute); const schema = aria.get(/** @type {ARIAProperty} */ (name)); if (schema !== undefined) { validate_aria_attribute_value(attribute, /** @type {ARIAProperty} */ (name), schema, value); } // aria-activedescendant-has-tabindex if ( name === 'aria-activedescendant' && !is_dynamic_element && !is_interactive_element(node.name, attribute_map) && !attribute_map.has('tabindex') && !has_spread ) { w.a11y_aria_activedescendant_has_tabindex(attribute); } } switch (name) { // aria-role case 'role': { if (invisible_elements.includes(node.name)) { // aria-unsupported-elements w.a11y_misplaced_role(attribute, node.name); } const value = get_static_value(attribute); if (typeof value !== 'string') { break; } for (const c_r of value.split(regex_whitespaces)) { const current_role = /** @type {ARIARoleDefinitionKey} current_role */ (c_r); if (current_role && is_abstract_role(current_role)) { w.a11y_no_abstract_role(attribute, current_role); } else if (current_role && !aria_roles.includes(current_role)) { const match = fuzzymatch(current_role, aria_roles); w.a11y_unknown_role(attribute, current_role, match); } // no-redundant-roles if ( current_role === get_implicit_role(node.name, attribute_map) && // <ul role="list"> is ok because CSS list-style:none removes the semantics and this is a way to bring them back !['ul', 'ol', 'li'].includes(node.name) && // <a role="link" /> is ok because without href the a tag doesn't have a role of link !(node.name === 'a' && !attribute_map.has('href')) ) { w.a11y_no_redundant_roles(attribute, current_role); } // Footers and headers are special cases, and should not have redundant roles unless they are the children of sections or articles. const is_parent_section_or_article = is_parent(context.path, ['section', 'article']); if (!is_parent_section_or_article) { const has_nested_redundant_role = current_role === a11y_nested_implicit_semantics.get(node.name); if (has_nested_redundant_role) { w.a11y_no_redundant_roles(attribute, current_role); } } // role-has-required-aria-props if ( !is_dynamic_element && !is_semantic_role_element(current_role, node.name, attribute_map) ) { const role = roles_map.get(current_role); if (role) { const required_role_props = Object.keys(role.requiredProps); const has_missing_props = !has_spread && required_role_props.some((prop) => !attributes.find((a) => a.name === prop)); if (has_missing_props) { w.a11y_role_has_required_aria_props( attribute, current_role, list( required_role_props.map((v) => `"${v}"`), 'and' ) ); } } } // interactive-supports-focus if ( !has_spread && !has_disabled_attribute(attribute_map) && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(current_role) && is_interactive_roles(current_role) && is_static_element(node.name, attribute_map) && !attribute_map.get('tabindex') ) { const has_interactive_handlers = [...handlers].some((handler) => a11y_interactive_handlers.includes(handler) ); if (has_interactive_handlers) { w.a11y_interactive_supports_focus(node, current_role); } } // no-interactive-element-to-noninteractive-role if ( !has_spread && is_interactive_element(node.name, attribute_map) && (is_non_interactive_roles(current_role) || is_presentation_role(current_role)) ) { w.a11y_no_interactive_element_to_noninteractive_role(node, node.name, current_role); } // no-noninteractive-element-to-interactive-role if ( !has_spread && is_non_interactive_element(node.name, attribute_map) && is_interactive_roles(current_role) && !a11y_non_interactive_element_to_interactive_role_exceptions[node.name]?.includes( current_role ) ) { w.a11y_no_noninteractive_element_to_interactive_role(node, node.name, current_role); } } break; } // no-access-key case 'accesskey': { w.a11y_accesskey(attribute); break; } // no-autofocus case 'autofocus': { if (node.name !== 'dialog' && !is_parent(context.path, ['dialog'])) { w.a11y_autofocus(attribute); } break; } // scope case 'scope': { if (!is_dynamic_element && node.name !== 'th') { w.a11y_misplaced_scope(attribute); } break; } // tabindex-no-positive case 'tabindex': { const value = get_static_value(attribute); // @ts-ignore todo is tabindex=true correct case? if (!isNaN(value) && +value > 0) { w.a11y_positive_tabindex(attribute); } break; } } } const role = attribute_map.get('role'); const role_static_value = /** @type {ARIARoleDefinitionKey} */ (get_static_text_value(role)); // click-events-have-key-events if (handlers.has('click')) { const is_non_presentation_role = role_static_value !== null && !is_presentation_role(role_static_value); if ( !is_dynamic_element && !is_hidden_from_screen_reader(node.name, attribute_map) && (!role || is_non_presentation_role) && !is_interactive_element(node.name, attribute_map) && !has_spread ) { const has_key_event = handlers.has('keydown') || handlers.has('keyup') || handlers.has('keypress'); if (!has_key_event) { w.a11y_click_events_have_key_events(node); } } } const role_value = /** @type {ARIARoleDefinitionKey} */ ( role ? role_static_value : get_implicit_role(node.name, attribute_map) ); // no-noninteractive-tabindex if ( !is_dynamic_element && !is_interactive_element(node.name, attribute_map) && !is_interactive_roles(role_static_value) ) { const tab_index = attribute_map.get('tabindex'); const tab_index_value = get_static_text_value(tab_index); if (tab_index && (tab_index_value === null || Number(tab_index_value) >= 0)) { w.a11y_no_noninteractive_tabindex(node); } } // role-supports-aria-props if (typeof role_value === 'string' && roles_map.has(role_value)) { const { props } = /** @type {ARIARoleDefinition} */ (roles_map.get(role_value)); const invalid_aria_props = aria.keys().filter((attribute) => !(attribute in props)); const is_implicit = role_value && role === undefined; for (const attr of attributes) { if (invalid_aria_props.includes(/** @type {ARIAProperty} */ (attr.name))) { if (is_implicit) { w.a11y_role_supports_aria_props_implicit(attr, attr.name, role_value, node.name); } else { w.a11y_role_supports_aria_props(attr, attr.name, role_value); } } } } // no-noninteractive-element-interactions if ( !has_spread && !has_contenteditable_attr && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(role_static_value) && ((!is_interactive_element(node.name, attribute_map) && is_non_interactive_roles(role_static_value)) || (is_non_interactive_element(node.name, attribute_map) && !role)) ) { const has_interactive_handlers = [...handlers].some((handler) => a11y_recommended_interactive_handlers.includes(handler) ); if (has_interactive_handlers) { w.a11y_no_noninteractive_element_interactions(node, node.name); } } // no-static-element-interactions if ( !has_spread && (!role || role_static_value !== null) && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(role_static_value) && !is_interactive_element(node.name, attribute_map) && !is_interactive_roles(role_static_value) && !is_non_interactive_element(node.name, attribute_map) && !is_non_interactive_roles(role_static_value) && !is_abstract_role(role_static_value) ) { const interactive_handlers = [...handlers].filter((handler) => a11y_interactive_handlers.includes(handler) ); if (interactive_handlers.length > 0) { w.a11y_no_static_element_interactions(node, node.name, list(interactive_handlers)); } } if (!has_spread && handlers.has('mouseover') && !handlers.has('focus')) { w.a11y_mouse_events_have_key_events(node, 'mouseover', 'focus'); } if (!has_spread && handlers.has('mouseout') && !handlers.has('blur')) { w.a11y_mouse_events_have_key_events(node, 'mouseout', 'blur'); } // element-specific checks const is_labelled = attribute_map.has('aria-label') || attribute_map.has('aria-labelledby'); switch (node.name) { case 'a': case 'button': { const is_hidden = get_static_value(attribute_map.get('aria-hidden')) === 'true' || get_static_value(attribute_map.get('inert')) !== null; if (!has_spread && !is_hidden && !is_labelled && !has_content(node)) { w.a11y_consider_explicit_label(node); } if (node.name === 'button') { break; } const href = attribute_map.get('href') || attribute_map.get('xlink:href'); if (href) { const href_value = get_static_text_value(href); if (href_value !== null) { if (href_value === '' || href_value === '#' || regex_js_prefix.test(href_value)) { w.a11y_invalid_attribute(href, href_value, href.name); } } } else if (!has_spread) { const id_attribute = get_static_value(attribute_map.get('id')); const name_attribute = get_static_value(attribute_map.get('name')); const aria_disabled_attribute = get_static_value(attribute_map.get('aria-disabled')); if (!id_attribute && !name_attribute && aria_disabled_attribute !== 'true') { warn_missing_attribute(node, ['href']); } } break; } case 'input': { const type = attribute_map.get('type'); const type_value = get_static_text_value(type); if (type_value === 'image' && !has_spread) { const required_attributes = ['alt', 'aria-label', 'aria-labelledby']; const has_attribute = required_attributes.some((name) => attribute_map.has(name)); if (!has_attribute) { warn_missing_attribute(node, required_attributes, 'input type="image"'); } } // autocomplete-valid const autocomplete = attribute_map.get('autocomplete'); if (type && autocomplete) { const autocomplete_value = get_static_value(autocomplete); if (!is_valid_autocomplete(autocomplete_value)) { w.a11y_autocomplete_valid( autocomplete, /** @type {string} */ (autocomplete_value), type_value ?? '...' ); } } break; } case 'img': { const alt_attribute = get_static_text_value(attribute_map.get('alt')); const aria_hidden = get_static_value(attribute_map.get('aria-hidden')); if (alt_attribute && !aria_hidden && !has_spread) { if (regex_redundant_img_alt.test(alt_attribute)) { w.a11y_img_redundant_alt(node); } } break; } case 'label': { /** @param {AST.TemplateNode} node */ const has_input_child = (node) => { let has = false; walk( node, {}, { _(node, { next }) { if ( node.type === 'SvelteElement' || node.type === 'SlotElement' || node.type === 'Component' || node.type === 'RenderTag' || (node.type === 'RegularElement' && (a11y_labelable.includes(node.name) || node.name === 'slot')) ) { has = true; } else { next(); } } } ); return has; }; if (!has_spread && !attribute_map.has('for') && !has_input_child(node)) { w.a11y_label_has_associated_control(node); } break; } case 'video': { const aria_hidden_attribute = attribute_map.get('aria-hidden'); const aria_hidden_exist = aria_hidden_attribute && get_static_value(aria_hidden_attribute); if (attribute_map.has('muted') || aria_hidden_exist === 'true' || has_spread) { return; } let has_caption = false; const track = /** @type {AST.RegularElement | undefined} */ ( node.fragment.nodes.find((i) => i.type === 'RegularElement' && i.name === 'track') ); if (track) { has_caption = track.attributes.some( (a) => a.type === 'SpreadAttribute' || (a.type === 'Attribute' && a.name === 'kind' && get_static_value(a) === 'captions') ); } if (!has_caption) { w.a11y_media_has_caption(node); } break; } case 'figcaption': { if (!is_parent(context.path, ['figure'])) { w.a11y_figcaption_parent(node); } break; } case 'figure': { const children = node.fragment.nodes.filter((node) => { if (node.type === 'Comment') return false; if (node.type === 'Text') return regex_not_whitespace.test(node.data); return true; }); const index = children.findIndex( (child) => child.type === 'RegularElement' && child.name === 'figcaption' ); if (index !== -1 && index !== 0 && index !== children.length - 1) { w.a11y_figcaption_index(children[index]); } break; } } if (!has_spread && node.name !== 'a') { const required_attributes = a11y_required_attributes[node.name]; if (required_attributes) { const has_attribute = required_attributes.some((name) => attribute_map.has(name)); if (!has_attribute) { warn_missing_attribute(node, required_attributes); } } } if (a11y_distracting_elements.includes(node.name)) { // no-distracting-elements w.a11y_distracting_elements(node, node.name); } // Check content if ( !has_spread && !is_labelled && !has_contenteditable_binding && a11y_required_content.includes(node.name) && !has_content(node) ) { w.a11y_missing_content(node, node.name); } } /** * @param {ARIARoleDefinitionKey} role */ function is_presentation_role(role) { return presentation_roles.includes(role); } /** * @param {string} tag_name * @param {Map<string, AST.Attribute>} attribute_map */ function is_hidden_from_screen_reader(tag_name, attribute_map) { if (tag_name === 'input') { const type = get_static_value(attribute_map.get('type')); if (type === 'hidden') { return true; } } const aria_hidden = attribute_map.get('aria-hidden'); if (!aria_hidden) return false; const aria_hidden_value = get_static_value(aria_hidden); if (aria_hidden_value === null) return true; return aria_hidden_value === true || aria_hidden_value === 'true'; } /** * @param {Map<string, AST.Attribute>} attribute_map */ function has_disabled_attribute(attribute_map) { const disabled_attr_value = get_static_value(attribute_map.get('disabled')); if (disabled_attr_value) { return true; } const aria_disabled_attr = attribute_map.get('aria-disabled'); if (aria_disabled_attr) { const aria_disabled_attr_value = get_static_value(aria_disabled_attr); if (aria_disabled_attr_value === 'true') { return true; } } return false; } /** * @param {string} tag_name * @param {Map<string, AST.Attribute>} attribute_map * @returns {ElementInteractivity[keyof ElementInteractivity]} */ function element_interactivity(tag_name, attribute_map) { if ( interactive_element_role_schemas.some((schema) => match_schema(schema, tag_name, attribute_map)) ) { return ElementInteractivity.Interactive; } if ( tag_name !== 'header' && non_interactive_element_role_schemas.some((schema) => match_schema(schema, tag_name, attribute_map) ) ) { return ElementInteractivity.NonInteractive; } if ( interactive_element_ax_object_schemas.some((schema) => match_schema(schema, tag_name, attribute_map) ) ) { return ElementInteractivity.Interactive; } if ( non_interactive_element_ax_object_schemas.some((schema) => match_schema(schema, tag_name, attribute_map) ) ) { return ElementInteractivity.NonInteractive; } return ElementInteractivity.Static; } /** * @param {string} tag_name * @param {Map<string, AST.Attribute>} attribute_map * @returns {boolean} */ function is_interactive_element(tag_name, attribute_map) { return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Interactive; } /** * @param {string} tag_name * @param {Map<string, AST.Attribute>} attribute_map * @returns {boolean} */ function is_non_interactive_element(tag_name, attribute_map) { return element_interactivity(tag_name, attribute_map) === ElementInteractivity.NonInteractive; } /** * @param {string} tag_name * @param {Map<string, AST.Attribute>} attribute_map * @returns {boolean} */ function is_static_element(tag_name, attribute_map) { return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Static; } /** * @param {ARIARoleDefinitionKey} role * @param {string} tag_name * @param {Map<string, AST.Attribute>} attribute_map */ function is_semantic_role_element(role, tag_name, attribute_map) { for (const [schema, ax_object] of elementAXObjects.entries()) { if ( schema.name === tag_name && (!schema.attributes || schema.attributes.every( /** @param {any} attr */ (attr) => attribute_map.has(attr.name) && get_static_value(attribute_map.get(attr.name)) === attr.value )) ) { for (const name of ax_object) { const roles = AXObjectRoles.get(name); if (roles) { for (const { name } of roles) { if (name === role) { return true; } } } } } } return false; } /** * @param {null | true | string} autocomplete */ function is_valid_autocomplete(autocomplete) { if (autocomplete === true) { return false; } else if (!autocomplete) { return true; // dynamic value } const tokens = autocomplete.trim().toLowerCase().split(regex_whitespaces); if (typeof tokens[0] === 'string' && tokens[0].startsWith('section-')) { tokens.shift(); } if (address_type_tokens.includes(tokens[0])) { tokens.shift(); } if (autofill_field_name_tokens.includes(tokens[0])) { tokens.shift(); } else { if (contact_type_tokens.includes(tokens[0])) { tokens.shift(); } if (autofill_contact_field_name_tokens.includes(tokens[0])) { tokens.shift(); } else { return false; } } if (tokens[0] === 'webauthn') { tokens.shift(); } return tokens.length === 0; } /** @param {Map<string, AST.Attribute>} attribute_map */ function input_implicit_role(attribute_map) { const type_attribute = attribute_map.get('type'); if (!type_attribute) return; const type = get_static_text_value(type_attribute); if (!type) return; const list_attribute_exists = attribute_map.has('list'); if (list_attribute_exists && combobox_if_list.includes(type)) { return 'combobox'; } return input_type_to_implicit_role.get(type); } /** @param {Map<string, AST.Attribute>} attribute_map */ function menuitem_implicit_role(attribute_map) { const type_attribute = attribute_map.get('type'); if (!type_attribute) return; const type = get_static_text_value(type_attribute); if (!type) return; return menuitem_type_to_implicit_role.get(type); } /** * @param {string} name * @param {Map<string, AST.Attribute>} attribute_map */ function get_implicit_role(name, attribute_map) { if (name === 'menuitem') { return menuitem_implicit_role(attribute_map); } else if (name === 'input') { return input_implicit_role(attribute_map); } else { return a11y_implicit_semantics.get(name); } } /** * @param {ARIARoleDefinitionKey} role */ function is_non_interactive_roles(role) { return non_interactive_roles.includes(role); } /** * @param {ARIARoleDefinitionKey} role */ function is_interactive_roles(role) { return interactive_roles.includes(role); } /** * @param {ARIARoleDefinitionKey} role */ function is_abstract_role(role) { return abstract_roles.includes(role); } /** * @param {AST.Attribute | undefined} attribute */ function get_static_text_value(attribute) { const value = get_static_value(attribute); if (value === true) return null; return value; } /** * @param {AST.Attribute | undefined} attribute */ function get_static_value(attribute) { if (!attribute) return null; if (attribute.value === true) return true; if (is_text_attribute(attribute)) return attribute.value[0].data; return null; } /** * @param {AST.RegularElement | AST.SvelteElement} element */ function has_content(element) { for (const node of element.fragment.nodes) { if (node.type === 'Text') { if (node.data.trim() === '') { continue; } } if (node.type === 'RegularElement' || node.type === 'SvelteElement') { if ( node.name === 'img' && node.attributes.some((node) => node.type === 'Attribute' && node.name === 'alt') ) { return true; } if (!has_content(node)) { continue; } } // assume everything else has content — this will result in false positives // (e.g. an empty `{#if ...}{/if}`) but that's probably fine return true; } } /** * @param {ARIARoleRelationConcept} schema * @param {string} tag_name * @param {Map<string, AST.Attribute>} attribute_map */ function match_schema(schema, tag_name, attribute_map) { if (schema.name !== tag_name) return false; if (!schema.attributes) return true; return schema.attributes.every((schema_attribute) => { const attribute = attribute_map.get(schema_attribute.name); if (!attribute) return false; if (schema_attribute.value && schema_attribute.value !== get_static_text_value(attribute)) { return false; } return true; }); } /** * @param {AST.SvelteNode[]} path * @param {string[]} elements */ function is_parent(path, elements) { let i = path.length; while (i--) { const parent = path[i]; if (parent.type === 'SvelteElement') return true; // unknown, play it safe, so we don't warn if (parent.type === 'RegularElement') { return elements.includes(parent.name); } } return false; } /** * @param {AST.Attribute} attribute * @param {ARIAProperty} name * @param {ARIAPropertyDefinition} schema * @param {string | true | null} value */ function validate_aria_attribute_value(attribute, name, schema, value) { const type = schema.type; if (value === null) return; if (value === true) value = ''; switch (type) { case 'id': case 'string': { if (value === '') { w.a11y_incorrect_aria_attribute_type(attribute, name, 'non-empty string'); } break; } case 'number': { if (value === '' || isNaN(+value)) { w.a11y_incorrect_aria_attribute_type(attribute, name, 'number'); } break; } case 'boolean': { if (value !== 'true' && value !== 'false') { w.a11y_incorrect_aria_attribute_type_boolean(attribute, name); } break; } case 'idlist': { if (value === '') { w.a11y_incorrect_aria_attribute_type_idlist(attribute, name); } break; } case 'integer': { if (value === '' || !Number.isInteger(+value)) { w.a11y_incorrect_aria_attribute_type_integer(attribute, name); } break; } case 'token': { const values = (schema.values ?? []).map((value) => value.toString()); if (!values.includes(value.toLowerCase())) { w.a11y_incorrect_aria_attribute_type_token( attribute, name, list(values.map((v) => `"${v}"`)) ); } break; } case 'tokenlist': { const values = (schema.values ?? []).map((value) => value.toString()); if ( value .toLowerCase() .split(regex_whitespaces) .some((value) => !values.includes(value)) ) { w.a11y_incorrect_aria_attribute_type_tokenlist( attribute, name, list(values.map((v) => `"${v}"`)) ); } break; } case 'tristate': { if (value !== 'true' && value !== 'false' && value !== 'mixed') { w.a11y_incorrect_aria_attribute_type_tristate(attribute, name); } break; } } } /** * @param {AST.RegularElement |AST.SvelteElement} node * @param {string[]} attributes * @param {string} name */ function warn_missing_attribute(node, attributes, name = node.name) { const article = regex_starts_with_vowel.test(attributes[0]) || attributes[0] === 'href' ? 'an' : 'a'; const sequence = attributes.length > 1 ? attributes.slice(0, -1).join(', ') + ` or ${attributes[attributes.length - 1]}` : attributes[0]; w.a11y_missing_attribute(node, name, article, sequence); }
```

# compiler/phases/2-analyze/visitors/shared/attribute.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../../types' */ import * as e from '../../../../errors.js'; import { is_text_attribute } from '../../../../utils/ast.js'; import * as w from '../../../../warnings.js'; import { is_custom_element_node } from '../../../nodes.js'; import { regex_only_whitespaces } from '../../../patterns.js'; /** * @param {AST.Attribute} attribute */ export function validate_attribute_name(attribute) { if ( attribute.name.includes(':') && !attribute.name.startsWith('xmlns:') && !attribute.name.startsWith('xlink:') && !attribute.name.startsWith('xml:') ) { w.attribute_illegal_colon(attribute); } } /** * @param {AST.Attribute} attribute * @param {AST.ElementLike} parent */ export function validate_attribute(attribute, parent) { if ( Array.isArray(attribute.value) && attribute.value.length === 1 && attribute.value[0].type === 'ExpressionTag' && (parent.type === 'Component' || parent.type === 'SvelteComponent' || parent.type === 'SvelteSelf' || (parent.type === 'RegularElement' && is_custom_element_node(parent))) ) { w.attribute_quoted(attribute); } if (attribute.value === true || !Array.isArray(attribute.value) || attribute.value.length === 1) { return; } const is_quoted = attribute.value.at(-1)?.end !== attribute.end; if (!is_quoted) { e.attribute_unquoted_sequence(attribute); } } /** * @param {Context} context * @param {AST.Attribute} attribute * @param {boolean} is_component */ export function validate_slot_attribute(context, attribute, is_component = false) { const parent = context.path.at(-2); let owner = undefined; if (parent?.type === 'SnippetBlock') { if (!is_text_attribute(attribute)) { e.slot_attribute_invalid(attribute); } return; } let i = context.path.length; while (i--) { const ancestor = context.path[i]; if ( !owner && (ancestor.type === 'Component' || ancestor.type === 'SvelteComponent' || ancestor.type === 'SvelteSelf' || ancestor.type === 'SvelteElement' || (ancestor.type === 'RegularElement' && is_custom_element_node(ancestor))) ) { owner = ancestor; } } if (owner) { if ( owner.type === 'Component' || owner.type === 'SvelteComponent' || owner.type === 'SvelteSelf' ) { if (owner !== parent) { if (!is_component) { e.slot_attribute_invalid_placement(attribute); } } else { if (!is_text_attribute(attribute)) { e.slot_attribute_invalid(attribute); } const name = attribute.value[0].data; if (context.state.component_slots.has(name)) { e.slot_attribute_duplicate(attribute, name, owner.name); } context.state.component_slots.add(name); if (name === 'default') { for (const node of owner.fragment.nodes) { if (node.type === 'Text' && regex_only_whitespaces.test(node.data)) { continue; } if (node.type === 'RegularElement' || node.type === 'SvelteFragment') { if (node.attributes.some((a) => a.type === 'Attribute' && a.name === 'slot')) { continue; } } e.slot_default_duplicate(node); } } } } } else if (!is_component) { e.slot_attribute_invalid_placement(attribute); } }
```

# compiler/phases/2-analyze/visitors/shared/component.js

```js
/** @import { Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { AnalysisState, Context } from '../../types' */ import * as e from '../../../../errors.js'; import { get_attribute_expression, is_expression_attribute } from '../../../../utils/ast.js'; import { determine_slot } from '../../../../utils/slot.js'; import { validate_attribute, validate_attribute_name, validate_slot_attribute } from './attribute.js'; import { mark_subtree_dynamic } from './fragment.js'; import { is_resolved_snippet } from './snippets.js'; /** * @param {AST.Component | AST.SvelteComponent | AST.SvelteSelf} node * @param {Context} context */ export function visit_component(node, context) { node.metadata.path = [...context.path]; // link this node to all the snippets that it could render, so that we can prune CSS correctly node.metadata.snippets = new Set(); // 'resolved' means we know which snippets this component might render. if it is `false`, // then `node.metadata.snippets` is populated with every locally defined snippet // once analysis is complete let resolved = true; for (const attribute of node.attributes) { if (attribute.type === 'SpreadAttribute' || attribute.type === 'BindDirective') { resolved = false; continue; } if (attribute.type !== 'Attribute' || !is_expression_attribute(attribute)) { continue; } const expression = get_attribute_expression(attribute); // given an attribute like `foo={bar}`, if `bar` resolves to an import or a prop // then we know it doesn't reference a locally defined snippet. if it resolves // to a `{#snippet bar()}` then we know _which_ snippet it resolves to. in all // other cases, we can't know (without much more complex static analysis) which // snippets the component might render, so we treat the component as unresolved if (expression.type === 'Identifier') { const binding = context.state.scope.get(expression.name); resolved &&= is_resolved_snippet(binding); if (binding?.initial?.type === 'SnippetBlock') { node.metadata.snippets.add(binding.initial); } } else if (expression.type !== 'Literal') { resolved = false; } } if (resolved) { for (const child of node.fragment.nodes) { if (child.type === 'SnippetBlock') { node.metadata.snippets.add(child); } } } context.state.analysis.snippet_renderers.set(node, resolved); mark_subtree_dynamic(context.path); for (const attribute of node.attributes) { if ( attribute.type !== 'Attribute' && attribute.type !== 'SpreadAttribute' && attribute.type !== 'LetDirective' && attribute.type !== 'OnDirective' && attribute.type !== 'BindDirective' && attribute.type !== 'AttachTag' ) { e.component_invalid_directive(attribute); } if ( attribute.type === 'OnDirective' && (attribute.modifiers.length > 1 || attribute.modifiers.some((m) => m !== 'once')) ) { e.event_handler_invalid_component_modifier(attribute); } if (attribute.type === 'Attribute') { if (context.state.analysis.runes) { validate_attribute(attribute, node); if (is_expression_attribute(attribute)) { disallow_unparenthesized_sequences( get_attribute_expression(attribute), context.state.analysis.source ); } } validate_attribute_name(attribute); if (attribute.name === 'slot') { validate_slot_attribute(context, attribute, true); } } if (attribute.type === 'BindDirective' && attribute.name !== 'this') { context.state.analysis.uses_component_bindings = true; } if (attribute.type === 'AttachTag') { disallow_unparenthesized_sequences(attribute.expression, context.state.analysis.source); } } // If the component has a slot attribute — `<Foo slot="whatever" .../>` — // then `let:` directives apply to other attributes, instead of just the // top-level contents of the component. Yes, this is very weird. const default_state = determine_slot(node) ? context.state : { ...context.state, scope: node.metadata.scopes.default }; for (const attribute of node.attributes) { context.visit(attribute, attribute.type === 'LetDirective' ? default_state : context.state); } /** @type {AST.Comment[]} */ let comments = []; /** @type {Record<string, AST.Fragment['nodes']>} */ const nodes = { default: [] }; for (const child of node.fragment.nodes) { if (child.type === 'Comment') { comments.push(child); continue; } const slot_name = determine_slot(child) ?? 'default'; (nodes[slot_name] ??= []).push(...comments, child); if (slot_name !== 'default') comments = []; } const component_slots = new Set(); for (const slot_name in nodes) { /** @type {AnalysisState} */ const state = { ...context.state, scope: node.metadata.scopes[slot_name], parent_element: null, component_slots }; context.visit({ ...node.fragment, nodes: nodes[slot_name] }, state); } } /** * @param {Expression} expression * @param {string} source */ function disallow_unparenthesized_sequences(expression, source) { if (expression.type === 'SequenceExpression') { let i = /** @type {number} */ (expression.start); while (--i > 0) { const char = source[i]; if (char === '(') break; // parenthesized sequence expressions are ok if (char === '{') e.attribute_invalid_sequence_expression(expression); } } }
```

# compiler/phases/2-analyze/visitors/shared/element.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../../types' */ import { get_attribute_expression, is_expression_attribute } from '../../../../utils/ast.js'; import { regex_illegal_attribute_character } from '../../../patterns.js'; import * as e from '../../../../errors.js'; import * as w from '../../../../warnings.js'; import { validate_attribute, validate_attribute_name, validate_slot_attribute } from './attribute.js'; const EVENT_MODIFIERS = [ 'preventDefault', 'stopPropagation', 'stopImmediatePropagation', 'capture', 'once', 'passive', 'nonpassive', 'self', 'trusted' ]; /** * @param {AST.RegularElement | AST.SvelteElement} node * @param {Context} context */ export function validate_element(node, context) { let has_animate_directive = false; /** @type {AST.TransitionDirective | null} */ let in_transition = null; /** @type {AST.TransitionDirective | null} */ let out_transition = null; for (const attribute of node.attributes) { if (attribute.type === 'Attribute') { const is_expression = is_expression_attribute(attribute); if (context.state.analysis.runes) { validate_attribute(attribute, node); if (is_expression) { const expression = get_attribute_expression(attribute); if (expression.type === 'SequenceExpression') { let i = /** @type {number} */ (expression.start); while (--i > 0) { const char = context.state.analysis.source[i]; if (char === '(') break; // parenthesized sequence expressions are ok if (char === '{') e.attribute_invalid_sequence_expression(expression); } } } } if (regex_illegal_attribute_character.test(attribute.name)) { e.attribute_invalid_name(attribute, attribute.name); } if (attribute.name.startsWith('on') && attribute.name.length > 2) { if (!is_expression) { e.attribute_invalid_event_handler(attribute); } const value = get_attribute_expression(attribute); if ( value.type === 'Identifier' && value.name === attribute.name && !context.state.scope.get(value.name) ) { w.attribute_global_event_reference(attribute, attribute.name); } } if (attribute.name === 'slot') { /** @type {AST.RegularElement | AST.SvelteElement | AST.Component | AST.SvelteComponent | AST.SvelteSelf | undefined} */ validate_slot_attribute(context, attribute); } if (attribute.name === 'is') { w.attribute_avoid_is(attribute); } const correct_name = react_attributes.get(attribute.name); if (correct_name) { w.attribute_invalid_property_name(attribute, attribute.name, correct_name); } validate_attribute_name(attribute); } else if (attribute.type === 'AnimateDirective') { const parent = context.path.at(-2); if (parent?.type !== 'EachBlock') { e.animation_invalid_placement(attribute); } else if (!parent.key) { e.animation_missing_key(attribute); } else if ( parent.body.nodes.filter( (n) => n.type !== 'Comment' && n.type !== 'ConstTag' && (n.type !== 'Text' || n.data.trim() !== '') ).length > 1 ) { e.animation_invalid_placement(attribute); } if (has_animate_directive) { e.animation_duplicate(attribute); } else { has_animate_directive = true; } } else if (attribute.type === 'TransitionDirective') { const existing = /** @type {AST.TransitionDirective | null} */ ( (attribute.intro && in_transition) || (attribute.outro && out_transition) ); if (existing) { const a = existing.intro ? (existing.outro ? 'transition' : 'in') : 'out'; const b = attribute.intro ? (attribute.outro ? 'transition' : 'in') : 'out'; if (a === b) { e.transition_duplicate(attribute, a); } else { e.transition_conflict(attribute, a, b); } } if (attribute.intro) in_transition = attribute; if (attribute.outro) out_transition = attribute; } else if (attribute.type === 'OnDirective') { let has_passive_modifier = false; let conflicting_passive_modifier = ''; for (const modifier of attribute.modifiers) { if (!EVENT_MODIFIERS.includes(modifier)) { const list = `${EVENT_MODIFIERS.slice(0, -1).join(', ')} or ${EVENT_MODIFIERS.at(-1)}`; e.event_handler_invalid_modifier(attribute, list); } if (modifier === 'passive') { has_passive_modifier = true; } else if (modifier === 'nonpassive' || modifier === 'preventDefault') { conflicting_passive_modifier = modifier; } if (has_passive_modifier && conflicting_passive_modifier) { e.event_handler_invalid_modifier_combination( attribute, 'passive', conflicting_passive_modifier ); } } } } } const react_attributes = new Map([ ['className', 'class'], ['htmlFor', 'for'] ]);
```

# compiler/phases/2-analyze/visitors/shared/fragment.js

```js
/** @import { AST } from '#compiler' */ /** * @param {AST.SvelteNode[]} path */ export function mark_subtree_dynamic(path) { let i = path.length; while (i--) { const node = path[i]; if (node.type === 'Fragment') { if (node.metadata.dynamic) return; node.metadata.dynamic = true; } } }
```

# compiler/phases/2-analyze/visitors/shared/function.js

```js
/** @import { ArrowFunctionExpression, FunctionDeclaration, FunctionExpression } from 'estree' */ /** @import { Context } from '../../types' */ /** * @param {ArrowFunctionExpression | FunctionExpression | FunctionDeclaration} node * @param {Context} context */ export function visit_function(node, context) { // TODO retire this in favour of a more general solution based on bindings node.metadata = { hoisted: false, hoisted_params: [], scope: context.state.scope }; if (context.state.expression) { for (const [name] of context.state.scope.references) { const binding = context.state.scope.get(name); if (binding && binding.scope.function_depth < context.state.scope.function_depth) { context.state.expression.references.add(binding); } } } context.next({ ...context.state, function_depth: context.state.function_depth + 1, expression: null }); }
```

# compiler/phases/2-analyze/visitors/shared/snippets.js

```js
/** @import { Binding } from '#compiler' */ /** * Returns `true` if a binding unambiguously resolves to a specific * snippet declaration, or is external to the current component * @param {Binding | null} binding */ export function is_resolved_snippet(binding) { return ( !binding || binding.declaration_kind === 'import' || binding.kind === 'prop' || binding.kind === 'rest_prop' || binding.kind === 'bindable_prop' || binding?.initial?.type === 'SnippetBlock' ); }
```

# compiler/phases/2-analyze/visitors/shared/special-element.js

```js
/** @import { AST } from '#compiler' */ import * as e from '../../../../errors.js'; /** * @param {AST.SvelteBody | AST.SvelteDocument | AST.SvelteOptionsRaw | AST.SvelteWindow} node */ export function disallow_children(node) { const { nodes } = node.fragment; if (nodes.length > 0) { const first = nodes[0]; const last = nodes[nodes.length - 1]; e.svelte_meta_invalid_content({ start: first.start, end: last.end }, node.name); } }
```

# compiler/phases/2-analyze/visitors/shared/utils.js

```js
/** @import { AssignmentExpression, Expression, Literal, Node, Pattern, Super, UpdateExpression, VariableDeclarator } from 'estree' */ /** @import { AST, Binding } from '#compiler' */ /** @import { AnalysisState, Context } from '../../types' */ /** @import { Scope } from '../../../scope' */ /** @import { NodeLike } from '../../../../errors.js' */ import * as e from '../../../../errors.js'; import { extract_identifiers, get_parent } from '../../../../utils/ast.js'; import * as w from '../../../../warnings.js'; import * as b from '#compiler/builders'; import { get_rune } from '../../../scope.js'; import { get_name } from '../../../nodes.js'; /** * @param {AssignmentExpression | UpdateExpression | AST.BindDirective} node * @param {Pattern | Expression} argument * @param {Context} context */ export function validate_assignment(node, argument, context) { validate_no_const_assignment(node, argument, context.state.scope, node.type === 'BindDirective'); if (argument.type === 'Identifier') { const binding = context.state.scope.get(argument.name); if (context.state.analysis.runes) { if (binding?.node === context.state.analysis.props_id) { e.constant_assignment(node, '$props.id()'); } if (binding?.kind === 'each') { e.each_item_invalid_assignment(node); } } if (binding?.kind === 'snippet') { e.snippet_parameter_assignment(node); } } if (argument.type === 'MemberExpression' && argument.object.type === 'ThisExpression') { const name = argument.computed && argument.property.type !== 'Literal' ? null : get_name(argument.property); const field = name !== null && context.state.state_fields?.get(name); // check we're not assigning to a state field before its declaration in the constructor if (field && field.node.type === 'AssignmentExpression' && node !== field.node) { let i = context.path.length; while (i--) { const parent = context.path[i]; if ( parent.type === 'FunctionDeclaration' || parent.type === 'FunctionExpression' || parent.type === 'ArrowFunctionExpression' ) { const grandparent = get_parent(context.path, i - 1); if ( grandparent.type === 'MethodDefinition' && grandparent.kind === 'constructor' && /** @type {number} */ (node.start) < /** @type {number} */ (field.node.start) ) { e.state_field_invalid_assignment(node); } break; } } } } } /** * @param {NodeLike} node * @param {Pattern | Expression} argument * @param {Scope} scope * @param {boolean} is_binding */ export function validate_no_const_assignment(node, argument, scope, is_binding) { if (argument.type === 'ArrayPattern') { for (const element of argument.elements) { if (element) { validate_no_const_assignment(node, element, scope, is_binding); } } } else if (argument.type === 'ObjectPattern') { for (const element of argument.properties) { if (element.type === 'Property') { validate_no_const_assignment(node, element.value, scope, is_binding); } } } else if (argument.type === 'Identifier') { const binding = scope.get(argument.name); if ( binding?.declaration_kind === 'import' || (binding?.declaration_kind === 'const' && binding.kind !== 'each') ) { // e.invalid_const_assignment( // node, // is_binding, // // This takes advantage of the fact that we don't assign initial for let directives and then/catch variables. // // If we start doing that, we need another property on the binding to differentiate, or give up on the more precise error message. // binding.kind !== 'state' && // binding.kind !== 'raw_state' && // (binding.kind !== 'normal' || !binding.initial) // ); // TODO have a more specific error message for assignments to things like `{:then foo}` const thing = binding.declaration_kind === 'import' ? 'import' : 'constant'; if (is_binding) { e.constant_binding(node, thing); } else { e.constant_assignment(node, thing); } } } } /** * Validates that the opening of a control flow block is `{` immediately followed by the expected character. * In legacy mode whitespace is allowed inbetween. TODO remove once legacy mode is gone and move this into parser instead. * @param {{start: number; end: number}} node * @param {AnalysisState} state * @param {string} expected */ export function validate_opening_tag(node, state, expected) { if (state.analysis.source[node.start + 1] !== expected) { // avoid a sea of red and only mark the first few characters e.block_unexpected_character({ start: node.start, end: node.start + 5 }, expected); } } /** * @param {AST.Fragment | null | undefined} node * @param {Context} context */ export function validate_block_not_empty(node, context) { if (!node) return; // Assumption: If the block has zero elements, someone's in the middle of typing it out, // so don't warn in that case because it would be distracting. if (node.nodes.length === 1 && node.nodes[0].type === 'Text' && !node.nodes[0].raw.trim()) { w.block_empty(node.nodes[0]); } } /** * @param {VariableDeclarator} node * @param {AnalysisState} state */ export function ensure_no_module_import_conflict(node, state) { const ids = extract_identifiers(node.id); for (const id of ids) { if ( state.ast_type === 'instance' && state.scope === state.analysis.instance.scope && state.analysis.module.scope.get(id.name)?.declaration_kind === 'import' ) { // TODO fix the message here e.declaration_duplicate_module_import(node.id); } } } /** * A 'safe' identifier means that the `foo` in `foo.bar` or `foo()` will not * call functions that require component context to exist * @param {Expression | Super} expression * @param {Scope} scope */ export function is_safe_identifier(expression, scope) { let node = expression; while (node.type === 'MemberExpression') node = node.object; if (node.type !== 'Identifier') return false; const binding = scope.get(node.name); if (!binding) return true; if (binding.kind === 'store_sub') { return is_safe_identifier({ name: node.name.slice(1), type: 'Identifier' }, scope); } return ( binding.declaration_kind !== 'import' && binding.kind !== 'prop' && binding.kind !== 'bindable_prop' && binding.kind !== 'rest_prop' ); } /** * @param {Expression | Literal | Super} node * @param {Context} context * @returns {boolean} */ export function is_pure(node, context) { if (node.type === 'Literal') { return true; } if (node.type === 'CallExpression') { if (!is_pure(node.callee, context)) { return false; } for (let arg of node.arguments) { if (!is_pure(arg.type === 'SpreadElement' ? arg.argument : arg, context)) { return false; } } return true; } if (node.type !== 'Identifier' && node.type !== 'MemberExpression') { return false; } if (get_rune(b.call(node), context.state.scope) === '$effect.tracking') { return false; } /** @type {Expression | Super | null} */ let left = node; while (left.type === 'MemberExpression') { left = left.object; } if (!left) return false; if (left.type === 'Identifier') { const binding = context.state.scope.get(left.name); if (binding === null) return true; // globals are assumed to be safe } else if (is_pure(left, context)) { return true; } // TODO add more cases (safe Svelte imports, etc) return false; } /** * Checks if the name is valid, which it is when it's not starting with (or is) a dollar sign or if it's a function parameter. * The second argument is the depth of the scope, which is there for backwards compatibility reasons: In Svelte 4, you * were allowed to define `$`-prefixed variables anywhere below the top level of components. Once legacy mode is gone, this * argument can be removed / the call sites adjusted accordingly. * @param {Binding | null} binding * @param {number | undefined} [function_depth] */ export function validate_identifier_name(binding, function_depth) { if (!binding) return; const declaration_kind = binding.declaration_kind; if ( declaration_kind !== 'synthetic' && declaration_kind !== 'param' && declaration_kind !== 'rest_param' && (!function_depth || function_depth <= 1) ) { const node = binding.node; if (node.name === '$') { e.dollar_binding_invalid(node); } else if ( node.name.startsWith('$') && // import type { $Type } from "" - these are normally already filtered out, // but for the migration they aren't, and throwing here is preventing the migration to complete // TODO -> once migration script is gone we can remove this check !( binding.initial?.type === 'ImportDeclaration' && /** @type {any} */ (binding.initial).importKind === 'type' ) ) { e.dollar_prefix_invalid(node); } } } /** * Checks that the exported name is not a derived or reassigned state variable. * @param {Node} node * @param {Scope} scope * @param {string} name */ export function validate_export(node, scope, name) { const binding = scope.get(name); if (!binding) return; if (binding.kind === 'derived') { e.derived_invalid_export(node); } if ((binding.kind === 'state' || binding.kind === 'raw_state') && binding.reassigned) { e.state_invalid_export(node); } }
```

# compiler/phases/2-analyze/visitors/SlotElement.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { is_text_attribute } from '../../../utils/ast.js'; import * as e from '../../../errors.js'; import * as w from '../../../warnings.js'; import { mark_subtree_dynamic } from './shared/fragment.js'; /** * @param {AST.SlotElement} node * @param {Context} context */ export function SlotElement(node, context) { if (context.state.analysis.runes && !context.state.analysis.custom_element) { w.slot_element_deprecated(node); } mark_subtree_dynamic(context.path); /** @type {string} */ let name = 'default'; for (const attribute of node.attributes) { if (attribute.type === 'Attribute') { if (attribute.name === 'name') { if (!is_text_attribute(attribute)) { e.slot_element_invalid_name(attribute); } name = attribute.value[0].data; if (name === 'default') { e.slot_element_invalid_name_default(attribute); } } } else if (attribute.type !== 'SpreadAttribute' && attribute.type !== 'LetDirective') { e.slot_element_invalid_attribute(attribute); } } context.state.analysis.slot_names.set(name, node); context.next(); }
```

# compiler/phases/2-analyze/visitors/SnippetBlock.js

```js
/** @import { AST, Binding } from '#compiler' */ /** @import { Scope } from '../../scope' */ /** @import { Context } from '../types' */ import { validate_block_not_empty, validate_opening_tag } from './shared/utils.js'; import * as e from '../../../errors.js'; /** * @param {AST.SnippetBlock} node * @param {Context} context */ export function SnippetBlock(node, context) { context.state.analysis.snippets.add(node); validate_block_not_empty(node.body, context); if (context.state.analysis.runes) { validate_opening_tag(node, context.state, '#'); } for (const arg of node.parameters) { if (arg.type === 'RestElement') { e.snippet_invalid_rest_parameter(arg); } } context.next({ ...context.state, parent_element: null }); const can_hoist = context.path.length === 1 && context.path[0].type === 'Fragment' && can_hoist_snippet(context.state.scope, context.state.scopes); const name = node.expression.name; if (can_hoist) { const binding = /** @type {Binding} */ (context.state.scope.get(name)); context.state.analysis.module.scope.declarations.set(name, binding); } else { const undefined_export = context.state.analysis.undefined_exports.get(name); if (undefined_export) { e.snippet_invalid_export(undefined_export); } } node.metadata.can_hoist = can_hoist; const { path } = context; const parent = path.at(-2); if (!parent) return; if ( parent.type === 'Component' && parent.attributes.some( (attribute) => (attribute.type === 'Attribute' || attribute.type === 'BindDirective') && attribute.name === node.expression.name ) ) { e.snippet_shadowing_prop(node, node.expression.name); } if (node.expression.name !== 'children') return; if ( parent.type === 'Component' || parent.type === 'SvelteComponent' || parent.type === 'SvelteSelf' ) { if ( parent.fragment.nodes.some( (node) => node.type !== 'SnippetBlock' && (node.type !== 'Text' || node.data.trim()) && node.type !== 'Comment' ) ) { e.snippet_conflict(node); } } } /** * @param {Map<AST.SvelteNode, Scope>} scopes * @param {Scope} scope */ function can_hoist_snippet(scope, scopes, visited = new Set()) { for (const [reference] of scope.references) { const binding = scope.get(reference); if (!binding || binding.scope.function_depth === 0) { continue; } // ignore bindings declared inside the snippet (e.g. the snippet's own parameters) if (binding.scope.function_depth >= scope.function_depth) { continue; } if (binding.initial?.type === 'SnippetBlock') { if (visited.has(binding)) continue; visited.add(binding); const snippet_scope = /** @type {Scope} */ (scopes.get(binding.initial)); if (can_hoist_snippet(snippet_scope, scopes, visited)) { continue; } } return false; } return true; }
```

# compiler/phases/2-analyze/visitors/SpreadAttribute.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { mark_subtree_dynamic } from './shared/fragment.js'; /** * @param {AST.SpreadAttribute} node * @param {Context} context */ export function SpreadAttribute(node, context) { mark_subtree_dynamic(context.path); context.next({ ...context.state, expression: node.metadata.expression }); }
```

# compiler/phases/2-analyze/visitors/SpreadElement.js

```js
/** @import { SpreadElement } from 'estree' */ /** @import { Context } from '../types' */ /** * @param {SpreadElement} node * @param {Context} context */ export function SpreadElement(node, context) { if (context.state.expression) { // treat e.g. `[...x]` the same as `[...x.values()]` context.state.expression.has_call = true; context.state.expression.has_state = true; } context.next(); }
```

# compiler/phases/2-analyze/visitors/StyleDirective.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import * as e from '../../../errors.js'; import { get_attribute_chunks } from '../../../utils/ast.js'; import { mark_subtree_dynamic } from './shared/fragment.js'; /** * @param {AST.StyleDirective} node * @param {Context} context */ export function StyleDirective(node, context) { if (node.modifiers.length > 1 || (node.modifiers.length && node.modifiers[0] !== 'important')) { e.style_directive_invalid_modifier(node); } mark_subtree_dynamic(context.path); if (node.value === true) { // get the binding for node.name and change the binding to state let binding = context.state.scope.get(node.name); if (binding) { if (binding.kind !== 'normal') { node.metadata.expression.has_state = true; } } } else { context.next(); for (const chunk of get_attribute_chunks(node.value)) { if (chunk.type !== 'ExpressionTag') continue; node.metadata.expression.has_state ||= chunk.metadata.expression.has_state; node.metadata.expression.has_call ||= chunk.metadata.expression.has_call; node.metadata.expression.has_await ||= chunk.metadata.expression.has_await; } } }
```

# compiler/phases/2-analyze/visitors/SvelteBody.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import * as e from '../../../errors.js'; import { is_event_attribute } from '../../../utils/ast.js'; import { disallow_children } from './shared/special-element.js'; /** * @param {AST.SvelteBody} node * @param {Context} context */ export function SvelteBody(node, context) { disallow_children(node); for (const attribute of node.attributes) { if ( attribute.type === 'SpreadAttribute' || (attribute.type === 'Attribute' && !is_event_attribute(attribute)) ) { e.svelte_body_illegal_attribute(attribute); } } context.next(); }
```

# compiler/phases/2-analyze/visitors/SvelteBoundary.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import * as e from '../../../errors.js'; const valid = ['onerror', 'failed', 'pending']; /** * @param {AST.SvelteBoundary} node * @param {Context} context */ export function SvelteBoundary(node, context) { for (const attribute of node.attributes) { if (attribute.type !== 'Attribute' || !valid.includes(attribute.name)) { e.svelte_boundary_invalid_attribute(attribute); } if ( attribute.value === true || (Array.isArray(attribute.value) && (attribute.value.length !== 1 || attribute.value[0].type !== 'ExpressionTag')) ) { e.svelte_boundary_invalid_attribute_value(attribute); } } context.next(); }
```

# compiler/phases/2-analyze/visitors/SvelteComponent.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import * as w from '../../../warnings.js'; import { visit_component } from './shared/component.js'; /** * @param {AST.SvelteComponent} node * @param {Context} context */ export function SvelteComponent(node, context) { if (context.state.analysis.runes) { w.svelte_component_deprecated(node); } context.visit(node.expression); visit_component(node, context); }
```

# compiler/phases/2-analyze/visitors/SvelteDocument.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { disallow_children } from './shared/special-element.js'; import * as e from '../../../errors.js'; import { is_event_attribute } from '../../../utils/ast.js'; /** * @param {AST.SvelteDocument} node * @param {Context} context */ export function SvelteDocument(node, context) { disallow_children(node); for (const attribute of node.attributes) { if ( attribute.type === 'SpreadAttribute' || (attribute.type === 'Attribute' && !is_event_attribute(attribute)) ) { e.illegal_element_attribute(attribute, 'svelte:document'); } } context.next(); }
```

# compiler/phases/2-analyze/visitors/SvelteElement.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { NAMESPACE_MATHML, NAMESPACE_SVG } from '../../../../constants.js'; import { is_text_attribute } from '../../../utils/ast.js'; import { check_element } from './shared/a11y/index.js'; import { validate_element } from './shared/element.js'; import { mark_subtree_dynamic } from './shared/fragment.js'; /** * @param {AST.SvelteElement} node * @param {Context} context */ export function SvelteElement(node, context) { validate_element(node, context); check_element(node, context); node.metadata.path = [...context.path]; context.state.analysis.elements.push(node); const xmlns = /** @type {AST.Attribute & { value: [AST.Text] } | undefined} */ ( node.attributes.find( (a) => a.type === 'Attribute' && a.name === 'xmlns' && is_text_attribute(a) ) ); if (xmlns) { node.metadata.svg = xmlns.value[0].data === NAMESPACE_SVG; node.metadata.mathml = xmlns.value[0].data === NAMESPACE_MATHML; } else { let i = context.path.length; while (i--) { const ancestor = context.path[i]; if ( ancestor.type === 'Component' || ancestor.type === 'SvelteComponent' || ancestor.type === 'SvelteFragment' || ancestor.type === 'SnippetBlock' || i === 0 ) { // Root element, or inside a slot or a snippet -> this resets the namespace, so assume the component namespace node.metadata.svg = context.state.options.namespace === 'svg'; node.metadata.mathml = context.state.options.namespace === 'mathml'; break; } if (ancestor.type === 'SvelteElement' || ancestor.type === 'RegularElement') { node.metadata.svg = ancestor.type === 'RegularElement' && ancestor.name === 'foreignObject' ? false : ancestor.metadata.svg; node.metadata.mathml = ancestor.type === 'RegularElement' && ancestor.name === 'foreignObject' ? false : ancestor.metadata.mathml; break; } } } mark_subtree_dynamic(context.path); context.visit(node.tag, { ...context.state, expression: node.metadata.expression }); for (const attribute of node.attributes) { context.visit(attribute); } context.visit(node.fragment, { ...context.state, parent_element: null }); }
```

# compiler/phases/2-analyze/visitors/SvelteFragment.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import * as e from '../../../errors.js'; import { validate_slot_attribute } from './shared/attribute.js'; /** * @param {AST.SvelteFragment} node * @param {Context} context */ export function SvelteFragment(node, context) { const parent = context.path.at(-2); if (parent?.type !== 'Component' && parent?.type !== 'SvelteComponent') { e.svelte_fragment_invalid_placement(node); } for (const attribute of node.attributes) { if (attribute.type === 'Attribute') { if (attribute.name === 'slot') { validate_slot_attribute(context, attribute); } } else if (attribute.type !== 'LetDirective') { e.svelte_fragment_invalid_attribute(attribute); } } context.next({ ...context.state, parent_element: null }); }
```

# compiler/phases/2-analyze/visitors/SvelteHead.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import * as e from '../../../errors.js'; import { mark_subtree_dynamic } from './shared/fragment.js'; /** * @param {AST.SvelteHead} node * @param {Context} context */ export function SvelteHead(node, context) { for (const attribute of node.attributes) { e.svelte_head_illegal_attribute(attribute); } mark_subtree_dynamic(context.path); context.next(); }
```

# compiler/phases/2-analyze/visitors/SvelteSelf.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { visit_component } from './shared/component.js'; import * as e from '../../../errors.js'; import * as w from '../../../warnings.js'; import { filename } from '../../../state.js'; /** * @param {AST.SvelteSelf} node * @param {Context} context */ export function SvelteSelf(node, context) { const valid = context.path.some( (node) => node.type === 'IfBlock' || node.type === 'EachBlock' || node.type === 'Component' || node.type === 'SnippetBlock' ); if (!valid) { e.svelte_self_invalid_placement(node); } if (context.state.analysis.runes) { const name = filename === '(unknown)' ? 'Self' : context.state.analysis.name; const basename = filename === '(unknown)' ? 'Self.svelte' : /** @type {string} */ (filename.split(/[/\\]/).pop()); w.svelte_self_deprecated(node, name, basename); } visit_component(node, context); }
```

# compiler/phases/2-analyze/visitors/SvelteWindow.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { disallow_children } from './shared/special-element.js'; import * as e from '../../../errors.js'; import { is_event_attribute } from '../../../utils/ast.js'; /** * @param {AST.SvelteWindow} node * @param {Context} context */ export function SvelteWindow(node, context) { disallow_children(node); for (const attribute of node.attributes) { if ( attribute.type === 'SpreadAttribute' || (attribute.type === 'Attribute' && !is_event_attribute(attribute)) ) { e.illegal_element_attribute(attribute, 'svelte:window'); } } context.next(); }
```

# compiler/phases/2-analyze/visitors/TaggedTemplateExpression.js

```js
/** @import { TaggedTemplateExpression } from 'estree' */ /** @import { Context } from '../types' */ import { is_pure } from './shared/utils.js'; /** * @param {TaggedTemplateExpression} node * @param {Context} context */ export function TaggedTemplateExpression(node, context) { if (context.state.expression && !is_pure(node.tag, context)) { context.state.expression.has_call = true; context.state.expression.has_state = true; } context.next(); }
```

# compiler/phases/2-analyze/visitors/TemplateElement.js

```js
/** @import { TemplateElement } from 'estree' */ import * as w from '../../../warnings.js'; import { regex_bidirectional_control_characters } from '../../patterns.js'; /** * @param {TemplateElement} node */ export function TemplateElement(node) { if (regex_bidirectional_control_characters.test(node.value.cooked ?? '')) { w.bidirectional_control_characters(node); } }
```

# compiler/phases/2-analyze/visitors/Text.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { is_tag_valid_with_parent } from '../../../../html-tree-validation.js'; import { regex_bidirectional_control_characters, regex_not_whitespace } from '../../patterns.js'; import * as e from '../../../errors.js'; import * as w from '../../../warnings.js'; import { extract_svelte_ignore } from '../../../utils/extract_svelte_ignore.js'; /** * @param {AST.Text} node * @param {Context} context */ export function Text(node, context) { const parent = /** @type {AST.SvelteNode} */ (context.path.at(-1)); if ( parent.type === 'Fragment' && context.state.parent_element && regex_not_whitespace.test(node.data) ) { const message = is_tag_valid_with_parent('#text', context.state.parent_element); if (message) { e.node_invalid_placement(node, message); } } regex_bidirectional_control_characters.lastIndex = 0; for (const match of node.data.matchAll(regex_bidirectional_control_characters)) { let is_ignored = false; // if we have a svelte-ignore comment earlier in the text, bail // (otherwise we can only use svelte-ignore on parent elements/blocks) if (parent.type === 'Fragment') { for (const child of parent.nodes) { if (child === node) break; if (child.type === 'Comment') { is_ignored ||= extract_svelte_ignore( child.start + 4, child.data, context.state.analysis.runes ).includes('bidirectional_control_characters'); } } } if (!is_ignored) { let start = match.index + node.start; w.bidirectional_control_characters({ start, end: start + match[0].length }); } } }
```

# compiler/phases/2-analyze/visitors/TitleElement.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import * as e from '../../../errors.js'; /** * @param {AST.TitleElement} node * @param {Context} context */ export function TitleElement(node, context) { for (const attribute of node.attributes) { e.title_illegal_attribute(attribute); } for (const child of node.fragment.nodes) { if (child.type !== 'Text' && child.type !== 'ExpressionTag') { e.title_invalid_content(child); } } context.next(); }
```

# compiler/phases/2-analyze/visitors/TransitionDirective.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { mark_subtree_dynamic } from './shared/fragment.js'; /** * @param {AST.TransitionDirective} node * @param {Context} context */ export function TransitionDirective(node, context) { mark_subtree_dynamic(context.path); context.next(); }
```

# compiler/phases/2-analyze/visitors/UpdateExpression.js

```js
/** @import { UpdateExpression } from 'estree' */ /** @import { Context } from '../types' */ import { object } from '../../../utils/ast.js'; import { validate_assignment } from './shared/utils.js'; /** * @param {UpdateExpression} node * @param {Context} context */ export function UpdateExpression(node, context) { validate_assignment(node, node.argument, context); if (context.state.reactive_statement) { const id = node.argument.type === 'MemberExpression' ? object(node.argument) : node.argument; if (id?.type === 'Identifier') { const binding = context.state.scope.get(id.name); if (binding) { context.state.reactive_statement.assignments.add(binding); } } } if (context.state.expression) { context.state.expression.has_assignment = true; } context.next(); }
```

# compiler/phases/2-analyze/visitors/UseDirective.js

```js
/** @import { AST } from '#compiler' */ /** @import { Context } from '../types' */ import { mark_subtree_dynamic } from './shared/fragment.js'; /** * @param {AST.UseDirective} node * @param {Context} context */ export function UseDirective(node, context) { mark_subtree_dynamic(context.path); context.next(); }
```

# compiler/phases/2-analyze/visitors/VariableDeclarator.js

```js
/** @import { Expression, Identifier, Literal, VariableDeclarator } from 'estree' */ /** @import { Binding } from '#compiler' */ /** @import { Context } from '../types' */ import { get_rune } from '../../scope.js'; import { ensure_no_module_import_conflict, validate_identifier_name } from './shared/utils.js'; import * as e from '../../../errors.js'; import * as w from '../../../warnings.js'; import { extract_paths } from '../../../utils/ast.js'; import { equal } from '../../../utils/assert.js'; import * as b from '#compiler/builders'; /** * @param {VariableDeclarator} node * @param {Context} context */ export function VariableDeclarator(node, context) { ensure_no_module_import_conflict(node, context.state); if (context.state.analysis.runes) { const init = node.init; const rune = get_rune(init, context.state.scope); const { paths } = extract_paths(node.id, b.id('dummy')); for (const path of paths) { validate_identifier_name(context.state.scope.get(/** @type {Identifier} */ (path.node).name)); } // TODO feels like this should happen during scope creation? if ( rune === '$state' || rune === '$state.raw' || rune === '$derived' || rune === '$derived.by' || rune === '$props' ) { for (const path of paths) { // @ts-ignore this fails in CI for some insane reason const binding = /** @type {Binding} */ (context.state.scope.get(path.node.name)); binding.kind = rune === '$state' ? 'state' : rune === '$state.raw' ? 'raw_state' : rune === '$derived' || rune === '$derived.by' ? 'derived' : path.is_rest ? 'rest_prop' : 'prop'; } } if (rune === '$props') { if (node.id.type !== 'ObjectPattern' && node.id.type !== 'Identifier') { e.props_invalid_identifier(node); } if ( context.state.analysis.custom_element && context.state.options.customElementOptions?.props == null ) { let warn_on; if ( node.id.type === 'Identifier' || (warn_on = node.id.properties.find((p) => p.type === 'RestElement')) != null ) { w.custom_element_props_identifier(warn_on ?? node.id); } } context.state.analysis.needs_props = true; if (node.id.type === 'Identifier') { const binding = /** @type {Binding} */ (context.state.scope.get(node.id.name)); binding.initial = null; // else would be $props() binding.kind = 'rest_prop'; } else { equal(node.id.type, 'ObjectPattern'); for (const property of node.id.properties) { if (property.type !== 'Property') continue; if (property.computed) { e.props_invalid_pattern(property); } if (property.key.type === 'Identifier' && property.key.name.startsWith('$$')) { e.props_illegal_name(property); } const value = property.value.type === 'AssignmentPattern' ? property.value.left : property.value; if (value.type !== 'Identifier') { e.props_invalid_pattern(property); } const alias = property.key.type === 'Identifier' ? property.key.name : String(/** @type {Literal} */ (property.key).value); let initial = property.value.type === 'AssignmentPattern' ? property.value.right : null; const binding = /** @type {Binding} */ (context.state.scope.get(value.name)); binding.prop_alias = alias; // rewire initial from $props() to the actual initial value, stripping $bindable() if necessary if ( initial?.type === 'CallExpression' && initial.callee.type === 'Identifier' && initial.callee.name === '$bindable' ) { binding.initial = /** @type {Expression | null} */ (initial.arguments[0] ?? null); binding.kind = 'bindable_prop'; } else { binding.initial = initial; } } } } } else { if (node.init?.type === 'CallExpression') { const callee = node.init.callee; if ( callee.type === 'Identifier' && (callee.name === '$state' || callee.name === '$derived' || callee.name === '$props') && context.state.scope.get(callee.name)?.kind !== 'store_sub' ) { e.rune_invalid_usage(node.init, callee.name); } } } context.next(); }
```

# compiler/phases/3-transform/client/transform-client.js

```js
/** @import * as ESTree from 'estree' */ /** @import { AST, ValidatedCompileOptions, ValidatedModuleCompileOptions } from '#compiler' */ /** @import { ComponentAnalysis, Analysis } from '../../types' */ /** @import { Visitors, ComponentClientTransformState, ClientTransformState } from './types' */ import { walk } from 'zimmerframe'; import * as b from '#compiler/builders'; import { build_getter, is_state_source } from './utils.js'; import { render_stylesheet } from '../css/index.js'; import { dev, filename } from '../../../state.js'; import { AnimateDirective } from './visitors/AnimateDirective.js'; import { ArrowFunctionExpression } from './visitors/ArrowFunctionExpression.js'; import { AssignmentExpression } from './visitors/AssignmentExpression.js'; import { Attribute } from './visitors/Attribute.js'; import { AwaitBlock } from './visitors/AwaitBlock.js'; import { AwaitExpression } from './visitors/AwaitExpression.js'; import { BinaryExpression } from './visitors/BinaryExpression.js'; import { BindDirective } from './visitors/BindDirective.js'; import { BlockStatement } from './visitors/BlockStatement.js'; import { BreakStatement } from './visitors/BreakStatement.js'; import { CallExpression } from './visitors/CallExpression.js'; import { ClassBody } from './visitors/ClassBody.js'; import { Comment } from './visitors/Comment.js'; import { Component } from './visitors/Component.js'; import { ConstTag } from './visitors/ConstTag.js'; import { DebugTag } from './visitors/DebugTag.js'; import { EachBlock } from './visitors/EachBlock.js'; import { ExportNamedDeclaration } from './visitors/ExportNamedDeclaration.js'; import { ExpressionStatement } from './visitors/ExpressionStatement.js'; import { Fragment } from './visitors/Fragment.js'; import { FunctionDeclaration } from './visitors/FunctionDeclaration.js'; import { FunctionExpression } from './visitors/FunctionExpression.js'; import { HtmlTag } from './visitors/HtmlTag.js'; import { Identifier } from './visitors/Identifier.js'; import { IfBlock } from './visitors/IfBlock.js'; import { ImportDeclaration } from './visitors/ImportDeclaration.js'; import { KeyBlock } from './visitors/KeyBlock.js'; import { LabeledStatement } from './visitors/LabeledStatement.js'; import { LetDirective } from './visitors/LetDirective.js'; import { MemberExpression } from './visitors/MemberExpression.js'; import { OnDirective } from './visitors/OnDirective.js'; import { Program } from './visitors/Program.js'; import { RegularElement } from './visitors/RegularElement.js'; import { RenderTag } from './visitors/RenderTag.js'; import { SlotElement } from './visitors/SlotElement.js'; import { SnippetBlock } from './visitors/SnippetBlock.js'; import { SpreadAttribute } from './visitors/SpreadAttribute.js'; import { SvelteBody } from './visitors/SvelteBody.js'; import { SvelteComponent } from './visitors/SvelteComponent.js'; import { SvelteDocument } from './visitors/SvelteDocument.js'; import { SvelteElement } from './visitors/SvelteElement.js'; import { SvelteFragment } from './visitors/SvelteFragment.js'; import { SvelteBoundary } from './visitors/SvelteBoundary.js'; import { SvelteHead } from './visitors/SvelteHead.js'; import { SvelteSelf } from './visitors/SvelteSelf.js'; import { SvelteWindow } from './visitors/SvelteWindow.js'; import { TitleElement } from './visitors/TitleElement.js'; import { TransitionDirective } from './visitors/TransitionDirective.js'; import { UpdateExpression } from './visitors/UpdateExpression.js'; import { UseDirective } from './visitors/UseDirective.js'; import { AttachTag } from './visitors/AttachTag.js'; import { VariableDeclaration } from './visitors/VariableDeclaration.js'; /** @type {Visitors} */ const visitors = { _: function set_scope(node, { next, state }) { const scope = state.scopes.get(node); if (scope && scope !== state.scope) { const transform = { ...state.transform }; for (const [name, binding] of scope.declarations) { if ( binding.kind === 'normal' || // Reads of `$state(...)` declarations are not // transformed if they are never reassigned (binding.kind === 'state' && !is_state_source(binding, state.analysis)) ) { delete transform[name]; } } next({ ...state, transform, scope }); } else { next(); } }, AnimateDirective, ArrowFunctionExpression, AssignmentExpression, Attribute, AwaitBlock, AwaitExpression, BinaryExpression, BindDirective, BlockStatement, BreakStatement, CallExpression, ClassBody, Comment, Component, ConstTag, DebugTag, EachBlock, ExportNamedDeclaration, ExpressionStatement, Fragment, FunctionDeclaration, FunctionExpression, HtmlTag, Identifier, IfBlock, ImportDeclaration, KeyBlock, LabeledStatement, LetDirective, MemberExpression, OnDirective, Program, RegularElement, RenderTag, SlotElement, SnippetBlock, SpreadAttribute, SvelteBody, SvelteComponent, SvelteDocument, SvelteElement, SvelteFragment, SvelteBoundary, SvelteHead, SvelteSelf, SvelteWindow, TitleElement, TransitionDirective, UpdateExpression, UseDirective, AttachTag, VariableDeclaration }; /** * @param {ComponentAnalysis} analysis * @param {ValidatedCompileOptions} options * @returns {ESTree.Program} */ export function client_component(analysis, options) { /** @type {ComponentClientTransformState} */ const state = { analysis, options, scope: analysis.module.scope, scopes: analysis.module.scopes, is_instance: false, hoisted: [b.import_all('$', 'svelte/internal/client')], node: /** @type {any} */ (null), // populated by the root node legacy_reactive_imports: [], legacy_reactive_statements: new Map(), metadata: { namespace: options.namespace, bound_contenteditable: false }, events: new Set(), preserve_whitespace: options.preserveWhitespace, state_fields: new Map(), transform: {}, in_constructor: false, in_derived: false, instance_level_snippets: [], module_level_snippets: [], // these are set inside the `Fragment` visitor, and cannot be used until then init: /** @type {any} */ (null), update: /** @type {any} */ (null), after_update: /** @type {any} */ (null), template: /** @type {any} */ (null), memoizer: /** @type {any} */ (null) }; const module = /** @type {ESTree.Program} */ ( walk(/** @type {AST.SvelteNode} */ (analysis.module.ast), state, visitors) ); const instance_state = { ...state, transform: { ...state.transform }, scope: analysis.instance.scope, scopes: analysis.instance.scopes, is_instance: true }; const instance = /** @type {ESTree.Program} */ ( walk(/** @type {AST.SvelteNode} */ (analysis.instance.ast), instance_state, visitors) ); const template = /** @type {ESTree.Program} */ ( walk( /** @type {AST.SvelteNode} */ (analysis.template.ast), { ...state, transform: instance_state.transform, scope: analysis.instance.scope, scopes: analysis.template.scopes }, visitors ) ); module.body.unshift(...state.legacy_reactive_imports); /** @type {ESTree.Statement[]} */ const store_setup = []; /** @type {ESTree.VariableDeclaration[]} */ const legacy_reactive_declarations = []; let needs_store_cleanup = false; for (const [name, binding] of analysis.instance.scope.declarations) { if (binding.kind === 'legacy_reactive') { legacy_reactive_declarations.push( b.const( name, b.call('$.mutable_source', undefined, analysis.immutable ? b.true : undefined) ) ); } if (binding.kind === 'store_sub') { if (store_setup.length === 0) { needs_store_cleanup = true; store_setup.push( b.const(b.array_pattern([b.id('$$stores'), b.id('$$cleanup')]), b.call('$.setup_stores')) ); } // We're creating an arrow function that gets the store value which minifies better for two or more references const store_reference = build_getter(b.id(name.slice(1)), instance_state); const store_get = b.call('$.store_get', store_reference, b.literal(name), b.id('$$stores')); store_setup.push( b.const( binding.node, dev ? b.thunk( b.sequence([ b.call('$.validate_store', store_reference, b.literal(name.slice(1))), store_get ]) ) : b.thunk(store_get) ) ); } } for (const [node] of analysis.reactive_statements) { const statement = [...state.legacy_reactive_statements].find(([n]) => n === node); if (statement === undefined) { throw new Error('Could not find reactive statement'); } instance.body.push(statement[1]); } if (analysis.reactive_statements.size > 0) { instance.body.push(b.stmt(b.call('$.legacy_pre_effect_reset'))); } /** * Used to store the group nodes * @type {ESTree.VariableDeclaration[]} */ const group_binding_declarations = []; for (const group of analysis.binding_groups.values()) { group_binding_declarations.push(b.const(group.name, b.array([]))); } /** @type {Array<ESTree.Property | ESTree.SpreadElement>} */ const component_returned_object = analysis.exports.flatMap(({ name, alias }) => { const binding = instance_state.scope.get(name); const expression = build_getter(b.id(name), instance_state); const getter = b.get(alias ?? name, [b.return(expression)]); if (expression.type === 'Identifier') { if (binding?.declaration_kind === 'let' || binding?.declaration_kind === 'var') { return [ getter, b.set(alias ?? name, [b.stmt(b.assignment('=', expression, b.id('$$value')))]) ]; } else if (!dev) { return b.init(alias ?? name, expression); } } if (binding?.kind === 'prop' || binding?.kind === 'bindable_prop') { return [getter, b.set(alias ?? name, [b.stmt(b.call(name, b.id('$$value')))])]; } if (binding?.kind === 'state' || binding?.kind === 'raw_state') { const value = binding.kind === 'state' ? b.call('$.proxy', b.id('$$value')) : b.id('$$value'); return [getter, b.set(alias ?? name, [b.stmt(b.call('$.set', b.id(name), value))])]; } return getter; }); const properties = [...analysis.instance.scope.declarations].filter( ([name, binding]) => (binding.kind === 'prop' || binding.kind === 'bindable_prop') && !name.startsWith('$$') ); if (analysis.accessors) { for (const [name, binding] of properties) { const key = binding.prop_alias ?? name; const getter = b.get(key, [b.return(b.call(b.id(name)))]); const setter = b.set(key, [ b.stmt(b.call(b.id(name), b.id('$$value'))), b.stmt(b.call('$.flush')) ]); if (analysis.runes && binding.initial) { // turn `set foo($$value)` into `set foo($$value = expression)` setter.value.params[0] = { type: 'AssignmentPattern', left: b.id('$$value'), right: /** @type {ESTree.Expression} */ (binding.initial) }; } component_returned_object.push(getter, setter); } } if (options.compatibility.componentApi === 4) { component_returned_object.push( b.init('$set', b.id('$.update_legacy_props')), b.init( '$on', b.arrow( [b.id('$$event_name'), b.id('$$event_cb')], b.call( '$.add_legacy_event_listener', b.id('$$props'), b.id('$$event_name'), b.id('$$event_cb') ) ) ) ); } else if (dev) { component_returned_object.push(b.spread(b.call(b.id('$.legacy_api')))); } const push_args = [b.id('$$props'), b.literal(analysis.runes)]; if (dev) push_args.push(b.id(analysis.name)); let component_block = b.block([ ...store_setup, ...legacy_reactive_declarations, ...group_binding_declarations, ...state.instance_level_snippets, .../** @type {ESTree.Statement[]} */ (instance.body), analysis.runes || !analysis.needs_context ? b.empty : b.stmt(b.call('$.init', analysis.immutable ? b.true : undefined)) ]); const should_inject_context = dev || analysis.needs_context || analysis.reactive_statements.size > 0 || component_returned_object.length > 0; let should_inject_props = should_inject_context || analysis.needs_props || analysis.uses_props || analysis.uses_rest_props || analysis.uses_slots || analysis.slot_names.size > 0; if (analysis.instance.has_await) { const body = b.function_declaration( b.id('$$body'), should_inject_props ? [b.id('$$anchor'), b.id('$$props')] : [b.id('$$anchor')], b.block([ b.var('$$unsuspend', b.call('$.suspend')), ...component_block.body, b.if(b.call('$.aborted'), b.return()), .../** @type {ESTree.Statement[]} */ (template.body), b.stmt(b.call('$$unsuspend')) ]), true ); state.hoisted.push(body); component_block = b.block([ b.var('fragment', b.call('$.comment')), b.var('node', b.call('$.first_child', b.id('fragment'))), b.stmt(b.call(body.id, b.id('node'), should_inject_props && b.id('$$props'))), b.stmt(b.call('$.append', b.id('$$anchor'), b.id('fragment'))) ]); } else { component_block.body.push(.../** @type {ESTree.Statement[]} */ (template.body)); } // trick esrap into including comments component_block.loc = instance.loc; if (!analysis.runes) { // Bind static exports to props so that people can access them with bind:x for (const { name, alias } of analysis.exports) { component_block.body.push( b.stmt( b.call( '$.bind_prop', b.id('$$props'), b.literal(alias ?? name), build_getter(b.id(name), instance_state) ) ) ); } } if (analysis.css.ast !== null && analysis.inject_styles) { const hash = b.literal(analysis.css.hash); const code = b.literal(render_stylesheet(analysis.source, analysis, options).code); state.hoisted.push(b.const('$$css', b.object([b.init('hash', hash), b.init('code', code)]))); component_block.body.unshift( b.stmt(b.call('$.append_styles', b.id('$$anchor'), b.id('$$css'))) ); } if (analysis.needs_mutation_validation) { component_block.body.unshift( b.var('$$ownership_validator', b.call('$.create_ownership_validator', b.id('$$props'))) ); } // we want the cleanup function for the stores to run as the very last thing // so that it can effectively clean up the store subscription even after the user effects runs if (should_inject_context) { component_block.body.unshift(b.stmt(b.call('$.push', ...push_args))); let to_push; if (component_returned_object.length > 0) { let pop_call = b.call('$.pop', b.object(component_returned_object)); to_push = needs_store_cleanup ? b.var('$$pop', pop_call) : b.return(pop_call); } else { to_push = b.stmt(b.call('$.pop')); } component_block.body.push(to_push); } if (needs_store_cleanup) { component_block.body.push(b.stmt(b.call('$$cleanup'))); if (component_returned_object.length > 0) { component_block.body.push(b.return(b.id('$$pop'))); } } if (analysis.uses_rest_props) { const named_props = analysis.exports.map(({ name, alias }) => alias ?? name); for (const [name, binding] of analysis.instance.scope.declarations) { if (binding.kind === 'bindable_prop') named_props.push(binding.prop_alias ?? name); } component_block.body.unshift( b.const( '$$restProps', b.call( '$.legacy_rest_props', b.id('$$sanitized_props'), b.array(named_props.map((name) => b.literal(name))) ) ) ); } if (analysis.uses_props || analysis.uses_rest_props) { const to_remove = [ b.literal('children'), b.literal('$$slots'), b.literal('$$events'), b.literal('$$legacy') ]; if (analysis.custom_element) { to_remove.push(b.literal('$$host')); } component_block.body.unshift( b.const( '$$sanitized_props', b.call('$.legacy_rest_props', b.id('$$props'), b.array(to_remove)) ) ); } if (analysis.uses_slots) { component_block.body.unshift(b.const('$$slots', b.call('$.sanitize_slots', b.id('$$props')))); } // Merge hoisted statements into module body. // Ensure imports are on top, with the order preserved, then module body, then hoisted statements /** @type {ESTree.ImportDeclaration[]} */ const imports = []; /** @type {ESTree.Program['body']} */ let body = []; for (const entry of [...module.body, ...state.hoisted]) { if (entry.type === 'ImportDeclaration') { imports.push(entry); } else { body.push(entry); } } body = [...imports, ...state.module_level_snippets, ...body]; const component = b.function_declaration( b.id(analysis.name), should_inject_props ? [b.id('$$anchor'), b.id('$$props')] : [b.id('$$anchor')], component_block ); if (options.hmr) { const id = b.id(analysis.name); const HMR = b.id('$.HMR'); const existing = b.member(id, HMR, true); const incoming = b.member(b.id('module.default'), HMR, true); const accept_fn_body = [ b.stmt(b.assignment('=', b.member(incoming, 'source'), b.member(existing, 'source'))), b.stmt(b.call('$.set', b.member(existing, 'source'), b.member(incoming, 'original'))) ]; if (analysis.css.hash) { // remove existing `<style>` element, in case CSS changed accept_fn_body.unshift(b.stmt(b.call('$.cleanup_styles', b.literal(analysis.css.hash)))); } const hmr = b.block([ b.stmt(b.assignment('=', id, b.call('$.hmr', id, b.thunk(b.member(existing, 'source'))))), b.stmt(b.call('import.meta.hot.accept', b.arrow([b.id('module')], b.block(accept_fn_body)))) ]); body.push(component, b.if(b.id('import.meta.hot'), hmr), b.export_default(b.id(analysis.name))); } else { body.push(b.export_default(component)); } if (dev) { // add `App[$.FILENAME] = 'App.svelte'` so that we can print useful messages later body.unshift( b.stmt( b.assignment('=', b.member(b.id(analysis.name), '$.FILENAME', true), b.literal(filename)) ) ); } if (options.experimental.async) { body.unshift(b.imports([], 'svelte/internal/flags/async')); } if (!analysis.runes) { body.unshift(b.imports([], 'svelte/internal/flags/legacy')); } if (analysis.tracing) { body.unshift(b.imports([], 'svelte/internal/flags/tracing')); } if (options.discloseVersion) { body.unshift(b.imports([], 'svelte/internal/disclose-version')); } if (options.compatibility.componentApi === 4) { body.unshift(b.imports([['createClassComponent', '$$_createClassComponent']], 'svelte/legacy')); component_block.body.unshift( b.if( b.id('new.target'), b.return( b.call( '$$_createClassComponent', // When called with new, the first argument is the constructor options b.object([b.init('component', b.id(analysis.name)), b.spread(b.id('$$anchor'))]) ) ) ) ); } else if (dev) { component_block.body.unshift(b.stmt(b.call('$.check_target', b.id('new.target')))); } if (analysis.props_id) { // need to be placed on first line of the component for hydration component_block.body.unshift(b.const(analysis.props_id, b.call('$.props_id'))); } if (state.events.size > 0) { body.push( b.stmt(b.call('$.delegate', b.array(Array.from(state.events).map((name) => b.literal(name))))) ); } if (analysis.custom_element) { const ce = analysis.custom_element; const ce_props = typeof ce === 'boolean' ? {} : ce.props || {}; /** @type {ESTree.Property[]} */ const props_str = []; for (const [name, prop_def] of Object.entries(ce_props)) { const binding = analysis.instance.scope.get(name); const key = binding?.prop_alias ?? name; if ( !prop_def.type && binding?.initial?.type === 'Literal' && typeof binding?.initial.value === 'boolean' ) { prop_def.type = 'Boolean'; } const value = b.object( /** @type {ESTree.Property[]} */ ( [ prop_def.attribute ? b.init('attribute', b.literal(prop_def.attribute)) : undefined, prop_def.reflect ? b.init('reflect', b.true) : undefined, prop_def.type ? b.init('type', b.literal(prop_def.type)) : undefined ].filter(Boolean) ) ); props_str.push(b.init(key, value)); } for (const [name, binding] of properties) { const key = binding.prop_alias ?? name; if (ce_props[key]) continue; props_str.push(b.init(key, b.object([]))); } const slots_str = b.array([...analysis.slot_names.keys()].map((name) => b.literal(name))); const accessors_str = b.array( analysis.exports.map(({ name, alias }) => b.literal(alias ?? name)) ); const use_shadow_dom = typeof ce === 'boolean' || ce.shadow !== 'none' ? true : false; const create_ce = b.call( '$.create_custom_element', b.id(analysis.name), b.object(props_str), slots_str, accessors_str, b.literal(use_shadow_dom), /** @type {any} */ (typeof ce !== 'boolean' ? ce.extend : undefined) ); // If a tag name is provided, call `customElements.define`, otherwise leave to the user if (typeof ce !== 'boolean' && typeof ce.tag === 'string') { const define = b.stmt(b.call('customElements.define', b.literal(ce.tag), create_ce)); if (options.hmr) { body.push( b.if(b.binary('==', b.call('customElements.get', b.literal(ce.tag)), b.null), define) ); } else { body.push(define); } } else { body.push(b.stmt(create_ce)); } } return { type: 'Program', sourceType: 'module', body }; } /** * @param {Analysis} analysis * @param {ValidatedModuleCompileOptions} options * @returns {ESTree.Program} */ export function client_module(analysis, options) { /** @type {ClientTransformState} */ const state = { analysis, options, scope: analysis.module.scope, scopes: analysis.module.scopes, state_fields: new Map(), transform: {}, in_constructor: false, in_derived: false, is_instance: false }; const module = /** @type {ESTree.Program} */ ( walk(/** @type {AST.SvelteNode} */ (analysis.module.ast), state, visitors) ); const body = [b.import_all('$', 'svelte/internal/client')]; if (analysis.tracing) { body.push(b.imports([], 'svelte/internal/flags/tracing')); } return { type: 'Program', sourceType: 'module', body: [...body, ...module.body] }; }
```

# compiler/phases/3-transform/client/transform-template/fix-attribute-casing.js

```js
const svg_attributes = 'accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan'.split( ' ' ); const svg_attribute_lookup = new Map(); svg_attributes.forEach((name) => { svg_attribute_lookup.set(name.toLowerCase(), name); }); /** * @param {string} name */ export default function fix_attribute_casing(name) { name = name.toLowerCase(); return svg_attribute_lookup.get(name) || name; }
```

# compiler/phases/3-transform/client/transform-template/index.js

```js
/** @import { Location } from 'locate-character' */ /** @import { Namespace } from '#compiler' */ /** @import { ComponentClientTransformState } from '../types.js' */ /** @import { Node } from './types.js' */ import { TEMPLATE_USE_MATHML, TEMPLATE_USE_SVG } from '../../../../../constants.js'; import { dev, locator } from '../../../../state.js'; import * as b from '../../../../utils/builders.js'; /** * @param {Node[]} nodes */ function build_locations(nodes) { const array = b.array([]); for (const node of nodes) { if (node.type !== 'element') continue; const { line, column } = /** @type {Location} */ (locator(node.start)); const expression = b.array([b.literal(line), b.literal(column)]); const children = build_locations(node.children); if (children.elements.length > 0) { expression.elements.push(children); } array.elements.push(expression); } return array; } /** * @param {ComponentClientTransformState} state * @param {Namespace} namespace * @param {number} [flags] */ export function transform_template(state, namespace, flags = 0) { const tree = state.options.fragments === 'tree'; const expression = tree ? state.template.as_tree() : state.template.as_html(); if (tree) { if (namespace === 'svg') flags |= TEMPLATE_USE_SVG; if (namespace === 'mathml') flags |= TEMPLATE_USE_MATHML; } let call = b.call( tree ? `$.from_tree` : `$.from_${namespace}`, expression, flags ? b.literal(flags) : undefined ); if (state.template.contains_script_tag) { call = b.call(`$.with_script`, call); } if (dev) { call = b.call( '$.add_locations', call, b.member(b.id(state.analysis.name), '$.FILENAME', true), build_locations(state.template.nodes) ); } return call; }
```

# compiler/phases/3-transform/client/transform-template/template.js

```js
/** @import { AST } from '#compiler' */ /** @import { Node, Element } from './types'; */ import { escape_html } from '../../../../../escaping.js'; import { is_void } from '../../../../../utils.js'; import * as b from '#compiler/builders'; import fix_attribute_casing from './fix-attribute-casing.js'; import { regex_starts_with_newline } from '../../../patterns.js'; export class Template { /** * `true` if HTML template contains a `<script>` tag. In this case we need to invoke a special * template instantiation function (see `create_fragment_with_script_from_html` for more info) */ contains_script_tag = false; /** `true` if the HTML template needs to be instantiated with `importNode` */ needs_import_node = false; /** @type {Node[]} */ nodes = []; /** @type {Node[][]} */ #stack = [this.nodes]; /** @type {Element | undefined} */ #element; #fragment = this.nodes; /** * @param {string} name * @param {number} start */ push_element(name, start) { this.#element = { type: 'element', name, attributes: {}, children: [], start }; this.#fragment.push(this.#element); this.#fragment = /** @type {Element} */ (this.#element).children; this.#stack.push(this.#fragment); } /** @param {string} [data] */ push_comment(data) { this.#fragment.push({ type: 'comment', data }); } /** @param {AST.Text[]} nodes */ push_text(nodes) { this.#fragment.push({ type: 'text', nodes }); } pop_element() { this.#stack.pop(); this.#fragment = /** @type {Node[]} */ (this.#stack.at(-1)); } /** * @param {string} key * @param {string | undefined} value */ set_prop(key, value) { /** @type {Element} */ (this.#element).attributes[key] = value; } as_html() { return b.template([b.quasi(this.nodes.map(stringify).join(''), true)], []); } as_tree() { // if the first item is a comment we need to add another comment for effect.start if (this.nodes[0].type === 'comment') { this.nodes.unshift({ type: 'comment', data: undefined }); } return b.array(this.nodes.map(objectify)); } } /** * @param {Node} item */ function stringify(item) { if (item.type === 'text') { return item.nodes.map((node) => node.raw).join(''); } if (item.type === 'comment') { return item.data ? `<!--${item.data}-->` : '<!>'; } let str = `<${item.name}`; for (const key in item.attributes) { const value = item.attributes[key]; str += ` ${key}`; if (value !== undefined) str += `="${escape_html(value, true)}"`; } if (is_void(item.name)) { str += '/>'; // XHTML compliance } else { str += `>`; str += item.children.map(stringify).join(''); str += `</${item.name}>`; } return str; } /** @param {Node} item */ function objectify(item) { if (item.type === 'text') { return b.literal(item.nodes.map((node) => node.data).join('')); } if (item.type === 'comment') { return item.data ? b.array([b.literal(`// ${item.data}`)]) : null; } const element = b.array([b.literal(item.name)]); const attributes = b.object([]); for (const key in item.attributes) { const value = item.attributes[key]; attributes.properties.push( b.prop( 'init', b.key(fix_attribute_casing(key)), value === undefined ? b.void0 : b.literal(value) ) ); } if (attributes.properties.length > 0 || item.children.length > 0) { element.elements.push(attributes.properties.length > 0 ? attributes : b.null); } if (item.children.length > 0) { const children = item.children.map(objectify); element.elements.push(...children); // special case — strip leading newline from `<pre>` and `<textarea>` if (item.name === 'pre' || item.name === 'textarea') { const first = children[0]; if (first?.type === 'Literal') { first.value = /** @type {string} */ (first.value).replace(regex_starts_with_newline, ''); } } } return element; }
```

# compiler/phases/3-transform/client/transform-template/types.d.ts

```ts
import type { AST } from '#compiler'; export interface Element { type: 'element'; name: string; attributes: Record<string, string | undefined>; children: Node[]; /** used for populating __svelte_meta */ start: number; } export interface Text { type: 'text'; nodes: AST.Text[]; } export interface Comment { type: 'comment'; data: string | undefined; } export type Node = Element | Text | Comment;
```

# compiler/phases/3-transform/client/types.d.ts

```ts
import type { ModuleDeclaration, Statement, LabeledStatement, Identifier, Expression, AssignmentExpression, UpdateExpression, VariableDeclaration } from 'estree'; import type { AST, Namespace, ValidatedCompileOptions } from '#compiler'; import type { TransformState } from '../types.js'; import type { ComponentAnalysis } from '../../types.js'; import type { Template } from './transform-template/template.js'; import type { Memoizer } from './visitors/shared/utils.js'; export interface ClientTransformState extends TransformState { /** * `true` if the current lexical scope belongs to a class constructor. this allows * us to rewrite `this.foo` as `this.#foo.value` */ readonly in_constructor: boolean; /** * True if we're directly inside a `$derived(...)` expression (but not `$derived.by(...)`) */ readonly in_derived: boolean; /** `true` if we're transforming the contents of `<script>` */ readonly is_instance: boolean; readonly transform: Record< string, { /** turn `foo` into e.g. `$.get(foo)` */ read: (id: Identifier) => Expression; /** turn `foo = bar` into e.g. `$.set(foo, bar)` */ assign?: (node: Identifier, value: Expression, proxy?: boolean) => Expression; /** turn `foo.bar = baz` into e.g. `$.mutate(foo, $.get(foo).bar = baz);` */ mutate?: (node: Identifier, mutation: AssignmentExpression | UpdateExpression) => Expression; /** turn `foo++` into e.g. `$.update(foo)` */ update?: (node: UpdateExpression) => Expression; } >; } export interface ComponentClientTransformState extends ClientTransformState { readonly analysis: ComponentAnalysis; readonly options: ValidatedCompileOptions; readonly hoisted: Array<Statement | ModuleDeclaration>; readonly events: Set<string>; readonly store_to_invalidate?: string; /** Stuff that happens before the render effect(s) */ readonly init: Statement[]; /** Stuff that happens inside the render effect */ readonly update: Statement[]; /** Stuff that happens after the render effect (control blocks, dynamic elements, bindings, actions, etc) */ readonly after_update: Statement[]; /** Memoized expressions */ readonly memoizer: Memoizer; /** The HTML template string */ readonly template: Template; readonly metadata: { namespace: Namespace; bound_contenteditable: boolean; }; readonly preserve_whitespace: boolean; /** The anchor node for the current context */ readonly node: Identifier; /** Imports that should be re-evaluated in legacy mode following a mutation */ readonly legacy_reactive_imports: Statement[]; /** The $: calls, which will be ordered in the end */ readonly legacy_reactive_statements: Map<LabeledStatement, Statement>; /** Snippets hoisted to the instance */ readonly instance_level_snippets: VariableDeclaration[]; /** Snippets hoisted to the module */ readonly module_level_snippets: VariableDeclaration[]; } export type Context = import('zimmerframe').Context<AST.SvelteNode, ClientTransformState>; export type Visitors = import('zimmerframe').Visitors<AST.SvelteNode, any>; export type ComponentContext = import('zimmerframe').Context< AST.SvelteNode, ComponentClientTransformState >; export type ComponentVisitors = import('zimmerframe').Visitors< AST.SvelteNode, ComponentClientTransformState >;
```

# compiler/phases/3-transform/client/utils.js

```js
/** @import { ArrowFunctionExpression, AssignmentExpression, Expression, FunctionDeclaration, FunctionExpression, Identifier, Node, Pattern, UpdateExpression } from 'estree' */ /** @import { Binding } from '#compiler' */ /** @import { ClientTransformState, ComponentClientTransformState, ComponentContext } from './types.js' */ /** @import { Analysis } from '../../types.js' */ /** @import { Scope } from '../../scope.js' */ import * as b from '#compiler/builders'; import { is_simple_expression } from '../../../utils/ast.js'; import { PROPS_IS_LAZY_INITIAL, PROPS_IS_IMMUTABLE, PROPS_IS_RUNES, PROPS_IS_UPDATED, PROPS_IS_BINDABLE } from '../../../../constants.js'; import { dev } from '../../../state.js'; import { walk } from 'zimmerframe'; import { validate_mutation } from './visitors/shared/utils.js'; /** * @param {Binding} binding * @param {Analysis} analysis * @returns {boolean} */ export function is_state_source(binding, analysis) { return ( (binding.kind === 'state' || binding.kind === 'raw_state') && (!analysis.immutable || binding.reassigned || analysis.accessors) ); } /** * @param {Identifier} node * @param {ClientTransformState} state * @returns {Expression} */ export function build_getter(node, state) { if (Object.hasOwn(state.transform, node.name)) { const binding = state.scope.get(node.name); // don't transform the declaration itself if (node !== binding?.node) { return state.transform[node.name].read(node); } } return node; } /** * @param {FunctionDeclaration | FunctionExpression | ArrowFunctionExpression} node * @param {ComponentContext} context * @returns {Pattern[]} */ function get_hoisted_params(node, context) { const scope = context.state.scope; /** @type {Identifier[]} */ const params = []; /** * We only want to push if it's not already present to avoid name clashing * @param {Identifier} id */ function push_unique(id) { if (!params.find((param) => param.name === id.name)) { params.push(id); } } for (const [reference] of scope.references) { let binding = scope.get(reference); if (binding !== null && !scope.declarations.has(reference) && binding.initial !== node) { if (binding.kind === 'store_sub') { // We need both the subscription for getting the value and the store for updating push_unique(b.id(binding.node.name)); binding = /** @type {Binding} */ (scope.get(binding.node.name.slice(1))); } let expression = context.state.transform[reference]?.read(b.id(binding.node.name)); if ( // If it's a destructured derived binding, then we can extract the derived signal reference and use that. // TODO this code is bad, we need to kill it expression != null && typeof expression !== 'function' && expression.type === 'MemberExpression' && expression.object.type === 'CallExpression' && expression.object.callee.type === 'Identifier' && expression.object.callee.name === '$.get' && expression.object.arguments[0].type === 'Identifier' ) { push_unique(b.id(expression.object.arguments[0].name)); } else if ( // If we are referencing a simple $$props value, then we need to reference the object property instead (binding.kind === 'prop' || binding.kind === 'bindable_prop') && !is_prop_source(binding, context.state) ) { push_unique(b.id('$$props')); } else if ( // imports don't need to be hoisted binding.declaration_kind !== 'import' ) { // create a copy to remove start/end tags which would mess up source maps push_unique(b.id(binding.node.name)); // rest props are often accessed through the $$props object for optimization reasons, // but we can't know if the delegated event handler will use it, so we need to add both as params if (binding.kind === 'rest_prop' && context.state.analysis.runes) { push_unique(b.id('$$props')); } } } } if (dev) { // this is a little hacky, but necessary for ownership validation // to work inside hoisted event handlers /** * @param {AssignmentExpression | UpdateExpression} node * @param {{ next: () => void, stop: () => void }} context */ function visit(node, { next, stop }) { if (validate_mutation(node, /** @type {any} */ (context), node) !== node) { params.push(b.id('$$ownership_validator')); stop(); } else { next(); } } walk(/** @type {Node} */ (node), null, { AssignmentExpression: visit, UpdateExpression: visit }); } return params; } /** * @param {FunctionDeclaration | FunctionExpression | ArrowFunctionExpression} node * @param {ComponentContext} context * @returns {Pattern[]} */ export function build_hoisted_params(node, context) { const hoisted_params = get_hoisted_params(node, context); node.metadata.hoisted_params = hoisted_params; /** @type {Pattern[]} */ const params = []; if (node.params.length === 0) { if (hoisted_params.length > 0) { // For the event object params.push(b.id(context.state.scope.generate('_'))); } } else { for (const param of node.params) { params.push(/** @type {Pattern} */ (context.visit(param))); } } params.push(...hoisted_params); return params; } /** * @param {Binding} binding * @param {ComponentClientTransformState} state * @param {string} name * @param {Expression | null} [initial] * @returns */ export function get_prop_source(binding, state, name, initial) { /** @type {Expression[]} */ const args = [b.id('$$props'), b.literal(name)]; let flags = 0; if (binding.kind === 'bindable_prop') { flags |= PROPS_IS_BINDABLE; } if (state.analysis.immutable) { flags |= PROPS_IS_IMMUTABLE; } if (state.analysis.runes) { flags |= PROPS_IS_RUNES; } if ( state.analysis.accessors || (state.analysis.immutable ? binding.reassigned || (state.analysis.runes && binding.mutated) : binding.updated) ) { flags |= PROPS_IS_UPDATED; } /** @type {Expression | undefined} */ let arg; if (initial) { // To avoid eagerly evaluating the right-hand-side, we wrap it in a thunk if necessary if (is_simple_expression(initial)) { arg = initial; } else { if ( initial.type === 'CallExpression' && initial.callee.type === 'Identifier' && initial.arguments.length === 0 ) { arg = initial.callee; } else { arg = b.thunk(initial); } flags |= PROPS_IS_LAZY_INITIAL; } } if (flags || arg) { args.push(b.literal(flags)); if (arg) args.push(arg); } return b.call('$.prop', ...args); } /** * * @param {Binding} binding * @param {ClientTransformState} state * @returns */ export function is_prop_source(binding, state) { return ( (binding.kind === 'prop' || binding.kind === 'bindable_prop') && (!state.analysis.runes || state.analysis.accessors || binding.reassigned || binding.initial || // Until legacy mode is gone, we also need to use the prop source when only mutated is true, // because the parent could be a legacy component which needs coarse-grained reactivity binding.updated) ); } /** * @param {Expression} node * @param {Scope | null} scope */ export function should_proxy(node, scope) { if ( !node || node.type === 'Literal' || node.type === 'TemplateLiteral' || node.type === 'ArrowFunctionExpression' || node.type === 'FunctionExpression' || node.type === 'UnaryExpression' || node.type === 'BinaryExpression' || (node.type === 'Identifier' && node.name === 'undefined') ) { return false; } if (node.type === 'Identifier' && scope !== null) { const binding = scope.get(node.name); // Let's see if the reference is something that can be proxied if ( binding !== null && !binding.reassigned && binding.initial !== null && binding.initial.type !== 'FunctionDeclaration' && binding.initial.type !== 'ClassDeclaration' && binding.initial.type !== 'ImportDeclaration' && binding.initial.type !== 'EachBlock' && binding.initial.type !== 'SnippetBlock' ) { return should_proxy(binding.initial, null); } } return true; } /** * Svelte legacy mode should use safe equals in most places, runes mode shouldn't * @param {ComponentClientTransformState} state * @param {Expression} arg */ export function create_derived(state, arg) { return b.call(state.analysis.runes ? '$.derived' : '$.derived_safe_equal', arg); }
```

# compiler/phases/3-transform/client/visitors/AnimateDirective.js

```js
/** @import { Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import * as b from '#compiler/builders'; import { parse_directive_name } from './shared/utils.js'; /** * @param {AST.AnimateDirective} node * @param {ComponentContext} context */ export function AnimateDirective(node, context) { const expression = node.expression === null ? b.null : b.thunk(/** @type {Expression} */ (context.visit(node.expression))); // in after_update to ensure it always happens after bind:this context.state.after_update.push( b.stmt( b.call( '$.animation', context.state.node, b.thunk(/** @type {Expression} */ (context.visit(parse_directive_name(node.name)))), expression ) ) ); }
```

# compiler/phases/3-transform/client/visitors/ArrowFunctionExpression.js

```js
/** @import { ArrowFunctionExpression } from 'estree' */ /** @import { ComponentContext } from '../types' */ import { visit_function } from './shared/function.js'; /** * @param {ArrowFunctionExpression} node * @param {ComponentContext} context */ export function ArrowFunctionExpression(node, context) { return visit_function(node, context); }
```

# compiler/phases/3-transform/client/visitors/AssignmentExpression.js

```js
/** @import { AssignmentExpression, AssignmentOperator, Expression, Identifier, Pattern } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { Context } from '../types.js' */ import * as b from '#compiler/builders'; import { build_assignment_value, get_attribute_expression, is_event_attribute } from '../../../../utils/ast.js'; import { dev, locate_node } from '../../../../state.js'; import { should_proxy } from '../utils.js'; import { visit_assignment_expression } from '../../shared/assignments.js'; import { validate_mutation } from './shared/utils.js'; import { get_rune } from '../../../scope.js'; import { get_name } from '../../../nodes.js'; /** * @param {AssignmentExpression} node * @param {Context} context */ export function AssignmentExpression(node, context) { const expression = /** @type {Expression} */ ( visit_assignment_expression(node, context, build_assignment) ?? context.next() ); return validate_mutation(node, context, expression); } /** * Determines whether the value will be coerced on assignment (as with e.g. `+=`). * If not, we may need to proxify the value, or warn that the value will not be * proxified in time * @param {AssignmentOperator} operator */ function is_non_coercive_operator(operator) { return ['=', '||=', '&&=', '??='].includes(operator); } /** @type {Record<string, string>} */ const callees = { '=': '$.assign', '&&=': '$.assign_and', '||=': '$.assign_or', '??=': '$.assign_nullish' }; /** * @param {AssignmentOperator} operator * @param {Pattern} left * @param {Expression} right * @param {Context} context * @returns {Expression | null} */ function build_assignment(operator, left, right, context) { if (context.state.analysis.runes && left.type === 'MemberExpression') { const name = get_name(left.property); const field = name && context.state.state_fields.get(name); if (field) { // special case — state declaration in class constructor if (field.node.type === 'AssignmentExpression' && left === field.node.left) { const rune = get_rune(right, context.state.scope); if (rune) { const child_state = { ...context.state, in_constructor: rune !== '$derived' && rune !== '$derived.by' }; let value = /** @type {Expression} */ (context.visit(right, child_state)); if (dev) { const declaration = context.path.findLast( (parent) => parent.type === 'ClassDeclaration' || parent.type === 'ClassExpression' ); value = b.call( '$.tag', value, b.literal(`${declaration?.id?.name ?? '[class]'}.${name}`) ); } return b.assignment(operator, b.member(b.this, field.key), value); } } // special case — assignment to private state field if (left.property.type === 'PrivateIdentifier') { let value = /** @type {Expression} */ ( context.visit(build_assignment_value(operator, left, right)) ); const needs_proxy = field.type === '$state' && is_non_coercive_operator(operator) && should_proxy(value, context.state.scope); return b.call('$.set', left, value, needs_proxy && b.true); } } } let object = left; while (object.type === 'MemberExpression') { // @ts-expect-error object = object.object; } if (object.type !== 'Identifier') { return null; } const binding = context.state.scope.get(object.name); if (!binding) return null; const transform = Object.hasOwn(context.state.transform, object.name) ? context.state.transform[object.name] : null; const path = context.path.map((node) => node.type); // reassignment if (object === left && transform?.assign) { // special case — if an element binding, we know it's a primitive const is_primitive = path.at(-1) === 'BindDirective' && path.at(-2) === 'RegularElement'; let value = /** @type {Expression} */ ( context.visit(build_assignment_value(operator, left, right)) ); return transform.assign( object, value, !is_primitive && binding.kind !== 'prop' && binding.kind !== 'bindable_prop' && binding.kind !== 'raw_state' && binding.kind !== 'derived' && binding.kind !== 'store_sub' && context.state.analysis.runes && should_proxy(right, context.state.scope) && is_non_coercive_operator(operator) ); } // mutation if (transform?.mutate) { return transform.mutate( object, b.assignment( operator, /** @type {Pattern} */ (context.visit(left)), /** @type {Expression} */ (context.visit(right)) ) ); } // in cases like `(object.items ??= []).push(value)`, we may need to warn // if the value gets proxified, since the proxy _isn't_ the thing that // will be pushed to. we do this by transforming it to something like // `$.assign_nullish(object, 'items', [])` let should_transform = dev && path.at(-1) !== 'ExpressionStatement' && is_non_coercive_operator(operator); // special case — ignore `onclick={() => (...)}` if ( path.at(-1) === 'ArrowFunctionExpression' && (path.at(-2) === 'RegularElement' || path.at(-2) === 'SvelteElement') ) { const element = /** @type {AST.RegularElement} */ (context.path.at(-2)); const attribute = element.attributes.find((attribute) => { if (attribute.type !== 'Attribute' || !is_event_attribute(attribute)) { return false; } const expression = get_attribute_expression(attribute); return expression === context.path.at(-1); }); if (attribute) { should_transform = false; } } // special case — ignore `bind:prop={getter, (v) => (...)}` / `bind:value={x.y}` if ( path.at(-1) === 'BindDirective' || path.at(-1) === 'Component' || path.at(-1) === 'SvelteComponent' || (path.at(-1) === 'ArrowFunctionExpression' && path.at(-2) === 'SequenceExpression' && (path.at(-3) === 'Component' || path.at(-3) === 'SvelteComponent' || path.at(-3) === 'BindDirective')) ) { should_transform = false; } if (left.type === 'MemberExpression' && should_transform) { const callee = callees[operator]; return /** @type {Expression} */ ( context.visit( b.call( callee, /** @type {Expression} */ (left.object), /** @type {Expression} */ ( left.computed ? left.property : b.literal(/** @type {Identifier} */ (left.property).name) ), right, b.literal(locate_node(left)) ) ) ); } return null; }
```

# compiler/phases/3-transform/client/visitors/AttachTag.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import * as b from '../../../../utils/builders.js'; import { build_expression } from './shared/utils.js'; /** * @param {AST.AttachTag} node * @param {ComponentContext} context */ export function AttachTag(node, context) { const expression = build_expression(context, node.expression, node.metadata.expression); context.state.init.push(b.stmt(b.call('$.attach', context.state.node, b.thunk(expression)))); context.next(); }
```

# compiler/phases/3-transform/client/visitors/Attribute.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { is_event_attribute } from '../../../../utils/ast.js'; import { visit_event_attribute } from './shared/events.js'; /** * @param {AST.Attribute} node * @param {ComponentContext} context */ export function Attribute(node, context) { if (is_event_attribute(node)) { visit_event_attribute(node, context); } }
```

# compiler/phases/3-transform/client/visitors/AwaitBlock.js

```js
/** @import { BlockStatement, Pattern, Statement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentClientTransformState, ComponentContext } from '../types' */ import { extract_identifiers } from '../../../../utils/ast.js'; import * as b from '#compiler/builders'; import { create_derived } from '../utils.js'; import { get_value } from './shared/declarations.js'; import { build_expression, add_svelte_meta } from './shared/utils.js'; /** * @param {AST.AwaitBlock} node * @param {ComponentContext} context */ export function AwaitBlock(node, context) { context.state.template.push_comment(); // Visit {#await <expression>} first to ensure that scopes are in the correct order const expression = b.thunk(build_expression(context, node.expression, node.metadata.expression)); let then_block; let catch_block; if (node.then) { const then_context = { ...context, state: { ...context.state, transform: { ...context.state.transform } } }; const argument = node.value && create_derived_block_argument(node.value, then_context); /** @type {Pattern[]} */ const args = [b.id('$$anchor')]; if (argument) args.push(argument.id); const declarations = argument?.declarations ?? []; const block = /** @type {BlockStatement} */ (then_context.visit(node.then, then_context.state)); then_block = b.arrow(args, b.block([...declarations, ...block.body])); } if (node.catch) { const catch_context = { ...context, state: { ...context.state } }; const argument = node.error && create_derived_block_argument(node.error, catch_context); /** @type {Pattern[]} */ const args = [b.id('$$anchor')]; if (argument) args.push(argument.id); const declarations = argument?.declarations ?? []; const block = /** @type {BlockStatement} */ ( catch_context.visit(node.catch, catch_context.state) ); catch_block = b.arrow(args, b.block([...declarations, ...block.body])); } context.state.init.push( add_svelte_meta( b.call( '$.await', context.state.node, expression, node.pending ? b.arrow([b.id('$$anchor')], /** @type {BlockStatement} */ (context.visit(node.pending))) : b.null, then_block, catch_block ), node, 'await' ) ); } /** * @param {Pattern} node * @param {import('zimmerframe').Context<AST.SvelteNode, ComponentClientTransformState>} context * @returns {{ id: Pattern, declarations: null | Statement[] }} */ function create_derived_block_argument(node, context) { if (node.type === 'Identifier') { context.state.transform[node.name] = { read: get_value }; return { id: node, declarations: null }; } const pattern = /** @type {Pattern} */ (context.visit(node)); const identifiers = extract_identifiers(node); const id = b.id('$$source'); const value = b.id('$$value'); const block = b.block([ b.var(pattern, b.call('$.get', id)), b.return(b.object(identifiers.map((identifier) => b.prop('init', identifier, identifier)))) ]); const declarations = [b.var(value, create_derived(context.state, b.thunk(block)))]; for (const id of identifiers) { context.state.transform[id.name] = { read: get_value }; declarations.push( b.var(id, create_derived(context.state, b.thunk(b.member(b.call('$.get', value), id)))) ); } return { id, declarations }; }
```

# compiler/phases/3-transform/client/visitors/AwaitExpression.js

```js
/** @import { AwaitExpression, Expression, Property, SpreadElement } from 'estree' */ /** @import { Context } from '../types' */ import { dev, is_ignored } from '../../../../state.js'; import * as b from '../../../../utils/builders.js'; /** * @param {AwaitExpression} node * @param {Context} context */ export function AwaitExpression(node, context) { const argument = /** @type {Expression} */ (context.visit(node.argument)); const tla = context.state.is_instance && context.state.scope.function_depth === 1; // preserve context for // a) top-level await and // b) awaits that precede other expressions in template or `$derived(...)` if (tla || (is_reactive_expression(context) && !is_last_evaluated_expression(context, node))) { return b.call(b.await(b.call('$.save', argument))); } // in dev, note which values are read inside a reactive expression, // but don't track them else if (dev && !is_ignored(node, 'await_reactivity_loss')) { return b.call(b.await(b.call('$.track_reactivity_loss', argument))); } return argument === node.argument ? node : { ...node, argument }; } /** * @param {Context} context */ function is_reactive_expression(context) { if (context.state.in_derived) { return true; } let i = context.path.length; while (i--) { const parent = context.path[i]; if ( parent.type === 'ArrowFunctionExpression' || parent.type === 'FunctionExpression' || parent.type === 'FunctionDeclaration' ) { return false; } // @ts-expect-error we could probably use a neater/more robust mechanism if (parent.metadata) { return true; } } return false; } /** * @param {Context} context * @param {Expression | SpreadElement | Property} node */ function is_last_evaluated_expression(context, node) { let i = context.path.length; while (i--) { const parent = /** @type {Expression | Property | SpreadElement} */ (context.path[i]); // @ts-expect-error we could probably use a neater/more robust mechanism if (parent.metadata) { return true; } switch (parent.type) { case 'ArrayExpression': if (node !== parent.elements.at(-1)) return false; break; case 'AssignmentExpression': case 'BinaryExpression': case 'LogicalExpression': if (node === parent.left) return false; break; case 'CallExpression': case 'NewExpression': if (node !== parent.arguments.at(-1)) return false; break; case 'ConditionalExpression': if (node === parent.test) return false; break; case 'MemberExpression': if (parent.computed && node === parent.object) return false; break; case 'ObjectExpression': if (node !== parent.properties.at(-1)) return false; break; case 'Property': if (node === parent.key) return false; break; case 'SequenceExpression': if (node !== parent.expressions.at(-1)) return false; break; case 'TaggedTemplateExpression': if (node !== parent.quasi.expressions.at(-1)) return false; break; case 'TemplateLiteral': if (node !== parent.expressions.at(-1)) return false; break; default: return false; } node = parent; } }
```

# compiler/phases/3-transform/client/visitors/BinaryExpression.js

```js
/** @import { Expression, BinaryExpression } from 'estree' */ /** @import { ComponentContext } from '../types' */ import { dev } from '../../../../state.js'; import * as b from '#compiler/builders'; /** * @param {BinaryExpression} node * @param {ComponentContext} context */ export function BinaryExpression(node, context) { if (dev) { const operator = node.operator; if (operator === '===' || operator === '!==') { return b.call( '$.strict_equals', /** @type {Expression} */ (context.visit(node.left)), /** @type {Expression} */ (context.visit(node.right)), operator === '!==' && b.false ); } if (operator === '==' || operator === '!=') { return b.call( '$.equals', /** @type {Expression} */ (context.visit(node.left)), /** @type {Expression} */ (context.visit(node.right)), operator === '!=' && b.false ); } } context.next(); }
```

# compiler/phases/3-transform/client/visitors/BindDirective.js

```js
/** @import { CallExpression, Expression, Pattern } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { dev, is_ignored } from '../../../../state.js'; import { is_text_attribute } from '../../../../utils/ast.js'; import * as b from '#compiler/builders'; import { binding_properties } from '../../../bindings.js'; import { build_attribute_value } from './shared/element.js'; import { build_bind_this, validate_binding } from './shared/utils.js'; /** * @param {AST.BindDirective} node * @param {ComponentContext} context */ export function BindDirective(node, context) { const expression = /** @type {Expression} */ (context.visit(node.expression)); const property = binding_properties[node.name]; const parent = /** @type {AST.SvelteNode} */ (context.path.at(-1)); let get, set; if (expression.type === 'SequenceExpression') { [get, set] = expression.expressions; } else { if ( dev && context.state.analysis.runes && expression.type === 'MemberExpression' && (node.name !== 'this' || context.path.some( ({ type }) => type === 'IfBlock' || type === 'EachBlock' || type === 'AwaitBlock' || type === 'KeyBlock' )) && !is_ignored(node, 'binding_property_non_reactive') ) { validate_binding(context.state, node, expression); } get = b.thunk(expression); /** @type {Expression | undefined} */ set = b.unthunk( b.arrow( [b.id('$$value')], /** @type {Expression} */ ( context.visit( b.assignment('=', /** @type {Pattern} */ (node.expression), b.id('$$value')) ) ) ) ); if (get === set) { set = undefined; } } /** @type {CallExpression} */ let call; if (property?.event) { call = b.call( '$.bind_property', b.literal(node.name), b.literal(property.event), context.state.node, set ?? get, property.bidirectional && get ); } else { // special cases switch (node.name) { // window case 'online': call = b.call(`$.bind_online`, set ?? get); break; case 'scrollX': case 'scrollY': call = b.call( '$.bind_window_scroll', b.literal(node.name === 'scrollX' ? 'x' : 'y'), get, set ); break; case 'innerWidth': case 'innerHeight': case 'outerWidth': case 'outerHeight': call = b.call('$.bind_window_size', b.literal(node.name), set ?? get); break; // document case 'activeElement': call = b.call('$.bind_active_element', set ?? get); break; // media case 'muted': call = b.call(`$.bind_muted`, context.state.node, get, set); break; case 'paused': call = b.call(`$.bind_paused`, context.state.node, get, set); break; case 'volume': call = b.call(`$.bind_volume`, context.state.node, get, set); break; case 'playbackRate': call = b.call(`$.bind_playback_rate`, context.state.node, get, set); break; case 'currentTime': call = b.call(`$.bind_current_time`, context.state.node, get, set); break; case 'buffered': call = b.call(`$.bind_buffered`, context.state.node, set ?? get); break; case 'played': call = b.call(`$.bind_played`, context.state.node, set ?? get); break; case 'seekable': call = b.call(`$.bind_seekable`, context.state.node, set ?? get); break; case 'seeking': call = b.call(`$.bind_seeking`, context.state.node, set ?? get); break; case 'ended': call = b.call(`$.bind_ended`, context.state.node, set ?? get); break; case 'readyState': call = b.call(`$.bind_ready_state`, context.state.node, set ?? get); break; // dimensions case 'contentRect': case 'contentBoxSize': case 'borderBoxSize': case 'devicePixelContentBoxSize': call = b.call( '$.bind_resize_observer', context.state.node, b.literal(node.name), set ?? get ); break; case 'clientWidth': case 'clientHeight': case 'offsetWidth': case 'offsetHeight': call = b.call('$.bind_element_size', context.state.node, b.literal(node.name), set ?? get); break; // various case 'value': { if (parent?.type === 'RegularElement' && parent.name === 'select') { call = b.call(`$.bind_select_value`, context.state.node, get, set); } else { call = b.call(`$.bind_value`, context.state.node, get, set); } break; } case 'files': call = b.call(`$.bind_files`, context.state.node, get, set); break; case 'this': call = build_bind_this(node.expression, context.state.node, context); break; case 'textContent': case 'innerHTML': case 'innerText': call = b.call( '$.bind_content_editable', b.literal(node.name), context.state.node, get, set ); break; // checkbox/radio case 'checked': call = b.call(`$.bind_checked`, context.state.node, get, set); break; case 'focused': call = b.call(`$.bind_focused`, context.state.node, set ?? get); break; case 'group': { const indexes = node.metadata.parent_each_blocks.map((each) => { // if we have a keyed block with an index, the index is wrapped in a source return each.metadata.keyed && each.index ? b.call('$.get', each.metadata.index) : each.metadata.index; }); // We need to additionally invoke the value attribute signal to register it as a dependency, // so that when the value is updated, the group binding is updated let group_getter = get; if (parent?.type === 'RegularElement') { const value = /** @type {any[]} */ ( /** @type {AST.Attribute} */ ( parent.attributes.find( (a) => a.type === 'Attribute' && a.name === 'value' && !is_text_attribute(a) && a.value !== true ) )?.value ); if (value !== undefined) { group_getter = b.thunk( b.block([b.stmt(build_attribute_value(value, context).value), b.return(expression)]) ); } } call = b.call( '$.bind_group', node.metadata.binding_group_name, b.array(indexes), context.state.node, group_getter, set ?? get ); break; } default: throw new Error('unknown binding ' + node.name); } } // Bindings need to happen after attribute updates, therefore after the render effect, and in order with events/actions. // bind:this is a special case as it's one-way and could influence the render effect. if (node.name === 'this') { context.state.init.push(b.stmt(call)); } else { const has_use = parent.type === 'RegularElement' && parent.attributes.find((a) => a.type === 'UseDirective'); if (has_use) { context.state.init.push(b.stmt(b.call('$.effect', b.thunk(call)))); } else { context.state.after_update.push(b.stmt(call)); } } }
```

# compiler/phases/3-transform/client/visitors/BlockStatement.js

```js
/** @import { ArrowFunctionExpression, BlockStatement, Expression, FunctionDeclaration, FunctionExpression, Statement } from 'estree' */ /** @import { ComponentContext } from '../types' */ import { add_state_transformers } from './shared/declarations.js'; import * as b from '#compiler/builders'; /** * @param {BlockStatement} node * @param {ComponentContext} context */ export function BlockStatement(node, context) { add_state_transformers(context); const tracing = context.state.scope.tracing; if (tracing !== null) { const parent = /** @type {ArrowFunctionExpression | FunctionDeclaration | FunctionExpression} */ ( context.path.at(-1) ); const is_async = parent.async; const call = b.call( '$.trace', /** @type {Expression} */ (tracing), b.thunk(b.block(node.body.map((n) => /** @type {Statement} */ (context.visit(n)))), is_async) ); return b.block([b.return(is_async ? b.await(call) : call)]); } context.next(); }
```

# compiler/phases/3-transform/client/visitors/BreakStatement.js

```js
/** @import { BreakStatement } from 'estree' */ /** @import { ComponentContext } from '../types' */ import * as b from '#compiler/builders'; /** * @param {BreakStatement} node * @param {ComponentContext} context */ export function BreakStatement(node, context) { if (context.state.analysis.runes || !node.label || node.label.name !== '$') { return; } const in_reactive_statement = context.path[1].type === 'LabeledStatement' && context.path[1].label.name === '$'; if (in_reactive_statement) { return b.return(); } }
```

# compiler/phases/3-transform/client/visitors/CallExpression.js

```js
/** @import { CallExpression, Expression } from 'estree' */ /** @import { Context } from '../types' */ import { dev, is_ignored } from '../../../../state.js'; import * as b from '#compiler/builders'; import { get_rune } from '../../../scope.js'; import { transform_inspect_rune } from '../../utils.js'; import { should_proxy } from '../utils.js'; /** * @param {CallExpression} node * @param {Context} context */ export function CallExpression(node, context) { const rune = get_rune(node, context.state.scope); switch (rune) { case '$host': return b.id('$$props.$$host'); case '$effect.tracking': return b.call('$.effect_tracking'); // transform state field assignments in constructors case '$state': case '$state.raw': { let arg = node.arguments[0]; /** @type {Expression | undefined} */ let value = undefined; if (arg) { value = /** @type {Expression} */ (context.visit(node.arguments[0])); if ( rune === '$state' && should_proxy(/** @type {Expression} */ (arg), context.state.scope) ) { value = b.call('$.proxy', value); } } return b.call('$.state', value); } case '$derived': case '$derived.by': { let fn = /** @type {Expression} */ ( context.visit(node.arguments[0], { ...context.state, in_derived: rune === '$derived' }) ); return b.call('$.derived', rune === '$derived' ? b.thunk(fn) : fn); } case '$state.snapshot': return b.call( '$.snapshot', /** @type {Expression} */ (context.visit(node.arguments[0])), is_ignored(node, 'state_snapshot_uncloneable') && b.true ); case '$effect.root': return b.call( '$.effect_root', .../** @type {Expression[]} */ (node.arguments.map((arg) => context.visit(arg))) ); case '$effect.pending': return b.call('$.pending'); case '$inspect': case '$inspect().with': return transform_inspect_rune(node, context); } if ( dev && node.callee.type === 'MemberExpression' && node.callee.object.type === 'Identifier' && node.callee.object.name === 'console' && context.state.scope.get('console') === null && node.callee.property.type === 'Identifier' && ['debug', 'dir', 'error', 'group', 'groupCollapsed', 'info', 'log', 'trace', 'warn'].includes( node.callee.property.name ) && node.arguments.some((arg) => arg.type !== 'Literal') // TODO more cases? ) { return b.call( node.callee, b.spread( b.call( '$.log_if_contains_state', b.literal(node.callee.property.name), .../** @type {Expression[]} */ (node.arguments.map((arg) => context.visit(arg))) ) ) ); } context.next(); }
```

# compiler/phases/3-transform/client/visitors/ClassBody.js

```js
/** @import { CallExpression, ClassBody, ClassDeclaration, ClassExpression, MethodDefinition, PropertyDefinition, StaticBlock } from 'estree' */ /** @import { StateField } from '#compiler' */ /** @import { Context } from '../types' */ import * as b from '#compiler/builders'; import { dev } from '../../../../state.js'; import { get_parent } from '../../../../utils/ast.js'; import { get_name } from '../../../nodes.js'; /** * @param {ClassBody} node * @param {Context} context */ export function ClassBody(node, context) { const state_fields = context.state.analysis.classes.get(node); if (!state_fields) { // in legacy mode, do nothing context.next(); return; } /** @type {Array<MethodDefinition | PropertyDefinition | StaticBlock>} */ const body = []; const child_state = { ...context.state, state_fields }; for (const [name, field] of state_fields) { if (name[0] === '#') { continue; } // insert backing fields for stuff declared in the constructor if (field.node.type === 'AssignmentExpression') { const member = b.member(b.this, field.key); const should_proxy = field.type === '$state' && true; // TODO const key = b.key(name); body.push( b.prop_def(field.key, null), b.method('get', key, [], [b.return(b.call('$.get', member))]), b.method( 'set', key, [b.id('value')], [b.stmt(b.call('$.set', member, b.id('value'), should_proxy && b.true))] ) ); } } const declaration = /** @type {ClassDeclaration | ClassExpression} */ ( get_parent(context.path, -1) ); // Replace parts of the class body for (const definition of node.body) { if (definition.type !== 'PropertyDefinition') { body.push( /** @type {MethodDefinition | StaticBlock} */ (context.visit(definition, child_state)) ); continue; } const name = get_name(definition.key); const field = name && /** @type {StateField} */ (state_fields.get(name)); if (!field) { body.push(/** @type {PropertyDefinition} */ (context.visit(definition, child_state))); continue; } if (name[0] === '#') { let value = definition.value ? /** @type {CallExpression} */ (context.visit(definition.value, child_state)) : undefined; if (dev && field.node === definition) { value = b.call('$.tag', value, b.literal(`${declaration.id?.name ?? '[class]'}.${name}`)); } body.push(b.prop_def(definition.key, value)); } else if (field.node === definition) { let call = /** @type {CallExpression} */ (context.visit(field.value, child_state)); if (dev) { call = b.call('$.tag', call, b.literal(`${declaration.id?.name ?? '[class]'}.${name}`)); } const member = b.member(b.this, field.key); const should_proxy = field.type === '$state' && true; // TODO body.push( b.prop_def(field.key, call), b.method('get', definition.key, [], [b.return(b.call('$.get', member))]), b.method( 'set', definition.key, [b.id('value')], [b.stmt(b.call('$.set', member, b.id('value'), should_proxy && b.true))] ) ); } } return { ...node, body }; }
```

# compiler/phases/3-transform/client/visitors/Comment.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ /** * @param {AST.Comment} node * @param {ComponentContext} context */ export function Comment(node, context) { // We'll only get here if comments are not filtered out, which they are unless preserveComments is true context.state.template.push_comment(node.data); }
```

# compiler/phases/3-transform/client/visitors/Component.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { regex_is_valid_identifier } from '../../../patterns.js'; import { build_component } from './shared/component.js'; /** * @param {AST.Component} node * @param {ComponentContext} context */ export function Component(node, context) { const component = build_component(node, node.name, context); context.state.init.push(component); }
```

# compiler/phases/3-transform/client/visitors/ConstTag.js

```js
/** @import { Pattern } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { dev } from '../../../../state.js'; import { extract_identifiers } from '../../../../utils/ast.js'; import * as b from '#compiler/builders'; import { create_derived } from '../utils.js'; import { get_value } from './shared/declarations.js'; import { build_expression } from './shared/utils.js'; /** * @param {AST.ConstTag} node * @param {ComponentContext} context */ export function ConstTag(node, context) { const declaration = node.declaration.declarations[0]; // TODO we can almost certainly share some code with $derived(...) if (declaration.id.type === 'Identifier') { const init = build_expression(context, declaration.init, node.metadata.expression); context.state.init.push(b.const(declaration.id, create_derived(context.state, b.thunk(init)))); context.state.transform[declaration.id.name] = { read: get_value }; // we need to eagerly evaluate the expression in order to hit any // 'Cannot access x before initialization' errors if (dev) { context.state.init.push(b.stmt(b.call('$.get', declaration.id))); } } else { const identifiers = extract_identifiers(declaration.id); const tmp = b.id(context.state.scope.generate('computed_const')); const transform = { ...context.state.transform }; // Make all identifiers that are declared within the following computed regular // variables, as they are not signals in that context yet for (const node of identifiers) { delete transform[node.name]; } const child_state = { ...context.state, transform }; // TODO optimise the simple `{ x } = y` case — we can just return `y` // instead of destructuring it only to return a new object const init = build_expression( { ...context, state: child_state }, declaration.init, node.metadata.expression ); const fn = b.arrow( [], b.block([ b.const(/** @type {Pattern} */ (context.visit(declaration.id, child_state)), init), b.return(b.object(identifiers.map((node) => b.prop('init', node, node)))) ]) ); context.state.init.push(b.const(tmp, create_derived(context.state, fn))); // we need to eagerly evaluate the expression in order to hit any // 'Cannot access x before initialization' errors if (dev) { context.state.init.push(b.stmt(b.call('$.get', tmp))); } for (const node of identifiers) { context.state.transform[node.name] = { read: (node) => b.member(b.call('$.get', tmp), node) }; } } }
```

# compiler/phases/3-transform/client/visitors/DebugTag.js

```js
/** @import { Expression} from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import * as b from '#compiler/builders'; /** * @param {AST.DebugTag} node * @param {ComponentContext} context */ export function DebugTag(node, context) { const object = b.object( node.identifiers.map((identifier) => { const visited = b.call('$.snapshot', /** @type {Expression} */ (context.visit(identifier))); return b.prop( 'init', identifier, context.state.analysis.runes ? visited : b.call('$.untrack', b.thunk(visited)) ); }) ); const call = b.call('console.log', object); context.state.init.push( b.stmt(b.call('$.template_effect', b.thunk(b.block([b.stmt(call), b.debugger])))) ); }
```

# compiler/phases/3-transform/client/visitors/EachBlock.js

```js
/** @import { BlockStatement, Expression, Identifier, Pattern, Statement } from 'estree' */ /** @import { AST, Binding } from '#compiler' */ /** @import { ComponentContext } from '../types' */ /** @import { Scope } from '../../../scope' */ import { EACH_INDEX_REACTIVE, EACH_IS_ANIMATED, EACH_IS_CONTROLLED, EACH_ITEM_IMMUTABLE, EACH_ITEM_REACTIVE } from '../../../../../constants.js'; import { dev } from '../../../../state.js'; import { extract_paths, object } from '../../../../utils/ast.js'; import * as b from '#compiler/builders'; import { get_value } from './shared/declarations.js'; import { build_expression, add_svelte_meta } from './shared/utils.js'; /** * @param {AST.EachBlock} node * @param {ComponentContext} context */ export function EachBlock(node, context) { const each_node_meta = node.metadata; // expression should be evaluated in the parent scope, not the scope // created by the each block itself const parent_scope_state = { ...context.state, scope: /** @type {Scope} */ (context.state.scope.parent) }; const collection = build_expression( { ...context, state: parent_scope_state }, node.expression, node.metadata.expression ); if (!each_node_meta.is_controlled) { context.state.template.push_comment(); } let flags = 0; if (node.metadata.keyed && node.index) { flags |= EACH_INDEX_REACTIVE; } const key_is_item = node.key?.type === 'Identifier' && node.context?.type === 'Identifier' && node.context?.name === node.key.name; // if the each block expression references a store subscription, we need // to use mutable stores internally let uses_store; for (const binding of node.metadata.expression.dependencies) { if (binding.kind === 'store_sub') { uses_store = true; break; } } for (const binding of node.metadata.expression.dependencies) { // if the expression doesn't reference any external state, we don't need to // create a source for the item. TODO cover more cases (e.g. `x.filter(y)` // should also qualify if `y` doesn't reference state, and non-state // bindings should also be fine if (binding.scope.function_depth >= context.state.scope.function_depth) { continue; } if (!context.state.analysis.runes || !key_is_item || uses_store) { flags |= EACH_ITEM_REACTIVE; break; } } if (context.state.analysis.runes && !uses_store) { flags |= EACH_ITEM_IMMUTABLE; } // Since `animate:` can only appear on elements that are the sole child of a keyed each block, // we can determine at compile time whether the each block is animated or not (in which // case it should measure animated elements before and after reconciliation). if ( node.key && node.body.nodes.some((child) => { if (child.type !== 'RegularElement' && child.type !== 'SvelteElement') return false; return child.attributes.some((attr) => attr.type === 'AnimateDirective'); }) ) { flags |= EACH_IS_ANIMATED; } if (each_node_meta.is_controlled) { flags |= EACH_IS_CONTROLLED; } // If the array is a store expression, we need to invalidate it when the array is changed. // This doesn't catch all cases, but all the ones that Svelte 4 catches, too. let store_to_invalidate = ''; if (node.expression.type === 'Identifier' || node.expression.type === 'MemberExpression') { const id = object(node.expression); if (id) { const binding = context.state.scope.get(id.name); if (binding?.kind === 'store_sub') { store_to_invalidate = id.name; } } } /** @type {Identifier | null} */ let collection_id = null; // Check if inner scope shadows something from outer scope. // This is necessary because we need access to the array expression of the each block // in the inner scope if bindings are used, in order to invalidate the array. for (const [name] of context.state.scope.declarations) { if (context.state.scope.parent?.get(name) != null) { collection_id = context.state.scope.root.unique('$$array'); break; } } const child_state = { ...context.state, transform: { ...context.state.transform }, store_to_invalidate }; /** The state used when generating the key function, if necessary */ const key_state = { ...context.state, transform: { ...context.state.transform } }; // We need to generate a unique identifier in case there's a bind:group below // which needs a reference to the index const index = each_node_meta.contains_group_binding || !node.index ? each_node_meta.index : b.id(node.index); const item = node.context?.type === 'Identifier' ? node.context : b.id('$$item'); let uses_index = each_node_meta.contains_group_binding; let key_uses_index = false; if (node.index) { child_state.transform[node.index] = { read: (node) => { uses_index = true; return (flags & EACH_INDEX_REACTIVE) !== 0 ? get_value(node) : node; } }; key_state.transform[node.index] = { read: (node) => { key_uses_index = true; return node; } }; } /** @type {Statement[]} */ const declarations = []; const invalidate_store = store_to_invalidate ? b.call('$.invalidate_store', b.id('$$stores'), b.literal(store_to_invalidate)) : undefined; /** @type {Expression[]} */ const sequence = []; if (!context.state.analysis.runes) { /** @type {Set<Identifier>} */ const transitive_deps = new Set(); if (collection_id) { transitive_deps.add(collection_id); child_state.transform[collection_id.name] = { read: b.call }; } else { for (const binding of each_node_meta.transitive_deps) { transitive_deps.add(binding.node); } } for (const block of collect_parent_each_blocks(context)) { for (const binding of block.metadata.transitive_deps) { transitive_deps.add(binding.node); } } if (transitive_deps.size > 0) { const invalidate = b.call( '$.invalidate_inner_signals', b.thunk( b.sequence( [...transitive_deps].map( (node) => /** @type {Expression} */ (context.visit({ ...node }, child_state)) ) ) ) ); sequence.push(invalidate); } } if (invalidate_store) { sequence.push(invalidate_store); } if (node.context?.type === 'Identifier') { const binding = /** @type {Binding} */ (context.state.scope.get(node.context.name)); child_state.transform[node.context.name] = { read: (node) => { if (binding.reassigned) { // we need to do `array[$$index]` instead of `$$item` or whatever // TODO 6.0 this only applies in legacy mode, reassignments are // forbidden in runes mode return b.member( collection_id ? b.call(collection_id) : collection, (flags & EACH_INDEX_REACTIVE) !== 0 ? get_value(index) : index, true ); } return (flags & EACH_ITEM_REACTIVE) !== 0 ? get_value(node) : node; }, assign: (_, value) => { uses_index = true; const left = b.member( collection_id ? b.call(collection_id) : collection, (flags & EACH_INDEX_REACTIVE) !== 0 ? get_value(index) : index, true ); return b.sequence([b.assignment('=', left, value), ...sequence]); }, mutate: (_, mutation) => { uses_index = true; return b.sequence([mutation, ...sequence]); } }; delete key_state.transform[node.context.name]; } else if (node.context) { const unwrapped = (flags & EACH_ITEM_REACTIVE) !== 0 ? b.call('$.get', item) : item; const { inserts, paths } = extract_paths(node.context, unwrapped); for (const { id, value } of inserts) { id.name = context.state.scope.generate('$$array'); child_state.transform[id.name] = { read: get_value }; const expression = /** @type {Expression} */ (context.visit(b.thunk(value), child_state)); declarations.push(b.var(id, b.call('$.derived', expression))); } for (const path of paths) { const name = /** @type {Identifier} */ (path.node).name; const needs_derived = path.has_default_value; // to ensure that default value is only called once const fn = b.thunk(/** @type {Expression} */ (context.visit(path.expression, child_state))); declarations.push(b.let(path.node, needs_derived ? b.call('$.derived_safe_equal', fn) : fn)); const read = needs_derived ? get_value : b.call; child_state.transform[name] = { read, assign: (_, value) => { const left = /** @type {Pattern} */ (path.update_expression); return b.sequence([b.assignment('=', left, value), ...sequence]); }, mutate: (_, mutation) => { return b.sequence([mutation, ...sequence]); } }; // we need to eagerly evaluate the expression in order to hit any // 'Cannot access x before initialization' errors if (dev) { declarations.push(b.stmt(read(b.id(name)))); } delete key_state.transform[name]; } } const block = /** @type {BlockStatement} */ (context.visit(node.body, child_state)); /** @type {Expression} */ let key_function = b.id('$.index'); if (node.metadata.keyed) { const pattern = /** @type {Pattern} */ (node.context); // can only be keyed when a context is provided const expression = /** @type {Expression} */ ( context.visit(/** @type {Expression} */ (node.key), key_state) ); key_function = b.arrow(key_uses_index ? [pattern, index] : [pattern], expression); } if (node.index && each_node_meta.contains_group_binding) { // We needed to create a unique identifier for the index above, but we want to use the // original index name in the template, therefore create another binding declarations.push(b.let(node.index, index)); } const { has_await } = node.metadata.expression; const get_collection = b.thunk(collection, has_await); const thunk = has_await ? b.thunk(b.call('$.get', b.id('$$collection'))) : get_collection; const render_args = [b.id('$$anchor'), item]; if (uses_index || collection_id) render_args.push(index); if (collection_id) render_args.push(collection_id); /** @type {Expression[]} */ const args = [ context.state.node, b.literal(flags), thunk, key_function, b.arrow(render_args, b.block(declarations.concat(block.body))) ]; if (node.fallback) { args.push( b.arrow([b.id('$$anchor')], /** @type {BlockStatement} */ (context.visit(node.fallback))) ); } const statements = [add_svelte_meta(b.call('$.each', ...args), node, 'each')]; if (dev && node.metadata.keyed) { statements.unshift(b.stmt(b.call('$.validate_each_keys', thunk, key_function))); } if (has_await) { context.state.init.push( b.stmt( b.call( '$.async', context.state.node, b.array([get_collection]), b.arrow([context.state.node, b.id('$$collection')], b.block(statements)) ) ) ); } else { context.state.init.push(...statements); } } /** * @param {ComponentContext} context */ function collect_parent_each_blocks(context) { return /** @type {AST.EachBlock[]} */ (context.path.filter((node) => node.type === 'EachBlock')); }
```

# compiler/phases/3-transform/client/visitors/ExportNamedDeclaration.js

```js
/** @import { ExportNamedDeclaration } from 'estree' */ /** @import { ComponentContext } from '../types' */ import * as b from '#compiler/builders'; /** * @param {ExportNamedDeclaration} node * @param {ComponentContext} context */ export function ExportNamedDeclaration(node, context) { if (context.state.is_instance) { if (node.declaration) { return context.visit(node.declaration); } return b.empty; } return context.next(); }
```

# compiler/phases/3-transform/client/visitors/ExpressionStatement.js

```js
/** @import { Expression, ExpressionStatement } from 'estree' */ /** @import { ComponentContext } from '../types' */ import * as b from '#compiler/builders'; import { get_rune } from '../../../scope.js'; /** * @param {ExpressionStatement} node * @param {ComponentContext} context */ export function ExpressionStatement(node, context) { if (node.expression.type === 'CallExpression') { const rune = get_rune(node.expression, context.state.scope); if (rune === '$effect' || rune === '$effect.pre') { const callee = rune === '$effect' ? '$.user_effect' : '$.user_pre_effect'; const func = /** @type {Expression} */ (context.visit(node.expression.arguments[0])); const expr = b.call(callee, /** @type {Expression} */ (func)); expr.callee.loc = node.expression.callee.loc; // ensure correct mapping return b.stmt(expr); } if (rune === '$inspect.trace') { return b.empty; } } context.next(); }
```

# compiler/phases/3-transform/client/visitors/Fragment.js

```js
/** @import { Expression, Statement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentClientTransformState, ComponentContext } from '../types' */ import { TEMPLATE_FRAGMENT, TEMPLATE_USE_IMPORT_NODE } from '../../../../../constants.js'; import * as b from '#compiler/builders'; import { clean_nodes, infer_namespace } from '../../utils.js'; import { transform_template } from '../transform-template/index.js'; import { process_children } from './shared/fragment.js'; import { build_render_statement, Memoizer } from './shared/utils.js'; import { Template } from '../transform-template/template.js'; /** * @param {AST.Fragment} node * @param {ComponentContext} context */ export function Fragment(node, context) { // Creates a new block which looks roughly like this: // \`\`\`js // // hoisted: // const block_name = $.from_html(`...`); // // // for the main block: // const id = block_name(); // // init stuff and possibly render effect // $.append($$anchor, id); // \`\`\` // Adds the hoisted parts to `context.state.hoisted` and returns the statements of the main block. const parent = context.path.at(-1) ?? node; const namespace = infer_namespace(context.state.metadata.namespace, parent, node.nodes); const { hoisted, trimmed, is_standalone, is_text_first } = clean_nodes( parent, node.nodes, context.path, namespace, context.state, context.state.preserve_whitespace, context.state.options.preserveComments ); if (hoisted.length === 0 && trimmed.length === 0) { return b.block([]); } const is_single_element = trimmed.length === 1 && trimmed[0].type === 'RegularElement'; const is_single_child_not_needing_template = trimmed.length === 1 && (trimmed[0].type === 'SvelteFragment' || trimmed[0].type === 'TitleElement'); const template_name = context.state.scope.root.unique('root'); // TODO infer name from parent /** @type {Statement[]} */ const body = []; /** @type {Statement | undefined} */ let close = undefined; /** @type {ComponentClientTransformState} */ const state = { ...context.state, init: [], update: [], after_update: [], memoizer: new Memoizer(), template: new Template(), transform: { ...context.state.transform }, metadata: { namespace, bound_contenteditable: context.state.metadata.bound_contenteditable } }; for (const node of hoisted) { context.visit(node, state); } if (is_text_first) { // skip over inserted comment body.push(b.stmt(b.call('$.next'))); } if (is_single_element) { const element = /** @type {AST.RegularElement} */ (trimmed[0]); const id = b.id(context.state.scope.generate(element.name)); context.visit(element, { ...state, node: id }); let flags = state.template.needs_import_node ? TEMPLATE_USE_IMPORT_NODE : undefined; const template = transform_template(state, namespace, flags); state.hoisted.push(b.var(template_name, template)); body.push(b.var(id, b.call(template_name))); close = b.stmt(b.call('$.append', b.id('$$anchor'), id)); } else if (is_single_child_not_needing_template) { context.visit(trimmed[0], state); } else if (trimmed.length === 1 && trimmed[0].type === 'Text') { const id = b.id(context.state.scope.generate('text')); body.push(b.var(id, b.call('$.text', b.literal(trimmed[0].data)))); close = b.stmt(b.call('$.append', b.id('$$anchor'), id)); } else if (trimmed.length > 0) { const id = b.id(context.state.scope.generate('fragment')); const use_space_template = trimmed.some((node) => node.type === 'ExpressionTag') && trimmed.every((node) => node.type === 'Text' || node.type === 'ExpressionTag'); if (use_space_template) { // special case — we can use `$.text` instead of creating a unique template const id = b.id(context.state.scope.generate('text')); process_children(trimmed, () => id, false, { ...context, state }); body.push(b.var(id, b.call('$.text'))); close = b.stmt(b.call('$.append', b.id('$$anchor'), id)); } else { if (is_standalone) { // no need to create a template, we can just use the existing block's anchor process_children(trimmed, () => b.id('$$anchor'), false, { ...context, state }); } else { /** @type {(is_text: boolean) => Expression} */ const expression = (is_text) => b.call('$.first_child', id, is_text && b.true); process_children(trimmed, expression, false, { ...context, state }); let flags = TEMPLATE_FRAGMENT; if (state.template.needs_import_node) { flags |= TEMPLATE_USE_IMPORT_NODE; } if (state.template.nodes.length === 1 && state.template.nodes[0].type === 'comment') { // special case — we can use `$.comment` instead of creating a unique template body.push(b.var(id, b.call('$.comment'))); } else { const template = transform_template(state, namespace, flags); state.hoisted.push(b.var(template_name, template)); body.push(b.var(id, b.call(template_name))); } close = b.stmt(b.call('$.append', b.id('$$anchor'), id)); } } } body.push(...state.init); if (state.update.length > 0) { body.push(build_render_statement(state)); } body.push(...state.after_update); if (close !== undefined) { // It's important that close is the last statement in the block, as any previous statements // could contain element insertions into the template, which the close statement needs to // know of when constructing the list of current inner elements. body.push(close); } return b.block(body); }
```

# compiler/phases/3-transform/client/visitors/FunctionDeclaration.js

```js
/** @import { FunctionDeclaration } from 'estree' */ /** @import { ComponentContext } from '../types' */ import { build_hoisted_params } from '../utils.js'; import * as b from '#compiler/builders'; /** * @param {FunctionDeclaration} node * @param {ComponentContext} context */ export function FunctionDeclaration(node, context) { const state = { ...context.state, in_constructor: false, in_derived: false }; if (node.metadata?.hoisted === true) { const params = build_hoisted_params(node, context); const body = context.visit(node.body, state); context.state.hoisted.push(/** @type {FunctionDeclaration} */ ({ ...node, params, body })); return b.empty; } context.next(state); }
```

# compiler/phases/3-transform/client/visitors/FunctionExpression.js

```js
/** @import { FunctionExpression } from 'estree' */ /** @import { ComponentContext } from '../types' */ import { visit_function } from './shared/function.js'; /** * @param {FunctionExpression} node * @param {ComponentContext} context */ export function FunctionExpression(node, context) { return visit_function(node, context); }
```

# compiler/phases/3-transform/client/visitors/HtmlTag.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { is_ignored } from '../../../../state.js'; import * as b from '#compiler/builders'; import { build_expression } from './shared/utils.js'; /** * @param {AST.HtmlTag} node * @param {ComponentContext} context */ export function HtmlTag(node, context) { context.state.template.push_comment(); const { has_await } = node.metadata.expression; const expression = build_expression(context, node.expression, node.metadata.expression); const html = has_await ? b.call('$.get', b.id('$$html')) : expression; const is_svg = context.state.metadata.namespace === 'svg'; const is_mathml = context.state.metadata.namespace === 'mathml'; const statement = b.stmt( b.call( '$.html', context.state.node, b.thunk(html), is_svg && b.true, is_mathml && b.true, is_ignored(node, 'hydration_html_changed') && b.true ) ); // push into init, so that bindings run afterwards, which might trigger another run and override hydration if (node.metadata.expression.has_await) { context.state.init.push( b.stmt( b.call( '$.async', context.state.node, b.array([b.thunk(expression, true)]), b.arrow([context.state.node, b.id('$$html')], b.block([statement])) ) ) ); } else { context.state.init.push(statement); } }
```

# compiler/phases/3-transform/client/visitors/Identifier.js

```js
/** @import { Identifier, Node } from 'estree' */ /** @import { Context } from '../types' */ import is_reference from 'is-reference'; import * as b from '#compiler/builders'; import { build_getter } from '../utils.js'; /** * @param {Identifier} node * @param {Context} context */ export function Identifier(node, context) { const parent = /** @type {Node} */ (context.path.at(-1)); if (is_reference(node, parent)) { if (node.name === '$$props') { return b.id('$$sanitized_props'); } // Optimize prop access: If it's a member read access, we can use the $$props object directly const binding = context.state.scope.get(node.name); if ( context.state.analysis.runes && // can't do this in legacy mode because the proxy does more than just read/write binding !== null && node !== binding.node && binding.kind === 'rest_prop' ) { const grand_parent = context.path.at(-2); if ( parent?.type === 'MemberExpression' && !parent.computed && grand_parent?.type !== 'AssignmentExpression' && grand_parent?.type !== 'UpdateExpression' ) { return b.id('$$props'); } } return build_getter(node, context.state); } }
```

# compiler/phases/3-transform/client/visitors/IfBlock.js

```js
/** @import { BlockStatement, Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import * as b from '#compiler/builders'; import { build_expression, add_svelte_meta } from './shared/utils.js'; /** * @param {AST.IfBlock} node * @param {ComponentContext} context */ export function IfBlock(node, context) { context.state.template.push_comment(); const statements = []; const consequent = /** @type {BlockStatement} */ (context.visit(node.consequent)); const consequent_id = b.id(context.state.scope.generate('consequent')); statements.push(b.var(consequent_id, b.arrow([b.id('$$anchor')], consequent))); let alternate_id; if (node.alternate) { const alternate = /** @type {BlockStatement} */ (context.visit(node.alternate)); alternate_id = b.id(context.state.scope.generate('alternate')); statements.push(b.var(alternate_id, b.arrow([b.id('$$anchor')], alternate))); } const { has_await } = node.metadata.expression; const expression = build_expression(context, node.test, node.metadata.expression); const test = has_await ? b.call('$.get', b.id('$$condition')) : expression; /** @type {Expression[]} */ const args = [ context.state.node, b.arrow( [b.id('$$render')], b.block([ b.if( test, b.stmt(b.call('$$render', consequent_id)), alternate_id && b.stmt(b.call('$$render', alternate_id, b.literal(false))) ) ]) ) ]; if (node.elseif) { // We treat this... // // {#if x} // ... // {:else} // {#if y} // <div transition:foo>...</div> // {/if} // {/if} // // ...slightly differently to this... // // {#if x} // ... // {:else if y} // <div transition:foo>...</div> // {/if} // // ...even though they're logically equivalent. In the first case, the // transition will only play when `y` changes, but in the second it // should play when `x` or `y` change — both are considered 'local' args.push(b.true); } statements.push(add_svelte_meta(b.call('$.if', ...args), node, 'if')); if (has_await) { context.state.init.push( b.stmt( b.call( '$.async', context.state.node, b.array([b.thunk(expression, true)]), b.arrow([context.state.node, b.id('$$condition')], b.block(statements)) ) ) ); } else { context.state.init.push(b.block(statements)); } }
```

# compiler/phases/3-transform/client/visitors/ImportDeclaration.js

```js
/** @import { ImportDeclaration } from 'estree' */ /** @import { ComponentContext } from '../types' */ import * as b from '#compiler/builders'; /** * @param {ImportDeclaration} node * @param {ComponentContext} context */ export function ImportDeclaration(node, context) { if ('hoisted' in context.state) { context.state.hoisted.push(node); return b.empty; } context.next(); }
```

# compiler/phases/3-transform/client/visitors/KeyBlock.js

```js
/** @import { Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import * as b from '#compiler/builders'; import { build_expression, add_svelte_meta } from './shared/utils.js'; /** * @param {AST.KeyBlock} node * @param {ComponentContext} context */ export function KeyBlock(node, context) { context.state.template.push_comment(); const { has_await } = node.metadata.expression; const expression = build_expression(context, node.expression, node.metadata.expression); const key = b.thunk(has_await ? b.call('$.get', b.id('$$key')) : expression); const body = /** @type {Expression} */ (context.visit(node.fragment)); let statement = add_svelte_meta( b.call('$.key', context.state.node, key, b.arrow([b.id('$$anchor')], body)), node, 'key' ); if (has_await) { statement = b.stmt( b.call( '$.async', context.state.node, b.array([b.thunk(expression, true)]), b.arrow([context.state.node, b.id('$$key')], b.block([statement])) ) ); } context.state.init.push(statement); }
```

# compiler/phases/3-transform/client/visitors/LabeledStatement.js

```js
/** @import { Expression, LabeledStatement, Statement } from 'estree' */ /** @import { ReactiveStatement } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import * as b from '#compiler/builders'; import { build_getter } from '../utils.js'; /** * @param {LabeledStatement} node * @param {ComponentContext} context */ export function LabeledStatement(node, context) { if (context.state.analysis.runes || context.path.length > 1 || node.label.name !== '$') { context.next(); return; } // To recreate Svelte 4 behaviour, we track the dependencies // the compiler can 'see', but we untrack the effect itself const reactive_statement = /** @type {ReactiveStatement} */ ( context.state.analysis.reactive_statements.get(node) ); if (!reactive_statement) return; // not the instance context let serialized_body = /** @type {Statement} */ (context.visit(node.body)); if (serialized_body.type !== 'BlockStatement') { serialized_body = b.block([serialized_body]); } const body = serialized_body.body; /** @type {Expression[]} */ const sequence = []; for (const binding of reactive_statement.dependencies) { if (binding.kind === 'normal' && binding.declaration_kind !== 'import') continue; const name = binding.node.name; let serialized = build_getter(b.id(name), context.state); // If the binding is a prop, we need to deep read it because it could be fine-grained $state // from a runes-component, where mutations don't trigger an update on the prop as a whole. if (name === '$$props' || name === '$$restProps' || binding.kind === 'bindable_prop') { serialized = b.call('$.deep_read_state', serialized); } sequence.push(serialized); } // these statements will be topologically ordered later context.state.legacy_reactive_statements.set( node, b.stmt( b.call( '$.legacy_pre_effect', sequence.length > 0 ? b.thunk(b.sequence(sequence)) : b.thunk(b.block([])), b.thunk(b.block(body)) ) ) ); return b.empty; }
```

# compiler/phases/3-transform/client/visitors/LetDirective.js

```js
/** @import { Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import * as b from '#compiler/builders'; import { create_derived } from '../utils.js'; /** * @param {AST.LetDirective} node * @param {ComponentContext} context */ export function LetDirective(node, context) { // let:x --> const x = $.derived(() => $$slotProps.x); // let:x={{y, z}} --> const derived_x = $.derived(() => { const { y, z } = $$slotProps.x; return { y, z })); if (node.expression && node.expression.type !== 'Identifier') { const name = context.state.scope.generate(node.name); const bindings = context.state.scope.get_bindings(node); for (const binding of bindings) { context.state.transform[binding.node.name] = { read: (node) => b.member(b.call('$.get', b.id(name)), node) }; } return b.const( name, b.call( '$.derived', b.thunk( b.block([ b.let( /** @type {Expression} */ (node.expression).type === 'ObjectExpression' ? // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine b.object_pattern(node.expression.properties) : // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine b.array_pattern(node.expression.elements), b.member(b.id('$$slotProps'), node.name) ), b.return(b.object(bindings.map((binding) => b.init(binding.node.name, binding.node)))) ]) ) ) ); } else { const name = node.expression === null ? node.name : node.expression.name; context.state.transform[name] = { read: (node) => b.call('$.get', node) }; return b.const( name, create_derived(context.state, b.thunk(b.member(b.id('$$slotProps'), node.name))) ); } }
```

# compiler/phases/3-transform/client/visitors/MemberExpression.js

```js
/** @import { MemberExpression } from 'estree' */ /** @import { Context } from '../types' */ import * as b from '#compiler/builders'; /** * @param {MemberExpression} node * @param {Context} context */ export function MemberExpression(node, context) { // rewrite `this.#foo` as `this.#foo.v` inside a constructor if (node.property.type === 'PrivateIdentifier') { const field = context.state.state_fields.get('#' + node.property.name); if (field) { return context.state.in_constructor && (field.type === '$state.raw' || field.type === '$state') ? b.member(node, 'v') : b.call('$.get', node); } } context.next(); }
```

# compiler/phases/3-transform/client/visitors/OnDirective.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import * as b from '#compiler/builders'; import { build_event, build_event_handler } from './shared/events.js'; const modifiers = [ 'stopPropagation', 'stopImmediatePropagation', 'preventDefault', 'self', 'trusted', 'once' ]; /** * @param {AST.OnDirective} node * @param {ComponentContext} context */ export function OnDirective(node, context) { if (!node.expression) { context.state.analysis.needs_props = true; } let handler = build_event_handler(node.expression, node.metadata.expression, context); for (const modifier of modifiers) { if (node.modifiers.includes(modifier)) { handler = b.call('$.' + modifier, handler); } } const capture = node.modifiers.includes('capture'); const passive = node.modifiers.includes('passive') || (node.modifiers.includes('nonpassive') ? false : undefined); return build_event(node.name, context.state.node, handler, capture, passive); }
```

# compiler/phases/3-transform/client/visitors/Program.js

```js
/** @import { Expression, ImportDeclaration, MemberExpression, Program } from 'estree' */ /** @import { ComponentContext } from '../types' */ import { build_getter, is_prop_source } from '../utils.js'; import * as b from '#compiler/builders'; import { add_state_transformers } from './shared/declarations.js'; /** * @param {Program} _ * @param {ComponentContext} context */ export function Program(_, context) { if (!context.state.analysis.runes) { context.state.transform['$$props'] = { read: (node) => ({ ...node, name: '$$sanitized_props' }) }; for (const [name, binding] of context.state.scope.declarations) { if (binding.declaration_kind === 'import' && binding.mutated) { // the declaration itself is hoisted to the module scope, so we need // to resort to cruder measures to differentiate instance/module imports const { start, end } = context.state.analysis.instance.ast; const node = /** @type {ImportDeclaration} */ (binding.initial); const is_instance_import = /** @type {number} */ (node.start) > /** @type {number} */ (start) && /** @type {number} */ (node.end) < /** @type {number} */ (end); if (is_instance_import) { const id = b.id('$$_import_' + name); context.state.transform[name] = { read: (_) => b.call(id), mutate: (_, mutation) => b.call(id, mutation) }; context.state.legacy_reactive_imports.push( b.var(id, b.call('$.reactive_import', b.thunk(b.id(name)))) ); } } } } for (const [name, binding] of context.state.scope.declarations) { if (binding.kind === 'store_sub') { // read lazily, so that transforms added later are still applied /** @type {Expression} */ let cached; const get_store = () => { return (cached ??= /** @type {Expression} */ (context.visit(b.id(name.slice(1))))); }; context.state.transform[name] = { read: b.call, assign: (_, value) => b.call('$.store_set', get_store(), value), mutate: (node, mutation) => { // We need to untrack the store read, for consistency with Svelte 4 const untracked = b.call('$.untrack', node); /** * * @param {Expression} n * @returns {Expression} */ function replace(n) { if (n.type === 'MemberExpression') { return { ...n, object: replace(/** @type {Expression} */ (n.object)), property: n.property }; } return untracked; } return b.call( '$.store_mutate', get_store(), mutation.type === 'AssignmentExpression' ? b.assignment( mutation.operator, /** @type {MemberExpression} */ ( replace(/** @type {MemberExpression} */ (mutation.left)) ), mutation.right ) : b.update(mutation.operator, replace(mutation.argument), mutation.prefix), untracked ); }, update: (node) => { return b.call( node.prefix ? '$.update_pre_store' : '$.update_store', build_getter(b.id(name.slice(1)), context.state), b.call(node.argument), node.operator === '--' && b.literal(-1) ); } }; } if (binding.kind === 'prop' || binding.kind === 'bindable_prop') { if (is_prop_source(binding, context.state)) { context.state.transform[name] = { read: b.call, assign: (node, value) => b.call(node, value), mutate: (node, value) => { if (binding.kind === 'bindable_prop') { // only necessary for interop with legacy parent bindings return b.call(node, value, b.true); } return value; }, update: (node) => { return b.call( node.prefix ? '$.update_pre_prop' : '$.update_prop', node.argument, node.operator === '--' && b.literal(-1) ); } }; } else if (binding.prop_alias) { const key = b.key(binding.prop_alias); context.state.transform[name] = { read: (_) => b.member(b.id('$$props'), key, key.type === 'Literal') }; } else { context.state.transform[name] = { read: (node) => b.member(b.id('$$props'), node) }; } } } add_state_transformers(context); context.next(); }
```

# compiler/phases/3-transform/client/visitors/RegularElement.js

```js
/** @import { ArrayExpression, Expression, ExpressionStatement, Identifier, MemberExpression, ObjectExpression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentClientTransformState, ComponentContext } from '../types' */ /** @import { Scope } from '../../../scope' */ import { cannot_be_set_statically, is_boolean_attribute, is_dom_property, is_load_error_element } from '../../../../../utils.js'; import { is_ignored } from '../../../../state.js'; import { is_event_attribute, is_text_attribute } from '../../../../utils/ast.js'; import * as b from '#compiler/builders'; import { is_custom_element_node } from '../../../nodes.js'; import { clean_nodes, determine_namespace_for_children } from '../../utils.js'; import { build_getter } from '../utils.js'; import { get_attribute_name, build_attribute_value, build_attribute_effect, build_set_class, build_set_style } from './shared/element.js'; import { process_children } from './shared/fragment.js'; import { build_render_statement, build_template_chunk, Memoizer } from './shared/utils.js'; import { visit_event_attribute } from './shared/events.js'; /** * @param {AST.RegularElement} node * @param {ComponentContext} context */ export function RegularElement(node, context) { context.state.template.push_element(node.name, node.start); if (node.name === 'noscript') { context.state.template.pop_element(); return; } const is_custom_element = is_custom_element_node(node); // cloneNode is faster, but it does not instantiate the underlying class of the // custom element until the template is connected to the dom, which would // cause problems when setting properties on the custom element. // Therefore we need to use importNode instead, which doesn't have this caveat. // Additionally, Webkit browsers need importNode for video elements for autoplay // to work correctly. context.state.template.needs_import_node ||= node.name === 'video' || is_custom_element; context.state.template.contains_script_tag ||= node.name === 'script'; /** @type {Array<AST.Attribute | AST.SpreadAttribute>} */ const attributes = []; /** @type {AST.ClassDirective[]} */ const class_directives = []; /** @type {AST.StyleDirective[]} */ const style_directives = []; /** @type {Array<AST.AnimateDirective | AST.BindDirective | AST.OnDirective | AST.TransitionDirective | AST.UseDirective | AST.AttachTag>} */ const other_directives = []; /** @type {ExpressionStatement[]} */ const lets = []; /** @type {Map<string, AST.Attribute>} */ const lookup = new Map(); /** @type {Map<string, AST.BindDirective>} */ const bindings = new Map(); let has_spread = node.metadata.has_spread; let has_use = false; for (const attribute of node.attributes) { switch (attribute.type) { case 'AnimateDirective': other_directives.push(attribute); break; case 'Attribute': // `is` attributes need to be part of the template, otherwise they break if (attribute.name === 'is' && context.state.metadata.namespace === 'html') { const { value } = build_attribute_value(attribute.value, context); if (value.type === 'Literal' && typeof value.value === 'string') { context.state.template.set_prop('is', value.value); continue; } } attributes.push(attribute); lookup.set(attribute.name, attribute); break; case 'BindDirective': bindings.set(attribute.name, attribute); other_directives.push(attribute); break; case 'ClassDirective': class_directives.push(attribute); break; case 'LetDirective': // visit let directives before everything else, to set state lets.push(/** @type {ExpressionStatement} */ (context.visit(attribute))); break; case 'OnDirective': other_directives.push(attribute); break; case 'SpreadAttribute': attributes.push(attribute); break; case 'StyleDirective': style_directives.push(attribute); break; case 'TransitionDirective': other_directives.push(attribute); break; case 'UseDirective': has_use = true; other_directives.push(attribute); break; case 'AttachTag': other_directives.push(attribute); break; } } /** @type {typeof state} */ const element_state = { ...context.state, init: [], after_update: [] }; for (const attribute of other_directives) { if (attribute.type === 'OnDirective') { const handler = /** @type {Expression} */ (context.visit(attribute)); if (has_use) { element_state.init.push(b.stmt(b.call('$.effect', b.thunk(handler)))); } else { element_state.after_update.push(b.stmt(handler)); } } else { context.visit(attribute, element_state); } } if (node.name === 'input') { const has_value_attribute = attributes.some( (attribute) => attribute.type === 'Attribute' && (attribute.name === 'value' || attribute.name === 'checked') && !is_text_attribute(attribute) ); const has_default_value_attribute = attributes.some( (attribute) => attribute.type === 'Attribute' && (attribute.name === 'defaultValue' || attribute.name === 'defaultChecked') ); if ( !has_default_value_attribute && (has_spread || bindings.has('value') || bindings.has('checked') || bindings.has('group') || (!bindings.has('group') && has_value_attribute)) ) { context.state.init.push(b.stmt(b.call('$.remove_input_defaults', context.state.node))); } } if (node.name === 'textarea') { const attribute = lookup.get('value') ?? lookup.get('checked'); const needs_content_reset = attribute && !is_text_attribute(attribute); if (has_spread || bindings.has('value') || needs_content_reset) { context.state.init.push(b.stmt(b.call('$.remove_textarea_child', context.state.node))); } } if (node.name === 'select' && bindings.has('value')) { setup_select_synchronization(/** @type {AST.BindDirective} */ (bindings.get('value')), context); } // Let bindings first, they can be used on attributes context.state.init.push(...lets); const node_id = context.state.node; /** If true, needs `__value` for inputs */ const needs_special_value_handling = node.name === 'option' || node.name === 'select' || bindings.has('group') || bindings.has('checked'); if (has_spread) { build_attribute_effect(attributes, class_directives, style_directives, context, node, node_id); } else { for (const attribute of /** @type {AST.Attribute[]} */ (attributes)) { if (is_event_attribute(attribute)) { visit_event_attribute(attribute, context); continue; } if (needs_special_value_handling && attribute.name === 'value') { continue; } const name = get_attribute_name(node, attribute); if ( !is_custom_element && !cannot_be_set_statically(attribute.name) && (attribute.value === true || is_text_attribute(attribute)) && (name !== 'class' || class_directives.length === 0) && (name !== 'style' || style_directives.length === 0) ) { let value = is_text_attribute(attribute) ? attribute.value[0].data : true; if (name === 'class' && node.metadata.scoped && context.state.analysis.css.hash) { if (value === true || value === '') { value = context.state.analysis.css.hash; } else { value += ' ' + context.state.analysis.css.hash; } } if (name !== 'class' || value) { context.state.template.set_prop( attribute.name, is_boolean_attribute(name) && value === true ? undefined : value === true ? '' : value ); } } else if (name === 'autofocus') { let { value } = build_attribute_value(attribute.value, context); context.state.init.push(b.stmt(b.call('$.autofocus', node_id, value))); } else if (name === 'class') { const is_html = context.state.metadata.namespace === 'html' && node.name !== 'svg'; build_set_class(node, node_id, attribute, class_directives, context, is_html); } else if (name === 'style') { build_set_style(node_id, attribute, style_directives, context); } else if (is_custom_element) { build_custom_element_attribute_update_assignment(node_id, attribute, context); } else { const { value, has_state } = build_attribute_value( attribute.value, context, (value, metadata) => metadata.has_call || metadata.has_await ? context.state.memoizer.add(value, metadata.has_await) : value ); const update = build_element_attribute_update(node, node_id, name, value, attributes); (has_state ? context.state.update : context.state.init).push(b.stmt(update)); } } } if ( is_load_error_element(node.name) && (has_spread || has_use || lookup.has('onload') || lookup.has('onerror')) ) { context.state.after_update.push(b.stmt(b.call('$.replay_events', node_id))); } const metadata = { ...context.state.metadata, namespace: determine_namespace_for_children(node, context.state.metadata.namespace) }; if (bindings.has('innerHTML') || bindings.has('innerText') || bindings.has('textContent')) { const contenteditable = lookup.get('contenteditable'); if ( contenteditable && (contenteditable.value === true || (is_text_attribute(contenteditable) && contenteditable.value[0].data === 'true')) ) { metadata.bound_contenteditable = true; } } /** @type {ComponentClientTransformState} */ const state = { ...context.state, metadata, scope: /** @type {Scope} */ (context.state.scopes.get(node.fragment)), preserve_whitespace: context.state.preserve_whitespace || node.name === 'pre' || node.name === 'textarea' }; const { hoisted, trimmed } = clean_nodes( node, node.fragment.nodes, context.path, state.metadata.namespace, state, node.name === 'script' || state.preserve_whitespace, state.options.preserveComments ); /** @type {typeof state} */ const child_state = { ...state, init: [], update: [], after_update: [] }; for (const node of hoisted) { context.visit(node, child_state); } // special case — if an element that only contains text, we don't need // to descend into it if the text is non-reactive // in the rare case that we have static text that can't be inlined // (e.g. `<span>{location}</span>`), set `textContent` programmatically const use_text_content = trimmed.every((node) => node.type === 'Text' || node.type === 'ExpressionTag') && trimmed.every( (node) => node.type === 'Text' || (!node.metadata.expression.has_state && !node.metadata.expression.has_await) ) && trimmed.some((node) => node.type === 'ExpressionTag'); if (use_text_content) { const { value } = build_template_chunk(trimmed, context, child_state); const empty_string = value.type === 'Literal' && value.value === ''; if (!empty_string) { child_state.init.push( b.stmt(b.assignment('=', b.member(context.state.node, 'textContent'), value)) ); } } else { /** @type {Expression} */ let arg = context.state.node; // If `hydrate_node` is set inside the element, we need to reset it // after the element has been hydrated let needs_reset = trimmed.some((node) => node.type !== 'Text'); // The same applies if it's a `<template>` element, since we need to // set the value of `hydrate_node` to `node.content` if (node.name === 'template') { needs_reset = true; child_state.init.push(b.stmt(b.call('$.hydrate_template', arg))); arg = b.member(arg, 'content'); } process_children(trimmed, (is_text) => b.call('$.child', arg, is_text && b.true), true, { ...context, state: child_state }); if (needs_reset) { child_state.init.push(b.stmt(b.call('$.reset', context.state.node))); } } if (node.fragment.nodes.some((node) => node.type === 'SnippetBlock')) { // Wrap children in `{...}` to avoid declaration conflicts context.state.init.push( b.block([ ...child_state.init, ...element_state.init, child_state.update.length > 0 ? build_render_statement(child_state) : b.empty, ...child_state.after_update, ...element_state.after_update ]) ); } else if (node.fragment.metadata.dynamic) { context.state.init.push(...child_state.init, ...element_state.init); context.state.update.push(...child_state.update); context.state.after_update.push(...child_state.after_update, ...element_state.after_update); } else { context.state.init.push(...element_state.init); context.state.after_update.push(...element_state.after_update); } if (lookup.has('dir')) { // This fixes an issue with Chromium where updates to text content within an element // does not update the direction when set to auto. If we just re-assign the dir, this fixes it. const dir = b.member(node_id, 'dir'); context.state.update.push(b.stmt(b.assignment('=', dir, dir))); } if (!has_spread && needs_special_value_handling) { for (const attribute of /** @type {AST.Attribute[]} */ (attributes)) { if (attribute.name === 'value') { build_element_special_value_attribute(node.name, node_id, attribute, context); break; } } } context.state.template.pop_element(); } /** * Special case: if we have a value binding on a select element, we need to set up synchronization * between the value binding and inner signals, for indirect updates * @param {AST.BindDirective} value_binding * @param {ComponentContext} context */ function setup_select_synchronization(value_binding, context) { if (context.state.analysis.runes) return; let bound = value_binding.expression; if (bound.type === 'SequenceExpression') { return; } while (bound.type === 'MemberExpression') { bound = /** @type {Identifier | MemberExpression} */ (bound.object); } /** @type {string[]} */ const names = []; for (const [name, refs] of context.state.scope.references) { if ( refs.length > 0 && // prevent infinite loop name !== bound.name ) { names.push(name); } } const invalidator = b.call( '$.invalidate_inner_signals', b.thunk( b.block( names.map((name) => { const serialized = build_getter(b.id(name), context.state); return b.stmt(serialized); }) ) ) ); context.state.init.push( b.stmt( b.call( '$.template_effect', b.thunk( b.block([b.stmt(/** @type {Expression} */ (context.visit(bound))), b.stmt(invalidator)]) ) ) ) ); } /** * @param {AST.ClassDirective[]} class_directives * @param {ComponentContext} context * @param {Memoizer} memoizer * @return {ObjectExpression | Identifier} */ export function build_class_directives_object( class_directives, context, memoizer = context.state.memoizer ) { let properties = []; let has_call_or_state = false; let has_await = false; for (const d of class_directives) { const expression = /** @type Expression */ (context.visit(d.expression)); properties.push(b.init(d.name, expression)); has_call_or_state ||= d.metadata.expression.has_call || d.metadata.expression.has_state; has_await ||= d.metadata.expression.has_await; } const directives = b.object(properties); return has_call_or_state || has_await ? memoizer.add(directives, has_await) : directives; } /** * @param {AST.StyleDirective[]} style_directives * @param {ComponentContext} context * @param {Memoizer} memoizer * @return {ObjectExpression | ArrayExpression | Identifier}} */ export function build_style_directives_object( style_directives, context, memoizer = context.state.memoizer ) { const normal = b.object([]); const important = b.object([]); let has_call_or_state = false; let has_await = false; for (const d of style_directives) { const expression = d.value === true ? build_getter(b.id(d.name), context.state) : build_attribute_value(d.value, context).value; const object = d.modifiers.includes('important') ? important : normal; object.properties.push(b.init(d.name, expression)); has_call_or_state ||= d.metadata.expression.has_call || d.metadata.expression.has_state; has_await ||= d.metadata.expression.has_await; } const directives = important.properties.length ? b.array([normal, important]) : normal; return has_call_or_state || has_await ? memoizer.add(directives, has_await) : directives; } /** * Serializes an assignment to an element property by adding relevant statements to either only * the init or the init and update arrays, depending on whether or not the value is dynamic. * Resulting code for static looks something like this: * \`\`\`js * element.property = value; * // or * $.set_attribute(element, property, value); * }); * \`\`\` * Resulting code for dynamic looks something like this: * \`\`\`js * let value; * $.template_effect(() => { * if (value !== (value = 'new value')) { * element.property = value; * // or * $.set_attribute(element, property, value); * } * }); * \`\`\` * Returns true if attribute is deemed reactive, false otherwise. * @param {AST.RegularElement} element * @param {Identifier} node_id * @param {string} name * @param {Expression} value * @param {Array<AST.Attribute | AST.SpreadAttribute>} attributes */ function build_element_attribute_update(element, node_id, name, value, attributes) { if (name === 'muted') { // Special case for Firefox who needs it set as a property in order to work return b.assignment('=', b.member(node_id, b.id('muted')), value); } if (name === 'value') { return b.call('$.set_value', node_id, value); } if (name === 'checked') { return b.call('$.set_checked', node_id, value); } if (name === 'selected') { return b.call('$.set_selected', node_id, value); } if ( // If we would just set the defaultValue property, it would override the value property, // because it is set in the template which implicitly means it's also setting the default value, // and if one updates the default value while the input is pristine it will also update the // current value, which is not what we want, which is why we need to do some extra work. name === 'defaultValue' && (attributes.some( (attr) => attr.type === 'Attribute' && attr.name === 'value' && is_text_attribute(attr) ) || (element.name === 'textarea' && element.fragment.nodes.length > 0)) ) { return b.call('$.set_default_value', node_id, value); } if ( // See defaultValue comment name === 'defaultChecked' && attributes.some( (attr) => attr.type === 'Attribute' && attr.name === 'checked' && attr.value === true ) ) { return b.call('$.set_default_checked', node_id, value); } if (is_dom_property(name)) { return b.assignment('=', b.member(node_id, name), value); } return b.call( name.startsWith('xlink') ? '$.set_xlink_attribute' : '$.set_attribute', node_id, b.literal(name), value, is_ignored(element, 'hydration_attribute_changed') && b.true ); } /** * Like `build_element_attribute_update` but without any special attribute treatment. * @param {Identifier} node_id * @param {AST.Attribute} attribute * @param {ComponentContext} context */ function build_custom_element_attribute_update_assignment(node_id, attribute, context) { const { value, has_state } = build_attribute_value(attribute.value, context); // don't lowercase name, as we set the element's property, which might be case sensitive const call = b.call('$.set_custom_element_data', node_id, b.literal(attribute.name), value); // this is different from other updates — it doesn't get grouped, // because set_custom_element_data may not be idempotent const update = has_state ? b.call('$.template_effect', b.thunk(call)) : call; context.state.init.push(b.stmt(update)); } /** * Serializes an assignment to the value property of a `<select>`, `<option>` or `<input>` element * that needs the hidden `__value` property. * Returns true if attribute is deemed reactive, false otherwise. * @param {string} element * @param {Identifier} node_id * @param {AST.Attribute} attribute * @param {ComponentContext} context */ function build_element_special_value_attribute(element, node_id, attribute, context) { const state = context.state; const is_select_with_value = // attribute.metadata.dynamic would give false negatives because even if the value does not change, // the inner options could still change, so we need to always treat it as reactive element === 'select' && attribute.value !== true && !is_text_attribute(attribute); const { value, has_state } = build_attribute_value(attribute.value, context, (value, metadata) => metadata.has_call || metadata.has_await ? state.memoizer.add(value, metadata.has_await) : value ); const evaluated = context.state.scope.evaluate(value); const assignment = b.assignment('=', b.member(node_id, '__value'), value); const inner_assignment = b.assignment( '=', b.member(node_id, 'value'), evaluated.is_defined ? assignment : b.logical('??', assignment, b.literal('')) ); const update = b.stmt( is_select_with_value ? b.sequence([ inner_assignment, // This ensures a one-way street to the DOM in case it's <select {value}> // and not <select bind:value>. We need it in addition to $.init_select // because the select value is not reflected as an attribute, so the // mutation observer wouldn't notice. b.call('$.select_option', node_id, value) ]) : inner_assignment ); if (has_state) { const id = b.id(state.scope.generate(`${node_id.name}_value`)); // `<option>` is a special case: The value property reflects to the DOM. If the value is set to undefined, // that means the value should be set to the empty string. To be able to do that when the value is // initially undefined, we need to set a value that is guaranteed to be different. const init = element === 'option' ? b.object([]) : undefined; state.init.push(b.var(id, init)); state.update.push(b.if(b.binary('!==', id, b.assignment('=', id, value)), b.block([update]))); } else { state.init.push(update); } if (is_select_with_value) { state.init.push(b.stmt(b.call('$.init_select', node_id))); } }
```

# compiler/phases/3-transform/client/visitors/RenderTag.js

```js
/** @import { Expression, Statement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { unwrap_optional } from '../../../../utils/ast.js'; import * as b from '#compiler/builders'; import { add_svelte_meta, build_expression, Memoizer } from './shared/utils.js'; /** * @param {AST.RenderTag} node * @param {ComponentContext} context */ export function RenderTag(node, context) { context.state.template.push_comment(); const call = unwrap_optional(node.expression); /** @type {Expression[]} */ let args = []; const memoizer = new Memoizer(); for (let i = 0; i < call.arguments.length; i++) { const arg = /** @type {Expression} */ (call.arguments[i]); const metadata = node.metadata.arguments[i]; let expression = build_expression(context, arg, metadata); if (metadata.has_await || metadata.has_call) { expression = b.call('$.get', memoizer.add(expression, metadata.has_await)); } args.push(b.thunk(expression)); } memoizer.apply(); /** @type {Statement[]} */ const statements = memoizer.deriveds(context.state.analysis.runes); let snippet_function = build_expression( context, /** @type {Expression} */ (call.callee), node.metadata.expression ); if (node.metadata.dynamic) { // If we have a chain expression then ensure a nullish snippet function gets turned into an empty one if (node.expression.type === 'ChainExpression') { snippet_function = b.logical('??', snippet_function, b.id('$.noop')); } statements.push( add_svelte_meta( b.call('$.snippet', context.state.node, b.thunk(snippet_function), ...args), node, 'render' ) ); } else { statements.push( add_svelte_meta( (node.expression.type === 'CallExpression' ? b.call : b.maybe_call)( snippet_function, context.state.node, ...args ), node, 'render' ) ); } const async_values = memoizer.async_values(); if (async_values) { context.state.init.push( b.stmt( b.call( '$.async', context.state.node, memoizer.async_values(), b.arrow([context.state.node, ...memoizer.async_ids()], b.block(statements)) ) ) ); } else { context.state.init.push(statements.length === 1 ? statements[0] : b.block(statements)); } }
```

# compiler/phases/3-transform/client/visitors/shared/component.js

```js
/** @import { BlockStatement, Expression, ExpressionStatement, Identifier, MemberExpression, Pattern, Property, SequenceExpression, Statement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../../types.js' */ import { dev, is_ignored } from '../../../../../state.js'; import { get_attribute_chunks, object } from '../../../../../utils/ast.js'; import * as b from '#compiler/builders'; import { add_svelte_meta, build_bind_this, Memoizer, validate_binding } from '../shared/utils.js'; import { build_attribute_value } from '../shared/element.js'; import { build_event_handler } from './events.js'; import { determine_slot } from '../../../../../utils/slot.js'; /** * @param {AST.Component | AST.SvelteComponent | AST.SvelteSelf} node * @param {string} component_name * @param {ComponentContext} context * @returns {Statement} */ export function build_component(node, component_name, context) { /** * @type {Expression} */ const anchor = context.state.node; /** @type {Array<Property[] | Expression>} */ const props_and_spreads = []; /** @type {Array<() => void>} */ const delayed_props = []; /** @type {ExpressionStatement[]} */ const lets = []; /** @type {Record<string, typeof context.state>} */ const states = { default: { ...context.state, scope: node.metadata.scopes.default, transform: { ...context.state.transform } } }; /** @type {Record<string, AST.TemplateNode[]>} */ const children = {}; /** @type {Record<string, Expression[]>} */ const events = {}; const memoizer = new Memoizer(); /** @type {Property[]} */ const custom_css_props = []; /** @type {Identifier | MemberExpression | SequenceExpression | null} */ let bind_this = null; /** @type {ExpressionStatement[]} */ const binding_initializers = []; const is_component_dynamic = node.type === 'SvelteComponent' || (node.type === 'Component' && node.metadata.dynamic); // The variable name used for the component inside $.component() const intermediate_name = node.type === 'Component' && node.metadata.dynamic ? context.state.scope.generate(node.name) : '$$component'; /** * If this component has a slot property, it is a named slot within another component. In this case * the slot scope applies to the component itself, too, and not just its children. */ let slot_scope_applies_to_itself = !!determine_slot(node); /** * Components may have a children prop and also have child nodes. In this case, we assume * that the child component isn't using render tags yet and pass the slot as $$slots.default. * We're not doing it for spread attributes, as this would result in too many false positives. */ let has_children_prop = false; /** * @param {Property} prop * @param {boolean} [delay] */ function push_prop(prop, delay = false) { const do_push = () => { const current = props_and_spreads.at(-1); const current_is_props = Array.isArray(current); const props = current_is_props ? current : []; props.push(prop); if (!current_is_props) { props_and_spreads.push(props); } }; if (delay) { delayed_props.push(do_push); } else { do_push(); } } if (slot_scope_applies_to_itself) { for (const attribute of node.attributes) { if (attribute.type === 'LetDirective') { lets.push(/** @type {ExpressionStatement} */ (context.visit(attribute))); } } } for (const attribute of node.attributes) { if (attribute.type === 'LetDirective') { if (!slot_scope_applies_to_itself) { lets.push(/** @type {ExpressionStatement} */ (context.visit(attribute, states.default))); } } else if (attribute.type === 'OnDirective') { if (!attribute.expression) { context.state.analysis.needs_props = true; } let handler = build_event_handler( attribute.expression, attribute.metadata.expression, context ); if (attribute.modifiers.includes('once')) { handler = b.call('$.once', handler); } (events[attribute.name] ||= []).push(handler); } else if (attribute.type === 'SpreadAttribute') { const expression = /** @type {Expression} */ (context.visit(attribute)); if (attribute.metadata.expression.has_state) { props_and_spreads.push( b.thunk( attribute.metadata.expression.has_await || attribute.metadata.expression.has_call ? b.call('$.get', memoizer.add(expression, attribute.metadata.expression.has_await)) : expression ) ); } else { props_and_spreads.push(expression); } } else if (attribute.type === 'Attribute') { if (attribute.name.startsWith('--')) { custom_css_props.push( b.init( attribute.name, build_attribute_value(attribute.value, context, (value, metadata) => { // TODO put the derived in the local block return metadata.has_call || metadata.has_await ? b.call('$.get', memoizer.add(value, metadata.has_await)) : value; }).value ) ); continue; } if (attribute.name === 'slot') { slot_scope_applies_to_itself = true; } if (attribute.name === 'children') { has_children_prop = true; } const { value, has_state } = build_attribute_value( attribute.value, context, (value, metadata) => { if (!metadata.has_state && !metadata.has_await) return value; // When we have a non-simple computation, anything other than an Identifier or Member expression, // then there's a good chance it needs to be memoized to avoid over-firing when read within the // child component (e.g. `active={i === index}`) const should_wrap_in_derived = metadata.has_await || get_attribute_chunks(attribute.value).some((n) => { return ( n.type === 'ExpressionTag' && n.expression.type !== 'Identifier' && n.expression.type !== 'MemberExpression' ); }); return should_wrap_in_derived ? b.call('$.get', memoizer.add(value, metadata.has_await)) : value; } ); if (has_state) { push_prop(b.get(attribute.name, [b.return(value)])); } else { push_prop(b.init(attribute.name, value)); } } else if (attribute.type === 'BindDirective') { const expression = /** @type {Expression} */ (context.visit(attribute.expression)); if ( dev && attribute.name !== 'this' && !is_ignored(node, 'ownership_invalid_binding') && // bind:x={() => x.y, y => x.y = y} will be handled by the assignment expression binding validation attribute.expression.type !== 'SequenceExpression' ) { const left = object(attribute.expression); const binding = left && context.state.scope.get(left.name); if (binding?.kind === 'bindable_prop' || binding?.kind === 'prop') { context.state.analysis.needs_mutation_validation = true; binding_initializers.push( b.stmt( b.call( '$$ownership_validator.binding', b.literal(binding.node.name), b.id(is_component_dynamic ? intermediate_name : component_name), b.thunk(expression) ) ) ); } } if (expression.type === 'SequenceExpression') { if (attribute.name === 'this') { bind_this = attribute.expression; } else { const [get, set] = expression.expressions; const get_id = b.id(context.state.scope.generate('bind_get')); const set_id = b.id(context.state.scope.generate('bind_set')); context.state.init.push(b.var(get_id, get)); context.state.init.push(b.var(set_id, set)); push_prop(b.get(attribute.name, [b.return(b.call(get_id))])); push_prop(b.set(attribute.name, [b.stmt(b.call(set_id, b.id('$$value')))])); } } else { if ( dev && expression.type === 'MemberExpression' && context.state.analysis.runes && !is_ignored(node, 'binding_property_non_reactive') ) { validate_binding(context.state, attribute, expression); } if (attribute.name === 'this') { bind_this = attribute.expression; } else { const is_store_sub = attribute.expression.type === 'Identifier' && context.state.scope.get(attribute.expression.name)?.kind === 'store_sub'; // Delay prop pushes so bindings come at the end, to avoid spreads overwriting them if (is_store_sub) { push_prop( b.get(attribute.name, [b.stmt(b.call('$.mark_store_binding')), b.return(expression)]), true ); } else { push_prop(b.get(attribute.name, [b.return(expression)]), true); } const assignment = b.assignment( '=', /** @type {Pattern} */ (attribute.expression), b.id('$$value') ); push_prop( b.set(attribute.name, [b.stmt(/** @type {Expression} */ (context.visit(assignment)))]), true ); } } } else if (attribute.type === 'AttachTag') { const evaluated = context.state.scope.evaluate(attribute.expression); let expression = /** @type {Expression} */ (context.visit(attribute.expression)); if (attribute.metadata.expression.has_state) { expression = b.arrow( [b.id('$$node')], b.call( evaluated.is_function ? expression : b.logical('||', expression, b.id('$.noop')), b.id('$$node') ) ); } push_prop(b.prop('init', b.call('$.attachment'), expression, true)); } } delayed_props.forEach((fn) => fn()); if (slot_scope_applies_to_itself) { context.state.init.push(...lets); } if (Object.keys(events).length > 0) { const events_expression = b.object( Object.keys(events).map((name) => b.init(name, events[name].length > 1 ? b.array(events[name]) : events[name][0]) ) ); push_prop(b.init('$$events', events_expression)); } /** @type {Statement[]} */ const snippet_declarations = []; /** @type {import('estree').Property[]} */ const serialized_slots = []; // Group children by slot for (const child of node.fragment.nodes) { if (child.type === 'SnippetBlock') { // the SnippetBlock visitor adds a declaration to `init`, but if it's directly // inside a component then we want to hoist them into a block so that they // can be used as props without creating conflicts context.visit(child, { ...context.state, init: snippet_declarations }); push_prop(b.prop('init', child.expression, child.expression)); // Interop: allows people to pass snippets when component still uses slots serialized_slots.push( b.init(child.expression.name === 'children' ? 'default' : child.expression.name, b.true) ); continue; } let slot_name = determine_slot(child) ?? 'default'; (children[slot_name] ||= []).push(child); } // Serialize each slot for (const slot_name of Object.keys(children)) { const block = /** @type {BlockStatement} */ ( context.visit( { ...node.fragment, // @ts-expect-error nodes: children[slot_name] }, slot_name === 'default' ? slot_scope_applies_to_itself ? context.state : states.default : { ...context.state, scope: node.metadata.scopes[slot_name], transform: { ...context.state.transform } } ) ); if (block.body.length === 0) continue; const slot_fn = b.arrow( [b.id('$$anchor'), b.id('$$slotProps')], b.block([ ...(slot_name === 'default' && !slot_scope_applies_to_itself ? lets : []), ...block.body ]) ); if (slot_name === 'default' && !has_children_prop) { if ( lets.length === 0 && children.default.every( (node) => node.type !== 'SvelteFragment' || !node.attributes.some((attr) => attr.type === 'LetDirective') ) ) { // create `children` prop... push_prop( b.init( 'children', dev ? b.call('$.wrap_snippet', b.id(context.state.analysis.name), slot_fn) : slot_fn ) ); // and `$$slots.default: true` so that `<slot>` on the child works serialized_slots.push(b.init(slot_name, b.true)); } else { // create `$$slots.default`... serialized_slots.push(b.init(slot_name, slot_fn)); // and a `children` prop that errors push_prop(b.init('children', b.id('$.invalid_default_snippet'))); } } else { serialized_slots.push(b.init(slot_name, slot_fn)); } } if (serialized_slots.length > 0) { push_prop(b.init('$$slots', b.object(serialized_slots))); } if ( !context.state.analysis.runes && node.attributes.some((attribute) => attribute.type === 'BindDirective') ) { push_prop(b.init('$$legacy', b.true)); } const props_expression = props_and_spreads.length === 0 || (props_and_spreads.length === 1 && Array.isArray(props_and_spreads[0])) ? b.object(/** @type {Property[]} */ (props_and_spreads[0]) || []) : b.call( '$.spread_props', ...props_and_spreads.map((p) => (Array.isArray(p) ? b.object(p) : p)) ); /** @param {Expression} node_id */ let fn = (node_id) => { return b.call( // TODO We can remove this ternary once we remove legacy mode, since in runes mode dynamic components // will be handled separately through the `$.component` function, and then the component name will // always be referenced through just the identifier here. is_component_dynamic ? intermediate_name : /** @type {Expression} */ (context.visit(b.member_id(component_name))), node_id, props_expression ); }; if (bind_this !== null) { const prev = fn; fn = (node_id) => { return build_bind_this(bind_this, prev(node_id), context); }; } const statements = [...snippet_declarations, ...memoizer.deriveds(context.state.analysis.runes)]; if (is_component_dynamic) { const prev = fn; fn = (node_id) => { return b.call( '$.component', node_id, b.thunk( /** @type {Expression} */ ( context.visit(node.type === 'Component' ? b.member_id(component_name) : node.expression) ) ), b.arrow( [b.id('$$anchor'), b.id(intermediate_name)], b.block([...binding_initializers, b.stmt(prev(b.id('$$anchor')))]) ) ); }; } else { statements.push(...binding_initializers); } if (Object.keys(custom_css_props).length > 0) { if (context.state.metadata.namespace === 'svg') { // this boils down to <g><!></g> context.state.template.push_element('g', node.start); } else { // this boils down to <svelte-css-wrapper style='display: contents'><!></svelte-css-wrapper> context.state.template.push_element('svelte-css-wrapper', node.start); context.state.template.set_prop('style', 'display: contents'); } context.state.template.push_comment(); context.state.template.pop_element(); statements.push( b.stmt(b.call('$.css_props', anchor, b.thunk(b.object(custom_css_props)))), b.stmt(fn(b.member(anchor, 'lastChild'))), b.stmt(b.call('$.reset', anchor)) ); } else { context.state.template.push_comment(); statements.push(add_svelte_meta(fn(anchor), node, 'component', { componentTag: node.name })); } memoizer.apply(); const async_values = memoizer.async_values(); if (async_values) { return b.stmt( b.call( '$.async', anchor, async_values, b.arrow([b.id('$$anchor'), ...memoizer.async_ids()], b.block(statements)) ) ); } return statements.length > 1 ? b.block(statements) : statements[0]; }
```

# compiler/phases/3-transform/client/visitors/shared/declarations.js

```js
/** @import { Identifier } from 'estree' */ /** @import { ComponentContext, Context } from '../../types' */ import { is_state_source } from '../../utils.js'; import * as b from '#compiler/builders'; /** * Turns `foo` into `$.get(foo)` * @param {Identifier} node */ export function get_value(node) { return b.call('$.get', node); } /** * * @param {Context | ComponentContext} context */ export function add_state_transformers(context) { for (const [name, binding] of context.state.scope.declarations) { if ( is_state_source(binding, context.state.analysis) || binding.kind === 'derived' || binding.kind === 'legacy_reactive' ) { context.state.transform[name] = { read: binding.declaration_kind === 'var' ? (node) => b.call('$.safe_get', node) : get_value, assign: (node, value, proxy = false) => { let call = b.call('$.set', node, value, proxy && b.true); if (context.state.scope.get(`$${node.name}`)?.kind === 'store_sub') { call = b.call('$.store_unsub', call, b.literal(`$${node.name}`), b.id('$$stores')); } return call; }, mutate: (node, mutation) => { if (context.state.analysis.runes) { return mutation; } return b.call('$.mutate', node, mutation); }, update: (node) => { return b.call( node.prefix ? '$.update_pre' : '$.update', node.argument, node.operator === '--' && b.literal(-1) ); } }; } } }
```

# compiler/phases/3-transform/client/visitors/shared/element.js

```js
/** @import { Expression, Identifier, ObjectExpression } from 'estree' */ /** @import { AST, ExpressionMetadata } from '#compiler' */ /** @import { ComponentContext } from '../../types' */ import { escape_html } from '../../../../../../escaping.js'; import { normalize_attribute } from '../../../../../../utils.js'; import { is_ignored } from '../../../../../state.js'; import { is_event_attribute } from '../../../../../utils/ast.js'; import * as b from '#compiler/builders'; import { build_class_directives_object, build_style_directives_object } from '../RegularElement.js'; import { build_expression, build_template_chunk, Memoizer } from './utils.js'; /** * @param {Array<AST.Attribute | AST.SpreadAttribute>} attributes * @param {AST.ClassDirective[]} class_directives * @param {AST.StyleDirective[]} style_directives * @param {ComponentContext} context * @param {AST.RegularElement | AST.SvelteElement} element * @param {Identifier} element_id */ export function build_attribute_effect( attributes, class_directives, style_directives, context, element, element_id ) { /** @type {ObjectExpression['properties']} */ const values = []; const memoizer = new Memoizer(); for (const attribute of attributes) { if (attribute.type === 'Attribute') { const { value } = build_attribute_value(attribute.value, context, (value, metadata) => metadata.has_call || metadata.has_await ? memoizer.add(value, metadata.has_await) : value ); if ( is_event_attribute(attribute) && (value.type === 'ArrowFunctionExpression' || value.type === 'FunctionExpression') ) { // Give the event handler a stable ID so it isn't removed and readded on every update const id = context.state.scope.generate('event_handler'); context.state.init.push(b.var(id, value)); values.push(b.init(attribute.name, b.id(id))); } else { values.push(b.init(attribute.name, value)); } } else { let value = /** @type {Expression} */ (context.visit(attribute)); if (attribute.metadata.expression.has_call || attribute.metadata.expression.has_await) { value = memoizer.add(value, attribute.metadata.expression.has_await); } values.push(b.spread(value)); } } if (class_directives.length) { values.push( b.prop( 'init', b.array([b.id('$.CLASS')]), build_class_directives_object(class_directives, context, memoizer) ) ); } if (style_directives.length) { values.push( b.prop( 'init', b.array([b.id('$.STYLE')]), build_style_directives_object(style_directives, context, memoizer) ) ); } const ids = memoizer.apply(); context.state.init.push( b.stmt( b.call( '$.attribute_effect', element_id, b.arrow(ids, b.object(values)), memoizer.sync_values(), memoizer.async_values(), element.metadata.scoped && context.state.analysis.css.hash !== '' && b.literal(context.state.analysis.css.hash), is_ignored(element, 'hydration_attribute_changed') && b.true ) ) ); } /** * @param {AST.Attribute['value']} value * @param {ComponentContext} context * @param {(value: Expression, metadata: ExpressionMetadata) => Expression} memoize * @returns {{ value: Expression, has_state: boolean }} */ export function build_attribute_value(value, context, memoize = (value) => value) { if (value === true) { return { value: b.true, has_state: false }; } if (!Array.isArray(value) || value.length === 1) { const chunk = Array.isArray(value) ? value[0] : value; if (chunk.type === 'Text') { return { value: b.literal(chunk.data), has_state: false }; } let expression = build_expression(context, chunk.expression, chunk.metadata.expression); return { value: memoize(expression, chunk.metadata.expression), has_state: chunk.metadata.expression.has_state || chunk.metadata.expression.has_await }; } return build_template_chunk(value, context, context.state, memoize); } /** * @param {AST.RegularElement | AST.SvelteElement} element * @param {AST.Attribute} attribute */ export function get_attribute_name(element, attribute) { if (!element.metadata.svg && !element.metadata.mathml) { return normalize_attribute(attribute.name); } return attribute.name; } /** * @param {AST.RegularElement | AST.SvelteElement} element * @param {Identifier} node_id * @param {AST.Attribute} attribute * @param {AST.ClassDirective[]} class_directives * @param {ComponentContext} context * @param {boolean} is_html */ export function build_set_class(element, node_id, attribute, class_directives, context, is_html) { let { value, has_state } = build_attribute_value(attribute.value, context, (value, metadata) => { if (attribute.metadata.needs_clsx) { value = b.call('$.clsx', value); } return metadata.has_call || metadata.has_await ? context.state.memoizer.add(value, metadata.has_await) : value; }); /** @type {Identifier | undefined} */ let previous_id; /** @type {ObjectExpression | Identifier | undefined} */ let prev; /** @type {ObjectExpression | Identifier | undefined} */ let next; if (class_directives.length) { next = build_class_directives_object(class_directives, context); has_state ||= class_directives.some( (d) => d.metadata.expression.has_state || d.metadata.expression.has_await ); if (has_state) { previous_id = b.id(context.state.scope.generate('classes')); context.state.init.push(b.declaration('let', [b.declarator(previous_id)])); prev = previous_id; } else { prev = b.object([]); } } /** @type {Expression | undefined} */ let css_hash; if (element.metadata.scoped && context.state.analysis.css.hash) { if (value.type === 'Literal' && (value.value === '' || value.value === null)) { value = b.literal(context.state.analysis.css.hash); } else if (value.type === 'Literal' && typeof value.value === 'string') { value = b.literal(escape_html(value.value, true) + ' ' + context.state.analysis.css.hash); } else { css_hash = b.literal(context.state.analysis.css.hash); } } if (!css_hash && next) { css_hash = b.null; } /** @type {Expression} */ let set_class = b.call( '$.set_class', node_id, is_html ? b.literal(1) : b.literal(0), value, css_hash, prev, next ); if (previous_id) { set_class = b.assignment('=', previous_id, set_class); } (has_state ? context.state.update : context.state.init).push(b.stmt(set_class)); } /** * @param {Identifier} node_id * @param {AST.Attribute} attribute * @param {AST.StyleDirective[]} style_directives * @param {ComponentContext} context */ export function build_set_style(node_id, attribute, style_directives, context) { let { value, has_state } = build_attribute_value(attribute.value, context, (value, metadata) => metadata.has_call ? context.state.memoizer.add(value, metadata.has_await) : value ); /** @type {Identifier | undefined} */ let previous_id; /** @type {ObjectExpression | Identifier | undefined} */ let prev; /** @type {Expression | undefined} */ let next; if (style_directives.length) { next = build_style_directives_object(style_directives, context); has_state ||= style_directives.some( (d) => d.metadata.expression.has_state || d.metadata.expression.has_await ); if (has_state) { previous_id = b.id(context.state.scope.generate('styles')); context.state.init.push(b.declaration('let', [b.declarator(previous_id)])); prev = previous_id; } else { prev = b.object([]); } } /** @type {Expression} */ let set_style = b.call('$.set_style', node_id, value, prev, next); if (previous_id) { set_style = b.assignment('=', previous_id, set_style); } (has_state ? context.state.update : context.state.init).push(b.stmt(set_style)); }
```

# compiler/phases/3-transform/client/visitors/shared/events.js

```js
/** @import { Expression } from 'estree' */ /** @import { AST, ExpressionMetadata } from '#compiler' */ /** @import { ComponentContext } from '../../types' */ import { is_capture_event, is_passive_event } from '../../../../../../utils.js'; import { dev, locator } from '../../../../../state.js'; import * as b from '#compiler/builders'; /** * @param {AST.Attribute} node * @param {ComponentContext} context */ export function visit_event_attribute(node, context) { let capture = false; let event_name = node.name.slice(2); if (is_capture_event(event_name)) { event_name = event_name.slice(0, -7); capture = true; } // we still need to support the weird `onclick="{() => {...}}" form const tag = Array.isArray(node.value) ? /** @type {AST.ExpressionTag} */ (node.value[0]) : /** @type {AST.ExpressionTag} */ (node.value); let handler = build_event_handler(tag.expression, tag.metadata.expression, context); if (node.metadata.delegated) { let delegated_assignment; if (!context.state.events.has(event_name)) { context.state.events.add(event_name); } // Hoist function if we can, otherwise we leave the function as is if (node.metadata.delegated.hoisted) { if (node.metadata.delegated.function === tag.expression) { const func_name = context.state.scope.root.unique('on_' + event_name); context.state.hoisted.push(b.var(func_name, handler)); handler = func_name; } const hoisted_params = /** @type {Expression[]} */ ( node.metadata.delegated.function.metadata.hoisted_params ); // When we hoist a function we assign an array with the function and all // hoisted closure params. if (hoisted_params) { const args = [handler, ...hoisted_params]; delegated_assignment = b.array(args); } else { delegated_assignment = handler; } } else { delegated_assignment = handler; } context.state.init.push( b.stmt( b.assignment('=', b.member(context.state.node, '__' + event_name), delegated_assignment) ) ); } else { const statement = b.stmt( build_event( event_name, context.state.node, handler, capture, is_passive_event(event_name) ? true : undefined ) ); const type = /** @type {AST.SvelteNode} */ (context.path.at(-1)).type; if (type === 'SvelteDocument' || type === 'SvelteWindow' || type === 'SvelteBody') { // These nodes are above the component tree, and its events should run parent first context.state.init.push(statement); } else { context.state.after_update.push(statement); } } } /** * Creates a `$.event(...)` call for non-delegated event handlers * @param {string} event_name * @param {Expression} node * @param {Expression} handler * @param {boolean} capture * @param {boolean | undefined} passive */ export function build_event(event_name, node, handler, capture, passive) { return b.call( '$.event', b.literal(event_name), node, handler, capture && b.true, passive === undefined ? undefined : b.literal(passive) ); } /** * Creates an event handler * @param {Expression | null} node * @param {ExpressionMetadata} metadata * @param {ComponentContext} context * @returns {Expression} */ export function build_event_handler(node, metadata, context) { if (node === null) { // bubble event return b.function( null, [b.id('$$arg')], b.block([b.stmt(b.call('$.bubble_event.call', b.this, b.id('$$props'), b.id('$$arg')))]) ); } let handler = /** @type {Expression} */ (context.visit(node)); // inline handler if (handler.type === 'ArrowFunctionExpression' || handler.type === 'FunctionExpression') { return handler; } // function declared in the script if (handler.type === 'Identifier') { const binding = context.state.scope.get(handler.name); if (binding?.is_function()) { return handler; } // local variable can be assigned directly // except in dev mode where when need $.apply() // in order to handle warnings. if (!dev && binding?.declaration_kind !== 'import') { return handler; } } if (metadata.has_call) { // memoize where necessary const id = b.id(context.state.scope.generate('event_handler')); context.state.init.push(b.var(id, b.call('$.derived', b.thunk(handler)))); handler = b.call('$.get', id); } // wrap the handler in a function, so the expression is re-evaluated for each event let call = b.call(b.member(handler, 'apply', false, true), b.this, b.id('$$args')); if (dev) { const loc = locator(/** @type {number} */ (node.start)); const remove_parens = node.type === 'CallExpression' && node.arguments.length === 0 && node.callee.type === 'Identifier'; call = b.call( '$.apply', b.thunk(handler), b.this, b.id('$$args'), b.id(context.state.analysis.name), loc && b.array([b.literal(loc.line), b.literal(loc.column)]), has_side_effects(node) && b.true, remove_parens && b.true ); } return b.function(null, [b.rest(b.id('$$args'))], b.block([b.stmt(call)])); } /** * @param {Expression} node */ function has_side_effects(node) { if ( node.type === 'CallExpression' || node.type === 'NewExpression' || node.type === 'AssignmentExpression' || node.type === 'UpdateExpression' ) { return true; } if (node.type === 'SequenceExpression') { return node.expressions.some(has_side_effects); } return false; }
```

# compiler/phases/3-transform/client/visitors/shared/fragment.js

```js
/** @import { Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../../types' */ import { cannot_be_set_statically } from '../../../../../../utils.js'; import { is_event_attribute, is_text_attribute } from '../../../../../utils/ast.js'; import * as b from '#compiler/builders'; import { is_custom_element_node } from '../../../../nodes.js'; import { build_template_chunk } from './utils.js'; /** * Processes an array of template nodes, joining sibling text/expression nodes * (e.g. `{a} b {c}`) into a single update function. Along the way it creates * corresponding template node references these updates are applied to. * @param {AST.SvelteNode[]} nodes * @param {(is_text: boolean) => Expression} initial * @param {boolean} is_element * @param {ComponentContext} context */ export function process_children(nodes, initial, is_element, context) { const within_bound_contenteditable = context.state.metadata.bound_contenteditable; let prev = initial; let skipped = 0; /** @typedef {Array<AST.Text | AST.ExpressionTag>} Sequence */ /** @type {Sequence} */ let sequence = []; /** @param {boolean} is_text */ function get_node(is_text) { if (skipped === 0) { return prev(is_text); } return b.call( '$.sibling', prev(false), (is_text || skipped !== 1) && b.literal(skipped), is_text && b.true ); } /** * @param {boolean} is_text * @param {string} name */ function flush_node(is_text, name) { const expression = get_node(is_text); let id = expression; if (id.type !== 'Identifier') { id = b.id(context.state.scope.generate(name)); context.state.init.push(b.var(id, expression)); } prev = () => id; skipped = 1; // the next node is `$.sibling(id)` return id; } /** * @param {Sequence} sequence */ function flush_sequence(sequence) { if (sequence.every((node) => node.type === 'Text')) { skipped += 1; context.state.template.push_text(sequence); return; } context.state.template.push_text([{ type: 'Text', data: ' ', raw: ' ', start: -1, end: -1 }]); const { has_state, value } = build_template_chunk(sequence, context); // if this is a standalone `{expression}`, make sure we handle the case where // no text node was created because the expression was empty during SSR const is_text = sequence.length === 1; const id = flush_node(is_text, 'text'); const update = b.stmt(b.call('$.set_text', id, value)); if (has_state && !within_bound_contenteditable) { context.state.update.push(update); } else { context.state.init.push(b.stmt(b.assignment('=', b.member(id, 'nodeValue'), value))); } } for (const node of nodes) { if (node.type === 'Text' || node.type === 'ExpressionTag') { sequence.push(node); } else { if (sequence.length > 0) { flush_sequence(sequence); sequence = []; } let child_state = context.state; if (is_static_element(node, context.state)) { skipped += 1; } else if (node.type === 'EachBlock' && nodes.length === 1 && is_element) { node.metadata.is_controlled = true; } else { const id = flush_node(false, node.type === 'RegularElement' ? node.name : 'node'); child_state = { ...context.state, node: id }; } context.visit(node, child_state); } } if (sequence.length > 0) { flush_sequence(sequence); } // if there are trailing static text nodes/elements, // traverse to the last (n - 1) one when hydrating if (skipped > 1) { skipped -= 1; context.state.init.push(b.stmt(b.call('$.next', skipped !== 1 && b.literal(skipped)))); } } /** * @param {AST.SvelteNode} node * @param {ComponentContext["state"]} state */ function is_static_element(node, state) { if (node.type !== 'RegularElement') return false; if (node.fragment.metadata.dynamic) return false; if (is_custom_element_node(node)) return false; // we're setting all attributes on custom elements through properties for (const attribute of node.attributes) { if (attribute.type !== 'Attribute') { return false; } if (is_event_attribute(attribute)) { return false; } if (cannot_be_set_statically(attribute.name)) { return false; } if (attribute.name === 'dir') { return false; } if ( ['input', 'textarea'].includes(node.name) && ['value', 'checked'].includes(attribute.name) ) { return false; } if (node.name === 'option' && attribute.name === 'value') { return false; } // We need to apply src and loading after appending the img to the DOM for lazy loading to work if (node.name === 'img' && attribute.name === 'loading') { return false; } if (attribute.value !== true && !is_text_attribute(attribute)) { return false; } } return true; }
```

# compiler/phases/3-transform/client/visitors/shared/function.js

```js
/** @import { ArrowFunctionExpression, FunctionExpression, Node } from 'estree' */ /** @import { ComponentContext } from '../../types' */ import { build_hoisted_params } from '../../utils.js'; /** * @param {ArrowFunctionExpression | FunctionExpression} node * @param {ComponentContext} context */ export const visit_function = (node, context) => { const metadata = node.metadata; let state = { ...context.state, in_constructor: false, in_derived: false }; if (node.type === 'FunctionExpression') { const parent = /** @type {Node} */ (context.path.at(-1)); state.in_constructor = parent.type === 'MethodDefinition' && parent.kind === 'constructor'; } if (metadata?.hoisted === true) { const params = build_hoisted_params(node, context); return /** @type {FunctionExpression} */ ({ ...node, params, body: context.visit(node.body, state) }); } context.next(state); };
```

# compiler/phases/3-transform/client/visitors/shared/special_element.js

```js
/** @import { Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../../types' */ import * as b from '#compiler/builders'; /** * * @param {AST.SvelteBody | AST.SvelteDocument | AST.SvelteWindow} node * @param {string} id * @param {ComponentContext} context */ export function visit_special_element(node, id, context) { const state = { ...context.state, node: b.id(id) }; for (const attribute of node.attributes) { if (attribute.type === 'OnDirective') { context.state.init.push(b.stmt(/** @type {Expression} */ (context.visit(attribute, state)))); } else { context.visit(attribute, state); } } }
```

# compiler/phases/3-transform/client/visitors/shared/utils.js

```js
/** @import { AssignmentExpression, Expression, Identifier, MemberExpression, SequenceExpression, Literal, Super, UpdateExpression, ExpressionStatement } from 'estree' */ /** @import { AST, ExpressionMetadata } from '#compiler' */ /** @import { ComponentClientTransformState, ComponentContext, Context } from '../../types' */ import { walk } from 'zimmerframe'; import { object } from '../../../../../utils/ast.js'; import * as b from '#compiler/builders'; import { sanitize_template_string } from '../../../../../utils/sanitize_template_string.js'; import { regex_is_valid_identifier } from '../../../../patterns.js'; import is_reference from 'is-reference'; import { dev, is_ignored, locator, component_name } from '../../../../../state.js'; import { build_getter } from '../../utils.js'; /** * A utility for extracting complex expressions (such as call expressions) * from templates and replacing them with `$0`, `$1` etc */ export class Memoizer { /** @type {Array<{ id: Identifier, expression: Expression }>} */ #sync = []; /** @type {Array<{ id: Identifier, expression: Expression }>} */ #async = []; /** * @param {Expression} expression * @param {boolean} has_await */ add(expression, has_await) { const id = b.id('#'); // filled in later (has_await ? this.#async : this.#sync).push({ id, expression }); return id; } apply() { return [...this.#async, ...this.#sync].map((memo, i) => { memo.id.name = `$${i}`; return memo.id; }); } deriveds(runes = true) { return this.#sync.map((memo) => b.let(memo.id, b.call(runes ? '$.derived' : '$.derived_safe_equal', b.thunk(memo.expression))) ); } async_ids() { return this.#async.map((memo) => memo.id); } async_values() { if (this.#async.length === 0) return; return b.array(this.#async.map((memo) => b.thunk(memo.expression, true))); } sync_values() { if (this.#sync.length === 0) return; return b.array(this.#sync.map((memo) => b.thunk(memo.expression))); } } /** * @param {Array<AST.Text | AST.ExpressionTag>} values * @param {ComponentContext} context * @param {ComponentClientTransformState} state * @param {(value: Expression, metadata: ExpressionMetadata) => Expression} memoize * @returns {{ value: Expression, has_state: boolean }} */ export function build_template_chunk( values, context, state = context.state, memoize = (value, metadata) => metadata.has_call || metadata.has_await ? state.memoizer.add(value, metadata.has_await) : value ) { /** @type {Expression[]} */ const expressions = []; let quasi = b.quasi(''); const quasis = [quasi]; let has_state = false; let has_await = false; for (let i = 0; i < values.length; i++) { const node = values[i]; if (node.type === 'Text') { quasi.value.cooked += node.data; } else if (node.expression.type === 'Literal') { if (node.expression.value != null) { quasi.value.cooked += node.expression.value + ''; } } else if ( node.expression.type !== 'Identifier' || node.expression.name !== 'undefined' || state.scope.get('undefined') ) { let value = memoize( build_expression(context, node.expression, node.metadata.expression, state), node.metadata.expression ); const evaluated = state.scope.evaluate(value); has_await ||= node.metadata.expression.has_await; has_state ||= has_await || (node.metadata.expression.has_state && !evaluated.is_known); if (values.length === 1) { // If we have a single expression, then pass that in directly to possibly avoid doing // extra work in the template_effect (instead we do the work in set_text). if (evaluated.is_known) { value = b.literal((evaluated.value ?? '') + ''); } return { value, has_state }; } if ( value.type === 'LogicalExpression' && value.right.type === 'Literal' && (value.operator === '??' || value.operator === '||') ) { // `foo ?? null` -=> `foo ?? ''` // otherwise leave the expression untouched if (value.right.value === null) { value = { ...value, right: b.literal('') }; } } if (evaluated.is_known) { quasi.value.cooked += (evaluated.value ?? '') + ''; } else { if (!evaluated.is_defined) { // add `?? ''` where necessary value = b.logical('??', value, b.literal('')); } expressions.push(value); quasi = b.quasi('', i + 1 === values.length); quasis.push(quasi); } } } for (const quasi of quasis) { quasi.value.raw = sanitize_template_string(/** @type {string} */ (quasi.value.cooked)); } const value = expressions.length > 0 ? b.template(quasis, expressions) : b.literal(/** @type {string} */ (quasi.value.cooked)); return { value, has_state }; } /** * @param {ComponentClientTransformState} state */ export function build_render_statement(state) { const { memoizer } = state; const ids = memoizer.apply(); return b.stmt( b.call( '$.template_effect', b.arrow( ids, state.update.length === 1 && state.update[0].type === 'ExpressionStatement' ? state.update[0].expression : b.block(state.update) ), memoizer.sync_values(), memoizer.async_values() ) ); } /** * For unfortunate legacy reasons, directive names can look like this `use:a.b-c` * This turns that string into a member expression * @param {string} name */ export function parse_directive_name(name) { // this allow for accessing members of an object const parts = name.split('.'); let part = /** @type {string} */ (parts.shift()); /** @type {Identifier | MemberExpression} */ let expression = b.id(part); while ((part = /** @type {string} */ (parts.shift()))) { const computed = !regex_is_valid_identifier.test(part); expression = b.member(expression, computed ? b.literal(part) : b.id(part), computed); } return expression; } /** * Serializes `bind:this` for components and elements. * @param {Identifier | MemberExpression | SequenceExpression} expression * @param {Expression} value * @param {import('zimmerframe').Context<AST.SvelteNode, ComponentClientTransformState>} context */ export function build_bind_this(expression, value, { state, visit }) { if (expression.type === 'SequenceExpression') { const [get, set] = /** @type {SequenceExpression} */ (visit(expression)).expressions; return b.call('$.bind_this', value, set, get); } /** @type {Identifier[]} */ const ids = []; /** @type {Expression[]} */ const values = []; /** @type {string[]} */ const seen = []; const transform = { ...state.transform }; // Pass in each context variables to the get/set functions, so that we can null out old values on teardown. // Note that we only do this for each context variables, the consequence is that the value might be stale in // some scenarios where the value is a member expression with changing computed parts or using a combination of multiple // variables, but that was the same case in Svelte 4, too. Once legacy mode is gone completely, we can revisit this. walk(expression, null, { Identifier(node, { path }) { if (seen.includes(node.name)) return; seen.push(node.name); const parent = /** @type {Expression} */ (path.at(-1)); if (!is_reference(node, parent)) return; const binding = state.scope.get(node.name); if (!binding) return; for (const [owner, scope] of state.scopes) { if (owner.type === 'EachBlock' && scope === binding.scope) { ids.push(node); values.push(/** @type {Expression} */ (visit(node))); if (transform[node.name]) { transform[node.name] = { ...transform[node.name], read: (node) => node }; } break; } } } }); const child_state = { ...state, transform }; const get = /** @type {Expression} */ (visit(expression, child_state)); const set = /** @type {Expression} */ ( visit(b.assignment('=', expression, b.id('$$value')), child_state) ); // If we're mutating a property, then it might already be non-existent. // If we make all the object nodes optional, then it avoids any runtime exceptions. /** @type {Expression | Super} */ let node = get; while (node.type === 'MemberExpression') { node.optional = true; node = node.object; } return b.call( '$.bind_this', value, b.arrow([b.id('$$value'), ...ids], set), b.arrow([...ids], get), values.length > 0 && b.thunk(b.array(values)) ); } /** * @param {ComponentClientTransformState} state * @param {AST.BindDirective} binding * @param {MemberExpression} expression */ export function validate_binding(state, binding, expression) { if (binding.expression.type === 'SequenceExpression') { return; } // If we are referencing a $store.foo then we don't need to add validation const left = object(binding.expression); const left_binding = left && state.scope.get(left.name); if (left_binding?.kind === 'store_sub') return; const loc = locator(binding.start); const obj = /** @type {Expression} */ (expression.object); state.init.push( b.stmt( b.call( '$.validate_binding', b.literal(state.analysis.source.slice(binding.start, binding.end)), b.thunk( state.store_to_invalidate ? b.sequence([b.call('$.mark_store_binding'), obj]) : obj ), b.thunk( /** @type {Expression} */ ( expression.computed ? expression.property : b.literal(/** @type {Identifier} */ (expression.property).name) ) ), loc && b.literal(loc.line), loc && b.literal(loc.column) ) ) ); } /** * In dev mode validate mutations to props * @param {AssignmentExpression | UpdateExpression} node * @param {Context} context * @param {Expression} expression */ export function validate_mutation(node, context, expression) { let left = /** @type {Expression | Super} */ ( node.type === 'AssignmentExpression' ? node.left : node.argument ); if (!dev || left.type !== 'MemberExpression' || is_ignored(node, 'ownership_invalid_mutation')) { return expression; } const name = object(left); if (!name) return expression; const binding = context.state.scope.get(name.name); if (binding?.kind !== 'prop' && binding?.kind !== 'bindable_prop') return expression; const state = /** @type {ComponentClientTransformState} */ (context.state); state.analysis.needs_mutation_validation = true; /** @type {Array<Identifier | Literal | Expression>} */ const path = []; while (left.type === 'MemberExpression') { if (left.property.type === 'Literal') { path.unshift(left.property); } else if (left.property.type === 'Identifier') { const transform = Object.hasOwn(context.state.transform, left.property.name) ? context.state.transform[left.property.name] : null; if (left.computed) { path.unshift(transform?.read ? transform.read(left.property) : left.property); } else { path.unshift(b.literal(left.property.name)); } } else { return expression; } left = left.object; } path.unshift(b.literal(name.name)); const loc = locator(/** @type {number} */ (left.start)); return b.call( '$$ownership_validator.mutation', b.literal(binding.prop_alias), b.array(path), expression, loc && b.literal(loc.line), loc && b.literal(loc.column) ); } /** * * @param {ComponentContext} context * @param {Expression} expression * @param {ExpressionMetadata} metadata */ export function build_expression(context, expression, metadata, state = context.state) { const value = /** @type {Expression} */ (context.visit(expression, state)); // Components not explicitly in legacy mode might be expected to be in runes mode (especially since we didn't // adjust this behavior until recently, which broke people's existing components), so we also bail in this case. // Kind of an in-between-mode. if (context.state.analysis.runes || context.state.analysis.maybe_runes) { return value; } if (!metadata.has_call && !metadata.has_member_expression && !metadata.has_assignment) { return value; } // Legacy reactivity is coarse-grained, looking at the statically visible dependencies. Replicate that here const sequence = b.sequence([]); for (const binding of metadata.references) { if (binding.kind === 'normal' && binding.declaration_kind !== 'import') { continue; } var getter = build_getter({ ...binding.node }, state); if ( binding.kind === 'bindable_prop' || binding.kind === 'template' || binding.declaration_kind === 'import' || binding.node.name === '$$props' || binding.node.name === '$$restProps' ) { getter = b.call('$.deep_read_state', getter); } sequence.expressions.push(getter); } sequence.expressions.push(b.call('$.untrack', b.thunk(value))); return sequence; } /** * Wraps a statement/expression with dev stack tracking in dev mode * @param {Expression} expression - The function call to wrap (e.g., $.if, $.each, etc.) * @param {{ start?: number }} node - AST node for location info * @param {'component' | 'if' | 'each' | 'await' | 'key' | 'render'} type - Type of block/component * @param {Record<string, number | string>} [additional] - Any additional properties to add to the dev stack entry * @returns {ExpressionStatement} - Statement with or without dev stack wrapping */ export function add_svelte_meta(expression, node, type, additional) { if (!dev) { return b.stmt(expression); } const location = node.start !== undefined && locator(node.start); if (!location) { return b.stmt(expression); } return b.stmt( b.call( '$.add_svelte_meta', b.arrow([], expression), b.literal(type), b.id(component_name), b.literal(location.line), b.literal(location.column), additional && b.object(Object.entries(additional).map(([k, v]) => b.init(k, b.literal(v)))) ) ); }
```

# compiler/phases/3-transform/client/visitors/SlotElement.js

```js
/** @import { BlockStatement, Expression, ExpressionStatement, Literal, Property, Statement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import * as b from '#compiler/builders'; import { build_attribute_value } from './shared/element.js'; import { Memoizer } from './shared/utils.js'; /** * @param {AST.SlotElement} node * @param {ComponentContext} context */ export function SlotElement(node, context) { // <slot {a}>fallback</slot> --> $.slot($$slots.default, { get a() { .. } }, () => ...fallback); context.state.template.push_comment(); /** @type {Property[]} */ const props = []; /** @type {Expression[]} */ const spreads = []; /** @type {ExpressionStatement[]} */ const lets = []; const memoizer = new Memoizer(); let name = b.literal('default'); for (const attribute of node.attributes) { if (attribute.type === 'SpreadAttribute') { spreads.push(b.thunk(/** @type {Expression} */ (context.visit(attribute)))); } else if (attribute.type === 'Attribute') { const { value, has_state } = build_attribute_value( attribute.value, context, (value, metadata) => metadata.has_call || metadata.has_await ? b.call('$.get', memoizer.add(value, metadata.has_await)) : value ); if (attribute.name === 'name') { name = /** @type {Literal} */ (value); } else if (attribute.name !== 'slot') { if (has_state) { props.push(b.get(attribute.name, [b.return(value)])); } else { props.push(b.init(attribute.name, value)); } } } else if (attribute.type === 'LetDirective') { lets.push(/** @type {ExpressionStatement} */ (context.visit(attribute))); } } memoizer.apply(); // Let bindings first, they can be used on attributes context.state.init.push(...lets); /** @type {Statement[]} */ const statements = memoizer.deriveds(context.state.analysis.runes); const props_expression = spreads.length === 0 ? b.object(props) : b.call('$.spread_props', b.object(props), ...spreads); const fallback = node.fragment.nodes.length === 0 ? b.null : b.arrow([b.id('$$anchor')], /** @type {BlockStatement} */ (context.visit(node.fragment))); statements.push( b.stmt(b.call('$.slot', context.state.node, b.id('$$props'), name, props_expression, fallback)) ); const async_values = memoizer.async_values(); if (async_values) { context.state.init.push( b.stmt( b.call( '$.async', context.state.node, async_values, b.arrow([context.state.node, ...memoizer.async_ids()], b.block(statements)) ) ) ); } else { context.state.init.push(statements.length === 1 ? statements[0] : b.block(statements)); } }
```

# compiler/phases/3-transform/client/visitors/SnippetBlock.js

```js
/** @import { AssignmentPattern, BlockStatement, Expression, Identifier, Statement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { dev } from '../../../../state.js'; import { extract_paths } from '../../../../utils/ast.js'; import * as b from '#compiler/builders'; import { get_value } from './shared/declarations.js'; /** * @param {AST.SnippetBlock} node * @param {ComponentContext} context */ export function SnippetBlock(node, context) { // TODO hoist where possible /** @type {(Identifier | AssignmentPattern)[]} */ const args = [b.id('$$anchor')]; /** @type {BlockStatement} */ let body; /** @type {Statement[]} */ const declarations = []; if (dev) { declarations.push(b.stmt(b.call('$.validate_snippet_args', b.spread(b.id('arguments'))))); } const transform = { ...context.state.transform }; const child_state = { ...context.state, transform }; for (let i = 0; i < node.parameters.length; i++) { const argument = node.parameters[i]; if (!argument) continue; if (argument.type === 'Identifier') { args.push(b.assignment_pattern(argument, b.id('$.noop'))); transform[argument.name] = { read: b.call }; continue; } let arg_alias = `$$arg${i}`; args.push(b.id(arg_alias)); const { inserts, paths } = extract_paths(argument, b.maybe_call(b.id(arg_alias))); for (const { id, value } of inserts) { id.name = context.state.scope.generate('$$array'); transform[id.name] = { read: get_value }; declarations.push( b.var(id, b.call('$.derived', /** @type {Expression} */ (context.visit(b.thunk(value))))) ); } for (const path of paths) { const name = /** @type {Identifier} */ (path.node).name; const needs_derived = path.has_default_value; // to ensure that default value is only called once const fn = b.thunk(/** @type {Expression} */ (context.visit(path.expression, child_state))); declarations.push(b.let(path.node, needs_derived ? b.call('$.derived_safe_equal', fn) : fn)); transform[name] = { read: needs_derived ? get_value : b.call }; // we need to eagerly evaluate the expression in order to hit any // 'Cannot access x before initialization' errors if (dev) { declarations.push(b.stmt(transform[name].read(b.id(name)))); } } } body = b.block([ ...declarations, .../** @type {BlockStatement} */ (context.visit(node.body, child_state)).body ]); // in dev we use a FunctionExpression (not arrow function) so we can use `arguments` let snippet = dev ? b.call('$.wrap_snippet', b.id(context.state.analysis.name), b.function(null, args, body)) : b.arrow(args, body); const declaration = b.const(node.expression, snippet); // Top-level snippets are hoisted so they can be referenced in the `<script>` if (context.path.length === 1 && context.path[0].type === 'Fragment') { if (node.metadata.can_hoist) { context.state.module_level_snippets.push(declaration); } else { context.state.instance_level_snippets.push(declaration); } } else { context.state.init.push(declaration); } }
```

# compiler/phases/3-transform/client/visitors/SpreadAttribute.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ /** * @param {AST.SpreadAttribute} node * @param {ComponentContext} context */ export function SpreadAttribute(node, context) { return context.visit(node.expression); }
```

# compiler/phases/3-transform/client/visitors/SvelteBody.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { visit_special_element } from './shared/special_element.js'; /** * @param {AST.SvelteBody} node * @param {ComponentContext} context */ export function SvelteBody(node, context) { visit_special_element(node, '$.document.body', context); }
```

# compiler/phases/3-transform/client/visitors/SvelteBoundary.js

```js
/** @import { BlockStatement, Statement, Expression, VariableDeclaration } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { dev } from '../../../../state.js'; import * as b from '#compiler/builders'; /** * @param {AST.SvelteBoundary} node * @param {ComponentContext} context */ export function SvelteBoundary(node, context) { const props = b.object([]); for (const attribute of node.attributes) { if (attribute.type !== 'Attribute' || attribute.value === true) { // these can't exist, because they would have caused validation // to fail, but typescript doesn't know that continue; } const chunk = Array.isArray(attribute.value) ? /** @type {AST.ExpressionTag} */ (attribute.value[0]) : attribute.value; const expression = /** @type {Expression} */ (context.visit(chunk.expression, context.state)); if (chunk.metadata.expression.has_state) { props.properties.push(b.get(attribute.name, [b.return(expression)])); } else { props.properties.push(b.init(attribute.name, expression)); } } const nodes = []; /** @type {Statement[]} */ const const_tags = []; /** @type {Statement[]} */ const hoisted = []; // const tags need to live inside the boundary, but might also be referenced in hoisted snippets. // to resolve this we cheat: we duplicate const tags inside snippets for (const child of node.fragment.nodes) { if (child.type === 'ConstTag') { context.visit(child, { ...context.state, init: const_tags }); } } for (const child of node.fragment.nodes) { if (child.type === 'ConstTag') { continue; } if (child.type === 'SnippetBlock') { /** @type {Statement[]} */ const statements = []; context.visit(child, { ...context.state, init: statements }); const snippet = /** @type {VariableDeclaration} */ (statements[0]); const snippet_fn = dev ? // @ts-expect-error we know this shape is correct snippet.declarations[0].init.arguments[1] : snippet.declarations[0].init; snippet_fn.body.body.unshift( ...const_tags.filter((node) => node.type === 'VariableDeclaration') ); hoisted.push(snippet); if (['failed', 'pending'].includes(child.expression.name)) { props.properties.push(b.prop('init', child.expression, child.expression)); } continue; } nodes.push(child); } const block = /** @type {BlockStatement} */ (context.visit({ ...node.fragment, nodes })); block.body.unshift(...const_tags); const boundary = b.stmt( b.call('$.boundary', context.state.node, props, b.arrow([b.id('$$anchor')], block)) ); context.state.template.push_comment(); context.state.init.push(hoisted.length > 0 ? b.block([...hoisted, boundary]) : boundary); }
```

# compiler/phases/3-transform/client/visitors/SvelteComponent.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { build_component } from './shared/component.js'; /** * @param {AST.SvelteComponent} node * @param {ComponentContext} context */ export function SvelteComponent(node, context) { const component = build_component(node, '$$component', context); context.state.init.push(component); }
```

# compiler/phases/3-transform/client/visitors/SvelteDocument.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { visit_special_element } from './shared/special_element.js'; /** * @param {AST.SvelteDocument} node * @param {ComponentContext} context */ export function SvelteDocument(node, context) { visit_special_element(node, '$.document', context); }
```

# compiler/phases/3-transform/client/visitors/SvelteElement.js

```js
/** @import { BlockStatement, Expression, ExpressionStatement, Statement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { dev, locator } from '../../../../state.js'; import { is_text_attribute } from '../../../../utils/ast.js'; import * as b from '#compiler/builders'; import { determine_namespace_for_children } from '../../utils.js'; import { build_attribute_value, build_attribute_effect, build_set_class } from './shared/element.js'; import { build_render_statement, Memoizer } from './shared/utils.js'; /** * @param {AST.SvelteElement} node * @param {ComponentContext} context */ export function SvelteElement(node, context) { context.state.template.push_comment(); /** @type {Array<AST.Attribute | AST.SpreadAttribute>} */ const attributes = []; /** @type {AST.Attribute['value'] | undefined} */ let dynamic_namespace = undefined; /** @type {AST.ClassDirective[]} */ const class_directives = []; /** @type {AST.StyleDirective[]} */ const style_directives = []; /** @type {ExpressionStatement[]} */ const statements = []; // Create a temporary context which picks up the init/update statements. // They'll then be added to the function parameter of $.element const element_id = b.id(context.state.scope.generate('$$element')); /** @type {ComponentContext} */ const inner_context = { ...context, state: { ...context.state, node: element_id, init: [], update: [], after_update: [], memoizer: new Memoizer() } }; for (const attribute of node.attributes) { if (attribute.type === 'Attribute') { if (attribute.name === 'xmlns' && !is_text_attribute(attribute)) { dynamic_namespace = attribute.value; } attributes.push(attribute); } else if (attribute.type === 'SpreadAttribute') { attributes.push(attribute); } else if (attribute.type === 'ClassDirective') { class_directives.push(attribute); } else if (attribute.type === 'StyleDirective') { style_directives.push(attribute); } else if (attribute.type === 'LetDirective') { statements.push(/** @type {ExpressionStatement} */ (context.visit(attribute))); } else if (attribute.type === 'OnDirective') { const handler = /** @type {Expression} */ (context.visit(attribute, inner_context.state)); inner_context.state.after_update.push(b.stmt(handler)); } else { context.visit(attribute, inner_context.state); } } if ( attributes.length === 1 && attributes[0].type === 'Attribute' && attributes[0].name.toLowerCase() === 'class' && is_text_attribute(attributes[0]) ) { build_set_class(node, element_id, attributes[0], class_directives, inner_context, false); } else if (attributes.length) { // Always use spread because we don't know whether the element is a custom element or not, // therefore we need to do the "how to set an attribute" logic at runtime. build_attribute_effect( attributes, class_directives, style_directives, inner_context, node, element_id ); } const { has_await } = node.metadata.expression; const expression = /** @type {Expression} */ (context.visit(node.tag)); const get_tag = b.thunk(has_await ? b.call('$.get', b.id('$$tag')) : expression); /** @type {Statement[]} */ const inner = inner_context.state.init; if (inner_context.state.update.length > 0) { inner.push(build_render_statement(inner_context.state)); } inner.push(...inner_context.state.after_update); inner.push( .../** @type {BlockStatement} */ ( context.visit(node.fragment, { ...context.state, metadata: { ...context.state.metadata, namespace: determine_namespace_for_children(node, context.state.metadata.namespace) } }) ).body ); if (dev) { if (node.fragment.nodes.length > 0) { statements.push(b.stmt(b.call('$.validate_void_dynamic_element', get_tag))); } statements.push(b.stmt(b.call('$.validate_dynamic_element_tag', get_tag))); } const location = dev && locator(node.start); statements.push( b.stmt( b.call( '$.element', context.state.node, get_tag, node.metadata.svg || node.metadata.mathml ? b.true : b.false, inner.length > 0 && b.arrow([element_id, b.id('$$anchor')], b.block(inner)), dynamic_namespace && b.thunk(build_attribute_value(dynamic_namespace, context).value), location && b.array([b.literal(location.line), b.literal(location.column)]) ) ) ); if (has_await) { context.state.init.push( b.stmt( b.call( '$.async', context.state.node, b.array([b.thunk(expression, true)]), b.arrow([context.state.node, b.id('$$tag')], b.block(statements)) ) ) ); } else { context.state.init.push(statements.length === 1 ? statements[0] : b.block(statements)); } }
```

# compiler/phases/3-transform/client/visitors/SvelteFragment.js

```js
/** @import { BlockStatement, ExpressionStatement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ /** * @param {AST.SvelteFragment} node * @param {ComponentContext} context */ export function SvelteFragment(node, context) { for (const attribute of node.attributes) { if (attribute.type === 'LetDirective') { context.state.init.push(/** @type {ExpressionStatement} */ (context.visit(attribute))); } } context.state.init.push(.../** @type {BlockStatement} */ (context.visit(node.fragment)).body); }
```

# compiler/phases/3-transform/client/visitors/SvelteHead.js

```js
/** @import { BlockStatement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import * as b from '#compiler/builders'; /** * @param {AST.SvelteHead} node * @param {ComponentContext} context */ export function SvelteHead(node, context) { // TODO attributes? context.state.init.push( b.stmt( b.call( '$.head', b.arrow([b.id('$$anchor')], /** @type {BlockStatement} */ (context.visit(node.fragment))) ) ) ); }
```

# compiler/phases/3-transform/client/visitors/SvelteSelf.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { build_component } from './shared/component.js'; /** * @param {AST.SvelteSelf} node * @param {ComponentContext} context */ export function SvelteSelf(node, context) { const component = build_component(node, context.state.analysis.name, context); context.state.init.push(component); }
```

# compiler/phases/3-transform/client/visitors/SvelteWindow.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { visit_special_element } from './shared/special_element.js'; /** * @param {AST.SvelteWindow} node * @param {ComponentContext} context */ export function SvelteWindow(node, context) { visit_special_element(node, '$.window', context); }
```

# compiler/phases/3-transform/client/visitors/TitleElement.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import * as b from '#compiler/builders'; import { build_template_chunk } from './shared/utils.js'; /** * @param {AST.TitleElement} node * @param {ComponentContext} context */ export function TitleElement(node, context) { const { has_state, value } = build_template_chunk( /** @type {any} */ (node.fragment.nodes), context ); const statement = b.stmt(b.assignment('=', b.id('$.document.title'), value)); if (has_state) { context.state.update.push(statement); } else { context.state.init.push(statement); } }
```

# compiler/phases/3-transform/client/visitors/TransitionDirective.js

```js
/** @import { Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { TRANSITION_GLOBAL, TRANSITION_IN, TRANSITION_OUT } from '../../../../../constants.js'; import * as b from '#compiler/builders'; import { parse_directive_name } from './shared/utils.js'; /** * @param {AST.TransitionDirective} node * @param {ComponentContext} context */ export function TransitionDirective(node, context) { let flags = node.modifiers.includes('global') ? TRANSITION_GLOBAL : 0; if (node.intro) flags |= TRANSITION_IN; if (node.outro) flags |= TRANSITION_OUT; const args = [ b.literal(flags), context.state.node, b.thunk(/** @type {Expression} */ (context.visit(parse_directive_name(node.name)))) ]; if (node.expression) { args.push(b.thunk(/** @type {Expression} */ (context.visit(node.expression)))); } // in after_update to ensure it always happens after bind:this context.state.after_update.push(b.stmt(b.call('$.transition', ...args))); }
```

# compiler/phases/3-transform/client/visitors/UpdateExpression.js

```js
/** @import { AssignmentExpression, Expression, UpdateExpression } from 'estree' */ /** @import { Context } from '../types' */ import { object } from '../../../../utils/ast.js'; import * as b from '#compiler/builders'; import { validate_mutation } from './shared/utils.js'; /** * @param {UpdateExpression} node * @param {Context} context */ export function UpdateExpression(node, context) { const argument = node.argument; if ( argument.type === 'MemberExpression' && argument.object.type === 'ThisExpression' && argument.property.type === 'PrivateIdentifier' && context.state.state_fields.has('#' + argument.property.name) ) { let fn = '$.update'; if (node.prefix) fn += '_pre'; /** @type {Expression[]} */ const args = [argument]; if (node.operator === '--') { args.push(b.literal(-1)); } return b.call(fn, ...args); } if (argument.type !== 'Identifier' && argument.type !== 'MemberExpression') { throw new Error('An impossible state was reached'); } const left = object(argument); const transformers = left && context.state.transform[left.name]; if (left === argument && transformers?.update) { // we don't need to worry about ownership_invalid_mutation here, because // we're not mutating but reassigning return transformers.update(node); } let update = /** @type {Expression} */ (context.next()); if (left && transformers?.mutate) { update = transformers.mutate( left, /** @type {AssignmentExpression | UpdateExpression} */ (update) ); } return validate_mutation(node, context, update); }
```

# compiler/phases/3-transform/client/visitors/UseDirective.js

```js
/** @import { Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import * as b from '#compiler/builders'; import { parse_directive_name } from './shared/utils.js'; /** * @param {AST.UseDirective} node * @param {ComponentContext} context */ export function UseDirective(node, context) { const params = [b.id('$$node')]; if (node.expression) { params.push(b.id('$$action_arg')); } /** @type {Expression[]} */ const args = [ context.state.node, b.arrow( params, b.maybe_call( /** @type {Expression} */ (context.visit(parse_directive_name(node.name))), ...params ) ) ]; if (node.expression) { args.push(b.thunk(/** @type {Expression} */ (context.visit(node.expression)))); } // actions need to run after attribute updates in order with bindings/events context.state.init.push(b.stmt(b.call('$.action', ...args))); context.next(); }
```

# compiler/phases/3-transform/client/visitors/VariableDeclaration.js

```js
/** @import { CallExpression, Expression, Identifier, Literal, VariableDeclaration, VariableDeclarator } from 'estree' */ /** @import { Binding } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { dev, is_ignored, locate_node } from '../../../../state.js'; import { extract_paths } from '../../../../utils/ast.js'; import * as b from '#compiler/builders'; import * as assert from '../../../../utils/assert.js'; import { get_rune } from '../../../scope.js'; import { get_prop_source, is_prop_source, is_state_source, should_proxy } from '../utils.js'; import { is_hoisted_function } from '../../utils.js'; import { get_value } from './shared/declarations.js'; /** * @param {VariableDeclaration} node * @param {ComponentContext} context */ export function VariableDeclaration(node, context) { /** @type {VariableDeclarator[]} */ const declarations = []; if (context.state.analysis.runes) { for (const declarator of node.declarations) { const init = /** @type {Expression} */ (declarator.init); const rune = get_rune(init, context.state.scope); if ( !rune || rune === '$effect.tracking' || rune === '$effect.root' || rune === '$inspect' || rune === '$inspect.trace' || rune === '$state.snapshot' || rune === '$host' ) { if (init != null && is_hoisted_function(init)) { context.state.hoisted.push( b.const(declarator.id, /** @type {Expression} */ (context.visit(init))) ); continue; } declarations.push(/** @type {VariableDeclarator} */ (context.visit(declarator))); continue; } if (rune === '$props.id') { // skip continue; } if (rune === '$props') { /** @type {string[]} */ const seen = ['$$slots', '$$events', '$$legacy']; if (context.state.analysis.custom_element) { seen.push('$$host'); } if (declarator.id.type === 'Identifier') { /** @type {Expression[]} */ const args = [b.id('$$props'), b.array(seen.map((name) => b.literal(name)))]; if (dev) { // include rest name, so we can provide informative error messages args.push(b.literal(declarator.id.name)); } declarations.push(b.declarator(declarator.id, b.call('$.rest_props', ...args))); } else { assert.equal(declarator.id.type, 'ObjectPattern'); for (const property of declarator.id.properties) { if (property.type === 'Property') { const key = /** @type {Identifier | Literal} */ (property.key); const name = key.type === 'Identifier' ? key.name : /** @type {string} */ (key.value); seen.push(name); let id = property.value.type === 'AssignmentPattern' ? property.value.left : property.value; assert.equal(id.type, 'Identifier'); const binding = /** @type {Binding} */ (context.state.scope.get(id.name)); let initial = binding.initial && /** @type {Expression} */ (context.visit(binding.initial)); // We're adding proxy here on demand and not within the prop runtime function so that // people not using proxied state anywhere in their code don't have to pay the additional bundle size cost if ( initial && binding.kind === 'bindable_prop' && should_proxy(initial, context.state.scope) ) { initial = b.call('$.proxy', initial); if (dev) { initial = b.call('$.tag_proxy', initial, b.literal(id.name)); } } if (is_prop_source(binding, context.state)) { declarations.push( b.declarator(id, get_prop_source(binding, context.state, name, initial)) ); } } else { // RestElement /** @type {Expression[]} */ const args = [b.id('$$props'), b.array(seen.map((name) => b.literal(name)))]; if (dev) { // include rest name, so we can provide informative error messages args.push(b.literal(/** @type {Identifier} */ (property.argument).name)); } declarations.push(b.declarator(property.argument, b.call('$.rest_props', ...args))); } } } // TODO continue; } const args = /** @type {CallExpression} */ (init).arguments; const value = /** @type {Expression} */ (args[0]) ?? b.void0; // TODO do we need the void 0? can we just omit it altogether? if (rune === '$state' || rune === '$state.raw') { /** * @param {Identifier} id * @param {Expression} value */ const create_state_declarator = (id, value) => { const binding = /** @type {import('#compiler').Binding} */ ( context.state.scope.get(id.name) ); const is_state = is_state_source(binding, context.state.analysis); const is_proxy = should_proxy(value, context.state.scope); if (rune === '$state' && is_proxy) { value = b.call('$.proxy', value); if (dev && !is_state) { value = b.call('$.tag_proxy', value, b.literal(id.name)); } } if (is_state) { value = b.call('$.state', value); if (dev) { value = b.call('$.tag', value, b.literal(id.name)); } } return value; }; if (declarator.id.type === 'Identifier') { const expression = /** @type {Expression} */ (context.visit(value)); declarations.push( b.declarator(declarator.id, create_state_declarator(declarator.id, expression)) ); } else { const tmp = b.id(context.state.scope.generate('tmp')); const { inserts, paths } = extract_paths(declarator.id, tmp); declarations.push( b.declarator(tmp, /** @type {Expression} */ (context.visit(value))), ...inserts.map(({ id, value }) => { id.name = context.state.scope.generate('$$array'); context.state.transform[id.name] = { read: get_value }; const expression = /** @type {Expression} */ (context.visit(b.thunk(value))); const call = b.call('$.derived', expression); return b.declarator( id, dev ? b.call('$.tag', call, b.literal('[$state iterable]')) : call ); }), ...paths.map((path) => { const value = /** @type {Expression} */ (context.visit(path.expression)); const binding = context.state.scope.get(/** @type {Identifier} */ (path.node).name); return b.declarator( path.node, binding?.kind === 'state' || binding?.kind === 'raw_state' ? create_state_declarator(binding.node, value) : value ); }) ); } continue; } if (rune === '$derived' || rune === '$derived.by') { const is_async = context.state.analysis.async_deriveds.has( /** @type {CallExpression} */ (init) ); if (declarator.id.type === 'Identifier') { let expression = /** @type {Expression} */ ( context.visit(value, { ...context.state, in_derived: rune === '$derived' }) ); if (is_async) { const location = dev && !is_ignored(init, 'await_waterfall') && locate_node(init); let call = b.call( '$.async_derived', b.thunk(expression, true), location ? b.literal(location) : undefined ); call = b.call(b.await(b.call('$.save', call))); if (dev) call = b.call('$.tag', call, b.literal(declarator.id.name)); declarations.push(b.declarator(declarator.id, call)); } else { if (rune === '$derived') expression = b.thunk(expression); let call = b.call('$.derived', expression); if (dev) call = b.call('$.tag', call, b.literal(declarator.id.name)); declarations.push(b.declarator(declarator.id, call)); } } else { const init = /** @type {CallExpression} */ (declarator.init); let rhs = value; if (rune !== '$derived' || init.arguments[0].type !== 'Identifier') { const id = b.id(context.state.scope.generate('$$d')); rhs = b.call('$.get', id); let expression = /** @type {Expression} */ (context.visit(value)); if (rune === '$derived') expression = b.thunk(expression); const call = b.call('$.derived', expression); declarations.push( b.declarator(id, dev ? b.call('$.tag', call, b.literal('[$derived iterable]')) : call) ); } const { inserts, paths } = extract_paths(declarator.id, rhs); for (const { id, value } of inserts) { id.name = context.state.scope.generate('$$array'); context.state.transform[id.name] = { read: get_value }; const expression = /** @type {Expression} */ (context.visit(b.thunk(value))); const call = b.call('$.derived', expression); declarations.push( b.declarator(id, dev ? b.call('$.tag', call, b.literal('[$derived iterable]')) : call) ); } for (const path of paths) { const expression = /** @type {Expression} */ (context.visit(path.expression)); const call = b.call('$.derived', b.thunk(expression)); declarations.push( b.declarator( path.node, dev ? b.call('$.tag', call, b.literal(/** @type {Identifier} */ (path.node).name)) : call ) ); } } continue; } } } else { for (const declarator of node.declarations) { const bindings = /** @type {Binding[]} */ (context.state.scope.get_bindings(declarator)); const has_state = bindings.some((binding) => binding.kind === 'state'); const has_props = bindings.some((binding) => binding.kind === 'bindable_prop'); if (!has_state && !has_props) { const init = declarator.init; if (init != null && is_hoisted_function(init)) { context.state.hoisted.push( b.const(declarator.id, /** @type {Expression} */ (context.visit(init))) ); continue; } declarations.push(/** @type {VariableDeclarator} */ (context.visit(declarator))); continue; } if (has_props) { if (declarator.id.type !== 'Identifier') { // Turn export let into props. It's really really weird because export let { x: foo, z: [bar]} = .. // means that foo and bar are the props (i.e. the leafs are the prop names), not x and z. const tmp = b.id(context.state.scope.generate('tmp')); const { inserts, paths } = extract_paths(declarator.id, tmp); declarations.push( b.declarator( tmp, /** @type {Expression} */ (context.visit(/** @type {Expression} */ (declarator.init))) ) ); for (const { id, value } of inserts) { id.name = context.state.scope.generate('$$array'); context.state.transform[id.name] = { read: get_value }; const expression = /** @type {Expression} */ (context.visit(b.thunk(value))); declarations.push(b.declarator(id, b.call('$.derived', expression))); } for (const path of paths) { const name = /** @type {Identifier} */ (path.node).name; const binding = /** @type {Binding} */ (context.state.scope.get(name)); const value = /** @type {Expression} */ (context.visit(path.expression)); declarations.push( b.declarator( path.node, binding.kind === 'bindable_prop' ? get_prop_source(binding, context.state, binding.prop_alias ?? name, value) : value ) ); } continue; } const binding = /** @type {Binding} */ (context.state.scope.get(declarator.id.name)); declarations.push( b.declarator( declarator.id, get_prop_source( binding, context.state, binding.prop_alias ?? declarator.id.name, declarator.init && /** @type {Expression} */ (context.visit(declarator.init)) ) ) ); continue; } declarations.push( ...create_state_declarators( declarator, context, /** @type {Expression} */ (declarator.init && context.visit(declarator.init)) ) ); } } if (declarations.length === 0) { return b.empty; } return { ...node, declarations }; } /** * Creates the output for a state declaration in legacy mode. * @param {VariableDeclarator} declarator * @param {ComponentContext} context * @param {Expression} value */ function create_state_declarators(declarator, context, value) { if (declarator.id.type === 'Identifier') { return [ b.declarator( declarator.id, b.call('$.mutable_source', value, context.state.analysis.immutable ? b.true : undefined) ) ]; } const tmp = b.id(context.state.scope.generate('tmp')); const { inserts, paths } = extract_paths(declarator.id, tmp); return [ b.declarator(tmp, value), ...inserts.map(({ id, value }) => { id.name = context.state.scope.generate('$$array'); context.state.transform[id.name] = { read: get_value }; const expression = /** @type {Expression} */ (context.visit(b.thunk(value))); return b.declarator(id, b.call('$.derived', expression)); }), ...paths.map((path) => { const value = /** @type {Expression} */ (context.visit(path.expression)); const binding = context.state.scope.get(/** @type {Identifier} */ (path.node).name); return b.declarator( path.node, binding?.kind === 'state' ? b.call('$.mutable_source', value, context.state.analysis.immutable ? b.true : undefined) : value ); }) ]; }
```

# compiler/phases/3-transform/css/index.js

```js
/** @import { Visitors } from 'zimmerframe' */ /** @import { AST, ValidatedCompileOptions } from '#compiler' */ /** @import { ComponentAnalysis } from '../../types.js' */ import MagicString from 'magic-string'; import { walk } from 'zimmerframe'; import { is_keyframes_node, regex_css_name_boundary, remove_css_prefix } from '../../css.js'; import { merge_with_preprocessor_map } from '../../../utils/mapped_code.js'; import { dev } from '../../../state.js'; /** * @typedef {{ * code: MagicString; * hash: string; * minify: boolean; * selector: string; * keyframes: string[]; * specificity: { * bumped: boolean * } * }} State */ /** * * @param {string} source * @param {ComponentAnalysis} analysis * @param {ValidatedCompileOptions} options */ export function render_stylesheet(source, analysis, options) { const code = new MagicString(source); /** @type {State} */ const state = { code, hash: analysis.css.hash, minify: analysis.inject_styles && !options.dev, selector: `.${analysis.css.hash}`, keyframes: analysis.css.keyframes, specificity: { bumped: false } }; const ast = /** @type {AST.CSS.StyleSheet} */ (analysis.css.ast); walk(/** @type {AST.CSS.Node} */ (ast), state, visitors); code.remove(0, ast.content.start); code.remove(/** @type {number} */ (ast.content.end), source.length); if (state.minify) { remove_preceding_whitespace(ast.content.end, state); } const css = { code: code.toString(), map: code.generateMap({ // include source content; makes it easier/more robust looking up the source map code includeContent: true, // generateMap takes care of calculating source relative to file source: options.filename, file: options.cssOutputFilename || options.filename }), hasGlobal: analysis.css.has_global }; merge_with_preprocessor_map(css, options, css.map.sources[0]); if (dev && options.css === 'injected' && css.code) { css.code += `\n/*# sourceMappingURL=${css.map.toUrl()} */`; } return css; } /** @type {Visitors<AST.CSS.Node, State>} */ const visitors = { _: (node, context) => { context.state.code.addSourcemapLocation(node.start); context.state.code.addSourcemapLocation(node.end); context.next(); }, Atrule(node, { state, next, path }) { if (is_keyframes_node(node)) { let start = node.start + node.name.length + 1; while (state.code.original[start] === ' ') start += 1; let end = start; while (state.code.original[end] !== '{' && state.code.original[end] !== ' ') end += 1; if (node.prelude.startsWith('-global-')) { state.code.remove(start, start + 8); } else if (!is_in_global_block(path)) { state.code.prependRight(start, `${state.hash}-`); } return; // don't transform anything within } next(); }, Declaration(node, { state }) { const property = node.property && remove_css_prefix(node.property.toLowerCase()); if (property === 'animation' || property === 'animation-name') { let index = node.start + node.property.length + 1; let name = ''; while (index < state.code.original.length) { const character = state.code.original[index]; if (regex_css_name_boundary.test(character)) { if (state.keyframes.includes(name)) { state.code.prependRight(index - name.length, `${state.hash}-`); } if (character === ';' || character === '}') { break; } name = ''; } else { name += character; } index++; } } else if (state.minify) { remove_preceding_whitespace(node.start, state); // Don't minify whitespace in custom properties, since some browsers (Chromium < 99) // treat --foo: ; and --foo:; differently if (!node.property.startsWith('--')) { let start = node.start + node.property.length + 1; let end = start; while (/\s/.test(state.code.original[end])) end++; if (end > start) state.code.remove(start, end); } } }, Rule(node, { state, next, visit, path }) { if (state.minify) { remove_preceding_whitespace(node.start, state); remove_preceding_whitespace(node.block.end - 1, state); } // keep empty rules in dev, because it's convenient to // see them in devtools if (!dev && is_empty(node, is_in_global_block(path))) { if (state.minify) { state.code.remove(node.start, node.end); } else { state.code.prependRight(node.start, '/* (empty) '); state.code.appendLeft(node.end, '*/'); escape_comment_close(node, state.code); } return; } if (!is_used(node) && !is_in_global_block(path)) { if (state.minify) { state.code.remove(node.start, node.end); } else { state.code.prependRight(node.start, '/* (unused) '); state.code.appendLeft(node.end, '*/'); escape_comment_close(node, state.code); } return; } if (node.metadata.is_global_block) { const selector = node.prelude.children[0]; if ( node.prelude.children.length === 1 && selector.children.length === 1 && selector.children[0].selectors.length === 1 ) { // `:global {...}` if (state.minify) { state.code.remove(node.start, node.block.start + 1); state.code.remove(node.block.end - 1, node.end); } else { state.code.prependRight(node.start, '/* '); state.code.appendLeft(node.block.start + 1, '*/'); state.code.prependRight(node.block.end - 1, '/*'); state.code.appendLeft(node.block.end, '*/'); } // don't recurse into selectors but visit the body visit(node.block); return; } } next(); }, SelectorList(node, { state, next, path }) { const parent = path.at(-1); // Only add comments if we're not inside a complex selector that itself is unused or a global block if ( (!is_in_global_block(path) || (node.children.length > 1 && parent?.type === 'Rule' && parent.metadata.is_global_block)) && !path.find((n) => n.type === 'ComplexSelector' && !n.metadata.used) ) { const children = node.children; let pruning = false; let prune_start = children[0].start; let last = prune_start; let has_previous_used = false; for (let i = 0; i < children.length; i += 1) { const selector = children[i]; if (selector.metadata.used === pruning) { if (pruning) { let i = selector.start; while (state.code.original[i] !== ',') i--; if (state.minify) { state.code.remove(prune_start, has_previous_used ? i : i + 1); } else { state.code.appendRight(has_previous_used ? i : i + 1, '*/'); } } else { if (i === 0) { if (state.minify) { prune_start = selector.start; } else { state.code.prependRight(selector.start, '/* (unused) '); } } else { if (state.minify) { prune_start = last; } else { state.code.overwrite(last, selector.start, ` /* (unused) `); } } } pruning = !pruning; } if (!pruning && selector.metadata.used) { has_previous_used = true; } last = selector.end; } if (pruning) { if (state.minify) { state.code.remove(prune_start, last); } else { state.code.appendLeft(last, '*/'); } } } // if we're in a `:is(...)` or whatever, keep existing specificity bump state let specificity = state.specificity; // if this selector list belongs to a rule, require a specificity bump for the // first scoped selector but only if we're at the top level if (parent?.type === 'Rule') { specificity = { bumped: false }; /** @type {AST.CSS.Rule | null} */ let rule = parent.metadata.parent_rule; while (rule) { if (rule.metadata.has_local_selectors) { specificity = { bumped: true }; break; } rule = rule.metadata.parent_rule; } } next({ ...state, specificity }); }, ComplexSelector(node, context) { const before_bumped = context.state.specificity.bumped; for (const relative_selector of node.children) { if (relative_selector.metadata.is_global) { const global = /** @type {AST.CSS.PseudoClassSelector} */ (relative_selector.selectors[0]); remove_global_pseudo_class(global, relative_selector.combinator, context.state); const parent_rule = node.metadata.rule?.metadata.parent_rule; if (parent_rule && global.args === null) { if (relative_selector.combinator === null) { // div { :global.x { ... } } becomes div { &.x { ... } } context.state.code.prependRight(global.start, '&'); } // In case of multiple :global selectors in a selector list we gotta delete the comma, too, but only if // the next selector is used; if it's unused then the comma deletion happens as part of removal of that next selector if ( parent_rule.prelude.children.length > 1 && node.children.length === node.children.findIndex((s) => s === relative_selector) - 1 ) { const next_selector = parent_rule.prelude.children.find((s) => s.start > global.end); if (next_selector && next_selector.metadata.used) { context.state.code.update(global.end, next_selector.start, ''); } } } continue; } else { // for any :global() or :global at the middle of compound selector for (const selector of relative_selector.selectors) { if (selector.type === 'PseudoClassSelector' && selector.name === 'global') { remove_global_pseudo_class(selector, null, context.state); } } } if (relative_selector.metadata.scoped) { if (relative_selector.selectors.length === 1) { // skip standalone :is/:where/& selectors const selector = relative_selector.selectors[0]; if ( selector.type === 'PseudoClassSelector' && (selector.name === 'is' || selector.name === 'where') ) { continue; } } if (relative_selector.selectors.some((s) => s.type === 'NestingSelector')) { continue; } // for the first occurrence, we use a classname selector, so that every // encapsulated selector gets a +0-1-0 specificity bump. thereafter, // we use a `:where` selector, which does not affect specificity let modifier = context.state.selector; if (context.state.specificity.bumped) modifier = `:where(${modifier})`; context.state.specificity.bumped = true; let i = relative_selector.selectors.length; while (i--) { const selector = relative_selector.selectors[i]; if ( selector.type === 'PseudoElementSelector' || selector.type === 'PseudoClassSelector' ) { if (selector.name !== 'root' && selector.name !== 'host') { if (i === 0) context.state.code.prependRight(selector.start, modifier); } continue; } if (selector.type === 'TypeSelector' && selector.name === '*') { context.state.code.update(selector.start, selector.end, modifier); } else { context.state.code.appendLeft(selector.end, modifier); } break; } } } context.next(); context.state.specificity.bumped = before_bumped; }, PseudoClassSelector(node, context) { if (node.name === 'is' || node.name === 'where' || node.name === 'has' || node.name === 'not') { context.next(); } } }; /** * @param {Array<AST.CSS.Node>} path */ function is_in_global_block(path) { return path.some((node) => node.type === 'Rule' && node.metadata.is_global_block); } /** * @param {AST.CSS.PseudoClassSelector} selector * @param {AST.CSS.Combinator | null} combinator * @param {State} state */ function remove_global_pseudo_class(selector, combinator, state) { if (selector.args === null) { let start = selector.start; if (combinator?.name === ' ') { // div :global.x becomes div.x while (/\s/.test(state.code.original[start - 1])) start--; } // update(...), not remove(...) because there could be a closing unused comment at the end state.code.update(start, selector.start + ':global'.length, ''); } else { state.code .remove(selector.start, selector.start + ':global('.length) .remove(selector.end - 1, selector.end); } } /** * Walk backwards until we find a non-whitespace character * @param {number} end * @param {State} state */ function remove_preceding_whitespace(end, state) { let start = end; while (/\s/.test(state.code.original[start - 1])) start--; if (start < end) state.code.remove(start, end); } /** * @param {AST.CSS.Rule} rule * @param {boolean} is_in_global_block */ function is_empty(rule, is_in_global_block) { if (rule.metadata.is_global_block) { return rule.block.children.length === 0; } for (const child of rule.block.children) { if (child.type === 'Declaration') { return false; } if (child.type === 'Rule') { if ((is_used(child) || is_in_global_block) && !is_empty(child, is_in_global_block)) { return false; } } if (child.type === 'Atrule') { if (child.block === null || child.block.children.length > 0) return false; } } return true; } /** @param {AST.CSS.Rule} rule */ function is_used(rule) { return rule.prelude.children.some((selector) => selector.metadata.used); } /** * * @param {AST.CSS.Rule} node * @param {MagicString} code */ function escape_comment_close(node, code) { let escaped = false; let in_comment = false; for (let i = node.start; i < node.end; i++) { if (escaped) { escaped = false; } else { const char = code.original[i]; if (in_comment) { if (char === '*' && code.original[i + 1] === '/') { code.prependRight(++i, '\\'); in_comment = false; } } else if (char === '\\') { escaped = true; } else if (char === '/' && code.original[++i] === '*') { in_comment = true; } } } }
```

# compiler/phases/3-transform/index.js

```js
/** @import { Node } from 'esrap/languages/ts' */ /** @import { ValidatedCompileOptions, CompileResult, ValidatedModuleCompileOptions } from '#compiler' */ /** @import { ComponentAnalysis, Analysis } from '../types' */ import { print } from 'esrap'; import ts from 'esrap/languages/ts'; import { VERSION } from '../../../version.js'; import { server_component, server_module } from './server/transform-server.js'; import { client_component, client_module } from './client/transform-client.js'; import { render_stylesheet } from './css/index.js'; import { merge_with_preprocessor_map, get_source_name } from '../../utils/mapped_code.js'; import * as state from '../../state.js'; /** * @param {ComponentAnalysis} analysis * @param {string} source * @param {ValidatedCompileOptions} options * @returns {CompileResult} */ export function transform_component(analysis, source, options) { if (options.generate === false) { return { js: /** @type {any} */ (null), css: null, warnings: state.warnings, // set afterwards metadata: { runes: analysis.runes }, ast: /** @type {any} */ (null) // set afterwards }; } const program = options.generate === 'server' ? server_component(analysis, options) : client_component(analysis, options); const js_source_name = get_source_name(options.filename, options.outputFilename, 'input.svelte'); const js = print(/** @type {Node} */ (program), ts({ comments: analysis.comments }), { // include source content; makes it easier/more robust looking up the source map code // (else esrap does return null for source and sourceMapContent which may trip up tooling) sourceMapContent: source, sourceMapSource: js_source_name }); merge_with_preprocessor_map(js, options, js_source_name); const css = analysis.css.ast && !analysis.inject_styles ? render_stylesheet(source, analysis, options) : null; return { js, css, warnings: state.warnings, // set afterwards. TODO apply preprocessor sourcemap metadata: { runes: analysis.runes }, ast: /** @type {any} */ (null) // set afterwards }; } /** * @param {Analysis} analysis * @param {string} source * @param {ValidatedModuleCompileOptions} options * @returns {CompileResult} */ export function transform_module(analysis, source, options) { if (options.generate === false) { return { js: /** @type {any} */ (null), css: null, warnings: state.warnings, // set afterwards metadata: { runes: true }, ast: /** @type {any} */ (null) // set afterwards }; } const program = options.generate === 'server' ? server_module(analysis, options) : client_module(analysis, options); const basename = options.filename.split(/[/\\]/).at(-1); if (program.body.length > 0) { program.body[0].leadingComments = [ { type: 'Block', value: ` ${basename} generated by Svelte v${VERSION} ` } ]; } const js = print(/** @type {Node} */ (program), ts({ comments: analysis.comments }), { // include source content; makes it easier/more robust looking up the source map code // (else esrap does return null for source and sourceMapContent which may trip up tooling) sourceMapContent: source, sourceMapSource: get_source_name(options.filename, undefined, 'input.svelte.js') }); // prepend comment js.code = `/* ${basename} generated by Svelte v${VERSION} */\n${js.code}`; js.map.mappings = ';' + js.map.mappings; return { js, css: null, metadata: { runes: true }, warnings: state.warnings, // set afterwards ast: /** @type {any} */ (null) // set afterwards }; }
```

# compiler/phases/3-transform/server/transform-server.js

```js
/** @import { Program, Property, Statement, VariableDeclarator } from 'estree' */ /** @import { AST, ValidatedCompileOptions, ValidatedModuleCompileOptions } from '#compiler' */ /** @import { ComponentServerTransformState, ComponentVisitors, ServerTransformState, Visitors } from './types.js' */ /** @import { Analysis, ComponentAnalysis } from '../../types.js' */ import { walk } from 'zimmerframe'; import { set_scope } from '../../scope.js'; import { extract_identifiers } from '../../../utils/ast.js'; import * as b from '#compiler/builders'; import { dev, filename } from '../../../state.js'; import { render_stylesheet } from '../css/index.js'; import { AssignmentExpression } from './visitors/AssignmentExpression.js'; import { AwaitBlock } from './visitors/AwaitBlock.js'; import { AwaitExpression } from './visitors/AwaitExpression.js'; import { CallExpression } from './visitors/CallExpression.js'; import { ClassBody } from './visitors/ClassBody.js'; import { Component } from './visitors/Component.js'; import { ConstTag } from './visitors/ConstTag.js'; import { DebugTag } from './visitors/DebugTag.js'; import { EachBlock } from './visitors/EachBlock.js'; import { ExpressionStatement } from './visitors/ExpressionStatement.js'; import { Fragment } from './visitors/Fragment.js'; import { HtmlTag } from './visitors/HtmlTag.js'; import { Identifier } from './visitors/Identifier.js'; import { IfBlock } from './visitors/IfBlock.js'; import { KeyBlock } from './visitors/KeyBlock.js'; import { LabeledStatement } from './visitors/LabeledStatement.js'; import { MemberExpression } from './visitors/MemberExpression.js'; import { PropertyDefinition } from './visitors/PropertyDefinition.js'; import { RegularElement } from './visitors/RegularElement.js'; import { RenderTag } from './visitors/RenderTag.js'; import { SlotElement } from './visitors/SlotElement.js'; import { SnippetBlock } from './visitors/SnippetBlock.js'; import { SpreadAttribute } from './visitors/SpreadAttribute.js'; import { SvelteComponent } from './visitors/SvelteComponent.js'; import { SvelteElement } from './visitors/SvelteElement.js'; import { SvelteFragment } from './visitors/SvelteFragment.js'; import { SvelteHead } from './visitors/SvelteHead.js'; import { SvelteSelf } from './visitors/SvelteSelf.js'; import { TitleElement } from './visitors/TitleElement.js'; import { UpdateExpression } from './visitors/UpdateExpression.js'; import { VariableDeclaration } from './visitors/VariableDeclaration.js'; import { SvelteBoundary } from './visitors/SvelteBoundary.js'; /** @type {Visitors} */ const global_visitors = { _: set_scope, AssignmentExpression, AwaitExpression, CallExpression, ClassBody, ExpressionStatement, Identifier, LabeledStatement, MemberExpression, PropertyDefinition, UpdateExpression, VariableDeclaration }; /** @type {ComponentVisitors} */ const template_visitors = { AwaitBlock, Component, ConstTag, DebugTag, EachBlock, Fragment, HtmlTag, IfBlock, KeyBlock, RegularElement, RenderTag, SlotElement, SnippetBlock, SpreadAttribute, SvelteComponent, SvelteElement, SvelteFragment, SvelteHead, SvelteSelf, TitleElement, SvelteBoundary }; /** * @param {ComponentAnalysis} analysis * @param {ValidatedCompileOptions} options * @returns {Program} */ export function server_component(analysis, options) { /** @type {ComponentServerTransformState} */ const state = { analysis, options, scope: analysis.module.scope, scopes: analysis.module.scopes, hoisted: [b.import_all('$', 'svelte/internal/server')], legacy_reactive_statements: new Map(), // these are set inside the `Fragment` visitor, and cannot be used until then init: /** @type {any} */ (null), template: /** @type {any} */ (null), namespace: options.namespace, preserve_whitespace: options.preserveWhitespace, state_fields: new Map(), skip_hydration_boundaries: false }; const module = /** @type {Program} */ ( walk(/** @type {AST.SvelteNode} */ (analysis.module.ast), state, global_visitors) ); const instance = /** @type {Program} */ ( walk( /** @type {AST.SvelteNode} */ (analysis.instance.ast), { ...state, scopes: analysis.instance.scopes }, { ...global_visitors, ImportDeclaration(node) { state.hoisted.push(node); return b.empty; }, ExportNamedDeclaration(node, context) { if (node.declaration) { return context.visit(node.declaration); } return b.empty; } } ) ); const template = /** @type {Program} */ ( walk( /** @type {AST.SvelteNode} */ (analysis.template.ast), { ...state, scopes: analysis.template.scopes }, // @ts-expect-error don't know, don't care { ...global_visitors, ...template_visitors } ) ); /** @type {VariableDeclarator[]} */ const legacy_reactive_declarations = []; for (const [node] of analysis.reactive_statements) { const statement = [...state.legacy_reactive_statements].find(([n]) => n === node); if (statement === undefined) { throw new Error('Could not find reactive statement'); } if ( node.body.type === 'ExpressionStatement' && node.body.expression.type === 'AssignmentExpression' ) { for (const id of extract_identifiers(node.body.expression.left)) { const binding = analysis.instance.scope.get(id.name); if (binding?.kind === 'legacy_reactive') { legacy_reactive_declarations.push(b.declarator(id)); } } } instance.body.push(statement[1]); } if (legacy_reactive_declarations.length > 0) { instance.body.unshift({ type: 'VariableDeclaration', kind: 'let', declarations: legacy_reactive_declarations }); } // If the component binds to a child, we need to put the template in a loop and repeat until legacy bindings are stable. // We can remove this once the legacy syntax is gone. if (analysis.uses_component_bindings) { const snippets = template.body.filter( // @ts-expect-error (node) => node.type === 'FunctionDeclaration' && node.___snippet ); const rest = template.body.filter( // @ts-expect-error (node) => node.type !== 'FunctionDeclaration' || !node.___snippet ); template.body = [ ...snippets, b.let('$$settled', b.true), b.let('$$inner_payload'), b.function_declaration( b.id('$$render_inner'), [b.id('$$payload')], b.block(/** @type {Statement[]} */ (rest)) ), b.do_while( b.unary('!', b.id('$$settled')), b.block([ b.stmt(b.assignment('=', b.id('$$settled'), b.true)), b.stmt( b.assignment('=', b.id('$$inner_payload'), b.call('$.copy_payload', b.id('$$payload'))) ), b.stmt(b.call('$$render_inner', b.id('$$inner_payload'))) ]) ), b.stmt(b.call('$.assign_payload', b.id('$$payload'), b.id('$$inner_payload'))) ]; } if ( [...analysis.instance.scope.declarations.values()].some( (binding) => binding.kind === 'store_sub' ) ) { instance.body.unshift(b.var('$$store_subs')); template.body.push( b.if(b.id('$$store_subs'), b.stmt(b.call('$.unsubscribe_stores', b.id('$$store_subs')))) ); } // Propagate values of bound props upwards if they're undefined in the parent and have a value. // Don't do this as part of the props retrieval because people could eagerly mutate the prop in the instance script. /** @type {Property[]} */ const props = []; for (const [name, binding] of analysis.instance.scope.declarations) { if (binding.kind === 'bindable_prop' && !name.startsWith('$$')) { props.push(b.init(binding.prop_alias ?? name, b.id(name))); } } for (const { name, alias } of analysis.exports) { props.push(b.init(alias ?? name, b.id(name))); } if (props.length > 0) { // This has no effect in runes mode other than throwing an error when someone passes // undefined to a binding that has a default value. template.body.push(b.stmt(b.call('$.bind_props', b.id('$$props'), b.object(props)))); } const component_block = b.block([ .../** @type {Statement[]} */ (instance.body), .../** @type {Statement[]} */ (template.body) ]); // trick esrap into including comments component_block.loc = instance.loc; if (analysis.props_id) { // need to be placed on first line of the component for hydration component_block.body.unshift( b.const(analysis.props_id, b.call('$.props_id', b.id('$$payload'))) ); } let should_inject_context = dev || analysis.needs_context; if (should_inject_context) { component_block.body.unshift(b.stmt(b.call('$.push', dev && b.id(analysis.name)))); component_block.body.push(b.stmt(b.call('$.pop'))); } if (analysis.uses_rest_props) { /** @type {string[]} */ const named_props = analysis.exports.map(({ name, alias }) => alias ?? name); for (const [name, binding] of analysis.instance.scope.declarations) { if (binding.kind === 'bindable_prop') named_props.push(binding.prop_alias ?? name); } component_block.body.unshift( b.const( '$$restProps', b.call( '$.rest_props', b.id('$$sanitized_props'), b.array(named_props.map((name) => b.literal(name))) ) ) ); } if (analysis.uses_props || analysis.uses_rest_props) { component_block.body.unshift( b.const('$$sanitized_props', b.call('$.sanitize_props', b.id('$$props'))) ); } if (analysis.uses_slots) { component_block.body.unshift(b.const('$$slots', b.call('$.sanitize_slots', b.id('$$props')))); } const body = [...state.hoisted, ...module.body]; if (analysis.css.ast !== null && options.css === 'injected' && !options.customElement) { const hash = b.literal(analysis.css.hash); const code = b.literal(render_stylesheet(analysis.source, analysis, options).code); body.push(b.const('$$css', b.object([b.init('hash', hash), b.init('code', code)]))); component_block.body.unshift(b.stmt(b.call('$$payload.css.add', b.id('$$css')))); } let should_inject_props = should_inject_context || props.length > 0 || analysis.needs_props || analysis.uses_props || analysis.uses_rest_props || analysis.uses_slots || analysis.slot_names.size > 0; const component_function = b.function_declaration( b.id(analysis.name), should_inject_props ? [b.id('$$payload'), b.id('$$props')] : [b.id('$$payload')], component_block ); if (options.compatibility.componentApi === 4) { body.unshift(b.imports([['render', '$$_render']], 'svelte/server')); body.push( component_function, b.stmt( b.assignment( '=', b.member_id(`${analysis.name}.render`), b.function( null, [b.id('$$props'), b.id('$$opts')], b.block([ b.return( b.call( '$$_render', b.id(analysis.name), b.object([ b.init('props', b.id('$$props')), b.init('context', b.member(b.id('$$opts'), 'context', false, true)) ]) ) ) ]) ) ) ), b.export_default(b.id(analysis.name)) ); } else if (dev) { body.push( component_function, b.stmt( b.assignment( '=', b.member_id(`${analysis.name}.render`), b.function( null, [], b.block([ b.throw_error( `Component.render(...) is no longer valid in Svelte 5. ` + 'See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information' ) ]) ) ) ), b.export_default(b.id(analysis.name)) ); } else { body.push(b.export_default(component_function)); } if (dev) { // add `App[$.FILENAME] = 'App.svelte'` so that we can print useful messages later body.unshift( b.stmt( b.assignment('=', b.member(b.id(analysis.name), '$.FILENAME', true), b.literal(filename)) ) ); } return { type: 'Program', sourceType: 'module', body }; } /** * @param {Analysis} analysis * @param {ValidatedModuleCompileOptions} options * @returns {Program} */ export function server_module(analysis, options) { /** @type {ServerTransformState} */ const state = { analysis, options, scope: analysis.module.scope, scopes: analysis.module.scopes, // this is an anomaly — it can only be used in components, but it needs // to be present for `javascript_visitors_legacy` and so is included in module // transform state as well as component transform state legacy_reactive_statements: new Map(), state_fields: new Map() }; const module = /** @type {Program} */ ( walk(/** @type {AST.SvelteNode} */ (analysis.module.ast), state, global_visitors) ); return { type: 'Program', sourceType: 'module', body: [b.import_all('$', 'svelte/internal/server'), ...module.body] }; }
```

# compiler/phases/3-transform/server/types.d.ts

```ts
import type { Expression, Statement, ModuleDeclaration, LabeledStatement } from 'estree'; import type { AST, Namespace, ValidatedCompileOptions } from '#compiler'; import type { TransformState } from '../types.js'; import type { ComponentAnalysis } from '../../types.js'; export interface ServerTransformState extends TransformState { /** The $: calls, which will be ordered in the end */ readonly legacy_reactive_statements: Map<LabeledStatement, Statement>; } export interface ComponentServerTransformState extends ServerTransformState { readonly analysis: ComponentAnalysis; readonly options: ValidatedCompileOptions; readonly init: Statement[]; readonly hoisted: Array<Statement | ModuleDeclaration>; /** The SSR template */ readonly template: Array<Statement | Expression>; readonly namespace: Namespace; readonly preserve_whitespace: boolean; readonly skip_hydration_boundaries: boolean; } export type Context = import('zimmerframe').Context<AST.SvelteNode, ServerTransformState>; export type Visitors = import('zimmerframe').Visitors<AST.SvelteNode, ServerTransformState>; export type ComponentContext = import('zimmerframe').Context< AST.SvelteNode, ComponentServerTransformState >; export type ComponentVisitors = import('zimmerframe').Visitors< AST.SvelteNode, ComponentServerTransformState >;
```

# compiler/phases/3-transform/server/visitors/AssignmentExpression.js

```js
/** @import { AssignmentExpression, AssignmentOperator, Expression, Pattern } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { Context, ServerTransformState } from '../types.js' */ import * as b from '#compiler/builders'; import { build_assignment_value } from '../../../../utils/ast.js'; import { get_name } from '../../../nodes.js'; import { get_rune } from '../../../scope.js'; import { visit_assignment_expression } from '../../shared/assignments.js'; /** * @param {AssignmentExpression} node * @param {Context} context */ export function AssignmentExpression(node, context) { return visit_assignment_expression(node, context, build_assignment) ?? context.next(); } /** * Only returns an expression if this is not a `$store` assignment, as others can be kept as-is * @param {AssignmentOperator} operator * @param {Pattern} left * @param {Expression} right * @param {import('zimmerframe').Context<AST.SvelteNode, ServerTransformState>} context * @returns {Expression | null} */ function build_assignment(operator, left, right, context) { if ( context.state.analysis.runes && left.type === 'MemberExpression' && left.object.type === 'ThisExpression' && !left.computed ) { const name = get_name(left.property); const field = name && context.state.state_fields.get(name); // special case — state declaration in class constructor if (field && field.node.type === 'AssignmentExpression' && left === field.node.left) { const rune = get_rune(right, context.state.scope); if (rune) { const key = left.property.type === 'PrivateIdentifier' || rune === '$state' || rune === '$state.raw' ? left.property : field.key; return b.assignment( operator, b.member(b.this, key, key.type === 'Literal'), /** @type {Expression} */ (context.visit(right)) ); } } else if ( field && (field.type === '$derived' || field.type === '$derived.by') && left.property.type === 'PrivateIdentifier' ) { let value = /** @type {Expression} */ ( context.visit(build_assignment_value(operator, left, right)) ); return b.call(b.member(b.this, name), value); } } let object = left; while (object.type === 'MemberExpression') { // @ts-expect-error object = object.object; } if (object.type !== 'Identifier' || !is_store_name(object.name)) { return null; } const name = object.name.slice(1); if (!context.state.scope.get(name)) { return null; } if (object === left) { let value = /** @type {Expression} */ ( context.visit(build_assignment_value(operator, left, right)) ); return b.call('$.store_set', b.id(name), value); } return b.call( '$.store_mutate', b.assignment('??=', b.id('$$store_subs'), b.object([])), b.literal(object.name), b.id(name), b.assignment( operator, /** @type {Pattern} */ (context.visit(left)), /** @type {Expression} */ (context.visit(right)) ) ); } /** * @param {string} name */ function is_store_name(name) { return name[0] === '$' && /[A-Za-z_]/.test(name[1]); }
```

# compiler/phases/3-transform/server/visitors/AwaitBlock.js

```js
/** @import { BlockStatement, Expression, Pattern } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types.js' */ import * as b from '#compiler/builders'; import { block_close } from './shared/utils.js'; /** * @param {AST.AwaitBlock} node * @param {ComponentContext} context */ export function AwaitBlock(node, context) { context.state.template.push( b.stmt( b.call( '$.await', b.id('$$payload'), /** @type {Expression} */ (context.visit(node.expression)), b.thunk( node.pending ? /** @type {BlockStatement} */ (context.visit(node.pending)) : b.block([]) ), b.arrow( node.value ? [/** @type {Pattern} */ (context.visit(node.value))] : [], node.then ? /** @type {BlockStatement} */ (context.visit(node.then)) : b.block([]) ) ) ), block_close ); }
```

# compiler/phases/3-transform/server/visitors/AwaitExpression.js

```js
/** @import { AwaitExpression } from 'estree' */ /** @import { Context } from '../types.js' */ import * as b from '../../../../utils/builders.js'; /** * @param {AwaitExpression} node * @param {Context} context */ export function AwaitExpression(node, context) { // if `await` is inside a function, or inside `<script module>`, // allow it, otherwise error if ( context.state.scope.function_depth === 0 || context.path.some( (node) => node.type === 'ArrowFunctionExpression' || node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' ) ) { return context.next(); } return b.call('$.await_outside_boundary'); }
```

# compiler/phases/3-transform/server/visitors/CallExpression.js

```js
/** @import { CallExpression, Expression } from 'estree' */ /** @import { Context } from '../types.js' */ import { is_ignored } from '../../../../state.js'; import * as b from '#compiler/builders'; import { get_rune } from '../../../scope.js'; import { transform_inspect_rune } from '../../utils.js'; /** * @param {CallExpression} node * @param {Context} context */ export function CallExpression(node, context) { const rune = get_rune(node, context.state.scope); if (rune === '$host') { return b.void0; } if (rune === '$effect.tracking') { return b.false; } if (rune === '$effect.root') { // ignore $effect.root() calls, just return a noop which mimics the cleanup function return b.arrow([], b.block([])); } if (rune === '$effect.pending') { return b.literal(0); } if (rune === '$state' || rune === '$state.raw') { return node.arguments[0] ? context.visit(node.arguments[0]) : b.void0; } if (rune === '$derived' || rune === '$derived.by') { const fn = /** @type {Expression} */ (context.visit(node.arguments[0])); return b.call('$.derived', rune === '$derived' ? b.thunk(fn) : fn); } if (rune === '$state.snapshot') { return b.call( '$.snapshot', /** @type {Expression} */ (context.visit(node.arguments[0])), is_ignored(node, 'state_snapshot_uncloneable') && b.true ); } if (rune === '$inspect' || rune === '$inspect().with') { return transform_inspect_rune(node, context); } context.next(); }
```

# compiler/phases/3-transform/server/visitors/ClassBody.js

```js
/** @import { CallExpression, ClassBody, MethodDefinition, PropertyDefinition, StaticBlock } from 'estree' */ /** @import { Context } from '../types.js' */ import * as b from '#compiler/builders'; import { get_name } from '../../../nodes.js'; /** * @param {ClassBody} node * @param {Context} context */ export function ClassBody(node, context) { const state_fields = context.state.analysis.classes.get(node); if (!state_fields) { // in legacy mode, do nothing context.next(); return; } /** @type {Array<MethodDefinition | PropertyDefinition | StaticBlock>} */ const body = []; const child_state = { ...context.state, state_fields }; for (const [name, field] of state_fields) { if (name[0] === '#') { continue; } // insert backing fields for stuff declared in the constructor if ( field && field.node.type === 'AssignmentExpression' && (field.type === '$derived' || field.type === '$derived.by') ) { const member = b.member(b.this, field.key); body.push( b.prop_def(field.key, null), b.method('get', b.key(name), [], [b.return(b.call(member))]), b.method('set', b.key(name), [b.id('$$value')], [b.return(b.call(member, b.id('$$value')))]) ); } } // Replace parts of the class body for (const definition of node.body) { if (definition.type !== 'PropertyDefinition') { body.push( /** @type {MethodDefinition | StaticBlock} */ (context.visit(definition, child_state)) ); continue; } const name = get_name(definition.key); const field = name && state_fields.get(name); if (!field) { body.push(/** @type {PropertyDefinition} */ (context.visit(definition, child_state))); continue; } if (name[0] === '#' || field.type === '$state' || field.type === '$state.raw') { body.push(/** @type {PropertyDefinition} */ (context.visit(definition, child_state))); } else if (field.node === definition) { // $derived / $derived.by const member = b.member(b.this, field.key); body.push( b.prop_def( field.key, /** @type {CallExpression} */ (context.visit(field.value, child_state)) ), b.method('get', definition.key, [], [b.return(b.call(member))]), b.method('set', b.key(name), [b.id('$$value')], [b.return(b.call(member, b.id('$$value')))]) ); } } return { ...node, body }; }
```

# compiler/phases/3-transform/server/visitors/Component.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types.js' */ import * as b from '#compiler/builders'; import { build_inline_component } from './shared/component.js'; /** * @param {AST.Component} node * @param {ComponentContext} context */ export function Component(node, context) { build_inline_component(node, b.id(node.name), context); }
```

# compiler/phases/3-transform/server/visitors/ConstTag.js

```js
/** @import { Expression, Pattern } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types.js' */ import * as b from '#compiler/builders'; /** * @param {AST.ConstTag} node * @param {ComponentContext} context */ export function ConstTag(node, context) { const declaration = node.declaration.declarations[0]; const id = /** @type {Pattern} */ (context.visit(declaration.id)); const init = /** @type {Expression} */ (context.visit(declaration.init)); context.state.init.push(b.const(id, init)); }
```

# compiler/phases/3-transform/server/visitors/DebugTag.js

```js
/** @import { Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types.js' */ import * as b from '#compiler/builders'; /** * @param {AST.DebugTag} node * @param {ComponentContext} context */ export function DebugTag(node, context) { context.state.template.push( b.stmt( b.call( 'console.log', b.object( node.identifiers.map((identifier) => b.prop('init', identifier, /** @type {Expression} */ (context.visit(identifier))) ) ) ) ), b.debugger ); }
```

# compiler/phases/3-transform/server/visitors/EachBlock.js

```js
/** @import { BlockStatement, Expression, Statement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types.js' */ import { BLOCK_OPEN_ELSE } from '../../../../../internal/server/hydration.js'; import * as b from '#compiler/builders'; import { block_close, block_open } from './shared/utils.js'; /** * @param {AST.EachBlock} node * @param {ComponentContext} context */ export function EachBlock(node, context) { const state = context.state; const each_node_meta = node.metadata; const collection = /** @type {Expression} */ (context.visit(node.expression)); const index = each_node_meta.contains_group_binding || !node.index ? each_node_meta.index : b.id(node.index); const array_id = state.scope.root.unique('each_array'); state.init.push(b.const(array_id, b.call('$.ensure_array_like', collection))); /** @type {Statement[]} */ const each = []; if (node.context) { each.push(b.let(node.context, b.member(array_id, index, true))); } if (index.name !== node.index && node.index != null) { each.push(b.let(node.index, index)); } each.push(.../** @type {BlockStatement} */ (context.visit(node.body)).body); const for_loop = b.for( b.declaration('let', [ b.declarator(index, b.literal(0)), b.declarator('$$length', b.member(array_id, 'length')) ]), b.binary('<', index, b.id('$$length')), b.update('++', index, false), b.block(each) ); if (node.fallback) { const open = b.stmt(b.assignment('+=', b.id('$$payload.out'), block_open)); const fallback = /** @type {BlockStatement} */ (context.visit(node.fallback)); fallback.body.unshift( b.stmt(b.assignment('+=', b.id('$$payload.out'), b.literal(BLOCK_OPEN_ELSE))) ); state.template.push( b.if( b.binary('!==', b.member(array_id, 'length'), b.literal(0)), b.block([open, for_loop]), fallback ), block_close ); } else { state.template.push(block_open, for_loop, block_close); } }
```

# compiler/phases/3-transform/server/visitors/ExpressionStatement.js

```js
/** @import { ExpressionStatement } from 'estree' */ /** @import { Context } from '../types.js' */ import * as b from '#compiler/builders'; import { get_rune } from '../../../scope.js'; /** * @param {ExpressionStatement} node * @param {Context} context */ export function ExpressionStatement(node, context) { const rune = get_rune(node.expression, context.state.scope); if ( rune === '$effect' || rune === '$effect.pre' || rune === '$effect.root' || rune === '$inspect.trace' ) { return b.empty; } context.next(); }
```

# compiler/phases/3-transform/server/visitors/Fragment.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext, ComponentServerTransformState } from '../types.js' */ import { clean_nodes, infer_namespace } from '../../utils.js'; import * as b from '#compiler/builders'; import { empty_comment, process_children, build_template } from './shared/utils.js'; /** * @param {AST.Fragment} node * @param {ComponentContext} context */ export function Fragment(node, context) { const parent = context.path.at(-1) ?? node; const namespace = infer_namespace(context.state.namespace, parent, node.nodes); const { hoisted, trimmed, is_standalone, is_text_first } = clean_nodes( parent, node.nodes, context.path, namespace, context.state, context.state.preserve_whitespace, context.state.options.preserveComments ); /** @type {ComponentServerTransformState} */ const state = { ...context.state, init: [], template: [], namespace, skip_hydration_boundaries: is_standalone }; for (const node of hoisted) { context.visit(node, state); } if (is_text_first) { // insert `<!---->` to prevent this from being glued to the previous fragment state.template.push(empty_comment); } process_children(trimmed, { ...context, state }); return b.block([...state.init, ...build_template(state.template)]); }
```

# compiler/phases/3-transform/server/visitors/HtmlTag.js

```js
/** @import { Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types.js' */ import * as b from '#compiler/builders'; /** * @param {AST.HtmlTag} node * @param {ComponentContext} context */ export function HtmlTag(node, context) { const expression = /** @type {Expression} */ (context.visit(node.expression)); context.state.template.push(b.call('$.html', expression)); }
```

# compiler/phases/3-transform/server/visitors/Identifier.js

```js
/** @import { Identifier, Node } from 'estree' */ /** @import { Context } from '../types.js' */ import is_reference from 'is-reference'; import * as b from '#compiler/builders'; import { build_getter } from './shared/utils.js'; /** * @param {Identifier} node * @param {Context} context */ export function Identifier(node, context) { if (is_reference(node, /** @type {Node} */ (context.path.at(-1)))) { if (node.name === '$$props') { return b.id('$$sanitized_props'); } return build_getter(node, context.state); } }
```

# compiler/phases/3-transform/server/visitors/IfBlock.js

```js
/** @import { BlockStatement, Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types.js' */ import { BLOCK_OPEN_ELSE } from '../../../../../internal/server/hydration.js'; import * as b from '#compiler/builders'; import { block_close, block_open } from './shared/utils.js'; /** * @param {AST.IfBlock} node * @param {ComponentContext} context */ export function IfBlock(node, context) { const test = /** @type {Expression} */ (context.visit(node.test)); const consequent = /** @type {BlockStatement} */ (context.visit(node.consequent)); const alternate = node.alternate ? /** @type {BlockStatement} */ (context.visit(node.alternate)) : b.block([]); consequent.body.unshift(b.stmt(b.assignment('+=', b.id('$$payload.out'), block_open))); alternate.body.unshift( b.stmt(b.assignment('+=', b.id('$$payload.out'), b.literal(BLOCK_OPEN_ELSE))) ); context.state.template.push(b.if(test, consequent, alternate), block_close); }
```

# compiler/phases/3-transform/server/visitors/KeyBlock.js

```js
/** @import { BlockStatement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types.js' */ import { empty_comment } from './shared/utils.js'; /** * @param {AST.KeyBlock} node * @param {ComponentContext} context */ export function KeyBlock(node, context) { context.state.template.push( empty_comment, /** @type {BlockStatement} */ (context.visit(node.fragment)), empty_comment ); }
```

# compiler/phases/3-transform/server/visitors/LabeledStatement.js

```js
/** @import { ExpressionStatement, LabeledStatement } from 'estree' */ /** @import { Context } from '../types.js' */ import * as b from '#compiler/builders'; /** * @param {LabeledStatement} node * @param {Context} context */ export function LabeledStatement(node, context) { if (context.state.analysis.runes || context.path.length > 1 || node.label.name !== '$') { return; } // TODO bail out if we're in module context // these statements will be topologically ordered later context.state.legacy_reactive_statements.set( node, // people could do "break $" inside, so we need to keep the label b.labeled('$', /** @type {ExpressionStatement} */ (context.visit(node.body))) ); return b.empty; }
```

# compiler/phases/3-transform/server/visitors/MemberExpression.js

```js
/** @import { ClassBody, MemberExpression } from 'estree' */ /** @import { Context } from '../types.js' */ import * as b from '#compiler/builders'; /** * @param {MemberExpression} node * @param {Context} context */ export function MemberExpression(node, context) { if ( context.state.analysis.runes && node.object.type === 'ThisExpression' && node.property.type === 'PrivateIdentifier' ) { const field = context.state.state_fields?.get(`#${node.property.name}`); if (field?.type === '$derived' || field?.type === '$derived.by') { return b.call(node); } } context.next(); }
```

# compiler/phases/3-transform/server/visitors/PropertyDefinition.js

```js
/** @import { Expression, PropertyDefinition } from 'estree' */ /** @import { Context } from '../types.js' */ import * as b from '#compiler/builders'; import { get_rune } from '../../../scope.js'; /** * @param {PropertyDefinition} node * @param {Context} context */ export function PropertyDefinition(node, context) { if (context.state.analysis.runes && node.value != null && node.value.type === 'CallExpression') { const rune = get_rune(node.value, context.state.scope); if (rune === '$state' || rune === '$state.raw') { return { ...node, value: node.value.arguments.length === 0 ? null : /** @type {Expression} */ (context.visit(node.value.arguments[0])) }; } if (rune === '$derived.by' || rune === '$derived') { const fn = /** @type {Expression} */ (context.visit(node.value.arguments[0])); return { ...node, value: node.value.arguments.length === 0 ? null : b.call('$.derived', rune === '$derived' ? b.thunk(fn) : fn) }; } } context.next(); }
```

# compiler/phases/3-transform/server/visitors/RegularElement.js

```js
/** @import { Expression } from 'estree' */ /** @import { Location } from 'locate-character' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext, ComponentServerTransformState } from '../types.js' */ /** @import { Scope } from '../../../scope.js' */ import { is_void } from '../../../../../utils.js'; import { dev, locator } from '../../../../state.js'; import * as b from '#compiler/builders'; import { clean_nodes, determine_namespace_for_children } from '../../utils.js'; import { build_element_attributes, build_spread_object } from './shared/element.js'; import { process_children, build_template, build_attribute_value } from './shared/utils.js'; /** * @param {AST.RegularElement} node * @param {ComponentContext} context */ export function RegularElement(node, context) { const namespace = determine_namespace_for_children(node, context.state.namespace); /** @type {ComponentServerTransformState} */ const state = { ...context.state, namespace, preserve_whitespace: context.state.preserve_whitespace || node.name === 'pre' || node.name === 'textarea' }; const node_is_void = is_void(node.name); context.state.template.push(b.literal(`<${node.name}`)); const body = build_element_attributes(node, { ...context, state }); context.state.template.push(b.literal(node_is_void ? '/>' : '>')); // add `/>` for XHTML compliance if ((node.name === 'script' || node.name === 'style') && node.fragment.nodes.length === 1) { context.state.template.push( b.literal(/** @type {AST.Text} */ (node.fragment.nodes[0]).data), b.literal(`</${node.name}>`) ); return; } const { hoisted, trimmed } = clean_nodes( node, node.fragment.nodes, context.path, namespace, { ...state, scope: /** @type {Scope} */ (state.scopes.get(node.fragment)) }, state.preserve_whitespace, state.options.preserveComments ); for (const node of hoisted) { context.visit(node, state); } if (dev) { const location = /** @type {Location} */ (locator(node.start)); state.template.push( b.stmt( b.call( '$.push_element', b.id('$$payload'), b.literal(node.name), b.literal(location.line), b.literal(location.column) ) ) ); } let select_with_value = false; if (node.name === 'select') { const value = node.attributes.find( (attribute) => (attribute.type === 'Attribute' || attribute.type === 'BindDirective') && attribute.name === 'value' ); if (node.attributes.some((attribute) => attribute.type === 'SpreadAttribute')) { select_with_value = true; state.template.push( b.stmt( b.assignment( '=', b.id('$$payload.select_value'), b.member( build_spread_object( node, node.attributes.filter( (attribute) => attribute.type === 'Attribute' || attribute.type === 'BindDirective' || attribute.type === 'SpreadAttribute' ), context ), 'value', false, true ) ) ) ); } else if (value) { select_with_value = true; const left = b.id('$$payload.select_value'); if (value.type === 'Attribute') { state.template.push( b.stmt(b.assignment('=', left, build_attribute_value(value.value, context))) ); } else if (value.type === 'BindDirective') { state.template.push( b.stmt( b.assignment( '=', left, value.expression.type === 'SequenceExpression' ? /** @type {Expression} */ (context.visit(b.call(value.expression.expressions[0]))) : /** @type {Expression} */ (context.visit(value.expression)) ) ) ); } } } if ( node.name === 'option' && !node.attributes.some( (attribute) => attribute.type === 'SpreadAttribute' || ((attribute.type === 'Attribute' || attribute.type === 'BindDirective') && attribute.name === 'value') ) ) { const inner_state = { ...state, template: [], init: [] }; process_children(trimmed, { ...context, state: inner_state }); state.template.push( b.stmt( b.call( '$.valueless_option', b.id('$$payload'), b.thunk(b.block([...inner_state.init, ...build_template(inner_state.template)])) ) ) ); } else if (body !== null) { // if this is a `<textarea>` value or a contenteditable binding, we only add // the body if the attribute/binding is falsy const inner_state = { ...state, template: [], init: [] }; process_children(trimmed, { ...context, state: inner_state }); let id = /** @type {Expression} */ (body); if (body.type !== 'Identifier') { id = b.id(state.scope.generate('$$body')); state.template.push(b.const(id, body)); } // Use the body expression as the body if it's truthy, otherwise use the inner template state.template.push( b.if( id, b.block(build_template([id])), b.block([...inner_state.init, ...build_template(inner_state.template)]) ) ); } else { process_children(trimmed, { ...context, state }); } if (select_with_value) { state.template.push(b.stmt(b.assignment('=', b.id('$$payload.select_value'), b.void0))); } if (!node_is_void) { state.template.push(b.literal(`</${node.name}>`)); } if (dev) { state.template.push(b.stmt(b.call('$.pop_element'))); } }
```

# compiler/phases/3-transform/server/visitors/RenderTag.js

```js
/** @import { Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types.js' */ import { unwrap_optional } from '../../../../utils/ast.js'; import * as b from '#compiler/builders'; import { empty_comment } from './shared/utils.js'; /** * @param {AST.RenderTag} node * @param {ComponentContext} context */ export function RenderTag(node, context) { const callee = unwrap_optional(node.expression).callee; const raw_args = unwrap_optional(node.expression).arguments; const snippet_function = /** @type {Expression} */ (context.visit(callee)); const snippet_args = raw_args.map((arg) => { return /** @type {Expression} */ (context.visit(arg)); }); context.state.template.push( b.stmt( (node.expression.type === 'CallExpression' ? b.call : b.maybe_call)( snippet_function, b.id('$$payload'), ...snippet_args ) ) ); if (!context.state.skip_hydration_boundaries) { context.state.template.push(empty_comment); } }
```

# compiler/phases/3-transform/server/visitors/shared/component.js

```js
/** @import { BlockStatement, Expression, Pattern, Property, SequenceExpression, Statement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../../types.js' */ import { empty_comment, build_attribute_value } from './utils.js'; import * as b from '#compiler/builders'; import { is_element_node } from '../../../../nodes.js'; import { dev } from '../../../../../state.js'; /** * @param {AST.Component | AST.SvelteComponent | AST.SvelteSelf} node * @param {Expression} expression * @param {ComponentContext} context */ export function build_inline_component(node, expression, context) { /** @type {Array<Property[] | Expression>} */ const props_and_spreads = []; /** @type {Array<() => void>} */ const delayed_props = []; /** @type {Property[]} */ const custom_css_props = []; /** @type {Record<string, AST.LetDirective[]>} */ const lets = { default: [] }; /** * Children in the default slot are evaluated in the component scope, * children in named slots are evaluated in the parent scope */ const child_state = { ...context.state, scope: node.metadata.scopes.default }; /** @type {Record<string, AST.TemplateNode[]>} */ const children = {}; /** * If this component has a slot property, it is a named slot within another component. In this case * the slot scope applies to the component itself, too, and not just its children. */ const slot_scope_applies_to_itself = node.attributes.some( (node) => node.type === 'Attribute' && node.name === 'slot' ); /** * Components may have a children prop and also have child nodes. In this case, we assume * that the child component isn't using render tags yet and pass the slot as $$slots.default. * We're not doing it for spread attributes, as this would result in too many false positives. */ let has_children_prop = false; /** * @param {Property} prop * @param {boolean} [delay] */ function push_prop(prop, delay = false) { const do_push = () => { const current = props_and_spreads.at(-1); const current_is_props = Array.isArray(current); const props = current_is_props ? current : []; props.push(prop); if (!current_is_props) { props_and_spreads.push(props); } }; if (delay) { delayed_props.push(do_push); } else { do_push(); } } for (const attribute of node.attributes) { if (attribute.type === 'LetDirective') { if (!slot_scope_applies_to_itself) { lets.default.push(attribute); } } else if (attribute.type === 'SpreadAttribute') { props_and_spreads.push(/** @type {Expression} */ (context.visit(attribute))); } else if (attribute.type === 'Attribute') { if (attribute.name.startsWith('--')) { const value = build_attribute_value(attribute.value, context, false, true); custom_css_props.push(b.init(attribute.name, value)); continue; } if (attribute.name === 'children') { has_children_prop = true; } const value = build_attribute_value(attribute.value, context, false, true); push_prop(b.prop('init', b.key(attribute.name), value)); } else if (attribute.type === 'BindDirective' && attribute.name !== 'this') { if (attribute.expression.type === 'SequenceExpression') { const [get, set] = /** @type {SequenceExpression} */ (context.visit(attribute.expression)) .expressions; const get_id = b.id(context.state.scope.generate('bind_get')); const set_id = b.id(context.state.scope.generate('bind_set')); context.state.init.push(b.var(get_id, get)); context.state.init.push(b.var(set_id, set)); push_prop(b.get(attribute.name, [b.return(b.call(get_id))])); push_prop(b.set(attribute.name, [b.stmt(b.call(set_id, b.id('$$value')))])); } else { // Delay prop pushes so bindings come at the end, to avoid spreads overwriting them push_prop( b.get(attribute.name, [ b.return(/** @type {Expression} */ (context.visit(attribute.expression))) ]), true ); push_prop( b.set(attribute.name, [ b.stmt( /** @type {Expression} */ ( context.visit(b.assignment('=', attribute.expression, b.id('$$value'))) ) ), b.stmt(b.assignment('=', b.id('$$settled'), b.false)) ]), true ); } } } delayed_props.forEach((fn) => fn()); /** @type {Statement[]} */ const snippet_declarations = []; /** @type {Property[]} */ const serialized_slots = []; // Group children by slot for (const child of node.fragment.nodes) { if (child.type === 'SnippetBlock') { // the SnippetBlock visitor adds a declaration to `init`, but if it's directly // inside a component then we want to hoist them into a block so that they // can be used as props without creating conflicts context.visit(child, { ...context.state, init: snippet_declarations }); push_prop(b.prop('init', child.expression, child.expression)); // Interop: allows people to pass snippets when component still uses slots serialized_slots.push( b.init(child.expression.name === 'children' ? 'default' : child.expression.name, b.true) ); continue; } let slot_name = 'default'; if (is_element_node(child)) { const slot = /** @type {AST.Attribute | undefined} */ ( child.attributes.find( (attribute) => attribute.type === 'Attribute' && attribute.name === 'slot' ) ); if (slot !== undefined) { slot_name = /** @type {AST.Text[]} */ (slot.value)[0].data; lets[slot_name] = child.attributes.filter((attribute) => attribute.type === 'LetDirective'); } else if (child.type === 'SvelteFragment') { lets.default.push( ...child.attributes.filter((attribute) => attribute.type === 'LetDirective') ); } } children[slot_name] = children[slot_name] || []; children[slot_name].push(child); } // Serialize each slot for (const slot_name of Object.keys(children)) { const block = /** @type {BlockStatement} */ ( context.visit( { ...node.fragment, // @ts-expect-error nodes: children[slot_name] }, slot_name === 'default' ? child_state : { ...context.state, scope: node.metadata.scopes[slot_name] } ) ); if (block.body.length === 0) continue; /** @type {Pattern[]} */ const params = [b.id('$$payload')]; if (lets[slot_name].length > 0) { const pattern = b.object_pattern( lets[slot_name].map((node) => { if (node.expression === null) { return b.init(node.name, b.id(node.name)); } if (node.expression.type === 'ObjectExpression') { // @ts-expect-error it gets parsed as an `ObjectExpression` but is really an `ObjectPattern` return b.init(node.name, b.object_pattern(node.expression.properties)); } if (node.expression.type === 'ArrayExpression') { // @ts-expect-error it gets parsed as an `ArrayExpression` but is really an `ArrayPattern` return b.init(node.name, b.array_pattern(node.expression.elements)); } return b.init(node.name, node.expression); }) ); params.push(pattern); } const slot_fn = b.arrow(params, b.block(block.body)); if (slot_name === 'default' && !has_children_prop) { if ( lets.default.length === 0 && children.default.every( (node) => node.type !== 'SvelteFragment' || !node.attributes.some((attr) => attr.type === 'LetDirective') ) ) { // create `children` prop... push_prop( b.prop( 'init', b.id('children'), dev ? b.call('$.prevent_snippet_stringification', slot_fn) : slot_fn ) ); // and `$$slots.default: true` so that `<slot>` on the child works serialized_slots.push(b.init(slot_name, b.true)); } else { // create `$$slots.default`... serialized_slots.push(b.init(slot_name, slot_fn)); // and a `children` prop that errors push_prop(b.init('children', b.id('$.invalid_default_snippet'))); } } else { serialized_slots.push(b.init(slot_name, slot_fn)); } } if (serialized_slots.length > 0) { push_prop(b.prop('init', b.id('$$slots'), b.object(serialized_slots))); } const props_expression = props_and_spreads.length === 0 || (props_and_spreads.length === 1 && Array.isArray(props_and_spreads[0])) ? b.object(/** @type {Property[]} */ (props_and_spreads[0] || [])) : b.call( '$.spread_props', b.array(props_and_spreads.map((p) => (Array.isArray(p) ? b.object(p) : p))) ); /** @type {Statement} */ let statement = b.stmt( (node.type === 'SvelteComponent' ? b.maybe_call : b.call)( expression, b.id('$$payload'), props_expression ) ); if (snippet_declarations.length > 0) { statement = b.block([...snippet_declarations, statement]); } const dynamic = node.type === 'SvelteComponent' || (node.type === 'Component' && node.metadata.dynamic); if (custom_css_props.length > 0) { context.state.template.push( b.stmt( b.call( '$.css_props', b.id('$$payload'), b.literal(context.state.namespace === 'svg' ? false : true), b.object(custom_css_props), b.thunk(b.block([statement])), dynamic && b.true ) ) ); } else { if (dynamic) { context.state.template.push(empty_comment); } context.state.template.push(statement); if (!context.state.skip_hydration_boundaries) { context.state.template.push(empty_comment); } } }
```

# compiler/phases/3-transform/server/visitors/shared/element.js

```js
/** @import { ArrayExpression, Expression, Literal, ObjectExpression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext, ComponentServerTransformState } from '../../types.js' */ import { is_event_attribute, is_text_attribute } from '../../../../../utils/ast.js'; import { binding_properties } from '../../../../bindings.js'; import { create_attribute, create_expression_metadata, is_custom_element_node } from '../../../../nodes.js'; import { regex_starts_with_newline } from '../../../../patterns.js'; import * as b from '#compiler/builders'; import { ELEMENT_IS_NAMESPACED, ELEMENT_PRESERVE_ATTRIBUTE_CASE } from '../../../../../../constants.js'; import { build_attribute_value } from './utils.js'; import { is_boolean_attribute, is_content_editable_binding, is_load_error_element } from '../../../../../../utils.js'; import { escape_html } from '../../../../../../escaping.js'; const WHITESPACE_INSENSITIVE_ATTRIBUTES = ['class', 'style']; /** * Writes the output to the template output. Some elements may have attributes on them that require the * their output to be the child content instead. In this case, an object is returned. * @param {AST.RegularElement | AST.SvelteElement} node * @param {import('zimmerframe').Context<AST.SvelteNode, ComponentServerTransformState>} context */ export function build_element_attributes(node, context) { /** @type {Array<AST.Attribute | AST.SpreadAttribute>} */ const attributes = []; /** @type {AST.ClassDirective[]} */ const class_directives = []; /** @type {AST.StyleDirective[]} */ const style_directives = []; /** @type {Expression | null} */ let content = null; let has_spread = false; let events_to_capture = new Set(); for (const attribute of node.attributes) { if (attribute.type === 'Attribute') { if (attribute.name === 'value') { if (node.name === 'textarea') { if ( attribute.value !== true && Array.isArray(attribute.value) && attribute.value[0].type === 'Text' && regex_starts_with_newline.test(attribute.value[0].data) ) { // Two or more leading newlines are required to restore the leading newline immediately after `<textarea>`. // see https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions // also see related code in analysis phase attribute.value[0].data = '\n' + attribute.value[0].data; } content = b.call('$.escape', build_attribute_value(attribute.value, context)); } else if (node.name !== 'select') { // omit value attribute for select elements, it's irrelevant for the initially selected value and has no // effect on the selected value after the user interacts with the select element (the value _property_ does, but not the attribute) attributes.push(attribute); } // omit event handlers except for special cases } else if (is_event_attribute(attribute)) { if ( (attribute.name === 'onload' || attribute.name === 'onerror') && is_load_error_element(node.name) ) { events_to_capture.add(attribute.name); } // the defaultValue/defaultChecked properties don't exist as attributes } else if (attribute.name !== 'defaultValue' && attribute.name !== 'defaultChecked') { if (attribute.name === 'class') { if (attribute.metadata.needs_clsx) { attributes.push({ ...attribute, value: { .../** @type {AST.ExpressionTag} */ (attribute.value), expression: b.call( '$.clsx', /** @type {AST.ExpressionTag} */ (attribute.value).expression ) } }); } else { attributes.push(attribute); } } else { attributes.push(attribute); } } } else if (attribute.type === 'BindDirective') { if (attribute.name === 'value' && node.name === 'select') continue; if ( attribute.name === 'value' && attributes.some( (attr) => attr.type === 'Attribute' && attr.name === 'type' && is_text_attribute(attr) && attr.value[0].data === 'file' ) ) { continue; } if (attribute.name === 'this') continue; const binding = binding_properties[attribute.name]; if (binding?.omit_in_ssr) continue; let expression = /** @type {Expression} */ (context.visit(attribute.expression)); if (expression.type === 'SequenceExpression') { expression = b.call(expression.expressions[0]); } if (is_content_editable_binding(attribute.name)) { content = expression; } else if (attribute.name === 'value' && node.name === 'textarea') { content = b.call('$.escape', expression); } else if (attribute.name === 'group' && attribute.expression.type !== 'SequenceExpression') { const value_attribute = /** @type {AST.Attribute | undefined} */ ( node.attributes.find((attr) => attr.type === 'Attribute' && attr.name === 'value') ); if (!value_attribute) continue; const is_checkbox = node.attributes.some( (attr) => attr.type === 'Attribute' && attr.name === 'type' && is_text_attribute(attr) && attr.value[0].data === 'checkbox' ); attributes.push( create_attribute('checked', -1, -1, [ { type: 'ExpressionTag', start: -1, end: -1, expression: is_checkbox ? b.call( b.member(attribute.expression, 'includes'), build_attribute_value(value_attribute.value, context) ) : b.binary( '===', attribute.expression, build_attribute_value(value_attribute.value, context) ), metadata: { expression: create_expression_metadata() } } ]) ); } else { attributes.push( create_attribute(attribute.name, -1, -1, [ { type: 'ExpressionTag', start: -1, end: -1, expression, metadata: { expression: create_expression_metadata() } } ]) ); } } else if (attribute.type === 'SpreadAttribute') { attributes.push(attribute); has_spread = true; if (is_load_error_element(node.name)) { events_to_capture.add('onload'); events_to_capture.add('onerror'); } } else if (attribute.type === 'UseDirective') { if (is_load_error_element(node.name)) { events_to_capture.add('onload'); events_to_capture.add('onerror'); } } else if (attribute.type === 'ClassDirective') { class_directives.push(attribute); } else if (attribute.type === 'StyleDirective') { style_directives.push(attribute); } else if (attribute.type === 'LetDirective') { // do nothing, these are handled inside `build_inline_component` } else { context.visit(attribute); } } if (has_spread) { build_element_spread_attributes(node, attributes, style_directives, class_directives, context); if (node.name === 'option') { context.state.template.push( b.call( '$.maybe_selected', b.id('$$payload'), b.member( build_spread_object( node, node.attributes.filter( (attribute) => attribute.type === 'Attribute' || attribute.type === 'BindDirective' || attribute.type === 'SpreadAttribute' ), context ), 'value', false, true ) ) ); } } else { const css_hash = node.metadata.scoped ? context.state.analysis.css.hash : null; for (const attribute of /** @type {AST.Attribute[]} */ (attributes)) { const name = get_attribute_name(node, attribute); const can_use_literal = (name !== 'class' || class_directives.length === 0) && (name !== 'style' || style_directives.length === 0); if (can_use_literal && (attribute.value === true || is_text_attribute(attribute))) { let literal_value = /** @type {Literal} */ ( build_attribute_value( attribute.value, context, WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name) ) ).value; if (name === 'class' && css_hash) { literal_value = (String(literal_value) + ' ' + css_hash).trim(); } if (name !== 'class' || literal_value) { context.state.template.push( b.literal( ` ${attribute.name}${ is_boolean_attribute(name) && literal_value === true ? '' : `="${literal_value === true ? '' : String(literal_value)}"` }` ) ); } if (node.name === 'option' && name === 'value') { context.state.template.push( b.call( '$.maybe_selected', b.id('$$payload'), literal_value != null ? b.literal(/** @type {any} */ (literal_value)) : b.void0 ) ); } continue; } const value = build_attribute_value( attribute.value, context, WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name) ); // pre-escape and inline literal attributes : if (can_use_literal && value.type === 'Literal' && typeof value.value === 'string') { if (name === 'class' && css_hash) { value.value = (value.value + ' ' + css_hash).trim(); } context.state.template.push(b.literal(` ${name}="${escape_html(value.value, true)}"`)); } else if (name === 'class') { context.state.template.push(build_attr_class(class_directives, value, context, css_hash)); } else if (name === 'style') { context.state.template.push(build_attr_style(style_directives, value, context)); } else { context.state.template.push( b.call('$.attr', b.literal(name), value, is_boolean_attribute(name) && b.true) ); } if (name === 'value' && node.name === 'option') { context.state.template.push(b.call('$.maybe_selected', b.id('$$payload'), value)); } } } if (events_to_capture.size !== 0) { for (const event of events_to_capture) { context.state.template.push(b.literal(` ${event}="this.__e=event"`)); } } return content; } /** * @param {AST.RegularElement | AST.SvelteElement} element * @param {AST.Attribute | AST.BindDirective} attribute */ function get_attribute_name(element, attribute) { let name = attribute.name; if (!element.metadata.svg && !element.metadata.mathml) { name = name.toLowerCase(); // don't lookup boolean aliases here, the server runtime function does only // check for the lowercase variants of boolean attributes } return name; } /** * @param {AST.RegularElement | AST.SvelteElement} element * @param {Array<AST.Attribute | AST.SpreadAttribute | AST.BindDirective>} attributes * @param {ComponentContext} context */ export function build_spread_object(element, attributes, context) { return b.object( attributes.map((attribute) => { if (attribute.type === 'Attribute') { const name = get_attribute_name(element, attribute); const value = build_attribute_value( attribute.value, context, WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name) ); return b.prop('init', b.key(name), value); } else if (attribute.type === 'BindDirective') { const name = get_attribute_name(element, attribute); const value = attribute.expression.type === 'SequenceExpression' ? b.call(attribute.expression.expressions[0]) : /** @type {Expression} */ (context.visit(attribute.expression)); return b.prop('init', b.key(name), value); } return b.spread(/** @type {Expression} */ (context.visit(attribute))); }) ); } /** * * @param {AST.RegularElement | AST.SvelteElement} element * @param {Array<AST.Attribute | AST.SpreadAttribute>} attributes * @param {AST.StyleDirective[]} style_directives * @param {AST.ClassDirective[]} class_directives * @param {ComponentContext} context */ function build_element_spread_attributes( element, attributes, style_directives, class_directives, context ) { let classes; let styles; let flags = 0; if (class_directives.length) { const properties = class_directives.map((directive) => b.init( directive.name, directive.expression.type === 'Identifier' && directive.expression.name === directive.name ? b.id(directive.name) : /** @type {Expression} */ (context.visit(directive.expression)) ) ); classes = b.object(properties); } if (style_directives.length > 0) { const properties = style_directives.map((directive) => b.init( directive.name, directive.value === true ? b.id(directive.name) : build_attribute_value(directive.value, context, true) ) ); styles = b.object(properties); } if (element.metadata.svg || element.metadata.mathml) { flags |= ELEMENT_IS_NAMESPACED | ELEMENT_PRESERVE_ATTRIBUTE_CASE; } else if (is_custom_element_node(element)) { flags |= ELEMENT_PRESERVE_ATTRIBUTE_CASE; } const object = build_spread_object(element, attributes, context); const css_hash = element.metadata.scoped && context.state.analysis.css.hash ? b.literal(context.state.analysis.css.hash) : b.null; const args = [object, css_hash, classes, styles, flags ? b.literal(flags) : undefined]; context.state.template.push(b.call('$.spread_attributes', ...args)); } /** * * @param {AST.ClassDirective[]} class_directives * @param {Expression} expression * @param {ComponentContext} context * @param {string | null} hash */ function build_attr_class(class_directives, expression, context, hash) { /** @type {ObjectExpression | undefined} */ let directives; if (class_directives.length) { directives = b.object( class_directives.map((directive) => b.prop( 'init', b.literal(directive.name), /** @type {Expression} */ (context.visit(directive.expression, context.state)) ) ) ); } let css_hash; if (hash) { if (expression.type === 'Literal' && typeof expression.value === 'string') { expression.value = (expression.value + ' ' + hash).trim(); } else { css_hash = b.literal(hash); } } return b.call('$.attr_class', expression, css_hash, directives); } /** * * @param {AST.StyleDirective[]} style_directives * @param {Expression} expression * @param {ComponentContext} context */ function build_attr_style(style_directives, expression, context) { /** @type {ArrayExpression | ObjectExpression | undefined} */ let directives; if (style_directives.length) { let normal_properties = []; let important_properties = []; for (const directive of style_directives) { const expression = directive.value === true ? b.id(directive.name) : build_attribute_value(directive.value, context, true); let name = directive.name; if (name[0] !== '-' || name[1] !== '-') { name = name.toLowerCase(); } const property = b.init(directive.name, expression); if (directive.modifiers.includes('important')) { important_properties.push(property); } else { normal_properties.push(property); } } if (important_properties.length) { directives = b.array([b.object(normal_properties), b.object(important_properties)]); } else { directives = b.object(normal_properties); } } return b.call('$.attr_style', expression, directives); }
```

# compiler/phases/3-transform/server/visitors/shared/utils.js

```js
/** @import { AssignmentOperator, Expression, Identifier, Node, Statement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext, ServerTransformState } from '../../types.js' */ import { escape_html } from '../../../../../../escaping.js'; import { BLOCK_CLOSE, BLOCK_OPEN, EMPTY_COMMENT } from '../../../../../../internal/server/hydration.js'; import * as b from '#compiler/builders'; import { sanitize_template_string } from '../../../../../utils/sanitize_template_string.js'; import { regex_whitespaces_strict } from '../../../../patterns.js'; /** Opens an if/each block, so that we can remove nodes in the case of a mismatch */ export const block_open = b.literal(BLOCK_OPEN); /** Closes an if/each block, so that we can remove nodes in the case of a mismatch. Also serves as an anchor for these blocks */ export const block_close = b.literal(BLOCK_CLOSE); /** Empty comment to keep text nodes separate, or provide an anchor node for blocks */ export const empty_comment = b.literal(EMPTY_COMMENT); /** * Processes an array of template nodes, joining sibling text/expression nodes and * recursing into child nodes. * @param {Array<AST.SvelteNode>} nodes * @param {ComponentContext} context */ export function process_children(nodes, { visit, state }) { /** @type {Array<AST.Text | AST.Comment | AST.ExpressionTag>} */ let sequence = []; function flush() { let quasi = b.quasi('', false); const quasis = [quasi]; /** @type {Expression[]} */ const expressions = []; for (let i = 0; i < sequence.length; i++) { const node = sequence[i]; if (node.type === 'Text' || node.type === 'Comment') { quasi.value.cooked += node.type === 'Comment' ? `<!--${node.data}-->` : escape_html(node.data); } else { const evaluated = state.scope.evaluate(node.expression); if (evaluated.is_known) { quasi.value.cooked += escape_html((evaluated.value ?? '') + ''); } else { expressions.push(b.call('$.escape', /** @type {Expression} */ (visit(node.expression)))); quasi = b.quasi('', i + 1 === sequence.length); quasis.push(quasi); } } } for (const quasi of quasis) { quasi.value.raw = sanitize_template_string(/** @type {string} */ (quasi.value.cooked)); } state.template.push(b.template(quasis, expressions)); } for (let i = 0; i < nodes.length; i += 1) { const node = nodes[i]; if (node.type === 'Text' || node.type === 'Comment' || node.type === 'ExpressionTag') { sequence.push(node); } else { if (sequence.length > 0) { flush(); sequence = []; } visit(node, { ...state }); } } if (sequence.length > 0) { flush(); } } /** * @param {Node} node * @returns {node is Statement} */ function is_statement(node) { return node.type.endsWith('Statement') || node.type.endsWith('Declaration'); } /** * @param {Array<Statement | Expression>} template * @param {Identifier} out * @param {AssignmentOperator} operator * @returns {Statement[]} */ export function build_template(template, out = b.id('$$payload.out'), operator = '+=') { /** @type {string[]} */ let strings = []; /** @type {Expression[]} */ let expressions = []; /** @type {Statement[]} */ const statements = []; const flush = () => { statements.push( b.stmt( b.assignment( operator, out, b.template( strings.map((cooked, i) => b.quasi(cooked, i === strings.length - 1)), expressions ) ) ) ); strings = []; expressions = []; }; for (let i = 0; i < template.length; i++) { const node = template[i]; if (is_statement(node)) { if (strings.length !== 0) { flush(); } statements.push(node); } else { if (strings.length === 0) { strings.push(''); } if (node.type === 'Literal') { strings[strings.length - 1] += node.value; } else if (node.type === 'TemplateLiteral') { strings[strings.length - 1] += node.quasis[0].value.cooked; strings.push(...node.quasis.slice(1).map((q) => /** @type {string} */ (q.value.cooked))); expressions.push(...node.expressions); } else { expressions.push(node); strings.push(''); } } } if (strings.length !== 0) { flush(); } return statements; } /** * * @param {AST.Attribute['value']} value * @param {ComponentContext} context * @param {boolean} trim_whitespace * @param {boolean} is_component * @returns {Expression} */ export function build_attribute_value( value, context, trim_whitespace = false, is_component = false ) { if (value === true) { return b.true; } if (!Array.isArray(value) || value.length === 1) { const chunk = Array.isArray(value) ? value[0] : value; if (chunk.type === 'Text') { const data = trim_whitespace ? chunk.data.replace(regex_whitespaces_strict, ' ').trim() : chunk.data; return b.literal(is_component ? data : escape_html(data, true)); } return /** @type {Expression} */ (context.visit(chunk.expression)); } let quasi = b.quasi('', false); const quasis = [quasi]; /** @type {Expression[]} */ const expressions = []; for (let i = 0; i < value.length; i++) { const node = value[i]; if (node.type === 'Text') { quasi.value.raw += trim_whitespace ? node.data.replace(regex_whitespaces_strict, ' ') : node.data; } else { expressions.push( b.call('$.stringify', /** @type {Expression} */ (context.visit(node.expression))) ); quasi = b.quasi('', i + 1 === value.length); quasis.push(quasi); } } return b.template(quasis, expressions); } /** * @param {Identifier} node * @param {ServerTransformState} state * @returns {Expression} */ export function build_getter(node, state) { const binding = state.scope.get(node.name); if (binding === null || node === binding.node) { // No associated binding or the declaration itself which shouldn't be transformed return node; } if (binding.kind === 'store_sub') { const store_id = b.id(node.name.slice(1)); return b.call( '$.store_get', b.assignment('??=', b.id('$$store_subs'), b.object([])), b.literal(node.name), build_getter(store_id, state) ); } return node; }
```

# compiler/phases/3-transform/server/visitors/SlotElement.js

```js
/** @import { BlockStatement, Expression, Literal, Property } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types.js' */ import * as b from '#compiler/builders'; import { empty_comment, build_attribute_value } from './shared/utils.js'; /** * @param {AST.SlotElement} node * @param {ComponentContext} context */ export function SlotElement(node, context) { /** @type {Property[]} */ const props = []; /** @type {Expression[]} */ const spreads = []; let name = b.literal('default'); for (const attribute of node.attributes) { if (attribute.type === 'SpreadAttribute') { spreads.push(/** @type {Expression} */ (context.visit(attribute))); } else if (attribute.type === 'Attribute') { const value = build_attribute_value(attribute.value, context, false, true); if (attribute.name === 'name') { name = /** @type {Literal} */ (value); } else if (attribute.name !== 'slot') { props.push(b.init(attribute.name, value)); } } } const props_expression = spreads.length === 0 ? b.object(props) : b.call('$.spread_props', b.array([b.object(props), ...spreads])); const fallback = node.fragment.nodes.length === 0 ? b.null : b.thunk(/** @type {BlockStatement} */ (context.visit(node.fragment))); const slot = b.call( '$.slot', b.id('$$payload'), b.id('$$props'), name, props_expression, fallback ); context.state.template.push(empty_comment, b.stmt(slot), empty_comment); }
```

# compiler/phases/3-transform/server/visitors/SnippetBlock.js

```js
/** @import { BlockStatement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types.js' */ import { dev } from '../../../../state.js'; import * as b from '#compiler/builders'; /** * @param {AST.SnippetBlock} node * @param {ComponentContext} context */ export function SnippetBlock(node, context) { let fn = b.function_declaration( node.expression, [b.id('$$payload'), ...node.parameters], /** @type {BlockStatement} */ (context.visit(node.body)) ); // @ts-expect-error - TODO remove this hack once $$render_inner for legacy bindings is gone fn.___snippet = true; const statements = node.metadata.can_hoist ? context.state.hoisted : context.state.init; if (dev) { fn.body.body.unshift(b.stmt(b.call('$.validate_snippet_args', b.id('$$payload')))); statements.push(b.stmt(b.call('$.prevent_snippet_stringification', fn.id))); } statements.push(fn); }
```

# compiler/phases/3-transform/server/visitors/SpreadAttribute.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ /** * @param {AST.SpreadAttribute} node * @param {ComponentContext} context */ export function SpreadAttribute(node, context) { return context.visit(node.expression); }
```

# compiler/phases/3-transform/server/visitors/SvelteBoundary.js

```js
/** @import { BlockStatement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ import { BLOCK_CLOSE, BLOCK_OPEN } from '../../../../../internal/server/hydration.js'; import * as b from '#compiler/builders'; import { build_attribute_value } from './shared/utils.js'; /** * @param {AST.SvelteBoundary} node * @param {ComponentContext} context */ export function SvelteBoundary(node, context) { context.state.template.push(b.literal(BLOCK_OPEN)); // if this has a `pending` snippet, render it const pending_attribute = /** @type {AST.Attribute} */ ( node.attributes.find((node) => node.type === 'Attribute' && node.name === 'pending') ); const pending_snippet = /** @type {AST.SnippetBlock} */ ( node.fragment.nodes.find( (node) => node.type === 'SnippetBlock' && node.expression.name === 'pending' ) ); if (pending_attribute) { const value = build_attribute_value(pending_attribute.value, context, false, true); context.state.template.push(b.call(value, b.id('$$payload'))); } else if (pending_snippet) { context.state.template.push( /** @type {BlockStatement} */ (context.visit(pending_snippet.body)) ); } else { context.state.template.push(/** @type {BlockStatement} */ (context.visit(node.fragment))); } context.state.template.push(b.literal(BLOCK_CLOSE)); }
```

# compiler/phases/3-transform/server/visitors/SvelteComponent.js

```js
/** @import { Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types.js' */ import { build_inline_component } from './shared/component.js'; /** * @param {AST.SvelteComponent} node * @param {ComponentContext} context */ export function SvelteComponent(node, context) { build_inline_component(node, /** @type {Expression} */ (context.visit(node.expression)), context); }
```

# compiler/phases/3-transform/server/visitors/SvelteElement.js

```js
/** @import { Location } from 'locate-character' */ /** @import { BlockStatement, Expression } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types.js' */ import { dev, locator } from '../../../../state.js'; import * as b from '#compiler/builders'; import { determine_namespace_for_children } from '../../utils.js'; import { build_element_attributes } from './shared/element.js'; import { build_template } from './shared/utils.js'; /** * @param {AST.SvelteElement} node * @param {ComponentContext} context */ export function SvelteElement(node, context) { let tag = /** @type {Expression} */ (context.visit(node.tag)); if (dev) { // Ensure getters/function calls aren't called multiple times. // If we ever start referencing `tag` more than once in prod, move this out of the if block. if (tag.type !== 'Identifier') { const tag_id = context.state.scope.generate('$$tag'); context.state.init.push(b.const(tag_id, tag)); tag = b.id(tag_id); } if (node.fragment.nodes.length > 0) { context.state.init.push(b.stmt(b.call('$.validate_void_dynamic_element', b.thunk(tag)))); } context.state.init.push(b.stmt(b.call('$.validate_dynamic_element_tag', b.thunk(tag)))); } const state = { ...context.state, namespace: determine_namespace_for_children(node, context.state.namespace), template: [], init: [] }; build_element_attributes(node, { ...context, state }); if (dev) { const location = /** @type {Location} */ (locator(node.start)); context.state.template.push( b.stmt( b.call( '$.push_element', b.id('$$payload'), tag, b.literal(location.line), b.literal(location.column) ) ) ); } const attributes = b.block([...state.init, ...build_template(state.template)]); const children = /** @type {BlockStatement} */ (context.visit(node.fragment, state)); context.state.template.push( b.stmt( b.call( '$.element', b.id('$$payload'), tag, attributes.body.length > 0 && b.thunk(attributes), children.body.length > 0 && b.thunk(children) ) ) ); if (dev) { context.state.template.push(b.stmt(b.call('$.pop_element'))); } }
```

# compiler/phases/3-transform/server/visitors/SvelteFragment.js

```js
/** @import { BlockStatement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types' */ /** * @param {AST.SvelteFragment} node * @param {ComponentContext} context */ export function SvelteFragment(node, context) { context.state.template.push(/** @type {BlockStatement} */ (context.visit(node.fragment))); }
```

# compiler/phases/3-transform/server/visitors/SvelteHead.js

```js
/** @import { BlockStatement } from 'estree' */ /** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types.js' */ import * as b from '#compiler/builders'; /** * @param {AST.SvelteHead} node * @param {ComponentContext} context */ export function SvelteHead(node, context) { const block = /** @type {BlockStatement} */ (context.visit(node.fragment)); context.state.template.push( b.stmt(b.call('$.head', b.id('$$payload'), b.arrow([b.id('$$payload')], block))) ); }
```

# compiler/phases/3-transform/server/visitors/SvelteSelf.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types.js' */ import * as b from '#compiler/builders'; import { build_inline_component } from './shared/component.js'; /** * @param {AST.SvelteSelf} node * @param {ComponentContext} context */ export function SvelteSelf(node, context) { build_inline_component(node, b.id(context.state.analysis.name), context); }
```

# compiler/phases/3-transform/server/visitors/TitleElement.js

```js
/** @import { AST } from '#compiler' */ /** @import { ComponentContext } from '../types.js' */ import * as b from '#compiler/builders'; import { process_children, build_template } from './shared/utils.js'; /** * @param {AST.TitleElement} node * @param {ComponentContext} context */ export function TitleElement(node, context) { // title is guaranteed to contain only text/expression tag children const template = [b.literal('<title>')]; process_children(node.fragment.nodes, { ...context, state: { ...context.state, template } }); template.push(b.literal('</title>')); context.state.init.push(...build_template(template, b.id('$$payload.title'), '=')); }
```

# compiler/phases/3-transform/server/visitors/UpdateExpression.js

```js
/** @import { UpdateExpression } from 'estree' */ /** @import { Context } from '../types.js' */ import * as b from '#compiler/builders'; /** * @param {UpdateExpression} node * @param {Context} context */ export function UpdateExpression(node, context) { const argument = node.argument; if ( argument.type === 'Identifier' && context.state.scope.get(argument.name)?.kind === 'store_sub' ) { return b.call( node.prefix ? '$.update_store_pre' : '$.update_store', b.assignment('??=', b.id('$$store_subs'), b.object([])), b.literal(argument.name), b.id(argument.name.slice(1)), node.operator === '--' && b.literal(-1) ); } return context.next(); }
```

# compiler/phases/3-transform/server/visitors/VariableDeclaration.js

```js
/** @import { VariableDeclaration, VariableDeclarator, Expression, CallExpression, Pattern, Identifier } from 'estree' */ /** @import { Binding } from '#compiler' */ /** @import { Context } from '../types.js' */ /** @import { ComponentAnalysis } from '../../../types.js' */ /** @import { Scope } from '../../../scope.js' */ import { build_fallback, extract_paths } from '../../../../utils/ast.js'; import * as b from '#compiler/builders'; import { get_rune } from '../../../scope.js'; import { walk } from 'zimmerframe'; /** * @param {VariableDeclaration} node * @param {Context} context */ export function VariableDeclaration(node, context) { /** @type {VariableDeclarator[]} */ const declarations = []; if (context.state.analysis.runes) { for (const declarator of node.declarations) { const init = declarator.init; const rune = get_rune(init, context.state.scope); if (!rune || rune === '$effect.tracking' || rune === '$inspect' || rune === '$effect.root') { declarations.push(/** @type {VariableDeclarator} */ (context.visit(declarator))); continue; } if (rune === '$props.id') { // skip continue; } if (rune === '$props') { let has_rest = false; // remove $bindable() from props declaration let id = walk(declarator.id, null, { RestElement(node, context) { if (context.path.at(-1) === declarator.id) { has_rest = true; } }, AssignmentPattern(node) { if ( node.right.type === 'CallExpression' && get_rune(node.right, context.state.scope) === '$bindable' ) { const right = node.right.arguments.length ? /** @type {Expression} */ (context.visit(node.right.arguments[0])) : b.void0; return b.assignment_pattern(node.left, right); } } }); // if `$$slots` is declared separately, deconflict const slots_name = /** @type {ComponentAnalysis} */ (context.state.analysis).uses_slots ? b.id('$$slots_') : b.id('$$slots'); if (id.type === 'ObjectPattern' && has_rest) { // If a rest pattern is used within an object pattern, we need to ensure we don't expose $$slots or $$events id.properties.splice( id.properties.length - 1, 0, // @ts-ignore b.prop('init', b.id('$$slots'), slots_name), b.prop('init', b.id('$$events'), b.id('$$events')) ); } else if (id.type === 'Identifier') { // If $props is referenced as an identifier, we need to ensure we don't expose $$slots or $$events as properties // on the identifier reference id = b.object_pattern([ b.prop('init', b.id('$$slots'), slots_name), b.prop('init', b.id('$$events'), b.id('$$events')), b.rest(b.id(id.name)) ]); } declarations.push( b.declarator(/** @type {Pattern} */ (context.visit(id)), b.id('$$props')) ); continue; } const args = /** @type {CallExpression} */ (init).arguments; const value = args.length > 0 ? /** @type {Expression} */ (context.visit(args[0])) : b.void0; if (rune === '$derived.by') { declarations.push( b.declarator(/** @type {Pattern} */ (context.visit(declarator.id)), b.call(value)) ); continue; } if (declarator.id.type === 'Identifier') { declarations.push(b.declarator(declarator.id, value)); continue; } if (rune === '$derived') { declarations.push( b.declarator(/** @type {Pattern} */ (context.visit(declarator.id)), value) ); continue; } declarations.push(...create_state_declarators(declarator, context.state.scope, value)); } } else { for (const declarator of node.declarations) { const bindings = /** @type {Binding[]} */ (context.state.scope.get_bindings(declarator)); const has_state = bindings.some((binding) => binding.kind === 'state'); const has_props = bindings.some((binding) => binding.kind === 'bindable_prop'); if (!has_state && !has_props) { declarations.push(/** @type {VariableDeclarator} */ (context.visit(declarator))); continue; } if (has_props) { if (declarator.id.type !== 'Identifier') { // Turn export let into props. It's really really weird because export let { x: foo, z: [bar]} = .. // means that foo and bar are the props (i.e. the leafs are the prop names), not x and z. const tmp = b.id(context.state.scope.generate('tmp')); const { inserts, paths } = extract_paths(declarator.id, tmp); declarations.push( b.declarator( tmp, /** @type {Expression} */ (context.visit(/** @type {Expression} */ (declarator.init))) ) ); for (const { id, value } of inserts) { id.name = context.state.scope.generate('$$array'); declarations.push(b.declarator(id, value)); } for (const path of paths) { const value = path.expression; const name = /** @type {Identifier} */ (path.node).name; const binding = /** @type {Binding} */ (context.state.scope.get(name)); const prop = b.member(b.id('$$props'), b.literal(binding.prop_alias ?? name), true); declarations.push(b.declarator(path.node, build_fallback(prop, value))); } continue; } const binding = /** @type {Binding} */ (context.state.scope.get(declarator.id.name)); const prop = b.member( b.id('$$props'), b.literal(binding.prop_alias ?? declarator.id.name), true ); /** @type {Expression} */ let init = prop; if (declarator.init) { const default_value = /** @type {Expression} */ (context.visit(declarator.init)); init = build_fallback(prop, default_value); } declarations.push(b.declarator(declarator.id, init)); continue; } declarations.push( ...create_state_declarators( declarator, context.state.scope, /** @type {Expression} */ (declarator.init && context.visit(declarator.init)) ) ); } } if (declarations.length === 0) { return b.empty; } return { ...node, declarations }; } /** * @param {VariableDeclarator} declarator * @param {Scope} scope * @param {Expression} value * @returns {VariableDeclarator[]} */ function create_state_declarators(declarator, scope, value) { if (declarator.id.type === 'Identifier') { return [b.declarator(declarator.id, value)]; } const tmp = b.id(scope.generate('tmp')); const { paths, inserts } = extract_paths(declarator.id, tmp); return [ b.declarator(tmp, value), // TODO inject declarator for opts, so we can use it below ...inserts.map(({ id, value }) => { id.name = scope.generate('$$array'); return b.declarator(id, value); }), ...paths.map((path) => { const value = path.expression; return b.declarator(path.node, value); }) ]; }
```

# compiler/phases/3-transform/shared/assignments.js

```js
/** @import { AssignmentExpression, AssignmentOperator, Expression, Node, Pattern, Statement } from 'estree' */ /** @import { Context as ClientContext } from '../client/types.js' */ /** @import { Context as ServerContext } from '../server/types.js' */ import { extract_paths, is_expression_async } from '../../../utils/ast.js'; import * as b from '#compiler/builders'; import { get_value } from '../client/visitors/shared/declarations.js'; /** * @template {ClientContext | ServerContext} Context * @param {AssignmentExpression} node * @param {Context} context * @param {(operator: AssignmentOperator, left: Pattern, right: Expression, context: Context) => Expression | null} build_assignment * @returns */ export function visit_assignment_expression(node, context, build_assignment) { if ( node.left.type === 'ArrayPattern' || node.left.type === 'ObjectPattern' || node.left.type === 'RestElement' ) { const value = /** @type {Expression} */ (context.visit(node.right)); const should_cache = value.type !== 'Identifier'; const rhs = should_cache ? b.id('$$value') : value; let changed = false; const { inserts, paths } = extract_paths(node.left, rhs); for (const { id } of inserts) { id.name = context.state.scope.generate('$$array'); } const assignments = paths.map((path) => { const value = path.expression; let assignment = build_assignment('=', path.node, value, context); if (assignment !== null) changed = true; return ( assignment ?? b.assignment( '=', /** @type {Pattern} */ (context.visit(path.node)), /** @type {Expression} */ (context.visit(value)) ) ); }); if (!changed) { // No change to output -> nothing to transform -> we can keep the original assignment return null; } const is_standalone = /** @type {Node} */ (context.path.at(-1)).type.endsWith('Statement'); if (inserts.length > 0 || should_cache) { /** @type {Statement[]} */ const statements = [ ...inserts.map(({ id, value }) => b.var(id, value)), ...assignments.map(b.stmt) ]; if (!is_standalone) { // this is part of an expression, we need the sequence to end with the value statements.push(b.return(rhs)); } const iife = b.arrow([rhs], b.block(statements)); const iife_is_async = is_expression_async(value) || assignments.some((assignment) => is_expression_async(assignment)); return iife_is_async ? b.await(b.call(b.async(iife), value)) : b.call(iife, value); } const sequence = b.sequence(assignments); if (!is_standalone) { // this is part of an expression, we need the sequence to end with the value sequence.expressions.push(rhs); } return sequence; } if (node.left.type !== 'Identifier' && node.left.type !== 'MemberExpression') { throw new Error(`Unexpected assignment type ${node.left.type}`); } return build_assignment(node.operator, node.left, node.right, context); }
```

# compiler/phases/3-transform/types.d.ts

```ts
import type { Scope } from '../scope.js'; import type { AST, StateField, ValidatedModuleCompileOptions } from '#compiler'; import type { Analysis } from '../types.js'; export interface TransformState { readonly analysis: Analysis; readonly options: ValidatedModuleCompileOptions; readonly scope: Scope; readonly scopes: Map<AST.SvelteNode, Scope>; readonly state_fields: Map<string, StateField>; }
```

# compiler/phases/3-transform/utils.js

```js
/** @import { Context } from 'zimmerframe' */ /** @import { TransformState } from './types.js' */ /** @import { AST, Binding, Namespace, ValidatedCompileOptions } from '#compiler' */ /** @import { Node, Expression, CallExpression } from 'estree' */ import { regex_ends_with_whitespaces, regex_not_whitespace, regex_starts_with_newline, regex_starts_with_whitespaces } from '../patterns.js'; import * as b from '#compiler/builders'; import * as e from '../../errors.js'; import { walk } from 'zimmerframe'; import { extract_identifiers } from '../../utils/ast.js'; import check_graph_for_cycles from '../2-analyze/utils/check_graph_for_cycles.js'; import is_reference from 'is-reference'; import { set_scope } from '../scope.js'; import { dev } from '../../state.js'; /** * @param {Node} node * @returns {boolean} */ export function is_hoisted_function(node) { if ( node.type === 'ArrowFunctionExpression' || node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration' ) { return node.metadata?.hoisted === true; } return false; } /** * Match Svelte 4 behaviour by sorting ConstTag nodes in topological order * @param {AST.SvelteNode[]} nodes * @param {TransformState} state */ function sort_const_tags(nodes, state) { /** * @typedef {{ * node: AST.ConstTag; * deps: Set<Binding>; * }} Tag */ const other = []; /** @type {Map<Binding, Tag>} */ const tags = new Map(); for (const node of nodes) { if (node.type === 'ConstTag') { const declaration = node.declaration.declarations[0]; const bindings = extract_identifiers(declaration.id).map((id) => { return /** @type {Binding} */ (state.scope.get(id.name)); }); /** @type {Set<Binding>} */ const deps = new Set(); walk(declaration.init, state, { // @ts-expect-error don't know, don't care _: set_scope, Identifier(node, context) { const parent = /** @type {Expression} */ (context.path.at(-1)); if (is_reference(node, parent)) { const binding = context.state.scope.get(node.name); if (binding) deps.add(binding); } } }); for (const binding of bindings) { tags.set(binding, { node, deps }); } } else { other.push(node); } } if (tags.size === 0) { return nodes; } /** @type {Array<[Binding, Binding]>} */ const edges = []; for (const [id, tag] of tags) { for (const dep of tag.deps) { if (tags.has(dep)) { edges.push([id, dep]); } } } const cycle = check_graph_for_cycles(edges); if (cycle?.length) { const tag = /** @type {Tag} */ (tags.get(cycle[0])); e.const_tag_cycle(tag.node, cycle.map((binding) => binding.node.name).join(' → ')); } /** @type {AST.ConstTag[]} */ const sorted = []; /** @param {Tag} tag */ function add(tag) { if (sorted.includes(tag.node)) { return; } for (const dep of tag.deps) { const dep_tag = tags.get(dep); if (dep_tag) add(dep_tag); } sorted.push(tag.node); } for (const tag of tags.values()) { add(tag); } return [...sorted, ...other]; } /** * Extract nodes that are hoisted and trim whitespace according to the following rules: * - trim leading and trailing whitespace, regardless of surroundings * - keep leading / trailing whitespace of inbetween text nodes, * unless it's whitespace-only, in which case collapse to a single whitespace for all cases * except when it's children of certain elements where we know ignore whitespace (like td/option/head), * in which case we remove it entirely * @param {AST.SvelteNode} parent * @param {AST.SvelteNode[]} nodes * @param {AST.SvelteNode[]} path * @param {Namespace} namespace * @param {TransformState & { options: ValidatedCompileOptions }} state * @param {boolean} preserve_whitespace * @param {boolean} preserve_comments */ export function clean_nodes( parent, nodes, path, namespace = 'html', state, // TODO give these defaults (state.options.preserveWhitespace and state.options.preserveComments). // first, we need to make `Component(Client|Server)TransformState` inherit from a new `ComponentTransformState` // rather than from `ClientTransformState` and `ServerTransformState` preserve_whitespace, preserve_comments ) { if (!state.analysis.runes) { nodes = sort_const_tags(nodes, state); } /** @type {AST.SvelteNode[]} */ const hoisted = []; /** @type {AST.SvelteNode[]} */ const regular = []; for (const node of nodes) { if (node.type === 'Comment' && !preserve_comments) { continue; } if ( node.type === 'ConstTag' || node.type === 'DebugTag' || node.type === 'SvelteBody' || node.type === 'SvelteWindow' || node.type === 'SvelteDocument' || node.type === 'SvelteHead' || node.type === 'TitleElement' || node.type === 'SnippetBlock' ) { // TODO others? hoisted.push(node); } else { regular.push(node); } } let trimmed = regular; if (!preserve_whitespace) { trimmed = []; let first, last; while ( (first = regular[0]) && first.type === 'Text' && !regex_not_whitespace.test(first.data) ) { regular.shift(); } if (first?.type === 'Text') { first.raw = first.raw.replace(regex_starts_with_whitespaces, ''); first.data = first.data.replace(regex_starts_with_whitespaces, ''); } while ( (last = regular.at(-1)) && last.type === 'Text' && !regex_not_whitespace.test(last.data) ) { regular.pop(); } if (last?.type === 'Text') { last.raw = last.raw.replace(regex_ends_with_whitespaces, ''); last.data = last.data.replace(regex_ends_with_whitespaces, ''); } const can_remove_entirely = (namespace === 'svg' && (parent.type !== 'RegularElement' || parent.name !== 'text') && !path.some((n) => n.type === 'RegularElement' && n.name === 'text')) || (parent.type === 'RegularElement' && // TODO others? (parent.name === 'select' || parent.name === 'tr' || parent.name === 'table' || parent.name === 'tbody' || parent.name === 'thead' || parent.name === 'tfoot' || parent.name === 'colgroup' || parent.name === 'datalist')); // Replace any whitespace between a text and non-text node with a single spaceand keep whitespace // as-is within text nodes, or between text nodes and expression tags (because in the end they count // as one text). This way whitespace is mostly preserved when using CSS with `white-space: pre-line` // and default slot content going into a pre tag (which we can't see). for (let i = 0; i < regular.length; i++) { const prev = regular[i - 1]; const node = regular[i]; const next = regular[i + 1]; if (node.type === 'Text') { if (prev?.type !== 'ExpressionTag') { const prev_is_text_ending_with_whitespace = prev?.type === 'Text' && regex_ends_with_whitespaces.test(prev.data); node.data = node.data.replace( regex_starts_with_whitespaces, prev_is_text_ending_with_whitespace ? '' : ' ' ); node.raw = node.raw.replace( regex_starts_with_whitespaces, prev_is_text_ending_with_whitespace ? '' : ' ' ); } if (next?.type !== 'ExpressionTag') { node.data = node.data.replace(regex_ends_with_whitespaces, ' '); node.raw = node.raw.replace(regex_ends_with_whitespaces, ' '); } if (node.data && (node.data !== ' ' || !can_remove_entirely)) { trimmed.push(node); } } else { trimmed.push(node); } } } var first = trimmed[0]; // if first text node inside a <pre> is a single newline, discard it, because otherwise // the browser will do it for us which could break hydration if (parent.type === 'RegularElement' && parent.name === 'pre' && first?.type === 'Text') { if (first.data === '\n' || first.data === '\r\n') { trimmed.shift(); first = trimmed[0]; } } // Special case: Add a comment if this is a lone script tag. This ensures that our run_scripts logic in template.js // will always be able to call node.replaceWith() on the script tag in order to make it run. If we don't add this // and would still call node.replaceWith() on the script tag, it would be a no-op because the script tag has no parent. if (trimmed.length === 1 && first.type === 'RegularElement' && first.name === 'script') { trimmed.push({ type: 'Comment', data: '', start: -1, end: -1 }); } return { hoisted, trimmed, /** * In a case like `{#if x}<Foo />{/if}`, we don't need to wrap the child in * comments — we can just use the parent block's anchor for the component. * TODO extend this optimisation to other cases */ is_standalone: trimmed.length === 1 && ((first.type === 'RenderTag' && !first.metadata.dynamic) || (first.type === 'Component' && !state.options.hmr && !first.metadata.dynamic && !first.attributes.some( (attribute) => attribute.type === 'Attribute' && attribute.name.startsWith('--') ))), /** if a component/snippet/each block starts with text, we need to add an anchor comment so that its text node doesn't get fused with its surroundings */ is_text_first: (parent.type === 'Fragment' || parent.type === 'SnippetBlock' || parent.type === 'EachBlock' || parent.type === 'SvelteComponent' || parent.type === 'SvelteBoundary' || parent.type === 'Component' || parent.type === 'SvelteSelf') && first && (first?.type === 'Text' || first?.type === 'ExpressionTag') }; } /** * Infers the namespace for the children of a node that should be used when creating the fragment * @param {Namespace} namespace * @param {AST.SvelteNode} parent * @param {AST.SvelteNode[]} nodes */ export function infer_namespace(namespace, parent, nodes) { if (parent.type === 'RegularElement' && parent.name === 'foreignObject') { return 'html'; } if (parent.type === 'RegularElement' || parent.type === 'SvelteElement') { if (parent.metadata.svg) { return 'svg'; } return parent.metadata.mathml ? 'mathml' : 'html'; } // Re-evaluate the namespace inside slot nodes that reset the namespace if ( parent.type === 'Fragment' || parent.type === 'Root' || parent.type === 'Component' || parent.type === 'SvelteComponent' || parent.type === 'SvelteFragment' || parent.type === 'SnippetBlock' || parent.type === 'SlotElement' ) { const new_namespace = check_nodes_for_namespace(nodes, 'keep'); if (new_namespace !== 'keep' && new_namespace !== 'maybe_html') { return new_namespace; } } /** @type {Namespace | null} */ let new_namespace = null; // Check the elements within the fragment and look for consistent namespaces. // If we have no namespaces or they are mixed, then fallback to existing namespace for (const node of nodes) { if (node.type !== 'RegularElement') continue; if (node.metadata.mathml) { new_namespace = new_namespace === null || new_namespace === 'mathml' ? 'mathml' : 'html'; } else if (node.metadata.svg) { new_namespace = new_namespace === null || new_namespace === 'svg' ? 'svg' : 'html'; } else { return 'html'; } } return new_namespace ?? namespace; } /** * Heuristic: Keep current namespace, unless we find a regular element, * in which case we always want html, or we only find svg nodes, * in which case we assume svg. * @param {AST.SvelteNode[]} nodes * @param {Namespace | 'keep' | 'maybe_html'} namespace */ function check_nodes_for_namespace(nodes, namespace) { /** * @param {AST.SvelteElement | AST.RegularElement} node} * @param {{stop: () => void}} context */ const RegularElement = (node, { stop }) => { if (!node.metadata.svg && !node.metadata.mathml) { namespace = 'html'; stop(); } else if (namespace === 'keep') { namespace = node.metadata.svg ? 'svg' : 'mathml'; } }; for (const node of nodes) { walk( node, {}, { _(node, { next }) { if ( node.type === 'EachBlock' || node.type === 'IfBlock' || node.type === 'AwaitBlock' || node.type === 'Fragment' || node.type === 'KeyBlock' || node.type === 'RegularElement' || node.type === 'SvelteElement' || node.type === 'Text' ) { next(); } }, SvelteElement: RegularElement, RegularElement, Text(node) { if (node.data.trim() !== '') { namespace = 'maybe_html'; } } } ); if (namespace === 'html') return namespace; } return namespace; } /** * Determines the namespace the children of this node are in. * @param {AST.RegularElement | AST.SvelteElement} node * @param {Namespace} namespace * @returns {Namespace} */ export function determine_namespace_for_children(node, namespace) { if (node.name === 'foreignObject') { return 'html'; } if (node.metadata.svg) { return 'svg'; } return node.metadata.mathml ? 'mathml' : 'html'; } /** * @template {TransformState} T * @param {CallExpression} node * @param {Context<any, T>} context */ export function transform_inspect_rune(node, context) { const { state, visit } = context; const as_fn = state.options.generate === 'client'; if (!dev) return b.empty; if (node.callee.type === 'MemberExpression') { const raw_inspect_args = /** @type {CallExpression} */ (node.callee.object).arguments; const inspect_args = /** @type {Array<Expression>} */ (raw_inspect_args.map((arg) => visit(arg))); const with_arg = /** @type {Expression} */ (visit(node.arguments[0])); return b.call( '$.inspect', as_fn ? b.thunk(b.array(inspect_args)) : b.array(inspect_args), with_arg ); } else { const arg = node.arguments.map((arg) => /** @type {Expression} */ (visit(arg))); return b.call('$.inspect', as_fn ? b.thunk(b.array(arg)) : b.array(arg)); } }
```

# compiler/phases/bindings.js

```js
/** * @typedef BindingProperty * @property {string} [event] This is set if the binding corresponds to the property name on the dom element it's bound to * and there's an event that notifies of a change to that property * @property {boolean} [bidirectional] Set this to `true` if updates are written to the dom property * @property {boolean} [omit_in_ssr] Set this to true if the binding should not be included in SSR * @property {string[]} [valid_elements] If this is set, the binding is only valid on the given elements * @property {string[]} [invalid_elements] If this is set, the binding is invalid on the given elements */ /** * @type {Record<string, BindingProperty>} */ export const binding_properties = { // media currentTime: { valid_elements: ['audio', 'video'], omit_in_ssr: true, bidirectional: true }, duration: { valid_elements: ['audio', 'video'], event: 'durationchange', omit_in_ssr: true }, focused: {}, paused: { valid_elements: ['audio', 'video'], omit_in_ssr: true, bidirectional: true }, buffered: { valid_elements: ['audio', 'video'], omit_in_ssr: true }, seekable: { valid_elements: ['audio', 'video'], omit_in_ssr: true }, played: { valid_elements: ['audio', 'video'], omit_in_ssr: true }, volume: { valid_elements: ['audio', 'video'], omit_in_ssr: true, bidirectional: true }, muted: { valid_elements: ['audio', 'video'], omit_in_ssr: true, bidirectional: true }, playbackRate: { valid_elements: ['audio', 'video'], omit_in_ssr: true, bidirectional: true }, seeking: { valid_elements: ['audio', 'video'], omit_in_ssr: true }, ended: { valid_elements: ['audio', 'video'], omit_in_ssr: true }, readyState: { valid_elements: ['audio', 'video'], omit_in_ssr: true }, // video videoHeight: { valid_elements: ['video'], event: 'resize', omit_in_ssr: true }, videoWidth: { valid_elements: ['video'], event: 'resize', omit_in_ssr: true }, // img naturalWidth: { valid_elements: ['img'], event: 'load', omit_in_ssr: true }, naturalHeight: { valid_elements: ['img'], event: 'load', omit_in_ssr: true }, // document activeElement: { valid_elements: ['svelte:document'], omit_in_ssr: true }, fullscreenElement: { valid_elements: ['svelte:document'], event: 'fullscreenchange', omit_in_ssr: true }, pointerLockElement: { valid_elements: ['svelte:document'], event: 'pointerlockchange', omit_in_ssr: true }, visibilityState: { valid_elements: ['svelte:document'], event: 'visibilitychange', omit_in_ssr: true }, // window innerWidth: { valid_elements: ['svelte:window'], omit_in_ssr: true }, innerHeight: { valid_elements: ['svelte:window'], omit_in_ssr: true }, outerWidth: { valid_elements: ['svelte:window'], omit_in_ssr: true }, outerHeight: { valid_elements: ['svelte:window'], omit_in_ssr: true }, scrollX: { valid_elements: ['svelte:window'], omit_in_ssr: true, bidirectional: true }, scrollY: { valid_elements: ['svelte:window'], omit_in_ssr: true, bidirectional: true }, online: { valid_elements: ['svelte:window'], omit_in_ssr: true }, devicePixelRatio: { valid_elements: ['svelte:window'], event: 'resize', omit_in_ssr: true }, // dimensions clientWidth: { omit_in_ssr: true, invalid_elements: ['svelte:window', 'svelte:document'] }, clientHeight: { omit_in_ssr: true, invalid_elements: ['svelte:window', 'svelte:document'] }, offsetWidth: { omit_in_ssr: true, invalid_elements: ['svelte:window', 'svelte:document'] }, offsetHeight: { omit_in_ssr: true, invalid_elements: ['svelte:window', 'svelte:document'] }, contentRect: { omit_in_ssr: true, invalid_elements: ['svelte:window', 'svelte:document'] }, contentBoxSize: { omit_in_ssr: true, invalid_elements: ['svelte:window', 'svelte:document'] }, borderBoxSize: { omit_in_ssr: true, invalid_elements: ['svelte:window', 'svelte:document'] }, devicePixelContentBoxSize: { omit_in_ssr: true, invalid_elements: ['svelte:window', 'svelte:document'] }, // checkbox/radio indeterminate: { event: 'change', bidirectional: true, valid_elements: ['input'], omit_in_ssr: true // no corresponding attribute }, checked: { valid_elements: ['input'], bidirectional: true }, group: { valid_elements: ['input'], bidirectional: true }, // various this: { omit_in_ssr: true }, innerText: { invalid_elements: ['svelte:window', 'svelte:document'], bidirectional: true }, innerHTML: { invalid_elements: ['svelte:window', 'svelte:document'], bidirectional: true }, textContent: { invalid_elements: ['svelte:window', 'svelte:document'], bidirectional: true }, open: { event: 'toggle', bidirectional: true, valid_elements: ['details'] }, value: { valid_elements: ['input', 'textarea', 'select'], bidirectional: true }, files: { valid_elements: ['input'], omit_in_ssr: true, bidirectional: true } };
```

# compiler/phases/css.js

```js
/** @import { AST } from '#compiler' */ const regex_css_browser_prefix = /^-((webkit)|(moz)|(o)|(ms))-/; export const regex_css_name_boundary = /^[\s,;}]$/; /** * @param {string} name * @returns {string} */ export function remove_css_prefix(name) { return name.replace(regex_css_browser_prefix, ''); } /** @param {AST.CSS.Atrule} node */ export const is_keyframes_node = (node) => remove_css_prefix(node.name) === 'keyframes';
```

# compiler/phases/nodes.js

```js
/** @import { Expression, PrivateIdentifier } from 'estree' */ /** @import { AST, ExpressionMetadata } from '#compiler' */ /** * All nodes that can appear elsewhere than the top level, have attributes and can contain children */ const element_nodes = [ 'SvelteElement', 'RegularElement', 'SvelteFragment', 'Component', 'SvelteComponent', 'SvelteSelf', 'SlotElement' ]; /** * Returns true for all nodes that can appear elsewhere than the top level, have attributes and can contain children * @param {AST.SvelteNode} node * @returns {node is AST.Component | AST.RegularElement | AST.SlotElement | AST.SvelteComponent | AST.SvelteElement | AST.SvelteFragment | AST.SvelteSelf} */ export function is_element_node(node) { return element_nodes.includes(node.type); } /** * @param {AST.RegularElement | AST.SvelteElement} node * @returns {boolean} */ export function is_custom_element_node(node) { return ( node.type === 'RegularElement' && (node.name.includes('-') || node.attributes.some((attr) => attr.type === 'Attribute' && attr.name === 'is')) ); } /** * @param {string} name * @param {number} start * @param {number} end * @param {AST.Attribute['value']} value * @returns {AST.Attribute} */ export function create_attribute(name, start, end, value) { return { type: 'Attribute', start, end, name, value, metadata: { delegated: null, needs_clsx: false } }; } /** * @returns {ExpressionMetadata} */ export function create_expression_metadata() { return { dependencies: new Set(), references: new Set(), has_state: false, has_call: false, has_member_expression: false, has_assignment: false, has_await: false }; } /** * @param {Expression | PrivateIdentifier} node */ export function get_name(node) { if (node.type === 'Literal') return String(node.value); if (node.type === 'PrivateIdentifier') return '#' + node.name; if (node.type === 'Identifier') return node.name; return null; }
```

# compiler/phases/patterns.js

```js
export const regex_whitespace = /\s/; export const regex_whitespaces = /\s+/; export const regex_starts_with_newline = /^\r?\n/; export const regex_starts_with_whitespace = /^\s/; export const regex_starts_with_whitespaces = /^[ \t\r\n]+/; export const regex_ends_with_whitespace = /\s$/; export const regex_ends_with_whitespaces = /[ \t\r\n]+$/; /** Not \S because that also removes explicit whitespace defined through things like `&nbsp;` */ export const regex_not_whitespace = /[^ \t\r\n]/; /** Not \s+ because that also includes explicit whitespace defined through things like `&nbsp;` */ export const regex_whitespaces_strict = /[ \t\n\r\f]+/g; export const regex_only_whitespaces = /^[ \t\n\r\f]+$/; export const regex_not_newline_characters = /[^\n]/g; export const regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/; // used in replace all to remove all invalid chars from a literal identifier export const regex_invalid_identifier_chars = /(^[^a-zA-Z_$]|[^a-zA-Z0-9_$])/g; export const regex_starts_with_vowel = /^[aeiou]/; export const regex_heading_tags = /^h[1-6]$/; export const regex_illegal_attribute_character = /(^[0-9-.])|[\^$@%&#?!|()[\]{}^*+~;]/; export const regex_bidirectional_control_characters = /[\u202a\u202b\u202c\u202d\u202e\u2066\u2067\u2068\u2069]+/g; export const regex_js_prefix = /^\W*javascript:/i; export const regex_redundant_img_alt = /\b(image|picture|photo)\b/i;
```

# compiler/phases/scope.js

```js
/** @import { ArrowFunctionExpression, BinaryOperator, ClassDeclaration, Expression, FunctionDeclaration, FunctionExpression, Identifier, ImportDeclaration, MemberExpression, LogicalOperator, Node, Pattern, UnaryOperator, VariableDeclarator, Super } from 'estree' */ /** @import { Context, Visitor } from 'zimmerframe' */ /** @import { AST, BindingKind, DeclarationKind } from '#compiler' */ import is_reference from 'is-reference'; import { walk } from 'zimmerframe'; import { create_expression_metadata } from './nodes.js'; import * as b from '#compiler/builders'; import * as e from '../errors.js'; import { extract_identifiers, extract_identifiers_from_destructuring, object, unwrap_pattern } from '../utils/ast.js'; import { is_reserved, is_rune } from '../../utils.js'; import { determine_slot } from '../utils/slot.js'; import { validate_identifier_name } from './2-analyze/visitors/shared/utils.js'; const UNKNOWN = Symbol('unknown'); /** Includes `BigInt` */ const NUMBER = Symbol('number'); const STRING = Symbol('string'); const FUNCTION = Symbol('string'); /** @type {Record<string, [type: NUMBER | STRING | UNKNOWN, fn?: Function]>} */ const globals = { BigInt: [NUMBER], 'Math.min': [NUMBER, Math.min], 'Math.max': [NUMBER, Math.max], 'Math.random': [NUMBER], 'Math.floor': [NUMBER, Math.floor], // @ts-ignore 'Math.f16round': [NUMBER, Math.f16round], 'Math.round': [NUMBER, Math.round], 'Math.abs': [NUMBER, Math.abs], 'Math.acos': [NUMBER, Math.acos], 'Math.asin': [NUMBER, Math.asin], 'Math.atan': [NUMBER, Math.atan], 'Math.atan2': [NUMBER, Math.atan2], 'Math.ceil': [NUMBER, Math.ceil], 'Math.cos': [NUMBER, Math.cos], 'Math.sin': [NUMBER, Math.sin], 'Math.tan': [NUMBER, Math.tan], 'Math.exp': [NUMBER, Math.exp], 'Math.log': [NUMBER, Math.log], 'Math.pow': [NUMBER, Math.pow], 'Math.sqrt': [NUMBER, Math.sqrt], 'Math.clz32': [NUMBER, Math.clz32], 'Math.imul': [NUMBER, Math.imul], 'Math.sign': [NUMBER, Math.sign], 'Math.log10': [NUMBER, Math.log10], 'Math.log2': [NUMBER, Math.log2], 'Math.log1p': [NUMBER, Math.log1p], 'Math.expm1': [NUMBER, Math.expm1], 'Math.cosh': [NUMBER, Math.cosh], 'Math.sinh': [NUMBER, Math.sinh], 'Math.tanh': [NUMBER, Math.tanh], 'Math.acosh': [NUMBER, Math.acosh], 'Math.asinh': [NUMBER, Math.asinh], 'Math.atanh': [NUMBER, Math.atanh], 'Math.trunc': [NUMBER, Math.trunc], 'Math.fround': [NUMBER, Math.fround], 'Math.cbrt': [NUMBER, Math.cbrt], Number: [NUMBER, Number], 'Number.isInteger': [NUMBER, Number.isInteger], 'Number.isFinite': [NUMBER, Number.isFinite], 'Number.isNaN': [NUMBER, Number.isNaN], 'Number.isSafeInteger': [NUMBER, Number.isSafeInteger], 'Number.parseFloat': [NUMBER, Number.parseFloat], 'Number.parseInt': [NUMBER, Number.parseInt], String: [STRING, String], 'String.fromCharCode': [STRING, String.fromCharCode], 'String.fromCodePoint': [STRING, String.fromCodePoint] }; /** @type {Record<string, any>} */ const global_constants = { 'Math.PI': Math.PI, 'Math.E': Math.E, 'Math.LN10': Math.LN10, 'Math.LN2': Math.LN2, 'Math.LOG10E': Math.LOG10E, 'Math.LOG2E': Math.LOG2E, 'Math.SQRT2': Math.SQRT2, 'Math.SQRT1_2': Math.SQRT1_2 }; export class Binding { /** @type {Scope} */ scope; /** @type {Identifier} */ node; /** @type {BindingKind} */ kind; /** @type {DeclarationKind} */ declaration_kind; /** * What the value was initialized with. * For destructured props such as `let { foo = 'bar' } = $props()` this is `'bar'` and not `$props()` * @type {null | Expression | FunctionDeclaration | ClassDeclaration | ImportDeclaration | AST.EachBlock | AST.SnippetBlock} */ initial = null; /** @type {Array<{ node: Identifier; path: AST.SvelteNode[] }>} */ references = []; /** * For `legacy_reactive`: its reactive dependencies * @type {Binding[]} */ legacy_dependencies = []; /** * Legacy props: the `class` in `{ export klass as class}`. $props(): The `class` in { class: klass } = $props() * @type {string | null} */ prop_alias = null; /** * Additional metadata, varies per binding type * @type {null | { inside_rest?: boolean }} */ metadata = null; mutated = false; reassigned = false; /** * * @param {Scope} scope * @param {Identifier} node * @param {BindingKind} kind * @param {DeclarationKind} declaration_kind * @param {Binding['initial']} initial */ constructor(scope, node, kind, declaration_kind, initial) { this.scope = scope; this.node = node; this.initial = initial; this.kind = kind; this.declaration_kind = declaration_kind; } get updated() { return this.mutated || this.reassigned; } /** * @returns {this is Binding & { initial: ArrowFunctionExpression | FunctionDeclaration | FunctionExpression }} */ is_function() { if (this.updated) { // even if it's reassigned to another function, // we can't use it directly as e.g. an event handler return false; } const type = this.initial?.type; return ( type === 'ArrowFunctionExpression' || type === 'FunctionExpression' || type === 'FunctionDeclaration' ); } } class Evaluation { /** @type {Set<any>} */ values; /** * True if there is exactly one possible value * @readonly * @type {boolean} */ is_known = true; /** * True if the value is known to not be null/undefined * @readonly * @type {boolean} */ is_defined = true; /** * True if the value is known to be a string * @readonly * @type {boolean} */ is_string = true; /** * True if the value is known to be a number * @readonly * @type {boolean} */ is_number = true; /** * True if the value is known to be a function * @readonly * @type {boolean} */ is_function = true; /** * @readonly * @type {any} */ value = undefined; /** * * @param {Scope} scope * @param {Expression | FunctionDeclaration} expression * @param {Set<any>} values */ constructor(scope, expression, values) { current_evaluations.set(expression, this); this.values = values; switch (expression.type) { case 'Literal': { this.values.add(expression.value); break; } case 'Identifier': { const binding = scope.get(expression.name); if (binding) { if ( binding.initial?.type === 'CallExpression' && get_rune(binding.initial, scope) === '$props.id' ) { this.values.add(STRING); break; } const is_prop = binding.kind === 'prop' || binding.kind === 'rest_prop' || binding.kind === 'bindable_prop'; if (binding.initial?.type === 'EachBlock' && binding.initial.index === expression.name) { this.values.add(NUMBER); break; } if (!binding.updated && binding.initial !== null && !is_prop) { binding.scope.evaluate(/** @type {Expression} */ (binding.initial), this.values); break; } } else if (expression.name === 'undefined') { this.values.add(undefined); break; } // TODO glean what we can from reassignments // TODO one day, expose props and imports somehow this.values.add(UNKNOWN); break; } case 'BinaryExpression': { const a = scope.evaluate(/** @type {Expression} */ (expression.left)); // `left` cannot be `PrivateIdentifier` unless operator is `in` const b = scope.evaluate(expression.right); if (a.is_known && b.is_known) { this.values.add(binary[expression.operator](a.value, b.value)); break; } switch (expression.operator) { case '!=': case '!==': case '<': case '<=': case '>': case '>=': case '==': case '===': case 'in': case 'instanceof': this.values.add(true); this.values.add(false); break; case '%': case '&': case '*': case '**': case '-': case '/': case '<<': case '>>': case '>>>': case '^': case '|': this.values.add(NUMBER); break; case '+': if (a.is_string || b.is_string) { this.values.add(STRING); } else if (a.is_number && b.is_number) { this.values.add(NUMBER); } else { this.values.add(STRING); this.values.add(NUMBER); } break; default: this.values.add(UNKNOWN); } break; } case 'ConditionalExpression': { const test = scope.evaluate(expression.test); const consequent = scope.evaluate(expression.consequent); const alternate = scope.evaluate(expression.alternate); if (test.is_known) { for (const value of (test.value ? consequent : alternate).values) { this.values.add(value); } } else { for (const value of consequent.values) { this.values.add(value); } for (const value of alternate.values) { this.values.add(value); } } break; } case 'LogicalExpression': { const a = scope.evaluate(expression.left); const b = scope.evaluate(expression.right); if (a.is_known) { if (b.is_known) { this.values.add(logical[expression.operator](a.value, b.value)); break; } if ( (expression.operator === '&&' && !a.value) || (expression.operator === '||' && a.value) || (expression.operator === '??' && a.value != null) ) { this.values.add(a.value); } else { for (const value of b.values) { this.values.add(value); } } break; } for (const value of a.values) { this.values.add(value); } for (const value of b.values) { this.values.add(value); } break; } case 'UnaryExpression': { const argument = scope.evaluate(expression.argument); if (argument.is_known) { this.values.add(unary[expression.operator](argument.value)); break; } switch (expression.operator) { case '!': case 'delete': this.values.add(false); this.values.add(true); break; case '+': case '-': case '~': this.values.add(NUMBER); break; case 'typeof': this.values.add(STRING); break; case 'void': this.values.add(undefined); break; default: this.values.add(UNKNOWN); } break; } case 'CallExpression': { const keypath = get_global_keypath(expression.callee, scope); if (keypath) { if (is_rune(keypath)) { const arg = /** @type {Expression | undefined} */ (expression.arguments[0]); switch (keypath) { case '$state': case '$state.raw': case '$derived': if (arg) { scope.evaluate(arg, this.values); } else { this.values.add(undefined); } break; case '$props.id': this.values.add(STRING); break; case '$effect.tracking': this.values.add(false); this.values.add(true); break; case '$derived.by': if (arg?.type === 'ArrowFunctionExpression' && arg.body.type !== 'BlockStatement') { scope.evaluate(arg.body, this.values); break; } this.values.add(UNKNOWN); break; default: { this.values.add(UNKNOWN); } } break; } if ( Object.hasOwn(globals, keypath) && expression.arguments.every((arg) => arg.type !== 'SpreadElement') ) { const [type, fn] = globals[keypath]; const values = expression.arguments.map((arg) => scope.evaluate(arg)); if (fn && values.every((e) => e.is_known)) { this.values.add(fn(...values.map((e) => e.value))); } else { this.values.add(type); } break; } } this.values.add(UNKNOWN); break; } case 'TemplateLiteral': { let result = expression.quasis[0].value.cooked; for (let i = 0; i < expression.expressions.length; i += 1) { const e = scope.evaluate(expression.expressions[i]); if (e.is_known) { result += e.value + expression.quasis[i + 1].value.cooked; } else { this.values.add(STRING); break; } } this.values.add(result); break; } case 'MemberExpression': { const keypath = get_global_keypath(expression, scope); if (keypath && Object.hasOwn(global_constants, keypath)) { this.values.add(global_constants[keypath]); break; } this.values.add(UNKNOWN); break; } case 'ArrowFunctionExpression': case 'FunctionExpression': case 'FunctionDeclaration': { this.values.add(FUNCTION); break; } default: { this.values.add(UNKNOWN); } } for (const value of this.values) { this.value = value; // saves having special logic for `size === 1` if (value !== STRING && typeof value !== 'string') { this.is_string = false; } if (value !== NUMBER && typeof value !== 'number') { this.is_number = false; } if (value !== FUNCTION) { this.is_function = false; } if (value == null || value === UNKNOWN) { this.is_defined = false; } } if (this.values.size > 1 || typeof this.value === 'symbol') { this.is_known = false; } current_evaluations.delete(expression); } } export class Scope { /** @type {ScopeRoot} */ root; /** * The immediate parent scope * @type {Scope | null} */ parent; /** * Whether or not `var` declarations are contained by this scope * @type {boolean} */ #porous; /** * A map of every identifier declared by this scope, and all the * identifiers that reference it * @type {Map<string, Binding>} */ declarations = new Map(); /** * A map of declarators to the bindings they declare * @type {Map<VariableDeclarator | AST.LetDirective, Binding[]>} */ declarators = new Map(); /** * A set of all the names referenced with this scope * — useful for generating unique names * @type {Map<string, { node: Identifier; path: AST.SvelteNode[] }[]>} */ references = new Map(); /** * The scope depth allows us to determine if a state variable is referenced in its own scope, * which is usually an error. Block statements do not increase this value */ function_depth = 0; /** * If tracing of reactive dependencies is enabled for this scope * @type {null | Expression} */ tracing = null; /** * * @param {ScopeRoot} root * @param {Scope | null} parent * @param {boolean} porous */ constructor(root, parent, porous) { this.root = root; this.parent = parent; this.#porous = porous; this.function_depth = parent ? parent.function_depth + (porous ? 0 : 1) : 0; } /** * @param {Identifier} node * @param {Binding['kind']} kind * @param {DeclarationKind} declaration_kind * @param {null | Expression | FunctionDeclaration | ClassDeclaration | ImportDeclaration | AST.EachBlock | AST.SnippetBlock} initial * @returns {Binding} */ declare(node, kind, declaration_kind, initial = null) { if (this.parent) { if (declaration_kind === 'var' && this.#porous) { return this.parent.declare(node, kind, declaration_kind); } if (declaration_kind === 'import') { return this.parent.declare(node, kind, declaration_kind, initial); } } if (this.declarations.has(node.name)) { const binding = this.declarations.get(node.name); if (binding && binding.declaration_kind !== 'var' && declaration_kind !== 'var') { // This also errors on function types, but that's arguably a good thing // declaring function twice is also caught by acorn in the parse phase e.declaration_duplicate(node, node.name); } } const binding = new Binding(this, node, kind, declaration_kind, initial); validate_identifier_name(binding, this.function_depth); this.declarations.set(node.name, binding); this.root.conflicts.add(node.name); return binding; } child(porous = false) { return new Scope(this.root, this, porous); } /** * @param {string} preferred_name * @returns {string} */ generate(preferred_name) { if (this.#porous) { return /** @type {Scope} */ (this.parent).generate(preferred_name); } preferred_name = preferred_name.replace(/[^a-zA-Z0-9_$]/g, '_').replace(/^[0-9]/, '_'); let name = preferred_name; let n = 1; while ( this.references.has(name) || this.declarations.has(name) || this.root.conflicts.has(name) || is_reserved(name) ) { name = `${preferred_name}_${n++}`; } this.references.set(name, []); this.root.conflicts.add(name); return name; } /** * @param {string} name * @returns {Binding | null} */ get(name) { return this.declarations.get(name) ?? this.parent?.get(name) ?? null; } /** * @param {VariableDeclarator | AST.LetDirective} node * @returns {Binding[]} */ get_bindings(node) { const bindings = this.declarators.get(node); if (!bindings) { throw new Error('No binding found for declarator'); } return bindings; } /** * @param {string} name * @returns {Scope | null} */ owner(name) { return this.declarations.has(name) ? this : this.parent && this.parent.owner(name); } /** * @param {Identifier} node * @param {AST.SvelteNode[]} path */ reference(node, path) { path = [...path]; // ensure that mutations to path afterwards don't affect this reference let references = this.references.get(node.name); if (!references) this.references.set(node.name, (references = [])); references.push({ node, path }); const binding = this.declarations.get(node.name); if (binding) { binding.references.push({ node, path }); } else if (this.parent) { this.parent.reference(node, path); } else { // no binding was found, and this is the top level scope, // which means this is a global this.root.conflicts.add(node.name); } } /** * Does partial evaluation to find an exact value or at least the rough type of the expression. * Only call this once scope has been fully generated in a first pass, * else this evaluates on incomplete data and may yield wrong results. * @param {Expression} expression * @param {Set<any>} [values] */ evaluate(expression, values = new Set()) { const current = current_evaluations.get(expression); if (current) return current; return new Evaluation(this, expression, values); } } /** * Track which expressions are currently being evaluated — this allows * us to prevent cyclical evaluations without passing the map around * @type {Map<Expression | FunctionDeclaration, Evaluation>} */ const current_evaluations = new Map(); /** @type {Record<BinaryOperator, (left: any, right: any) => any>} */ const binary = { '!=': (left, right) => left != right, '!==': (left, right) => left !== right, '<': (left, right) => left < right, '<=': (left, right) => left <= right, '>': (left, right) => left > right, '>=': (left, right) => left >= right, '==': (left, right) => left == right, '===': (left, right) => left === right, in: (left, right) => left in right, instanceof: (left, right) => left instanceof right, '%': (left, right) => left % right, '&': (left, right) => left & right, '*': (left, right) => left * right, '**': (left, right) => left ** right, '+': (left, right) => left + right, '-': (left, right) => left - right, '/': (left, right) => left / right, '<<': (left, right) => left << right, '>>': (left, right) => left >> right, '>>>': (left, right) => left >>> right, '^': (left, right) => left ^ right, '|': (left, right) => left | right }; /** @type {Record<UnaryOperator, (argument: any) => any>} */ const unary = { '-': (argument) => -argument, '+': (argument) => +argument, '!': (argument) => !argument, '~': (argument) => ~argument, typeof: (argument) => typeof argument, void: () => undefined, delete: () => true }; /** @type {Record<LogicalOperator, (left: any, right: any) => any>} */ const logical = { '||': (left, right) => left || right, '&&': (left, right) => left && right, '??': (left, right) => left ?? right }; export class ScopeRoot { /** @type {Set<string>} */ conflicts = new Set(); /** * @param {string} preferred_name */ unique(preferred_name) { preferred_name = preferred_name.replace(/[^a-zA-Z0-9_$]/g, '_'); let final_name = preferred_name; let n = 1; while (this.conflicts.has(final_name)) { final_name = `${preferred_name}_${n++}`; } this.conflicts.add(final_name); const id = b.id(final_name); return id; } } /** * @param {AST.SvelteNode} ast * @param {ScopeRoot} root * @param {boolean} allow_reactive_declarations * @param {Scope | null} parent */ export function create_scopes(ast, root, allow_reactive_declarations, parent) { /** @typedef {{ scope: Scope }} State */ /** * A map of node->associated scope. A node appearing in this map does not necessarily mean that it created a scope * @type {Map<AST.SvelteNode, Scope>} */ const scopes = new Map(); const scope = new Scope(root, parent, false); scopes.set(ast, scope); /** @type {State} */ const state = { scope }; /** @type {[Scope, { node: Identifier; path: AST.SvelteNode[] }][]} */ const references = []; /** @type {[Scope, Pattern | MemberExpression][]} */ const updates = []; /** * An array of reactive declarations, i.e. the `a` in `$: a = b * 2` * @type {Identifier[]} */ const possible_implicit_declarations = []; /** * @param {Scope} scope * @param {Pattern[]} params */ function add_params(scope, params) { for (const param of params) { for (const node of extract_identifiers(param)) { scope.declare(node, 'normal', param.type === 'RestElement' ? 'rest_param' : 'param'); } } } /** * @type {Visitor<Node, State, AST.SvelteNode>} */ const create_block_scope = (node, { state, next }) => { const scope = state.scope.child(true); scopes.set(node, scope); next({ scope }); }; /** * @type {Visitor<AST.ElementLike, State, AST.SvelteNode>} */ const SvelteFragment = (node, { state, next }) => { const scope = state.scope.child(); scopes.set(node, scope); next({ scope }); }; /** * @type {Visitor<AST.Component | AST.SvelteComponent | AST.SvelteSelf, State, AST.SvelteNode>} */ const Component = (node, context) => { node.metadata.scopes = { default: context.state.scope.child() }; if (node.type === 'SvelteComponent') { context.visit(node.expression); } const default_state = determine_slot(node) ? context.state : { scope: node.metadata.scopes.default }; for (const attribute of node.attributes) { if (attribute.type === 'LetDirective') { context.visit(attribute, default_state); } else { context.visit(attribute); } } for (const child of node.fragment.nodes) { let state = default_state; const slot_name = determine_slot(child); if (slot_name !== null) { node.metadata.scopes[slot_name] = context.state.scope.child(); state = { scope: node.metadata.scopes[slot_name] }; } context.visit(child, state); } }; /** * @type {Visitor<AST.AnimateDirective | AST.TransitionDirective | AST.UseDirective, State, AST.SvelteNode>} */ const SvelteDirective = (node, { state, path, visit }) => { state.scope.reference(b.id(node.name.split('.')[0]), path); if (node.expression) { visit(node.expression); } }; let has_await = false; walk(ast, state, { AwaitExpression(node, context) { // this doesn't _really_ belong here, but it allows us to // automatically opt into runes mode on encountering // blocking awaits, without doing an additional walk // before the analysis occurs // TODO remove this in Svelte 7.0 or whenever we get rid of legacy support has_await ||= context.path.every( ({ type }) => type !== 'ArrowFunctionExpression' && type !== 'FunctionExpression' && type !== 'FunctionDeclaration' ); context.next(); }, // references Identifier(node, { path, state }) { const parent = path.at(-1); if ( parent && is_reference(node, /** @type {Node} */ (parent)) && // TSTypeAnnotation, TSInterfaceDeclaration etc - these are normally already filtered out, // but for the migration they aren't, so we need to filter them out here // TODO -> once migration script is gone we can remove this check !parent.type.startsWith('TS') ) { references.push([state.scope, { node, path: path.slice() }]); } }, LabeledStatement(node, { path, next }) { if (path.length > 1 || !allow_reactive_declarations) return next(); if (node.label.name !== '$') return next(); // create a scope for the $: block const scope = state.scope.child(); scopes.set(node, scope); if ( node.body.type === 'ExpressionStatement' && node.body.expression.type === 'AssignmentExpression' ) { for (const id of extract_identifiers(node.body.expression.left)) { if (!id.name.startsWith('$')) { possible_implicit_declarations.push(id); } } } next({ scope }); }, SvelteFragment, SlotElement: SvelteFragment, SvelteElement: SvelteFragment, RegularElement: SvelteFragment, LetDirective(node, context) { const scope = context.state.scope; /** @type {Binding[]} */ const bindings = []; scope.declarators.set(node, bindings); if (node.expression) { for (const id of extract_identifiers_from_destructuring(node.expression)) { const binding = scope.declare(id, 'template', 'const'); scope.reference(id, [context.path[context.path.length - 1], node]); bindings.push(binding); } } else { /** @type {Identifier} */ const id = { name: node.name, type: 'Identifier', start: node.start, end: node.end }; const binding = scope.declare(id, 'template', 'const'); scope.reference(id, [context.path[context.path.length - 1], node]); bindings.push(binding); } }, Component: (node, context) => { context.state.scope.reference(b.id(node.name), context.path); Component(node, context); }, SvelteSelf: Component, SvelteComponent: Component, // updates AssignmentExpression(node, { state, next }) { updates.push([state.scope, node.left]); next(); }, UpdateExpression(node, { state, next }) { updates.push([state.scope, /** @type {Identifier | MemberExpression} */ (node.argument)]); next(); }, ImportDeclaration(node, { state }) { for (const specifier of node.specifiers) { state.scope.declare(specifier.local, 'normal', 'import', node); } }, FunctionExpression(node, { state, next }) { const scope = state.scope.child(); scopes.set(node, scope); if (node.id) scope.declare(node.id, 'normal', 'function'); add_params(scope, node.params); next({ scope }); }, FunctionDeclaration(node, { state, next }) { if (node.id) state.scope.declare(node.id, 'normal', 'function', node); const scope = state.scope.child(); scopes.set(node, scope); add_params(scope, node.params); next({ scope }); }, ArrowFunctionExpression(node, { state, next }) { const scope = state.scope.child(); scopes.set(node, scope); add_params(scope, node.params); next({ scope }); }, ForStatement: create_block_scope, ForInStatement: create_block_scope, ForOfStatement: create_block_scope, SwitchStatement: create_block_scope, BlockStatement(node, context) { const parent = context.path.at(-1); if ( parent?.type === 'FunctionDeclaration' || parent?.type === 'FunctionExpression' || parent?.type === 'ArrowFunctionExpression' ) { // We already created a new scope for the function context.next(); } else { create_block_scope(node, context); } }, ClassDeclaration(node, { state, next }) { if (node.id) state.scope.declare(node.id, 'normal', 'let', node); next(); }, VariableDeclaration(node, { state, path, next }) { const is_parent_const_tag = path.at(-1)?.type === 'ConstTag'; for (const declarator of node.declarations) { /** @type {Binding[]} */ const bindings = []; state.scope.declarators.set(declarator, bindings); for (const id of extract_identifiers(declarator.id)) { const binding = state.scope.declare( id, is_parent_const_tag ? 'template' : 'normal', node.kind, declarator.init ); bindings.push(binding); } } next(); }, CatchClause(node, { state, next }) { if (node.param) { const scope = state.scope.child(true); scopes.set(node, scope); for (const id of extract_identifiers(node.param)) { scope.declare(id, 'normal', 'let'); } next({ scope }); } else { next(); } }, EachBlock(node, { state, visit }) { visit(node.expression); // context and children are a new scope const scope = state.scope.child(); scopes.set(node, scope); if (node.context) { // declarations for (const id of extract_identifiers(node.context)) { const binding = scope.declare(id, 'each', 'const'); let inside_rest = false; let is_rest_id = false; walk(node.context, null, { Identifier(node) { if (inside_rest && node === id) { is_rest_id = true; } }, RestElement(_, { next }) { const prev = inside_rest; inside_rest = true; next(); inside_rest = prev; } }); binding.metadata = { inside_rest: is_rest_id }; } // Visit to pick up references from default initializers visit(node.context, { scope }); } if (node.index) { const is_keyed = node.key && (node.key.type !== 'Identifier' || !node.index || node.key.name !== node.index); scope.declare(b.id(node.index), is_keyed ? 'template' : 'static', 'const', node); } if (node.key) visit(node.key, { scope }); // children for (const child of node.body.nodes) { visit(child, { scope }); } if (node.fallback) visit(node.fallback, { scope }); node.metadata = { expression: create_expression_metadata(), keyed: false, contains_group_binding: false, index: scope.root.unique('$$index'), declarations: scope.declarations, is_controlled: false, // filled in during analysis transitive_deps: new Set() }; }, AwaitBlock(node, context) { context.visit(node.expression); if (node.pending) { context.visit(node.pending); } if (node.then) { context.visit(node.then); if (node.value) { const then_scope = /** @type {Scope} */ (scopes.get(node.then)); const value_scope = context.state.scope.child(); scopes.set(node.value, value_scope); context.visit(node.value, { scope: value_scope }); for (const id of extract_identifiers(node.value)) { then_scope.declare(id, 'template', 'const'); value_scope.declare(id, 'normal', 'const'); } } } if (node.catch) { context.visit(node.catch); if (node.error) { const catch_scope = /** @type {Scope} */ (scopes.get(node.catch)); const error_scope = context.state.scope.child(); scopes.set(node.error, error_scope); context.visit(node.error, { scope: error_scope }); for (const id of extract_identifiers(node.error)) { catch_scope.declare(id, 'template', 'const'); error_scope.declare(id, 'normal', 'const'); } } } }, SnippetBlock(node, context) { const state = context.state; let scope = state.scope; scope.declare(node.expression, 'normal', 'function', node); const child_scope = state.scope.child(); scopes.set(node, child_scope); for (const param of node.parameters) { for (const id of extract_identifiers(param)) { child_scope.declare(id, 'snippet', 'let'); } } context.next({ scope: child_scope }); }, Fragment: (node, context) => { const scope = context.state.scope.child(node.metadata.transparent); scopes.set(node, scope); context.next({ scope }); }, BindDirective(node, context) { updates.push([ context.state.scope, /** @type {Identifier | MemberExpression} */ (node.expression) ]); context.next(); }, TransitionDirective: SvelteDirective, AnimateDirective: SvelteDirective, UseDirective: SvelteDirective, // using it's own function instead of `SvelteDirective` because // StyleDirective doesn't have expressions and are generally already // handled by `Identifier`. This is the special case for the shorthand // eg <button style:height /> where the variable has the same name of // the css property StyleDirective(node, { path, state, next }) { if (node.value === true) { state.scope.reference(b.id(node.name), path.concat(node)); } next(); } // TODO others }); for (const id of possible_implicit_declarations) { const binding = scope.get(id.name); if (binding) continue; // TODO can also be legacy_reactive if declared outside of reactive statement scope.declare(id, 'legacy_reactive', 'let'); } // we do this after the fact, so that we don't need to worry // about encountering references before their declarations for (const [scope, { node, path }] of references) { scope.reference(node, path); } for (const [scope, node] of updates) { for (const expression of unwrap_pattern(node)) { const left = object(expression); const binding = left && scope.get(left.name); if (binding !== null && left !== binding.node) { if (left === expression) { binding.reassigned = true; } else { binding.mutated = true; } } } } return { has_await, scope, scopes }; } /** * @template {{ scope: Scope, scopes: Map<AST.SvelteNode, Scope> }} State * @param {AST.SvelteNode} node * @param {Context<AST.SvelteNode, State>} context */ export function set_scope(node, { next, state }) { const scope = state.scopes.get(node); next(scope !== undefined && scope !== state.scope ? { ...state, scope } : state); } /** * Returns the name of the rune if the given expression is a `CallExpression` using a rune. * @param {Node | null | undefined} node * @param {Scope} scope */ export function get_rune(node, scope) { if (!node) return null; if (node.type !== 'CallExpression') return null; const keypath = get_global_keypath(node.callee, scope); if (!keypath || !is_rune(keypath)) return null; return keypath; } /** * Returns the name of the rune if the given expression is a `CallExpression` using a rune. * @param {Expression | Super} node * @param {Scope} scope */ function get_global_keypath(node, scope) { let n = node; let joined = ''; while (n.type === 'MemberExpression') { if (n.computed) return null; if (n.property.type !== 'Identifier') return null; joined = '.' + n.property.name + joined; n = n.object; } if (n.type === 'CallExpression' && n.callee.type === 'Identifier') { joined = '()' + joined; n = n.callee; } if (n.type !== 'Identifier') return null; const binding = scope.get(n.name); if (binding !== null) return null; // rune name, but references a variable or store return n.name + joined; }
```

# compiler/phases/types.d.ts

```ts
import type { AST, Binding, StateField } from '#compiler'; import type { CallExpression, ClassBody, Identifier, LabeledStatement, Node, Program } from 'estree'; import type { Scope, ScopeRoot } from './scope.js'; export interface Js { ast: Program; scope: Scope; scopes: Map<AST.SvelteNode, Scope>; has_await: boolean; } export interface Template { ast: AST.Fragment; scope: Scope; scopes: Map<AST.SvelteNode, Scope>; } export interface ReactiveStatement { assignments: Set<Binding>; dependencies: Binding[]; } /** * Analysis common to modules and components */ export interface Analysis { module: Js; /** @deprecated use `component_name` from `state.js` instead */ name: string; // TODO should this be filename? it's used in `compileModule` as well as `compile` /** @deprecated use `runes` from `state.js` instead */ runes: boolean; immutable: boolean; tracing: boolean; comments: AST.JSComment[]; classes: Map<ClassBody, Map<string, StateField>>; // TODO figure out if we can move this to ComponentAnalysis accessors: boolean; /** A set of deriveds that contain `await` expressions */ async_deriveds: Set<CallExpression>; } export interface ComponentAnalysis extends Analysis { root: ScopeRoot; instance: Js; template: Template; /** Used for CSS pruning and scoping */ elements: Array<AST.RegularElement | AST.SvelteElement>; runes: boolean; maybe_runes: boolean; tracing: boolean; exports: Array<{ name: string; alias: string | null }>; /** Whether the component uses `$$props` */ uses_props: boolean; /** The component ID variable name, if any */ props_id: Identifier | null; /** Whether the component uses `$$restProps` */ uses_rest_props: boolean; /** Whether the component uses `$$slots` */ uses_slots: boolean; uses_component_bindings: boolean; uses_render_tags: boolean; needs_context: boolean; needs_mutation_validation: boolean; needs_props: boolean; /** Set to the first event directive (on:x) found on a DOM element in the code */ event_directive_node: AST.OnDirective | null; /** true if uses event attributes (onclick) on a DOM element */ uses_event_attributes: boolean; /** * Contains the content of `<svelte:options customElement={...} />`, * or if not present a boolean which corresponds to the compiler option value */ custom_element: boolean | AST.SvelteOptions['customElement']; /** If `true`, should append styles through JavaScript */ inject_styles: boolean; reactive_statements: Map<LabeledStatement, ReactiveStatement>; /** Identifiers that make up the `bind:group` expression -> internal group binding name */ binding_groups: Map<[key: string, bindings: Array<Binding | null>], Identifier>; slot_names: Map<string, AST.SlotElement>; css: { ast: AST.CSS.StyleSheet | null; hash: string; keyframes: string[]; has_global: boolean; }; /** @deprecated use `source` from `state.js` instead */ source: string; undefined_exports: Map<string, Node>; /** * Every render tag/component, and whether it could be definitively resolved or not */ snippet_renderers: Map< AST.RenderTag | AST.Component | AST.SvelteComponent | AST.SvelteSelf, boolean >; /** * Every snippet that is declared locally */ snippets: Set<AST.SnippetBlock>; } declare module 'estree' { interface ArrowFunctionExpression { metadata: { hoisted: boolean; hoisted_params: Pattern[]; scope: Scope; }; } interface FunctionExpression { metadata: { hoisted: boolean; hoisted_params: Pattern[]; scope: Scope; }; } interface FunctionDeclaration { metadata: { hoisted: boolean; hoisted_params: Pattern[]; scope: Scope; }; } }
```

# compiler/preprocess/decode_sourcemap.js

```js
/** @import { Processed } from './public.js' */ import { decode as decode_mappings } from '@jridgewell/sourcemap-codec'; /** * Import decoded sourcemap from mozilla/source-map/SourceMapGenerator * Forked from source-map/lib/source-map-generator.js * from methods _serializeMappings and toJSON. * We cannot use source-map.d.ts types, because we access hidden properties. * @param {any} generator */ function decoded_sourcemap_from_generator(generator) { let previous_generated_line = 1; /** @type {number[][][]} */ const converted_mappings = [[]]; let result_line = converted_mappings[0]; let result_segment; let mapping; const source_idx = generator._sources .toArray() // @ts-ignore .reduce((acc, val, idx) => ((acc[val] = idx), acc), {}); const name_idx = generator._names .toArray() // @ts-ignore .reduce((acc, val, idx) => ((acc[val] = idx), acc), {}); const mappings = generator._mappings.toArray(); for (let i = 0, len = mappings.length; i < len; i++) { mapping = mappings[i]; if (mapping.generatedLine > previous_generated_line) { while (mapping.generatedLine > previous_generated_line) { converted_mappings.push([]); previous_generated_line++; } result_line = converted_mappings[mapping.generatedLine - 1]; // line is one-based } else if (i > 0) { const previous_mapping = mappings[i - 1]; if ( // sorted by selectivity mapping.generatedColumn === previous_mapping.generatedColumn && mapping.originalColumn === previous_mapping.originalColumn && mapping.name === previous_mapping.name && mapping.generatedLine === previous_mapping.generatedLine && mapping.originalLine === previous_mapping.originalLine && mapping.source === previous_mapping.source ) { continue; } } result_line.push([mapping.generatedColumn]); result_segment = result_line[result_line.length - 1]; if (mapping.source != null) { result_segment.push( ...[source_idx[mapping.source], mapping.originalLine - 1, mapping.originalColumn] ); if (mapping.name != null) { result_segment.push(name_idx[mapping.name]); } } } /** * @type {{ * version: number; * sources: string[]; * names: string[]; * mappings: number[][][]; * file?: string; * }} */ const map = { version: generator._version, sources: generator._sources.toArray(), names: generator._names.toArray(), mappings: converted_mappings }; if (generator._file != null) { map.file = generator._file; } // not needed: map.sourcesContent and map.sourceRoot return map; } /** * @param {Processed} processed */ export function decode_map(processed) { let decoded_map = typeof processed.map === 'string' ? JSON.parse(processed.map) : processed.map; if (typeof decoded_map.mappings === 'string') { decoded_map.mappings = decode_mappings(decoded_map.mappings); } if (decoded_map._mappings && decoded_map.constructor.name === 'SourceMapGenerator') { // import decoded sourcemap from mozilla/source-map/SourceMapGenerator decoded_map = decoded_sourcemap_from_generator(decoded_map); } return decoded_map; }
```

# compiler/preprocess/index.js

```js
/** @import { Processed, Preprocessor, MarkupPreprocessor, PreprocessorGroup } from './public.js' */ /** @import { SourceUpdate, Source } from './private.js' */ /** @import { DecodedSourceMap, RawSourceMap } from '@ampproject/remapping' */ import { getLocator } from 'locate-character'; import { MappedCode, parse_attached_sourcemap, sourcemap_add_offset, combine_sourcemaps, get_basename } from '../utils/mapped_code.js'; import { decode_map } from './decode_sourcemap.js'; import { replace_in_code, slice_source } from './replace_in_code.js'; /** * Represents intermediate states of the preprocessing. * Implements the Source interface. */ class PreprocessResult { /** @type {string} */ source; /** @type {string | undefined} The filename passed as-is to preprocess */ filename; // sourcemap_list is sorted in reverse order from last map (index 0) to first map (index -1) // so we use sourcemap_list.unshift() to add new maps // https://github.com/ampproject/remapping#multiple-transformations-of-a-file /** * @default [] * @type {Array<DecodedSourceMap | RawSourceMap>} */ sourcemap_list = []; /** * @default [] * @type {string[]} */ dependencies = []; /** * @type {string | null} last part of the filename, as used for `sources` in sourcemaps */ file_basename = /** @type {any} */ (undefined); /** * @type {ReturnType<typeof getLocator>} */ get_location = /** @type {any} */ (undefined); /** * @param {string} source * @param {string} [filename] */ constructor(source, filename) { this.source = source; this.filename = filename; this.update_source({ string: source }); // preprocess source must be relative to itself or equal null this.file_basename = filename == null ? null : get_basename(filename); } /** * @param {SourceUpdate} opts */ update_source({ string: source, map, dependencies }) { if (source != null) { this.source = source; this.get_location = getLocator(source); } if (map) { this.sourcemap_list.unshift(map); } if (dependencies) { this.dependencies.push(...dependencies); } } /** * @returns {Processed} */ to_processed() { // Combine all the source maps for each preprocessor function into one // @ts-expect-error TODO there might be a bug in hiding here const map = combine_sourcemaps(this.file_basename, this.sourcemap_list); return { // TODO return separated output, in future version where svelte.compile supports it: // style: { code: styleCode, map: styleMap }, // script { code: scriptCode, map: scriptMap }, // markup { code: markupCode, map: markupMap }, code: this.source, dependencies: [...new Set(this.dependencies)], // @ts-expect-error TODO there might be a bug in hiding here map, toString: () => this.source }; } } /** * Convert preprocessor output for the tag content into MappedCode * @param {Processed} processed * @param {{ line: number; column: number; }} location * @param {string} file_basename * @returns {MappedCode} */ function processed_content_to_code(processed, location, file_basename) { // Convert the preprocessed code and its sourcemap to a MappedCode /** * @type {DecodedSourceMap | undefined} */ let decoded_map = undefined; if (processed.map) { decoded_map = decode_map(processed); // decoded map may not have sources for empty maps like `{ mappings: '' }` if (decoded_map?.sources) { // offset only segments pointing at original component source const source_index = decoded_map.sources.indexOf(file_basename); if (source_index !== -1) { sourcemap_add_offset(decoded_map, location, source_index); } } } return MappedCode.from_processed(processed.code, decoded_map); } /** * Given the whole tag including content, return a `MappedCode` * representing the tag content replaced with `processed`. * @param {Processed} processed * @param {'style' | 'script'} tag_name * @param {string} original_attributes * @param {string} generated_attributes * @param {Source} source * @returns {MappedCode} */ function processed_tag_to_code( processed, tag_name, original_attributes, generated_attributes, source ) { const { file_basename, get_location } = source; /** * @param {string} code * @param {number} offset */ const build_mapped_code = (code, offset) => MappedCode.from_source(slice_source(code, offset, source)); // To map the open/close tag and content starts positions correctly, we need to // differentiate between the original attributes and the generated attributes: // `source` contains the original attributes and its get_location maps accordingly. const original_tag_open = `<${tag_name}${original_attributes}>`; const tag_open = `<${tag_name}${generated_attributes}>`; /** @type {MappedCode} */ let tag_open_code; if (original_tag_open.length !== tag_open.length) { // Generate a source map for the open tag /** @type {DecodedSourceMap['mappings']} */ const mappings = [ [ // start of tag [0, 0, 0, 0], // end of tag start [`<${tag_name}`.length, 0, 0, `<${tag_name}`.length] ] ]; const line = tag_open.split('\n').length - 1; const column = tag_open.length - (line === 0 ? 0 : tag_open.lastIndexOf('\n')) - 1; while (mappings.length <= line) { // end of tag start again, if this is a multi line mapping mappings.push([[0, 0, 0, `<${tag_name}`.length]]); } // end of tag mappings[line].push([ column, 0, original_tag_open.split('\n').length - 1, original_tag_open.length - original_tag_open.lastIndexOf('\n') - 1 ]); /** @type {DecodedSourceMap} */ const map = { version: 3, names: [], sources: [file_basename], mappings }; sourcemap_add_offset(map, get_location(0), 0); tag_open_code = MappedCode.from_processed(tag_open, map); } else { tag_open_code = build_mapped_code(tag_open, 0); } const tag_close = `</${tag_name}>`; const tag_close_code = build_mapped_code( tag_close, original_tag_open.length + source.source.length ); parse_attached_sourcemap(processed, tag_name); const content_code = processed_content_to_code( processed, get_location(original_tag_open.length), file_basename ); return tag_open_code.concat(content_code).concat(tag_close_code); } const attribute_pattern = /([\w-$]+\b)(?:=(?:"([^"]*)"|'([^']*)'|(\S+)))?/g; /** * @param {string} str */ function parse_tag_attributes(str) { /** @type {Record<string, string | boolean>} */ const attrs = {}; /** @type {RegExpMatchArray | null} */ let match; while ((match = attribute_pattern.exec(str)) !== null) { const name = match[1]; const value = match[2] || match[3] || match[4]; attrs[name] = !value || value; } return attrs; } /** * @param {Record<string, string | boolean> | undefined} attributes */ function stringify_tag_attributes(attributes) { if (!attributes) return; let value = Object.entries(attributes) .map(([key, value]) => (value === true ? key : `${key}="${value}"`)) .join(' '); if (value) { value = ' ' + value; } return value; } const regex_style_tags = /<!--[^]*?-->|<style((?:\s+[^=>'"/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/style>)/g; const regex_script_tags = /<!--[^]*?-->|<script((?:\s+[^=>'"/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/script>)/g; /** * Calculate the updates required to process all instances of the specified tag. * @param {'style' | 'script'} tag_name * @param {Preprocessor} preprocessor * @param {Source} source * @returns {Promise<SourceUpdate>} */ async function process_tag(tag_name, preprocessor, source) { const { filename, source: markup } = source; const tag_regex = tag_name === 'style' ? regex_style_tags : regex_script_tags; /** * @type {string[]} */ const dependencies = []; /** * @param {string} tag_with_content * @param {number} tag_offset * @returns {Promise<MappedCode>} */ async function process_single_tag(tag_with_content, attributes = '', content = '', tag_offset) { const no_change = () => MappedCode.from_source(slice_source(tag_with_content, tag_offset, source)); if (!attributes && !content) return no_change(); const processed = await preprocessor({ content: content || '', attributes: parse_tag_attributes(attributes || ''), markup, filename }); if (!processed) return no_change(); if (processed.dependencies) dependencies.push(...processed.dependencies); if (!processed.map && processed.code === content) return no_change(); return processed_tag_to_code( processed, tag_name, attributes, stringify_tag_attributes(processed.attributes) ?? attributes, slice_source(content, tag_offset, source) ); } const { string, map } = await replace_in_code(tag_regex, process_single_tag, source); return { string, map, dependencies }; } /** * @param {MarkupPreprocessor} process * @param {Source} source */ async function process_markup(process, source) { const processed = await process({ content: source.source, filename: source.filename }); if (processed) { return { string: processed.code, map: processed.map ? // TODO: can we use decode_sourcemap? typeof processed.map === 'string' ? JSON.parse(processed.map) : processed.map : undefined, dependencies: processed.dependencies }; } else { return {}; } } /** * The preprocess function provides convenient hooks for arbitrarily transforming component source code. * For example, it can be used to convert a `<style lang="sass">` block into vanilla CSS. * * @param {string} source * @param {PreprocessorGroup | PreprocessorGroup[]} preprocessor * @param {{ filename?: string }} [options] * @returns {Promise<Processed>} */ export default async function preprocess(source, preprocessor, options) { /** * @type {string | undefined} */ const filename = (options && options.filename) || /** @type {any} */ (preprocessor).filename; // legacy const preprocessors = preprocessor ? Array.isArray(preprocessor) ? preprocessor : [preprocessor] : []; const result = new PreprocessResult(source, filename); // TODO keep track: what preprocessor generated what sourcemap? // to make debugging easier = detect low-resolution sourcemaps in fn combine_mappings for (const preprocessor of preprocessors) { if (preprocessor.markup) { // @ts-expect-error TODO there might be a bug in hiding here result.update_source(await process_markup(preprocessor.markup, result)); } if (preprocessor.script) { // @ts-expect-error TODO there might be a bug in hiding here result.update_source(await process_tag('script', preprocessor.script, result)); } if (preprocessor.style) { // @ts-expect-error TODO there might be a bug in hiding here result.update_source(await process_tag('style', preprocessor.style, result)); } } return result.to_processed(); }
```

# compiler/preprocess/legacy-public.d.ts

```ts
import { MarkupPreprocessor as M, Preprocessor as PP, PreprocessorGroup as PG, Processed as P, SveltePreprocessor as S } from './public.js'; /** @deprecated import this from 'svelte/preprocess' instead */ export type MarkupPreprocessor = M; /** @deprecated import this from 'svelte/preprocess' instead */ export type Preprocessor = PP; /** @deprecated import this from 'svelte/preprocess' instead */ export type PreprocessorGroup = PG; /** @deprecated import this from 'svelte/preprocess' instead */ export type Processed = P; /** @deprecated import this from 'svelte/preprocess' instead */ export type SveltePreprocessor<PreprocessorType extends keyof PG, Options = any> = S< PreprocessorType, Options >;
```

# compiler/preprocess/private.d.ts

```ts
import { DecodedSourceMap } from '@ampproject/remapping'; import { Location } from 'locate-character'; import { MappedCode } from '../utils/mapped_code.js'; export interface Source { source: string; get_location: (search: number) => Location; file_basename: string; filename?: string; } export interface SourceUpdate { string?: string; map?: DecodedSourceMap; dependencies?: string[]; } export interface Replacement { offset: number; length: number; replacement: MappedCode; }
```

# compiler/preprocess/public.d.ts

```ts
/** * The result of a preprocessor run. If the preprocessor does not return a result, it is assumed that the code is unchanged. */ export interface Processed { /** * The new code */ code: string; /** * A source map mapping back to the original code */ map?: string | object; // we are opaque with the type here to avoid dependency on the remapping module for our public types. /** * A list of additional files to watch for changes */ dependencies?: string[]; /** * Only for script/style preprocessors: The updated attributes to set on the tag. If undefined, attributes stay unchanged. */ attributes?: Record<string, string | boolean>; toString?: () => string; } /** * A markup preprocessor that takes a string of code and returns a processed version. */ export type MarkupPreprocessor = (options: { /** * The whole Svelte file content */ content: string; /** * The filename of the Svelte file */ filename?: string; }) => Processed | void | Promise<Processed | void>; /** * A script/style preprocessor that takes a string of code and returns a processed version. */ export type Preprocessor = (options: { /** * The script/style tag content */ content: string; /** * The attributes on the script/style tag */ attributes: Record<string, string | boolean>; /** * The whole Svelte file content */ markup: string; /** * The filename of the Svelte file */ filename?: string; }) => Processed | void | Promise<Processed | void>; /** * A preprocessor group is a set of preprocessors that are applied to a Svelte file. */ export interface PreprocessorGroup { /** Name of the preprocessor. Will be a required option in the next major version */ name?: string; markup?: MarkupPreprocessor; style?: Preprocessor; script?: Preprocessor; } /** * @description Utility type to extract the type of a preprocessor from a preprocessor group * @deprecated Create this utility type yourself instead */ export interface SveltePreprocessor< PreprocessorType extends keyof PreprocessorGroup, Options = any > { (options?: Options): Required<Pick<PreprocessorGroup, PreprocessorType>>; }
```

# compiler/preprocess/replace_in_code.js

```js
/** @import { Source, Replacement } from './private.js' */ import { MappedCode } from '../utils/mapped_code.js'; /** * @param {string} code_slice * @param {number} offset * @param {Source} opts * @returns {Source} */ export function slice_source(code_slice, offset, { file_basename, filename, get_location }) { return { source: code_slice, get_location: (index) => get_location(index + offset), file_basename, filename }; } /** * @param {RegExp} re * @param {(...match: any[]) => Promise<MappedCode>} get_replacement * @param {string} source */ function calculate_replacements(re, get_replacement, source) { /** * @type {Array<Promise<Replacement>>} */ const replacements = []; source.replace(re, (...match) => { replacements.push( get_replacement(...match).then((replacement) => { const matched_string = match[0]; const offset = match[match.length - 2]; return { offset, length: matched_string.length, replacement }; }) ); return ''; }); return Promise.all(replacements); } /** * @param {Replacement[]} replacements * @param {Source} source * @returns {MappedCode} */ function perform_replacements(replacements, source) { const out = new MappedCode(); let last_end = 0; for (const { offset, length, replacement } of replacements) { const unchanged_prefix = MappedCode.from_source( slice_source(source.source.slice(last_end, offset), last_end, source) ); out.concat(unchanged_prefix).concat(replacement); last_end = offset + length; } const unchanged_suffix = MappedCode.from_source( slice_source(source.source.slice(last_end), last_end, source) ); return out.concat(unchanged_suffix); } /** * @param {RegExp} regex * @param {(...match: any[]) => Promise<MappedCode>} get_replacement * @param {Source} location * @returns {Promise<MappedCode>} */ export async function replace_in_code(regex, get_replacement, location) { const replacements = await calculate_replacements(regex, get_replacement, location.source); return perform_replacements(replacements, location); }
```

# compiler/private.d.ts

```ts
export * from './types/index'; export * from './index';
```

# compiler/public.d.ts

```ts
export * from './index.js'; export type { MarkupPreprocessor, Preprocessor, PreprocessorGroup, Processed } from './preprocess/public'; export type { CompileError, CompileOptions, ModuleCompileOptions, CompileResult, Warning } from './types/index'; export type { AST } from './types/template';
```

# compiler/state.js

```js
/** @import { Location } from 'locate-character' */ /** @import { CompileOptions } from './types' */ /** @import { AST, Warning } from '#compiler' */ import { getLocator } from 'locate-character'; import { sanitize_location } from '../utils.js'; /** @typedef {{ start?: number, end?: number }} NodeLike */ /** @type {Warning[]} */ export let warnings = []; /** * The filename relative to the rootDir (if specified). * This should not be used in the compiler output except in dev mode * @type {string} */ export let filename; /** * The name of the component that is used in the `export default function ...` statement. */ export let component_name = '<unknown>'; /** * The original source code * @type {string} */ export let source; /** * True if compiling with `dev: true` * @type {boolean} */ export let dev; export let runes = false; export let locator = getLocator('', { offsetLine: 1 }); /** @param {string} value */ export function set_source(value) { source = value; locator = getLocator(source, { offsetLine: 1 }); } /** * @param {AST.SvelteNode & { start?: number | undefined }} node */ export function locate_node(node) { const loc = /** @type {Location} */ (locator(/** @type {number} */ (node.start))); return `${sanitize_location(filename)}:${loc?.line}:${loc.column}`; } /** @type {NonNullable<CompileOptions['warningFilter']>} */ export let warning_filter; /** * The current stack of ignored warnings * @type {Set<string>[]} */ export let ignore_stack = []; /** * For each node the list of warnings that should be ignored for that node. * Exists in addition to `ignore_stack` because not all warnings are emitted * while the stack is being built. * @type {Map<AST.SvelteNode | NodeLike, Set<string>[]>} */ export let ignore_map = new Map(); /** * @param {string[]} ignores */ export function push_ignore(ignores) { const next = new Set([...(ignore_stack.at(-1) || []), ...ignores]); ignore_stack.push(next); } export function pop_ignore() { ignore_stack.pop(); } /** * * @param {(warning: Warning) => boolean} fn */ export function reset_warnings(fn = () => true) { warning_filter = fn; warnings = []; } /** * @param {AST.SvelteNode | NodeLike} node * @param {import('../constants.js').IGNORABLE_RUNTIME_WARNINGS[number]} code * @returns */ export function is_ignored(node, code) { return dev && !!ignore_map.get(node)?.some((codes) => codes.has(code)); } /** * @param {{ * dev: boolean; * filename: string; * component_name?: string; * rootDir?: string; * runes: boolean; * }} state */ export function reset(state) { const root_dir = state.rootDir?.replace(/\\/g, '/'); filename = state.filename.replace(/\\/g, '/'); dev = state.dev; runes = state.runes; component_name = state.component_name ?? '(unknown)'; if (typeof root_dir === 'string' && filename.startsWith(root_dir)) { // make filename relative to rootDir filename = filename.replace(root_dir, '').replace(/^[/\\]/, ''); } ignore_stack = []; ignore_map.clear(); }
```

# compiler/types/css.d.ts

```ts
import type { AST } from '#compiler'; export namespace _CSS { export interface BaseNode { start: number; end: number; } export interface StyleSheet extends BaseNode { type: 'StyleSheet'; attributes: any[]; // TODO children: Array<Atrule | Rule>; content: { start: number; end: number; styles: string; /** Possible comment atop the style tag */ comment: AST.Comment | null; }; } export interface Atrule extends BaseNode { type: 'Atrule'; name: string; prelude: string; block: Block | null; } export interface Rule extends BaseNode { type: 'Rule'; prelude: SelectorList; block: Block; /** @internal */ metadata: { parent_rule: null | Rule; has_local_selectors: boolean; /** * `true` if the rule contains a ComplexSelector whose RelativeSelectors are all global or global-like */ has_global_selectors: boolean; /** * `true` if the rule contains a `:global` selector, and therefore everything inside should be unscoped */ is_global_block: boolean; }; } /** * A list of selectors, e.g. `a, b, c {}` */ export interface SelectorList extends BaseNode { type: 'SelectorList'; /** * The `a`, `b` and `c` in `a, b, c {}` */ children: ComplexSelector[]; } /** * A complex selector, e.g. `a b c {}` */ export interface ComplexSelector extends BaseNode { type: 'ComplexSelector'; /** * The `a`, `b` and `c` in `a b c {}` */ children: RelativeSelector[]; /** @internal */ metadata: { rule: null | Rule; is_global: boolean; /** True if this selector applies to an element. For global selectors, this is defined in css-analyze, for others in css-prune while scoping */ used: boolean; }; } /** * A relative selector, e.g the `a` and `> b` in `a > b {}` */ export interface RelativeSelector extends BaseNode { type: 'RelativeSelector'; /** * In `a > b`, `> b` forms one relative selector, and `>` is the combinator. `null` for the first selector. */ combinator: null | Combinator; /** * The `b:is(...)` in `> b:is(...)` */ selectors: SimpleSelector[]; /** @internal */ metadata: { /** * `true` if the whole selector is unscoped, e.g. `:global(...)` or `:global` or `:global.x`. * Selectors like `:global(...).x` are not considered global, because they still need scoping. * Selectors like `:global(...):is/where/not/has(...)` are only considered global if all their * children are global. */ is_global: boolean; /** `:root`, `:host`, `::view-transition`, or selectors after a `:global` */ is_global_like: boolean; scoped: boolean; }; } export interface TypeSelector extends BaseNode { type: 'TypeSelector'; name: string; } export interface IdSelector extends BaseNode { type: 'IdSelector'; name: string; } export interface ClassSelector extends BaseNode { type: 'ClassSelector'; name: string; } export interface AttributeSelector extends BaseNode { type: 'AttributeSelector'; name: string; matcher: string | null; value: string | null; flags: string | null; } export interface PseudoElementSelector extends BaseNode { type: 'PseudoElementSelector'; name: string; } export interface PseudoClassSelector extends BaseNode { type: 'PseudoClassSelector'; name: string; args: SelectorList | null; } export interface Percentage extends BaseNode { type: 'Percentage'; value: string; } export interface NestingSelector extends BaseNode { type: 'NestingSelector'; name: '&'; } export interface Nth extends BaseNode { type: 'Nth'; value: string; } export type SimpleSelector = | TypeSelector | IdSelector | ClassSelector | AttributeSelector | PseudoElementSelector | PseudoClassSelector | Percentage | Nth | NestingSelector; export interface Combinator extends BaseNode { type: 'Combinator'; name: string; } export interface Block extends BaseNode { type: 'Block'; children: Array<Declaration | Rule | Atrule>; } export interface Declaration extends BaseNode { type: 'Declaration'; property: string; value: string; } // for zimmerframe export type Node = | StyleSheet | Rule | Atrule | SelectorList | Block | ComplexSelector | RelativeSelector | Combinator | SimpleSelector | Declaration; }
```

# compiler/types/index.d.ts

```ts
import type { SourceMap } from 'magic-string'; import type { Binding } from '../phases/scope.js'; import type { AST, Namespace } from './template.js'; import type { ICompileDiagnostic } from '../utils/compile_diagnostic.js'; import type { StateCreationRuneName } from '../../utils.js'; import type { AssignmentExpression, CallExpression, PrivateIdentifier, PropertyDefinition } from 'estree'; /** The return value of `compile` from `svelte/compiler` */ export interface CompileResult { /** The compiled JavaScript */ js: { /** The generated code */ code: string; /** A source map */ map: SourceMap; }; /** The compiled CSS */ css: null | { /** The generated code */ code: string; /** A source map */ map: SourceMap; /** Whether or not the CSS includes global rules */ hasGlobal: boolean; }; /** * An array of warning objects that were generated during compilation. Each warning has several properties: * - `code` is a string identifying the category of warning * - `message` describes the issue in human-readable terms * - `start` and `end`, if the warning relates to a specific location, are objects with `line`, `column` and `character` properties */ warnings: Warning[]; /** * Metadata about the compiled component */ metadata: { /** * Whether the file was compiled in runes mode, either because of an explicit option or inferred from usage. * For `compileModule`, this is always `true` */ runes: boolean; }; /** The AST */ ast: any; } export interface Warning extends ICompileDiagnostic {} export interface CompileError extends ICompileDiagnostic {} export type CssHashGetter = (args: { name: string; filename: string; css: string; hash: (input: string) => string; }) => string; export interface OptimizeOptions { hydrate?: boolean; } export interface CompileOptions extends ModuleCompileOptions { /** * Sets the name of the resulting JavaScript class (though the compiler will rename it if it would otherwise conflict with other variables in scope). * If unspecified, will be inferred from `filename` */ name?: string; /** * If `true`, tells the compiler to generate a custom element constructor instead of a regular Svelte component. * * @default false */ customElement?: boolean; /** * If `true`, getters and setters will be created for the component's props. If `false`, they will only be created for readonly exported values (i.e. those declared with `const`, `class` and `function`). If compiling with `customElement: true` this option defaults to `true`. * * @default false * @deprecated This will have no effect in runes mode */ accessors?: boolean; /** * The namespace of the element; e.g., `"html"`, `"svg"`, `"mathml"`. * * @default 'html' */ namespace?: Namespace; /** * If `true`, tells the compiler that you promise not to mutate any objects. * This allows it to be less conservative about checking whether values have changed. * * @default false * @deprecated This will have no effect in runes mode */ immutable?: boolean; /** * - `'injected'`: styles will be included in the `head` when using `render(...)`, and injected into the document (if not already present) when the component mounts. For components compiled as custom elements, styles are injected to the shadow root. * - `'external'`: the CSS will only be returned in the `css` field of the compilation result. Most Svelte bundler plugins will set this to `'external'` and use the CSS that is statically generated for better performance, as it will result in smaller JavaScript bundles and the output can be served as cacheable `.css` files. * This is always `'injected'` when compiling with `customElement` mode. */ css?: 'injected' | 'external'; /** * A function that takes a `{ hash, css, name, filename }` argument and returns the string that is used as a classname for scoped CSS. * It defaults to returning `svelte-${hash(css)}`. * * @default undefined */ cssHash?: CssHashGetter; /** * If `true`, your HTML comments will be preserved in the output. By default, they are stripped out. * * @default false */ preserveComments?: boolean; /** * If `true`, whitespace inside and between elements is kept as you typed it, rather than removed or collapsed to a single space where possible. * * @default false */ preserveWhitespace?: boolean; /** * Which strategy to use when cloning DOM fragments: * * - `html` populates a `<template>` with `innerHTML` and clones it. This is faster, but cannot be used if your app's [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CSP) includes [`require-trusted-types-for 'script'`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy/require-trusted-types-for) * - `tree` creates the fragment one element at a time and _then_ clones it. This is slower, but works everywhere * * @default 'html' * @since 5.33 */ fragments?: 'html' | 'tree'; /** * Set to `true` to force the compiler into runes mode, even if there are no indications of runes usage. * Set to `false` to force the compiler into ignoring runes, even if there are indications of runes usage. * Set to `undefined` (the default) to infer runes mode from the component code. * Is always `true` for JS/TS modules compiled with Svelte. * Will be `true` by default in Svelte 6. * Note that setting this to `true` in your `svelte.config.js` will force runes mode for your entire project, including components in `node_modules`, * which is likely not what you want. If you're using Vite, consider using [dynamicCompileOptions](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/config.md#dynamiccompileoptions) instead. * @default undefined */ runes?: boolean | undefined; /** * If `true`, exposes the Svelte major version in the browser by adding it to a `Set` stored in the global `window.__svelte.v`. * * @default true */ discloseVersion?: boolean; /** * @deprecated Use these only as a temporary solution before migrating your code */ compatibility?: { /** * Applies a transformation so that the default export of Svelte files can still be instantiated the same way as in Svelte 4 — * as a class when compiling for the browser (as though using `createClassComponent(MyComponent, {...})` from `svelte/legacy`) * or as an object with a `.render(...)` method when compiling for the server * @default 5 */ componentApi?: 4 | 5; }; /** * An initial sourcemap that will be merged into the final output sourcemap. * This is usually the preprocessor sourcemap. * * @default null */ sourcemap?: object | string; /** * Used for your JavaScript sourcemap. * * @default null */ outputFilename?: string; /** * Used for your CSS sourcemap. * * @default null */ cssOutputFilename?: string; /** * If `true`, compiles components with hot reloading support. * * @default false */ hmr?: boolean; /** * If `true`, returns the modern version of the AST. * Will become `true` by default in Svelte 6, and the option will be removed in Svelte 7. * * @default false */ modernAst?: boolean; } export interface ModuleCompileOptions { /** * If `true`, causes extra code to be added that will perform runtime checks and provide debugging information during development. * * @default false */ dev?: boolean; /** * If `"client"`, Svelte emits code designed to run in the browser. * If `"server"`, Svelte emits code suitable for server-side rendering. * If `false`, nothing is generated. Useful for tooling that is only interested in warnings. * * @default 'client' */ generate?: 'client' | 'server' | false; /** * Used for debugging hints and sourcemaps. Your bundler plugin will set it automatically. */ filename?: string; /** * Used for ensuring filenames don't leak filesystem information. Your bundler plugin will set it automatically. * @default process.cwd() on node-like environments, undefined elsewhere */ rootDir?: string; /** * A function that gets a `Warning` as an argument and returns a boolean. * Use this to filter out warnings. Return `true` to keep the warning, `false` to discard it. */ warningFilter?: (warning: Warning) => boolean; /** Experimental options */ experimental?: { /** Allow `await` keyword in deriveds, template expressions, and the top level of components */ async?: boolean; }; } // The following two somewhat scary looking types ensure that certain types are required but can be undefined still export type ValidatedModuleCompileOptions = Omit<Required<ModuleCompileOptions>, 'rootDir'> & { rootDir: ModuleCompileOptions['rootDir']; }; export type ValidatedCompileOptions = ValidatedModuleCompileOptions & Omit< Required<CompileOptions>, | keyof ModuleCompileOptions | 'name' | 'compatibility' | 'outputFilename' | 'cssOutputFilename' | 'sourcemap' | 'runes' > & { name: CompileOptions['name']; outputFilename: CompileOptions['outputFilename']; cssOutputFilename: CompileOptions['cssOutputFilename']; sourcemap: CompileOptions['sourcemap']; compatibility: Required<Required<CompileOptions>['compatibility']>; runes: CompileOptions['runes']; customElementOptions: AST.SvelteOptions['customElement']; hmr: CompileOptions['hmr']; }; export type BindingKind = | 'normal' // A variable that is not in any way special | 'prop' // A normal prop (possibly reassigned or mutated) | 'bindable_prop' // A prop one can `bind:` to (possibly reassigned or mutated) | 'rest_prop' // A rest prop | 'raw_state' // A state variable | 'state' // A deeply reactive state variable | 'derived' // A derived variable | 'each' // An each block parameter | 'snippet' // A snippet parameter | 'store_sub' // A $store value | 'legacy_reactive' // A `$:` declaration | 'template' // A binding declared in the template, e.g. in an `await` block or `const` tag | 'static'; // A binding whose value is known to be static (i.e. each index) export type DeclarationKind = | 'var' | 'let' | 'const' | 'function' | 'import' | 'param' | 'rest_param' | 'synthetic'; export interface ExpressionMetadata { /** All the bindings that are referenced eagerly (not inside functions) in this expression */ dependencies: Set<Binding>; /** All the bindings that are referenced inside this expression, including inside functions */ references: Set<Binding>; /** True if the expression references state directly, or _might_ (via member/call expressions) */ has_state: boolean; /** True if the expression involves a call expression (often, it will need to be wrapped in a derived) */ has_call: boolean; /** True if the expression contains `await` */ has_await: boolean; /** True if the expression includes a member expression */ has_member_expression: boolean; /** True if the expression includes an assignment or an update */ has_assignment: boolean; } export interface StateField { type: StateCreationRuneName; node: PropertyDefinition | AssignmentExpression; key: PrivateIdentifier; value: CallExpression; } export * from './template.js'; export { Binding, Scope } from '../phases/scope.js'; // TODO this chain is a bit weird export { ReactiveStatement } from '../phases/types.js';
```

# compiler/types/legacy-interfaces.d.ts

```ts
import { CompileOptions as C, Warning as W } from '#compiler'; /** @deprecated import this from 'svelte' instead */ export type CompileOptions = C; /** @deprecated import this from 'svelte' instead */ export type Warning = W;
```

# compiler/types/legacy-nodes.d.ts

```ts
import type { AST } from '#compiler'; import type { ArrayExpression, AssignmentExpression, Expression, Identifier, MemberExpression, ObjectExpression, Pattern, SequenceExpression } from 'estree'; interface BaseNode { type: string; start: number; end: number; } interface BaseElement extends BaseNode { name: string; attributes: Array<LegacyAttributeLike>; children: Array<LegacyElementLike>; } export interface LegacyRoot extends BaseNode { html: LegacySvelteNode; css?: any; instance?: any; module?: any; } export interface LegacyAction extends BaseNode { type: 'Action'; /** The 'x' in `use:x` */ name: string; /** The 'y' in `use:x={y}` */ expression: null | Expression; } export interface LegacyAnimation extends BaseNode { type: 'Animation'; /** The 'x' in `animate:x` */ name: string; /** The y in `animate:x={y}` */ expression: null | Expression; } export interface LegacyBinding extends BaseNode { type: 'Binding'; /** The 'x' in `bind:x` */ name: string; /** The y in `bind:x={y}` */ expression: Identifier | MemberExpression | SequenceExpression; } export interface LegacyBody extends BaseElement { type: 'Body'; name: 'svelte:body'; } export interface LegacyAttribute extends BaseNode { type: 'Attribute'; name: string; value: true | Array<AST.Text | LegacyMustacheTag | LegacyAttributeShorthand>; } export interface LegacyAttributeShorthand extends BaseNode { type: 'AttributeShorthand'; expression: Expression; } export interface LegacyLet extends BaseNode { type: 'Let'; /** The 'x' in `let:x` */ name: string; /** The 'y' in `let:x={y}` */ expression: null | Identifier | ArrayExpression | ObjectExpression; } export interface LegacyCatchBlock extends BaseNode { type: 'CatchBlock'; children: LegacySvelteNode[]; skip: boolean; } export interface LegacyClass extends BaseNode { type: 'Class'; /** The 'x' in `class:x` */ name: 'class'; /** The 'y' in `class:x={y}`, or the `x` in `class:x` */ expression: Expression; } export interface LegacyDocument extends BaseElement { type: 'Document'; } export interface LegacyElement { type: 'Element'; } export interface LegacyEventHandler extends BaseNode { type: 'EventHandler'; /** The 'x' in `on:x` */ name: string; /** The 'y' in `on:x={y}` */ expression: null | Expression; modifiers: string[]; } export interface LegacyHead extends BaseElement { type: 'Head'; } export interface LegacyInlineComponent extends BaseElement { type: 'InlineComponent'; /** Set if this is a `<svelte:component>` */ expression?: Expression; } export interface LegacyMustacheTag extends BaseNode { type: 'MustacheTag'; expression: Expression; } export interface LegacyOptions { type: 'Options'; name: 'svelte:options'; attributes: Array<any>; } export interface LegacyPendingBlock extends BaseNode { type: 'PendingBlock'; children: LegacySvelteNode[]; skip: boolean; } export interface LegacyRawMustacheTag extends BaseNode { type: 'RawMustacheTag'; expression: Expression; } export interface LegacySpread extends BaseNode { type: 'Spread'; expression: Expression; } export interface LegacySlot extends BaseElement { type: 'Slot'; } export interface LegacySlotTemplate extends BaseElement { type: 'SlotTemplate'; } export interface LegacyThenBlock extends BaseNode { type: 'ThenBlock'; children: LegacySvelteNode[]; skip: boolean; } export interface SnippetBlock extends BaseNode { type: 'SnippetBlock'; expression: Identifier; context: null | Pattern; children: LegacySvelteNode[]; } export interface RenderTag extends BaseNode { type: 'RenderTag'; expression: Identifier; argument: null | Expression; } export interface LegacyTitle extends BaseElement { type: 'Title'; name: 'title'; } export interface LegacyConstTag extends BaseNode { type: 'ConstTag'; expression: AssignmentExpression; } export interface LegacyTransition extends BaseNode { type: 'Transition'; /** The 'x' in `transition:x` */ name: string; /** The 'y' in `transition:x={y}` */ expression: null | Expression; modifiers: Array<'local' | 'global'>; /** True if this is a `transition:` or `in:` directive */ intro: boolean; /** True if this is a `transition:` or `out:` directive */ outro: boolean; } /** A `style:` directive */ export interface LegacyStyleDirective extends BaseNode { type: 'StyleDirective'; /** The 'x' in `style:x` */ name: string; /** The 'y' in `style:x={y}` */ value: true | Array<AST.ExpressionTag | AST.Text>; modifiers: Array<'important'>; } export interface LegacyWindow extends BaseElement { type: 'Window'; } export interface LegacyComment extends BaseNode { type: 'Comment'; /** the contents of the comment */ data: string; /** any svelte-ignore directives — <!-- svelte-ignore a b c --> would result in ['a', 'b', 'c'] */ ignores: string[]; } type LegacyDirective = | LegacyAnimation | LegacyBinding | LegacyClass | LegacyLet | LegacyEventHandler | LegacyStyleDirective | LegacyTransition | LegacyAction; export type LegacyAttributeLike = LegacyAttribute | LegacySpread | LegacyDirective; export type LegacyElementLike = | LegacyBody | LegacyCatchBlock | LegacyComment | LegacyDocument | LegacyElement | LegacyHead | LegacyInlineComponent | LegacyMustacheTag | LegacyOptions | LegacyPendingBlock | LegacyRawMustacheTag | LegacySlot | LegacySlotTemplate | LegacyThenBlock | LegacyTitle | LegacyWindow; export interface LegacyStyle extends BaseNode { type: 'Style'; attributes: any[]; content: { start: number; end: number; styles: string; }; children: any[]; } export interface LegacySelector extends BaseNode { type: 'Selector'; children: Array<AST.CSS.Combinator | AST.CSS.SimpleSelector>; } export type LegacyCssNode = LegacyStyle | LegacySelector; export type LegacySvelteNode = | LegacyConstTag | LegacyElementLike | LegacyAttributeLike | LegacyAttributeShorthand | LegacyCssNode | AST.Text;
```

# compiler/types/template.d.ts

```ts
import type { Binding, ExpressionMetadata } from '#compiler'; import type { ArrayExpression, ArrowFunctionExpression, VariableDeclaration, VariableDeclarator, Expression, FunctionDeclaration, FunctionExpression, Identifier, MemberExpression, Node, ObjectExpression, Pattern, Program, ChainExpression, SimpleCallExpression, SequenceExpression } from 'estree'; import type { Scope } from '../phases/scope'; import type { _CSS } from './css'; /** * - `html` — the default, for e.g. `<div>` or `<span>` * - `svg` — for e.g. `<svg>` or `<g>` * - `mathml` — for e.g. `<math>` or `<mrow>` */ export type Namespace = 'html' | 'svg' | 'mathml'; export type DelegatedEvent = | { hoisted: true; function: ArrowFunctionExpression | FunctionExpression | FunctionDeclaration; } | { hoisted: false }; export namespace AST { export interface BaseNode { type: string; start: number; end: number; } export interface Fragment { type: 'Fragment'; nodes: Array<Text | Tag | ElementLike | Block | Comment>; /** @internal */ metadata: { /** * Fragments declare their own scopes. A transparent fragment is one whose scope * is not represented by a scope in the resulting JavaScript (e.g. an element scope), * and should therefore delegate to parent scopes when generating unique identifiers */ transparent: boolean; /** * Whether or not we need to traverse into the fragment during mount/hydrate */ dynamic: boolean; }; } export interface Root extends BaseNode { type: 'Root'; /** * Inline options provided by `<svelte:options>` — these override options passed to `compile(...)` */ options: SvelteOptions | null; fragment: Fragment; /** The parsed `<style>` element, if exists */ css: AST.CSS.StyleSheet | null; /** The parsed `<script>` element, if exists */ instance: Script | null; /** The parsed `<script module>` element, if exists */ module: Script | null; /** Comments found in <script> and {expressions} */ comments: JSComment[]; /** @internal */ metadata: { /** Whether the component was parsed with typescript */ ts: boolean; }; } export interface SvelteOptions { // start/end info (needed for warnings and for our Prettier plugin) start: number; end: number; // options runes?: boolean; immutable?: boolean; accessors?: boolean; preserveWhitespace?: boolean; namespace?: Namespace; css?: 'injected'; customElement?: { tag?: string; shadow?: 'open' | 'none'; props?: Record< string, { attribute?: string; reflect?: boolean; type?: 'Array' | 'Boolean' | 'Number' | 'Object' | 'String'; } >; /** * Is of type * \`\`\`ts * (ceClass: new () => HTMLElement) => new () => HTMLElement * \`\`\` */ extend?: ArrowFunctionExpression | Identifier; }; attributes: Attribute[]; } /** Static text */ export interface Text extends BaseNode { type: 'Text'; /** Text with decoded HTML entities */ data: string; /** The original text, with undecoded HTML entities */ raw: string; } /** A (possibly reactive) template expression — `{...}` */ export interface ExpressionTag extends BaseNode { type: 'ExpressionTag'; expression: Expression; /** @internal */ metadata: { expression: ExpressionMetadata; }; } /** A (possibly reactive) HTML template expression — `{@html ...}` */ export interface HtmlTag extends BaseNode { type: 'HtmlTag'; expression: Expression; /** @internal */ metadata: { expression: ExpressionMetadata; }; } /** An HTML comment */ // TODO rename to disambiguate export interface Comment extends BaseNode { type: 'Comment'; /** the contents of the comment */ data: string; } /** A `{@const ...}` tag */ export interface ConstTag extends BaseNode { type: 'ConstTag'; declaration: VariableDeclaration & { declarations: [VariableDeclarator & { id: Pattern; init: Expression }]; }; /** @internal */ metadata: { expression: ExpressionMetadata; }; } /** A `{@debug ...}` tag */ export interface DebugTag extends BaseNode { type: 'DebugTag'; identifiers: Identifier[]; } /** A `{@render foo(...)} tag */ export interface RenderTag extends BaseNode { type: 'RenderTag'; expression: SimpleCallExpression | (ChainExpression & { expression: SimpleCallExpression }); /** @internal */ metadata: { expression: ExpressionMetadata; dynamic: boolean; arguments: ExpressionMetadata[]; path: SvelteNode[]; /** The set of locally-defined snippets that this render tag could correspond to, * used for CSS pruning purposes */ snippets: Set<SnippetBlock>; }; } /** A `{@attach foo(...)} tag */ export interface AttachTag extends BaseNode { type: 'AttachTag'; expression: Expression; /** @internal */ metadata: { expression: ExpressionMetadata; }; } /** An `animate:` directive */ export interface AnimateDirective extends BaseNode { type: 'AnimateDirective'; /** The 'x' in `animate:x` */ name: string; /** The y in `animate:x={y}` */ expression: null | Expression; } /** A `bind:` directive */ export interface BindDirective extends BaseNode { type: 'BindDirective'; /** The 'x' in `bind:x` */ name: string; /** The y in `bind:x={y}` */ expression: Identifier | MemberExpression | SequenceExpression; /** @internal */ metadata: { binding_group_name: Identifier; parent_each_blocks: EachBlock[]; }; } /** A `class:` directive */ export interface ClassDirective extends BaseNode { type: 'ClassDirective'; /** The 'x' in `class:x` */ name: 'class'; /** The 'y' in `class:x={y}`, or the `x` in `class:x` */ expression: Expression; /** @internal */ metadata: { expression: ExpressionMetadata; }; } /** A `let:` directive */ export interface LetDirective extends BaseNode { type: 'LetDirective'; /** The 'x' in `let:x` */ name: string; /** The 'y' in `let:x={y}` */ expression: null | Identifier | ArrayExpression | ObjectExpression; } /** An `on:` directive */ export interface OnDirective extends BaseNode { type: 'OnDirective'; /** The 'x' in `on:x` */ name: string; /** The 'y' in `on:x={y}` */ expression: null | Expression; modifiers: string[]; // TODO specify /** @internal */ metadata: { expression: ExpressionMetadata; }; } /** A `style:` directive */ export interface StyleDirective extends BaseNode { type: 'StyleDirective'; /** The 'x' in `style:x` */ name: string; /** The 'y' in `style:x={y}` */ value: true | ExpressionTag | Array<ExpressionTag | Text>; modifiers: Array<'important'>; /** @internal */ metadata: { expression: ExpressionMetadata; }; } // TODO have separate in/out/transition directives /** A `transition:`, `in:` or `out:` directive */ export interface TransitionDirective extends BaseNode { type: 'TransitionDirective'; /** The 'x' in `transition:x` */ name: string; /** The 'y' in `transition:x={y}` */ expression: null | Expression; modifiers: Array<'local' | 'global'>; /** True if this is a `transition:` or `in:` directive */ intro: boolean; /** True if this is a `transition:` or `out:` directive */ outro: boolean; } /** A `use:` directive */ export interface UseDirective extends BaseNode { type: 'UseDirective'; /** The 'x' in `use:x` */ name: string; /** The 'y' in `use:x={y}` */ expression: null | Expression; } interface BaseElement extends BaseNode { name: string; attributes: Array<Attribute | SpreadAttribute | Directive | AttachTag>; fragment: Fragment; } export interface Component extends BaseElement { type: 'Component'; /** @internal */ metadata: { scopes: Record<string, Scope>; dynamic: boolean; /** The set of locally-defined snippets that this component tag could render, * used for CSS pruning purposes */ snippets: Set<SnippetBlock>; path: SvelteNode[]; }; } export interface TitleElement extends BaseElement { type: 'TitleElement'; name: 'title'; } export interface SlotElement extends BaseElement { type: 'SlotElement'; name: 'slot'; } export interface RegularElement extends BaseElement { type: 'RegularElement'; /** @internal */ metadata: { /** `true` if this is an svg element */ svg: boolean; /** `true` if this is a mathml element */ mathml: boolean; /** `true` if contains a SpreadAttribute */ has_spread: boolean; scoped: boolean; path: SvelteNode[]; }; } export interface SvelteBody extends BaseElement { type: 'SvelteBody'; name: 'svelte:body'; } export interface SvelteComponent extends BaseElement { type: 'SvelteComponent'; name: 'svelte:component'; expression: Expression; /** @internal */ metadata: { scopes: Record<string, Scope>; /** The set of locally-defined snippets that this component tag could render, * used for CSS pruning purposes */ snippets: Set<SnippetBlock>; path: SvelteNode[]; }; } export interface SvelteDocument extends BaseElement { type: 'SvelteDocument'; name: 'svelte:document'; } export interface SvelteElement extends BaseElement { type: 'SvelteElement'; name: 'svelte:element'; tag: Expression; /** @internal */ metadata: { expression: ExpressionMetadata; /** * `true` if this is an svg element. The boolean may not be accurate because * the tag is dynamic, but we do our best to infer it from the template. */ svg: boolean; /** * `true` if this is a mathml element. The boolean may not be accurate because * the tag is dynamic, but we do our best to infer it from the template. */ mathml: boolean; scoped: boolean; path: SvelteNode[]; }; } export interface SvelteFragment extends BaseElement { type: 'SvelteFragment'; name: 'svelte:fragment'; } export interface SvelteBoundary extends BaseElement { type: 'SvelteBoundary'; name: 'svelte:boundary'; } export interface SvelteHead extends BaseElement { type: 'SvelteHead'; name: 'svelte:head'; } /** This is only an intermediate representation while parsing, it doesn't exist in the final AST */ export interface SvelteOptionsRaw extends BaseElement { type: 'SvelteOptions'; name: 'svelte:options'; } export interface SvelteSelf extends BaseElement { type: 'SvelteSelf'; name: 'svelte:self'; /** @internal */ metadata: { scopes: Record<string, Scope>; /** The set of locally-defined snippets that this component tag could render, * used for CSS pruning purposes */ snippets: Set<SnippetBlock>; path: SvelteNode[]; }; } export interface SvelteWindow extends BaseElement { type: 'SvelteWindow'; name: 'svelte:window'; } /** An `{#each ...}` block */ export interface EachBlock extends BaseNode { type: 'EachBlock'; expression: Expression; /** The `entry` in `{#each item as entry}`. `null` if `as` part is omitted */ context: Pattern | null; body: Fragment; fallback?: Fragment; index?: string; key?: Expression; /** @internal */ metadata: { expression: ExpressionMetadata; keyed: boolean; contains_group_binding: boolean; index: Identifier; declarations: Map<string, Binding>; /** * Optimization path for each blocks: If the parent isn't a fragment and * it only has a single child, then we can classify the block as being "controlled". * This saves us from creating an extra comment and insertion being faster. */ is_controlled: boolean; /** * Bindings this each block transitively depends on. In legacy mode, we * invalidate these bindings when mutations happen to each block items */ transitive_deps: Set<Binding>; }; } /** An `{#if ...}` block */ export interface IfBlock extends BaseNode { type: 'IfBlock'; elseif: boolean; test: Expression; consequent: Fragment; alternate: Fragment | null; /** @internal */ metadata: { expression: ExpressionMetadata; }; } /** An `{#await ...}` block */ export interface AwaitBlock extends BaseNode { type: 'AwaitBlock'; expression: Expression; // TODO can/should we move these inside the ThenBlock and CatchBlock? /** The resolved value inside the `then` block */ value: Pattern | null; /** The rejection reason inside the `catch` block */ error: Pattern | null; pending: Fragment | null; then: Fragment | null; catch: Fragment | null; /** @internal */ metadata: { expression: ExpressionMetadata; }; } export interface KeyBlock extends BaseNode { type: 'KeyBlock'; expression: Expression; fragment: Fragment; /** @internal */ metadata: { expression: ExpressionMetadata; }; } export interface SnippetBlock extends BaseNode { type: 'SnippetBlock'; expression: Identifier; parameters: Pattern[]; typeParams?: string; body: Fragment; /** @internal */ metadata: { can_hoist: boolean; /** The set of components/render tags that could render this snippet, * used for CSS pruning */ sites: Set<Component | SvelteComponent | SvelteSelf | RenderTag>; }; } export interface Attribute extends BaseNode { type: 'Attribute'; name: string; /** * Quoted/string values are represented by an array, even if they contain a single expression like `"{x}"` */ value: true | ExpressionTag | Array<Text | ExpressionTag>; /** @internal */ metadata: { /** May be set if this is an event attribute */ delegated: null | DelegatedEvent; /** May be `true` if this is a `class` attribute that needs `clsx` */ needs_clsx: boolean; }; } export interface SpreadAttribute extends BaseNode { type: 'SpreadAttribute'; expression: Expression; /** @internal */ metadata: { expression: ExpressionMetadata; }; } export interface Script extends BaseNode { type: 'Script'; context: 'default' | 'module'; content: Program; attributes: Attribute[]; } export interface JSComment { type: 'Line' | 'Block'; value: string; start: number; end: number; loc: { start: { line: number; column: number }; end: { line: number; column: number }; }; } export type AttributeLike = Attribute | SpreadAttribute | Directive; export type Directive = | AST.AnimateDirective | AST.BindDirective | AST.ClassDirective | AST.LetDirective | AST.OnDirective | AST.StyleDirective | AST.TransitionDirective | AST.UseDirective; export type Block = | AST.EachBlock | AST.IfBlock | AST.AwaitBlock | AST.KeyBlock | AST.SnippetBlock; export type ElementLike = | AST.Component | AST.TitleElement | AST.SlotElement | AST.RegularElement | AST.SvelteBody | AST.SvelteBoundary | AST.SvelteComponent | AST.SvelteDocument | AST.SvelteElement | AST.SvelteFragment | AST.SvelteHead | AST.SvelteOptionsRaw | AST.SvelteSelf | AST.SvelteWindow | AST.SvelteBoundary; export type Tag = | AST.AttachTag | AST.ConstTag | AST.DebugTag | AST.ExpressionTag | AST.HtmlTag | AST.RenderTag; export type TemplateNode = | AST.Root | AST.Text | Tag | ElementLike | AST.Attribute | AST.SpreadAttribute | Directive | AST.AttachTag | AST.Comment | Block; export type SvelteNode = Node | TemplateNode | AST.Fragment | _CSS.Node | Script; export type { _CSS as CSS }; } declare module 'estree' { export interface BaseNode { /** Added by the Svelte parser */ start?: number; /** Added by the Svelte parser */ end?: number; /** Added by acorn-typescript */ typeAnnotation?: any; } }
```

# compiler/utils/assert.js

```js
/** * @template T * @param {any} actual * @param {T} expected * @returns {asserts actual is T} */ export function equal(actual, expected) { if (actual !== expected) throw new Error('Assertion failed'); }
```

# compiler/utils/ast.js

```js
/** @import { AST } from '#compiler' */ /** @import * as ESTree from 'estree' */ import { walk } from 'zimmerframe'; import * as b from '#compiler/builders'; /** * Gets the left-most identifier of a member expression or identifier. * @param {ESTree.MemberExpression | ESTree.Identifier} expression * @returns {ESTree.Identifier | null} */ export function object(expression) { while (expression.type === 'MemberExpression') { expression = /** @type {ESTree.MemberExpression | ESTree.Identifier} */ (expression.object); } if (expression.type !== 'Identifier') { return null; } return expression; } /** * Returns true if the attribute contains a single static text node. * @param {AST.Attribute} attribute * @returns {attribute is AST.Attribute & { value: [AST.Text] }} */ export function is_text_attribute(attribute) { return ( Array.isArray(attribute.value) && attribute.value.length === 1 && attribute.value[0].type === 'Text' ); } /** * Returns true if the attribute contains a single expression node. * In Svelte 5, this also includes a single expression node wrapped in an array. * TODO change that in a future version * @param {AST.Attribute} attribute * @returns {attribute is AST.Attribute & { value: [AST.ExpressionTag] | AST.ExpressionTag }} */ export function is_expression_attribute(attribute) { return ( (attribute.value !== true && !Array.isArray(attribute.value)) || (Array.isArray(attribute.value) && attribute.value.length === 1 && attribute.value[0].type === 'ExpressionTag') ); } /** * Returns the single attribute expression node. * In Svelte 5, this also includes a single expression node wrapped in an array. * TODO change that in a future version * @param { AST.Attribute & { value: [AST.ExpressionTag] | AST.ExpressionTag }} attribute * @returns {ESTree.Expression} */ export function get_attribute_expression(attribute) { return Array.isArray(attribute.value) ? /** @type {AST.ExpressionTag} */ (attribute.value[0]).expression : attribute.value.expression; } /** * Returns the expression chunks of an attribute value * @param {AST.Attribute['value']} value * @returns {Array<AST.Text | AST.ExpressionTag>} */ export function get_attribute_chunks(value) { return Array.isArray(value) ? value : typeof value === 'boolean' ? [] : [value]; } /** * Returns true if the attribute starts with `on` and contains a single expression node. * @param {AST.Attribute} attribute * @returns {attribute is AST.Attribute & { value: [AST.ExpressionTag] | AST.ExpressionTag }} */ export function is_event_attribute(attribute) { return is_expression_attribute(attribute) && attribute.name.startsWith('on'); } /** * Extracts all identifiers and member expressions from a pattern. * @param {ESTree.Pattern} pattern * @param {Array<ESTree.Identifier | ESTree.MemberExpression>} [nodes] * @returns {Array<ESTree.Identifier | ESTree.MemberExpression>} */ export function unwrap_pattern(pattern, nodes = []) { switch (pattern.type) { case 'Identifier': nodes.push(pattern); break; case 'MemberExpression': // member expressions can be part of an assignment pattern, but not a binding pattern // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#binding_and_assignment nodes.push(pattern); break; case 'ObjectPattern': for (const prop of pattern.properties) { if (prop.type === 'RestElement') { unwrap_pattern(prop.argument, nodes); } else { unwrap_pattern(prop.value, nodes); } } break; case 'ArrayPattern': for (const element of pattern.elements) { if (element) unwrap_pattern(element, nodes); } break; case 'RestElement': unwrap_pattern(pattern.argument, nodes); break; case 'AssignmentPattern': unwrap_pattern(pattern.left, nodes); break; } return nodes; } /** * Extracts all identifiers from a pattern. * @param {ESTree.Pattern} pattern * @returns {ESTree.Identifier[]} */ export function extract_identifiers(pattern) { return unwrap_pattern(pattern, []).filter((node) => node.type === 'Identifier'); } /** * Extracts all identifiers and a stringified keypath from an expression. * TODO replace this with `expression.dependencies` * @param {ESTree.Expression} expr * @returns {[keypath: string, ids: ESTree.Identifier[]]} */ export function extract_all_identifiers_from_expression(expr) { /** @type {ESTree.Identifier[]} */ let nodes = []; /** @type {string[]} */ let keypath = []; walk( expr, {}, { Identifier(node, { path }) { const parent = path.at(-1); if (parent?.type !== 'MemberExpression' || parent.property !== node || parent.computed) { nodes.push(node); } if (parent?.type === 'MemberExpression' && parent.computed && parent.property === node) { keypath.push(`[${node.name}]`); } else { keypath.push(node.name); } }, Literal(node, { path }) { const value = typeof node.value === 'string' ? `"${node.value}"` : String(node.value); const parent = path.at(-1); if (parent?.type === 'MemberExpression' && parent.computed && parent.property === node) { keypath.push(`[${value}]`); } else { keypath.push(value); } }, ThisExpression(_, { next }) { keypath.push('this'); next(); } } ); return [keypath.join('.'), nodes]; } /** * Extracts all leaf identifiers from a destructuring expression. * @param {ESTree.Identifier | ESTree.ObjectExpression | ESTree.ArrayExpression} node * @param {ESTree.Identifier[]} [nodes] * @returns */ export function extract_identifiers_from_destructuring(node, nodes = []) { // TODO This isn't complete, but it should be enough for our purposes switch (node.type) { case 'Identifier': nodes.push(node); break; case 'ObjectExpression': for (const prop of node.properties) { if (prop.type === 'Property') { extract_identifiers_from_destructuring(/** @type {any} */ (prop.value), nodes); } else { extract_identifiers_from_destructuring(/** @type {any} */ (prop.argument), nodes); } } break; case 'ArrayExpression': for (const element of node.elements) { if (element) extract_identifiers_from_destructuring(/** @type {any} */ (element), nodes); } break; } return nodes; } /** * Represents the path of a destructured assignment from either a declaration * or assignment expression. For example, given `const { foo: { bar: baz } } = quux`, * the path of `baz` is `foo.bar` * @typedef {Object} DestructuredAssignment * @property {ESTree.Identifier | ESTree.MemberExpression} node The node the destructuring path end in. Can be a member expression only for assignment expressions * @property {boolean} is_rest `true` if this is a `...rest` destructuring * @property {boolean} has_default_value `true` if this has a fallback value like `const { foo = 'bar } = ..` * @property {ESTree.Expression} expression The value of the current path * This will be a call expression if a rest element or default is involved — e.g. `const { foo: { bar: baz = 42 }, ...rest } = quux` — since we can't represent `baz` or `rest` purely as a path * Will be an await expression in case of an async default value (`const { foo = await bar } = ...`) * @property {ESTree.Expression} update_expression Like `expression` but without default values. */ /** * Extracts all destructured assignments from a pattern. * For each `id` in the returned `inserts`, make sure to adjust the `name`. * @param {ESTree.Node} param * @param {ESTree.Expression} initial * @returns {{ inserts: Array<{ id: ESTree.Identifier, value: ESTree.Expression }>, paths: DestructuredAssignment[] }} */ export function extract_paths(param, initial) { /** * When dealing with array destructuring patterns (`let [a, b, c] = $derived(blah())`) * we need an intermediate declaration that creates an array, since `blah()` could * return a non-array-like iterator * @type {Array<{ id: ESTree.Identifier, value: ESTree.Expression }>} */ const inserts = []; /** @type {DestructuredAssignment[]} */ const paths = []; _extract_paths(paths, inserts, param, initial, initial, false); return { inserts, paths }; } /** * @param {DestructuredAssignment[]} paths * @param {Array<{ id: ESTree.Identifier, value: ESTree.Expression }>} inserts * @param {ESTree.Node} param * @param {ESTree.Expression} expression * @param {ESTree.Expression} update_expression * @param {boolean} has_default_value * @returns {DestructuredAssignment[]} */ function _extract_paths(paths, inserts, param, expression, update_expression, has_default_value) { switch (param.type) { case 'Identifier': case 'MemberExpression': paths.push({ node: param, is_rest: false, has_default_value, expression, update_expression }); break; case 'ObjectPattern': for (const prop of param.properties) { if (prop.type === 'RestElement') { /** @type {ESTree.Expression[]} */ const props = []; for (const p of param.properties) { if (p.type === 'Property' && p.key.type !== 'PrivateIdentifier') { if (p.key.type === 'Identifier' && !p.computed) { props.push(b.literal(p.key.name)); } else if (p.key.type === 'Literal') { props.push(b.literal(String(p.key.value))); } else { props.push(b.call('String', p.key)); } } } const rest_expression = b.call('$.exclude_from_object', expression, b.array(props)); if (prop.argument.type === 'Identifier') { paths.push({ node: prop.argument, is_rest: true, has_default_value, expression: rest_expression, update_expression: rest_expression }); } else { _extract_paths( paths, inserts, prop.argument, rest_expression, rest_expression, has_default_value ); } } else { const object_expression = b.member( expression, prop.key, prop.computed || prop.key.type !== 'Identifier' ); _extract_paths( paths, inserts, prop.value, object_expression, object_expression, has_default_value ); } } break; case 'ArrayPattern': { // we create an intermediate declaration to convert iterables to arrays if necessary. // the consumer is responsible for setting the name of the identifier const id = b.id('#'); const value = b.call( '$.to_array', expression, param.elements.at(-1)?.type === 'RestElement' ? undefined : b.literal(param.elements.length) ); inserts.push({ id, value }); for (let i = 0; i < param.elements.length; i += 1) { const element = param.elements[i]; if (element) { if (element.type === 'RestElement') { const rest_expression = b.call(b.member(id, 'slice'), b.literal(i)); if (element.argument.type === 'Identifier') { paths.push({ node: element.argument, is_rest: true, has_default_value, expression: rest_expression, update_expression: rest_expression }); } else { _extract_paths( paths, inserts, element.argument, rest_expression, rest_expression, has_default_value ); } } else { const array_expression = b.member(id, b.literal(i), true); _extract_paths( paths, inserts, element, array_expression, array_expression, has_default_value ); } } } break; } case 'AssignmentPattern': { const fallback_expression = build_fallback(expression, param.right); if (param.left.type === 'Identifier') { paths.push({ node: param.left, is_rest: false, has_default_value: true, expression: fallback_expression, update_expression }); } else { _extract_paths(paths, inserts, param.left, fallback_expression, update_expression, true); } break; } } return paths; } /** * Like `path.at(x)`, but skips over `TSNonNullExpression` and `TSAsExpression` nodes and eases assertions a bit * by removing the `| undefined` from the resulting type. * * @template {AST.SvelteNode} T * @param {T[]} path * @param {number} at */ export function get_parent(path, at) { let node = path.at(at); // @ts-expect-error if (node.type === 'TSNonNullExpression' || node.type === 'TSAsExpression') { return /** @type {T} */ (path.at(at < 0 ? at - 1 : at + 1)); } return /** @type {T} */ (node); } /** * Returns `true` if the expression is an identifier, a literal, a function expression, * or a logical expression that only contains simple expressions. Used to determine whether * something needs to be treated as though accessing it could have side-effects (i.e. * reading signals prematurely) * @param {ESTree.Expression} node * @returns {boolean} */ export function is_simple_expression(node) { if ( node.type === 'Literal' || node.type === 'Identifier' || node.type === 'ArrowFunctionExpression' || node.type === 'FunctionExpression' ) { return true; } if (node.type === 'ConditionalExpression') { return ( is_simple_expression(node.test) && is_simple_expression(node.consequent) && is_simple_expression(node.alternate) ); } if (node.type === 'BinaryExpression' || node.type === 'LogicalExpression') { return ( node.left.type !== 'PrivateIdentifier' && is_simple_expression(node.left) && is_simple_expression(node.right) ); } return false; } /** * @template {ESTree.SimpleCallExpression | ESTree.MemberExpression} T * @param {ESTree.ChainExpression & { expression : T } | T} node * @returns {T} */ export function unwrap_optional(node) { return node.type === 'ChainExpression' ? node.expression : node; } /** * @param {ESTree.Expression | ESTree.Pattern} expression * @returns {boolean} */ export function is_expression_async(expression) { switch (expression.type) { case 'AwaitExpression': { return true; } case 'ArrayPattern': { return expression.elements.some((element) => element && is_expression_async(element)); } case 'ArrayExpression': { return expression.elements.some((element) => { if (!element) { return false; } else if (element.type === 'SpreadElement') { return is_expression_async(element.argument); } else { return is_expression_async(element); } }); } case 'AssignmentPattern': case 'AssignmentExpression': case 'BinaryExpression': case 'LogicalExpression': { return ( (expression.left.type !== 'PrivateIdentifier' && is_expression_async(expression.left)) || is_expression_async(expression.right) ); } case 'CallExpression': case 'NewExpression': { return ( (expression.callee.type !== 'Super' && is_expression_async(expression.callee)) || expression.arguments.some((element) => { if (element.type === 'SpreadElement') { return is_expression_async(element.argument); } else { return is_expression_async(element); } }) ); } case 'ChainExpression': { return is_expression_async(expression.expression); } case 'ConditionalExpression': { return ( is_expression_async(expression.test) || is_expression_async(expression.alternate) || is_expression_async(expression.consequent) ); } case 'ImportExpression': { return is_expression_async(expression.source); } case 'MemberExpression': { return ( (expression.object.type !== 'Super' && is_expression_async(expression.object)) || (expression.property.type !== 'PrivateIdentifier' && is_expression_async(expression.property)) ); } case 'ObjectPattern': case 'ObjectExpression': { return expression.properties.some((property) => { if (property.type === 'SpreadElement') { return is_expression_async(property.argument); } else if (property.type === 'Property') { return ( (property.key.type !== 'PrivateIdentifier' && is_expression_async(property.key)) || is_expression_async(property.value) ); } }); } case 'RestElement': { return is_expression_async(expression.argument); } case 'SequenceExpression': case 'TemplateLiteral': { return expression.expressions.some((subexpression) => is_expression_async(subexpression)); } case 'TaggedTemplateExpression': { return is_expression_async(expression.tag) || is_expression_async(expression.quasi); } case 'UnaryExpression': case 'UpdateExpression': { return is_expression_async(expression.argument); } case 'YieldExpression': { return expression.argument ? is_expression_async(expression.argument) : false; } default: return false; } } /** * * @param {ESTree.Expression} expression * @param {ESTree.Expression} fallback */ export function build_fallback(expression, fallback) { if (is_simple_expression(fallback)) { return b.call('$.fallback', expression, fallback); } if (fallback.type === 'AwaitExpression' && is_simple_expression(fallback.argument)) { return b.await(b.call('$.fallback', expression, fallback.argument)); } return is_expression_async(fallback) ? b.await(b.call('$.fallback', expression, b.thunk(fallback, true), b.true)) : b.call('$.fallback', expression, b.thunk(fallback), b.true); } /** * @param {ESTree.AssignmentOperator} operator * @param {ESTree.Identifier | ESTree.MemberExpression} left * @param {ESTree.Expression} right */ export function build_assignment_value(operator, left, right) { return operator === '=' ? right : // turn something like x += 1 into x = x + 1 ['||=', '&&=', '??='].includes(operator) ? b.logical(/** @type {ESTree.LogicalOperator} */ (operator.slice(0, -1)), left, right) : b.binary(/** @type {ESTree.BinaryOperator} */ (operator.slice(0, -1)), left, right); }
```

# compiler/utils/builders.js

```js
/** @import * as ESTree from 'estree' */ import { walk } from 'zimmerframe'; import { regex_is_valid_identifier } from '../phases/patterns.js'; import { sanitize_template_string } from './sanitize_template_string.js'; /** * @param {Array<ESTree.Expression | ESTree.SpreadElement | null>} elements * @returns {ESTree.ArrayExpression} */ export function array(elements = []) { return { type: 'ArrayExpression', elements }; } /** * @param {Array<ESTree.Pattern | null>} elements * @returns {ESTree.ArrayPattern} */ export function array_pattern(elements) { return { type: 'ArrayPattern', elements }; } /** * @param {ESTree.Pattern} left * @param {ESTree.Expression} right * @returns {ESTree.AssignmentPattern} */ export function assignment_pattern(left, right) { return { type: 'AssignmentPattern', left, right }; } /** * @param {Array<ESTree.Pattern>} params * @param {ESTree.BlockStatement | ESTree.Expression} body * @param {boolean} async * @returns {ESTree.ArrowFunctionExpression} */ export function arrow(params, body, async = false) { return { type: 'ArrowFunctionExpression', params, body, expression: body.type !== 'BlockStatement', generator: false, async, metadata: /** @type {any} */ (null) // should not be used by codegen }; } /** * @param {ESTree.AssignmentOperator} operator * @param {ESTree.Pattern} left * @param {ESTree.Expression} right * @returns {ESTree.AssignmentExpression} */ export function assignment(operator, left, right) { return { type: 'AssignmentExpression', operator, left, right }; } /** * @template T * @param {T & ESTree.BaseFunction} func * @returns {T & ESTree.BaseFunction} */ export function async(func) { return { ...func, async: true }; } /** * @param {ESTree.Expression} argument * @returns {ESTree.AwaitExpression} */ function await_builder(argument) { return { type: 'AwaitExpression', argument }; } /** * @param {ESTree.BinaryOperator} operator * @param {ESTree.Expression} left * @param {ESTree.Expression} right * @returns {ESTree.BinaryExpression} */ export function binary(operator, left, right) { return { type: 'BinaryExpression', operator, left, right }; } /** * @param {ESTree.Statement[]} body * @returns {ESTree.BlockStatement} */ export function block(body) { return { type: 'BlockStatement', body }; } /** * @param {string} name * @param {ESTree.Statement} body * @returns {ESTree.LabeledStatement} */ export function labeled(name, body) { return { type: 'LabeledStatement', label: id(name), body }; } /** * @param {string | ESTree.Expression} callee * @param {...(ESTree.Expression | ESTree.SpreadElement | false | undefined | null)} args * @returns {ESTree.CallExpression} */ export function call(callee, ...args) { if (typeof callee === 'string') callee = id(callee); args = args.slice(); // replacing missing arguments with `undefined`, unless they're at the end in which case remove them let i = args.length; let popping = true; while (i--) { if (!args[i]) { if (popping) { args.pop(); } else { args[i] = id('undefined'); } } else { popping = false; } } return { type: 'CallExpression', callee, arguments: /** @type {Array<ESTree.Expression | ESTree.SpreadElement>} */ (args), optional: false }; } /** * @param {string | ESTree.Expression} callee * @param {...ESTree.Expression} args * @returns {ESTree.ChainExpression} */ export function maybe_call(callee, ...args) { const expression = /** @type {ESTree.SimpleCallExpression} */ (call(callee, ...args)); expression.optional = true; return { type: 'ChainExpression', expression }; } /** * @param {ESTree.UnaryOperator} operator * @param {ESTree.Expression} argument * @returns {ESTree.UnaryExpression} */ export function unary(operator, argument) { return { type: 'UnaryExpression', argument, operator, prefix: true }; } export const void0 = unary('void', literal(0)); /** * @param {ESTree.Expression} test * @param {ESTree.Expression} consequent * @param {ESTree.Expression} alternate * @returns {ESTree.ConditionalExpression} */ export function conditional(test, consequent, alternate) { return { type: 'ConditionalExpression', test, consequent, alternate }; } /** * @param {ESTree.LogicalOperator} operator * @param {ESTree.Expression} left * @param {ESTree.Expression} right * @returns {ESTree.LogicalExpression} */ export function logical(operator, left, right) { return { type: 'LogicalExpression', operator, left, right }; } /** * @param {'const' | 'let' | 'var'} kind * @param {ESTree.VariableDeclarator[]} declarations * @returns {ESTree.VariableDeclaration} */ export function declaration(kind, declarations) { return { type: 'VariableDeclaration', kind, declarations }; } /** * @param {ESTree.Pattern | string} pattern * @param {ESTree.Expression} [init] * @returns {ESTree.VariableDeclarator} */ export function declarator(pattern, init) { if (typeof pattern === 'string') pattern = id(pattern); return { type: 'VariableDeclarator', id: pattern, init }; } /** @type {ESTree.EmptyStatement} */ export const empty = { type: 'EmptyStatement' }; /** * @param {ESTree.Expression | ESTree.MaybeNamedClassDeclaration | ESTree.MaybeNamedFunctionDeclaration} declaration * @returns {ESTree.ExportDefaultDeclaration} */ export function export_default(declaration) { return { type: 'ExportDefaultDeclaration', declaration }; } /** * @param {ESTree.Identifier} id * @param {ESTree.Pattern[]} params * @param {ESTree.BlockStatement} body * @param {boolean} async * @returns {ESTree.FunctionDeclaration} */ export function function_declaration(id, params, body, async = false) { return { type: 'FunctionDeclaration', id, params, body, generator: false, async, metadata: /** @type {any} */ (null) // should not be used by codegen }; } /** * @param {string} name * @param {ESTree.Statement[]} body * @returns {ESTree.Property & { value: ESTree.FunctionExpression}}} */ export function get(name, body) { return prop('get', key(name), function_builder(null, [], block(body))); } /** * @param {string} name * @returns {ESTree.Identifier} */ export function id(name) { return { type: 'Identifier', name }; } /** * @param {string} name * @returns {ESTree.PrivateIdentifier} */ export function private_id(name) { return { type: 'PrivateIdentifier', name }; } /** * @param {string} local * @returns {ESTree.ImportNamespaceSpecifier} */ function import_namespace(local) { return { type: 'ImportNamespaceSpecifier', local: id(local) }; } /** * @param {string} name * @param {ESTree.Expression} value * @returns {ESTree.Property} */ export function init(name, value) { return prop('init', key(name), value); } /** * @param {string | boolean | null | number | RegExp} value * @returns {ESTree.Literal} */ export function literal(value) { // @ts-expect-error we don't want to muck around with bigint here return { type: 'Literal', value }; } /** * @param {ESTree.Expression | ESTree.Super} object * @param {string | ESTree.Expression | ESTree.PrivateIdentifier} property * @param {boolean} computed * @param {boolean} optional * @returns {ESTree.MemberExpression} */ export function member(object, property, computed = false, optional = false) { if (typeof property === 'string') { property = id(property); } return { type: 'MemberExpression', object, property, computed, optional }; } /** * @param {string} path * @returns {ESTree.Identifier | ESTree.MemberExpression} */ export function member_id(path) { const parts = path.split('.'); /** @type {ESTree.Identifier | ESTree.MemberExpression} */ let expression = id(parts[0]); for (let i = 1; i < parts.length; i += 1) { expression = member(expression, id(parts[i])); } return expression; } /** * @param {Array<ESTree.Property | ESTree.SpreadElement>} properties * @returns {ESTree.ObjectExpression} */ export function object(properties) { return { type: 'ObjectExpression', properties }; } /** * @param {Array<ESTree.RestElement | ESTree.AssignmentProperty | ESTree.Property>} properties * @returns {ESTree.ObjectPattern} */ export function object_pattern(properties) { // @ts-expect-error the types appear to be wrong return { type: 'ObjectPattern', properties }; } /** * @template {ESTree.Expression} Value * @param {'init' | 'get' | 'set'} kind * @param {ESTree.Expression} key * @param {Value} value * @param {boolean} computed * @returns {ESTree.Property & { value: Value }} */ export function prop(kind, key, value, computed = false) { return { type: 'Property', kind, key, value, method: false, shorthand: false, computed }; } /** * @param {ESTree.Expression | ESTree.PrivateIdentifier} key * @param {ESTree.Expression | null | undefined} value * @param {boolean} computed * @param {boolean} is_static * @returns {ESTree.PropertyDefinition} */ export function prop_def(key, value, computed = false, is_static = false) { return { type: 'PropertyDefinition', key, value, computed, static: is_static }; } /** * @param {string} cooked * @param {boolean} tail * @returns {ESTree.TemplateElement} */ export function quasi(cooked, tail = false) { const raw = sanitize_template_string(cooked); return { type: 'TemplateElement', value: { raw, cooked }, tail }; } /** * @param {ESTree.Pattern} argument * @returns {ESTree.RestElement} */ export function rest(argument) { return { type: 'RestElement', argument }; } /** * @param {ESTree.Expression[]} expressions * @returns {ESTree.SequenceExpression} */ export function sequence(expressions) { return { type: 'SequenceExpression', expressions }; } /** * @param {string} name * @param {ESTree.Statement[]} body * @returns {ESTree.Property & { value: ESTree.FunctionExpression}} */ export function set(name, body) { return prop('set', key(name), function_builder(null, [id('$$value')], block(body))); } /** * @param {ESTree.Expression} argument * @returns {ESTree.SpreadElement} */ export function spread(argument) { return { type: 'SpreadElement', argument }; } /** * @param {ESTree.Expression} expression * @returns {ESTree.ExpressionStatement} */ export function stmt(expression) { return { type: 'ExpressionStatement', expression }; } /** * @param {ESTree.TemplateElement[]} elements * @param {ESTree.Expression[]} expressions * @returns {ESTree.TemplateLiteral} */ export function template(elements, expressions) { return { type: 'TemplateLiteral', quasis: elements, expressions }; } /** * @param {ESTree.Expression | ESTree.BlockStatement} expression * @param {boolean} [async] * @returns {ESTree.Expression} */ export function thunk(expression, async = false) { return unthunk(arrow([], expression, async)); } /** * Replace "(arg) => func(arg)" to "func" * @param {ESTree.ArrowFunctionExpression} expression * @returns {ESTree.Expression} */ export function unthunk(expression) { // optimize `async () => await x()`, but not `async () => await x(await y)` if (expression.async && expression.body.type === 'AwaitExpression') { let has_await = false; walk(expression.body.argument, null, { AwaitExpression(_node, context) { has_await = true; context.stop(); } }); if (!has_await) { return unthunk(arrow(expression.params, expression.body.argument)); } } if ( expression.async === false && expression.body.type === 'CallExpression' && expression.body.callee.type === 'Identifier' && expression.params.length === expression.body.arguments.length && expression.params.every((param, index) => { const arg = /** @type {ESTree.SimpleCallExpression} */ (expression.body).arguments[index]; return param.type === 'Identifier' && arg.type === 'Identifier' && param.name === arg.name; }) ) { return expression.body.callee; } return expression; } /** * * @param {string | ESTree.Expression} expression * @param {...ESTree.Expression} args * @returns {ESTree.NewExpression} */ function new_builder(expression, ...args) { if (typeof expression === 'string') expression = id(expression); return { callee: expression, arguments: args, type: 'NewExpression' }; } /** * @param {ESTree.UpdateOperator} operator * @param {ESTree.Expression} argument * @param {boolean} prefix * @returns {ESTree.UpdateExpression} */ export function update(operator, argument, prefix = false) { return { type: 'UpdateExpression', operator, argument, prefix }; } /** * @param {ESTree.Expression} test * @param {ESTree.Statement} body * @returns {ESTree.DoWhileStatement} */ export function do_while(test, body) { return { type: 'DoWhileStatement', test, body }; } const true_instance = literal(true); const false_instance = literal(false); const null_instance = literal(null); /** @type {ESTree.DebuggerStatement} */ const debugger_builder = { type: 'DebuggerStatement' }; /** @type {ESTree.ThisExpression} */ const this_instance = { type: 'ThisExpression' }; /** * @param {string | ESTree.Pattern} pattern * @param { ESTree.Expression} [init] * @returns {ESTree.VariableDeclaration} */ function let_builder(pattern, init) { return declaration('let', [declarator(pattern, init)]); } /** * @param {string | ESTree.Pattern} pattern * @param { ESTree.Expression} init * @returns {ESTree.VariableDeclaration} */ function const_builder(pattern, init) { return declaration('const', [declarator(pattern, init)]); } /** * @param {string | ESTree.Pattern} pattern * @param { ESTree.Expression} [init] * @returns {ESTree.VariableDeclaration} */ function var_builder(pattern, init) { return declaration('var', [declarator(pattern, init)]); } /** * * @param {ESTree.VariableDeclaration | ESTree.Expression | null} init * @param {ESTree.Expression} test * @param {ESTree.Expression} update * @param {ESTree.Statement} body * @returns {ESTree.ForStatement} */ function for_builder(init, test, update, body) { return { type: 'ForStatement', init, test, update, body }; } /** * * @param {'constructor' | 'method' | 'get' | 'set'} kind * @param {ESTree.Expression | ESTree.PrivateIdentifier} key * @param {ESTree.Pattern[]} params * @param {ESTree.Statement[]} body * @param {boolean} computed * @param {boolean} is_static * @returns {ESTree.MethodDefinition} */ export function method(kind, key, params, body, computed = false, is_static = false) { return { type: 'MethodDefinition', key, kind, value: function_builder(null, params, block(body)), computed, static: is_static }; } /** * * @param {ESTree.Identifier | null} id * @param {ESTree.Pattern[]} params * @param {ESTree.BlockStatement} body * @returns {ESTree.FunctionExpression} */ function function_builder(id, params, body) { return { type: 'FunctionExpression', id, params, body, generator: false, async: false, metadata: /** @type {any} */ (null) // should not be used by codegen }; } /** * @param {ESTree.Expression} test * @param {ESTree.Statement} consequent * @param {ESTree.Statement} [alternate] * @returns {ESTree.IfStatement} */ function if_builder(test, consequent, alternate) { return { type: 'IfStatement', test, consequent, alternate }; } /** * @param {string} as * @param {string} source * @returns {ESTree.ImportDeclaration} */ export function import_all(as, source) { return { type: 'ImportDeclaration', source: literal(source), specifiers: [import_namespace(as)] }; } /** * @param {Array<[string, string]>} parts * @param {string} source * @returns {ESTree.ImportDeclaration} */ export function imports(parts, source) { return { type: 'ImportDeclaration', source: literal(source), specifiers: parts.map((p) => ({ type: 'ImportSpecifier', imported: id(p[0]), local: id(p[1]) })) }; } /** * @param {ESTree.Expression | null} argument * @returns {ESTree.ReturnStatement} */ function return_builder(argument = null) { return { type: 'ReturnStatement', argument }; } /** * @param {string} str * @returns {ESTree.ThrowStatement} */ export function throw_error(str) { return { type: 'ThrowStatement', argument: new_builder('Error', literal(str)) }; } export { await_builder as await, let_builder as let, const_builder as const, var_builder as var, true_instance as true, false_instance as false, for_builder as for, function_builder as function, return_builder as return, if_builder as if, this_instance as this, null_instance as null, debugger_builder as debugger }; /** * @param {string} name * @returns {ESTree.Expression} */ export function key(name) { return regex_is_valid_identifier.test(name) ? id(name) : literal(name); }
```

# compiler/utils/compile_diagnostic.js

```js
/** @import { Location } from 'locate-character' */ import * as state from '../state.js'; const regex_tabs = /^\t+/; /** * @param {string} str */ function tabs_to_spaces(str) { return str.replace(regex_tabs, (match) => match.split('\t').join(' ')); } /** * @param {string} source * @param {number} line * @param {number} column */ function get_code_frame(source, line, column) { const lines = source.split('\n'); const frame_start = Math.max(0, line - 2); const frame_end = Math.min(line + 3, lines.length); const digits = String(frame_end + 1).length; return lines .slice(frame_start, frame_end) .map((str, i) => { const is_error_line = frame_start + i === line; const line_num = String(i + frame_start + 1).padStart(digits, ' '); if (is_error_line) { const indicator = ' '.repeat(digits + 2 + tabs_to_spaces(str.slice(0, column)).length) + '^'; return `${line_num}: ${tabs_to_spaces(str)}\n${indicator}`; } return `${line_num}: ${tabs_to_spaces(str)}`; }) .join('\n'); } /** * @typedef {{ * code: string; * message: string; * stack?: string; * filename?: string; * start?: Location; * end?: Location; * position?: [number, number]; * frame?: string; * }} ICompileDiagnostic */ /** @implements {ICompileDiagnostic} */ export class CompileDiagnostic { name = 'CompileDiagnostic'; /** * @param {string} code * @param {string} message * @param {[number, number] | undefined} position */ constructor(code, message, position) { this.code = code; this.message = message; if (state.filename) { this.filename = state.filename; } if (position) { this.position = position; this.start = state.locator(position[0]); this.end = state.locator(position[1]); if (this.start && this.end) { this.frame = get_code_frame(state.source, this.start.line - 1, this.end.column); } } } toString() { let out = `${this.code}: ${this.message}`; if (this.filename) { out += `\n${this.filename}`; if (this.start) { out += `:${this.start.line}:${this.start.column}`; } } if (this.frame) { out += `\n${this.frame}`; } return out; } toJSON() { return { code: this.code, message: this.message, filename: this.filename, start: this.start, end: this.end, position: this.position, frame: this.frame }; } }
```

# compiler/utils/extract_svelte_ignore.js

```js
import { IGNORABLE_RUNTIME_WARNINGS } from '../../constants.js'; import fuzzymatch from '../phases/1-parse/utils/fuzzymatch.js'; import * as w from '../warnings.js'; const regex_svelte_ignore = /^\s*svelte-ignore\s/; /** @type {Record<string, string>} Map of legacy code -> new code */ const replacements = { 'non-top-level-reactive-declaration': 'reactive_declaration_invalid_placement', 'module-script-reactive-declaration': 'reactive_declaration_module_script', 'empty-block': 'block_empty', 'avoid-is': 'attribute_avoid_is', 'invalid-html-attribute': 'attribute_invalid_property_name', 'a11y-structure': 'a11y_figcaption_parent', 'illegal-attribute-character': 'attribute_illegal_colon', 'invalid-rest-eachblock-binding': 'bind_invalid_each_rest', 'unused-export-let': 'export_let_unused' }; const codes = w.codes.concat(IGNORABLE_RUNTIME_WARNINGS); /** * @param {number} offset * @param {string} text * @param {boolean} runes * @returns {string[]} */ export function extract_svelte_ignore(offset, text, runes) { const match = regex_svelte_ignore.exec(text); if (!match) return []; let length = match[0].length; offset += length; /** @type {string[]} */ const ignores = []; if (runes) { // Warnings have to be separated by commas, everything after is interpreted as prose for (const match of text.slice(length).matchAll(/([\w$-]+)(,)?/gm)) { const code = match[1]; if (codes.includes(code)) { ignores.push(code); } else { const replacement = replacements[code] ?? code.replace(/-/g, '_'); // The type cast is for some reason necessary to pass the type check in CI const start = offset + /** @type {number} */ (match.index); const end = start + code.length; if (codes.includes(replacement)) { w.legacy_code({ start, end }, code, replacement); } else { const suggestion = fuzzymatch(code, codes); w.unknown_code({ start, end }, code, suggestion); } } if (!match[2]) { break; } } } else { // Non-runes mode: lax parsing, backwards compat with old codes for (const match of text.slice(length).matchAll(/[\w$-]+/gm)) { const code = match[0]; ignores.push(code); if (!codes.includes(code)) { const replacement = replacements[code] ?? code.replace(/-/g, '_'); if (codes.includes(replacement)) { ignores.push(replacement); } } } } return ignores; } /** * Replaces legacy svelte-ignore codes with new codes. * @param {string} text * @returns {string} */ export function migrate_svelte_ignore(text) { const match = regex_svelte_ignore.exec(text); if (!match) return text; const length = match[0].length; return ( text.substring(0, length) + text.substring(length).replace(/\w+-\w+(-\w+)*/g, (code, _, idx) => { let replacement = replacements[code] ?? code.replace(/-/g, '_'); if (/\w+-\w+/.test(text.substring(length + idx + code.length))) { replacement += ','; } return replacement; }) ); }
```

# compiler/utils/mapped_code.js

```js
/** @import { ValidatedCompileOptions } from '#compiler' */ /** @import { Processed } from '../preprocess/public.js' */ /** @import { SourceMap } from 'magic-string' */ /** @import { Source } from '../preprocess/private.js' */ /** @import { DecodedSourceMap, SourceMapSegment, RawSourceMap } from '@ampproject/remapping' */ import remapping from '@ampproject/remapping'; import { push_array } from './push_array.js'; /** * @param {string} s */ function last_line_length(s) { return s.length - s.lastIndexOf('\n') - 1; } // mutate map in-place /** * @param {DecodedSourceMap} map * @param {{ line: number; column: number; }} offset * @param {number} source_index */ export function sourcemap_add_offset(map, offset, source_index) { if (map.mappings.length == 0) return; for (let line = 0; line < map.mappings.length; line++) { const segment_list = map.mappings[line]; for (let segment = 0; segment < segment_list.length; segment++) { const seg = segment_list[segment]; // shift only segments that belong to component source file if (seg[1] === source_index) { // also ensures that seg.length >= 4 // shift column if it points at the first line if (seg[2] === 0) { /** @type {any} */ (seg[3]) += offset.column; } // shift line /** @type {any} */ (seg[2]) += offset.line; } } } } /** * @template T * @param {T[]} this_table * @param {T[]} other_table * @returns {[T[], number[], boolean, boolean]} */ function merge_tables(this_table, other_table) { const new_table = this_table.slice(); const idx_map = []; other_table = other_table || []; let val_changed = false; for (const [other_idx, other_val] of other_table.entries()) { const this_idx = this_table.indexOf(other_val); if (this_idx >= 0) { idx_map[other_idx] = this_idx; } else { const new_idx = new_table.length; new_table[new_idx] = other_val; idx_map[other_idx] = new_idx; val_changed = true; } } let idx_changed = val_changed; if (val_changed) { if (idx_map.find((val, idx) => val != idx) === undefined) { // idx_map is identity map [0, 1, 2, 3, 4, ....] idx_changed = false; } } return [new_table, idx_map, val_changed, idx_changed]; } const regex_line_token = /([^\w\s]|\s+)/g; /** */ export class MappedCode { /** * @type {string} */ string = /** @type {any} */ (undefined); /** * @type {DecodedSourceMap} */ map = /** @type {any} */ (undefined); /** * @param {string} string * @param {DecodedSourceMap | null} map */ constructor(string = '', map = null) { this.string = string; if (map) { this.map = map; } else { this.map = { version: 3, mappings: [], sources: [], names: [] }; } } /** * concat in-place (mutable), return this (chainable) * will also mutate the `other` object * @param {MappedCode} other * @returns {MappedCode} */ concat(other) { // noop: if one is empty, return the other if (other.string == '') return this; if (this.string == '') { this.string = other.string; this.map = other.map; return this; } // compute last line length before mutating const column_offset = last_line_length(this.string); this.string += other.string; const m1 = this.map; const m2 = other.map; if (m2.mappings.length == 0) return this; // combine sources and names const [sources, new_source_idx, sources_changed, sources_idx_changed] = merge_tables( m1.sources, m2.sources ); const [names, new_name_idx, names_changed, names_idx_changed] = merge_tables( m1.names, m2.names ); if (sources_changed) m1.sources = sources; if (names_changed) m1.names = names; // unswitched loops are faster if (sources_idx_changed && names_idx_changed) { for (let line = 0; line < m2.mappings.length; line++) { const segment_list = m2.mappings[line]; for (let segment = 0; segment < segment_list.length; segment++) { const seg = segment_list[segment]; // @ts-ignore if (seg[1] >= 0) seg[1] = new_source_idx[seg[1]]; // @ts-ignore if (seg[4] >= 0) seg[4] = new_name_idx[seg[4]]; } } } else if (sources_idx_changed) { for (let line = 0; line < m2.mappings.length; line++) { const segment_list = m2.mappings[line]; for (let segment = 0; segment < segment_list.length; segment++) { const seg = segment_list[segment]; // @ts-ignore if (seg[1] >= 0) seg[1] = new_source_idx[seg[1]]; } } } else if (names_idx_changed) { for (let line = 0; line < m2.mappings.length; line++) { const segment_list = m2.mappings[line]; for (let segment = 0; segment < segment_list.length; segment++) { const seg = segment_list[segment]; // @ts-ignore if (seg[4] >= 0) seg[4] = new_name_idx[seg[4]]; } } } // combine the mappings // combine // 1. last line of first map // 2. first line of second map // columns of 2 must be shifted if (m2.mappings.length > 0 && column_offset > 0) { const first_line = m2.mappings[0]; for (let i = 0; i < first_line.length; i++) { first_line[i][0] += column_offset; } } // combine last line + first line push_array( m1.mappings[m1.mappings.length - 1], /** @type {SourceMapSegment[]} */ (m2.mappings.shift()) ); // append other lines push_array(m1.mappings, m2.mappings); return this; } /** * @static * @param {string} string * @param {DecodedSourceMap} [map] * @returns {MappedCode} */ static from_processed(string, map) { const line_count = string.split('\n').length; if (map) { // ensure that count of source map mappings lines // is equal to count of generated code lines // (some tools may produce less) const missing_lines = line_count - map.mappings.length; for (let i = 0; i < missing_lines; i++) { map.mappings.push([]); } return new MappedCode(string, map); } if (string == '') return new MappedCode(); map = { version: 3, names: [], sources: [], mappings: [] }; // add empty SourceMapSegment[] for every line for (let i = 0; i < line_count; i++) map.mappings.push([]); return new MappedCode(string, map); } /** * @static * @param {Source} opts * @returns {MappedCode} */ static from_source({ source, file_basename, get_location }) { /** * @type {{ line: number; column: number; }} */ let offset = get_location(0); if (!offset) offset = { line: 0, column: 0 }; /** * @type {DecodedSourceMap} */ const map = { version: 3, names: [], sources: [file_basename], mappings: [] }; if (source == '') return new MappedCode(source, map); // we create a high resolution identity map here, // we know that it will eventually be merged with svelte's map, // at which stage the resolution will decrease. const line_list = source.split('\n'); for (let line = 0; line < line_list.length; line++) { map.mappings.push([]); const token_list = line_list[line].split(regex_line_token); for (let token = 0, column = 0; token < token_list.length; token++) { if (token_list[token] == '') continue; map.mappings[line].push([column, 0, offset.line + line, column]); column += token_list[token].length; } } // shift columns in first line const segment_list = map.mappings[0]; for (let segment = 0; segment < segment_list.length; segment++) { // @ts-ignore segment_list[segment][3] += offset.column; } return new MappedCode(source, map); } } // browser vs node.js const b64enc = typeof window !== 'undefined' && typeof btoa === 'function' ? /** @param {string} str */ (str) => btoa(unescape(encodeURIComponent(str))) : /** @param {string} str */ (str) => Buffer.from(str).toString('base64'); const b64dec = typeof window !== 'undefined' && typeof atob === 'function' ? atob : /** @param {any} a */ (a) => Buffer.from(a, 'base64').toString(); /** * @param {string} filename Basename of the input file * @param {Array<DecodedSourceMap | RawSourceMap>} sourcemap_list */ export function combine_sourcemaps(filename, sourcemap_list) { if (sourcemap_list.length == 0) return null; let map_idx = 1; const map = sourcemap_list.slice(0, -1).find((m) => m.sources.length !== 1) === undefined ? remapping( // use array interface // only the oldest sourcemap can have multiple sources sourcemap_list, () => null, true // skip optional field `sourcesContent` ) : remapping( // use loader interface sourcemap_list[0], // last map (sourcefile) => { // TODO the equality check assumes that the preprocessor map has the input file as a relative path in sources, // e.g. when the input file is `src/foo/bar.svelte`, then sources is expected to contain just `bar.svelte`. // Therefore filename also needs to be the basename of the path. This feels brittle, investigate how we can // harden this (without breaking other tooling that assumes this behavior). if (sourcefile === filename && sourcemap_list[map_idx]) { return sourcemap_list[map_idx++]; // idx 1, 2, ... // bundle file = branch node } else { return null; // source file = leaf node } }, true ); if (!map.file) delete map.file; // skip optional field `file` // When source maps are combined and the leading map is empty, sources is not set. // Add the filename to the empty array in this case. // Further improvements to remapping may help address this as well https://github.com/ampproject/remapping/issues/116 if (!map.sources.length) map.sources = [filename]; return map; } /** * @param {string} filename * @param {SourceMap} svelte_map * @param {string | DecodedSourceMap | RawSourceMap} preprocessor_map_input * @returns {SourceMap} */ function apply_preprocessor_sourcemap(filename, svelte_map, preprocessor_map_input) { if (!svelte_map || !preprocessor_map_input) return svelte_map; const preprocessor_map = typeof preprocessor_map_input === 'string' ? JSON.parse(preprocessor_map_input) : preprocessor_map_input; const result_map = combine_sourcemaps(filename, [svelte_map, preprocessor_map]); // Svelte expects a SourceMap which includes toUrl and toString. Instead of wrapping our output in a class, // we just tack on the extra properties. Object.defineProperties(result_map, { toString: { enumerable: false, value: function toString() { return JSON.stringify(this); } }, toUrl: { enumerable: false, value: function toUrl() { return 'data:application/json;charset=utf-8;base64,' + b64enc(this.toString()); } } }); return /** @type {any} */ (result_map); } const regex_data_uri = /data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(\S*)/; // parse attached sourcemap in processed.code /** * @param {Processed} processed * @param {'script' | 'style'} tag_name * @returns {void} */ export function parse_attached_sourcemap(processed, tag_name) { const r_in = '[#@]\\s*sourceMappingURL\\s*=\\s*(\\S*)'; const regex = tag_name == 'script' ? new RegExp('(?://' + r_in + ')|(?:/\\*' + r_in + '\\s*\\*/)$') : new RegExp('/\\*' + r_in + '\\s*\\*/$'); /** * @param {any} message */ function log_warning(message) { // code_start: help to find preprocessor const code_start = processed.code.length < 100 ? processed.code : processed.code.slice(0, 100) + ' [...]'; // eslint-disable-next-line no-console console.warn(`warning: ${message}. processed.code = ${JSON.stringify(code_start)}`); } processed.code = processed.code.replace(regex, (_, match1, match2) => { const map_url = tag_name == 'script' ? match1 || match2 : match1; const map_data = (map_url.match(regex_data_uri) || [])[1]; if (map_data) { // sourceMappingURL is data URL if (processed.map) { log_warning( 'Not implemented. ' + 'Found sourcemap in both processed.code and processed.map. ' + 'Please update your preprocessor to return only one sourcemap.' ); // ignore attached sourcemap return ''; } processed.map = b64dec(map_data); // use attached sourcemap return ''; // remove from processed.code } // sourceMappingURL is path or URL if (!processed.map) { log_warning( `Found sourcemap path ${JSON.stringify( map_url )} in processed.code, but no sourcemap data. ` + 'Please update your preprocessor to return sourcemap data directly.' ); } // ignore sourcemap path return ''; // remove from processed.code }); } /** * @param {{ code: string, map: SourceMap}} result * @param {ValidatedCompileOptions} options * @param {string} source_name */ export function merge_with_preprocessor_map(result, options, source_name) { if (options.sourcemap) { const file_basename = get_basename(options.filename); // The preprocessor map is expected to contain `sources: [basename_of_filename]`, but our own // map may contain a different file name. Patch our map beforehand to align sources so merging // with the preprocessor map works correctly. result.map.sources = [file_basename]; Object.assign( result.map, apply_preprocessor_sourcemap( file_basename, result.map, /** @type {any} */ (options.sourcemap) ) ); // After applying the preprocessor map, we need to do the inverse and make the sources // relative to the input file again in case the output code is in a different directory. if (file_basename !== source_name) { result.map.sources = result.map.sources.map( /** @param {string} source */ (source) => get_relative_path(source_name, source) ); } } } /** * @param {string} from * @param {string} to */ function get_relative_path(from, to) { // Don't use node's utils here to ensure the compiler is usable in a browser environment const from_parts = from.split(/[/\\]/); const to_parts = to.split(/[/\\]/); from_parts.pop(); // get dirname while (from_parts[0] === to_parts[0]) { from_parts.shift(); to_parts.shift(); } if (from_parts.length) { let i = from_parts.length; while (i--) from_parts[i] = '..'; } return from_parts.concat(to_parts).join('/'); } /** * Like node's `basename`, but doesn't use it to ensure the compiler is usable in a browser environment * @param {string} filename */ export function get_basename(filename) { return /** @type {string} */ (filename.split(/[/\\]/).pop()); } /** * @param {string} filename * @param {string | undefined} output_filename * @param {string} fallback */ export function get_source_name(filename, output_filename, fallback) { return output_filename ? get_relative_path(output_filename, filename) : get_basename(filename); }
```

# compiler/utils/push_array.js

```js
/** * Pushes all `items` into `array` using `push`, therefore mutating the array. * We do this for memory and perf reasons, and because `array.push(...items)` would * run into a "max call stack size exceeded" error with too many items (~65k). * @template T * @param {T[]} array * @param {T[]} items */ export function push_array(array, items) { for (let i = 0; i < items.length; i++) { array.push(items[i]); } }
```

# compiler/utils/sanitize_template_string.js

```js
/** * @param {string} str * @returns {string} */ export function sanitize_template_string(str) { return str.replace(/(`|\${|\\)/g, '\\$1'); }
```

# compiler/utils/slot.js

```js
/** @import { AST } from '#compiler' */ import { is_element_node } from '../phases/nodes.js'; import { is_text_attribute } from './ast.js'; /** * @param {AST.SvelteNode} node */ export function determine_slot(node) { if (!is_element_node(node)) return null; for (const attribute of node.attributes) { if (attribute.type !== 'Attribute') continue; if (attribute.name !== 'slot') continue; if (!is_text_attribute(attribute)) continue; return /** @type {string} */ (attribute.value[0].data); } return null; }
```

# compiler/utils/string.js

```js
/** * @param {string[]} strings * @param {string} conjunction */ export function list(strings, conjunction = 'or') { if (strings.length === 1) return strings[0]; if (strings.length === 2) return `${strings[0]} ${conjunction} ${strings[1]}`; return `${strings.slice(0, -1).join(', ')} ${conjunction} ${strings[strings.length - 1]}`; }
```

# compiler/validate-options.js

```js
/** @import { ModuleCompileOptions, ValidatedModuleCompileOptions, CompileOptions, ValidatedCompileOptions } from '#compiler' */ import * as e from './errors.js'; import * as w from './warnings.js'; /** * @template [Input=any] * @template [Output=Input] * @typedef {(input: Input, keypath: string) => Required<Output>} Validator */ const common = { filename: string('(unknown)'), // default to process.cwd() where it exists to replicate svelte4 behavior (and make Deno work with this as well) // see https://github.com/sveltejs/svelte/blob/b62fc8c8fd2640c9b99168f01b9d958cb2f7574f/packages/svelte/src/compiler/compile/Component.js#L211 /* eslint-disable */ rootDir: string( typeof process !== 'undefined' ? process.cwd?.() : // @ts-expect-error typeof Deno !== 'undefined' ? // @ts-expect-error Deno.cwd() : undefined ), /* eslint-enable */ dev: boolean(false), generate: validator('client', (input, keypath) => { if (input === 'dom' || input === 'ssr') { warn_once(w.options_renamed_ssr_dom); return input === 'dom' ? 'client' : 'server'; } // TODO deprecate `false` in favour of `analyze`/`analyzeModule` https://github.com/sveltejs/svelte-octane/issues/655 if (input !== 'client' && input !== 'server' && input !== false) { throw_error(`${keypath} must be "client", "server" or false`); } return input; }), warningFilter: fun(() => true), experimental: object({ async: boolean(false) }) }; export const validate_module_options = /** @type {Validator<ModuleCompileOptions, ValidatedModuleCompileOptions>} */ ( object({ ...common }) ); export const validate_component_options = /** @type {Validator<CompileOptions, ValidatedCompileOptions>} */ ( object({ ...common, accessors: deprecate(w.options_deprecated_accessors, boolean(false)), css: validator('external', (input) => { if (input === true || input === false) { throw_error( 'The boolean options have been removed from the css option. Use "external" instead of false and "injected" instead of true' ); } if (input === 'none') { throw_error( 'css: "none" is no longer a valid option. If this was crucial for you, please open an issue on GitHub with your use case.' ); } if (input !== 'external' && input !== 'injected') { throw_error(`css should be either "external" (default, recommended) or "injected"`); } return input; }), cssHash: fun(({ css, hash }) => { return `svelte-${hash(css)}`; }), // TODO this is a sourcemap option, would be good to put under a sourcemap namespace cssOutputFilename: string(undefined), customElement: boolean(false), discloseVersion: boolean(true), immutable: deprecate(w.options_deprecated_immutable, boolean(false)), legacy: removed( 'The legacy option has been removed. If you are using this because of legacy.componentApi, use compatibility.componentApi instead' ), compatibility: object({ componentApi: list([4, 5], 5) }), loopGuardTimeout: warn_removed(w.options_removed_loop_guard_timeout), name: string(undefined), namespace: list(['html', 'mathml', 'svg']), modernAst: boolean(false), outputFilename: string(undefined), preserveComments: boolean(false), fragments: list(['html', 'tree']), preserveWhitespace: boolean(false), runes: boolean(undefined), hmr: boolean(false), sourcemap: validator(undefined, (input) => { // Source maps can take on a variety of values, including string, JSON, map objects from magic-string and source-map, // so there's no good way to check type validity here return input; }), enableSourcemap: warn_removed(w.options_removed_enable_sourcemap), hydratable: warn_removed(w.options_removed_hydratable), format: removed( 'The format option has been removed in Svelte 4, the compiler only outputs ESM now. Remove "format" from your compiler options. ' + 'If you did not set this yourself, bump the version of your bundler plugin (vite-plugin-svelte/rollup-plugin-svelte/svelte-loader)' ), tag: removed( 'The tag option has been removed in Svelte 5. Use `<svelte:options customElement="tag-name" />` inside the component instead. ' + 'If that does not solve your use case, please open an issue on GitHub with details.' ), sveltePath: removed( 'The sveltePath option has been removed in Svelte 5. ' + 'If this option was crucial for you, please open an issue on GitHub with your use case.' ), // These two were primarily created for svelte-preprocess (https://github.com/sveltejs/svelte/pull/6194), // but with new TypeScript compilation modes strictly separating types it's not necessary anymore errorMode: removed( 'The errorMode option has been removed. If you are using this through svelte-preprocess with TypeScript, ' + 'use the https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax setting instead' ), varsReport: removed( 'The vars option has been removed. If you are using this through svelte-preprocess with TypeScript, ' + 'use the https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax setting instead' ) }) ); /** * @param {string} msg * @returns {Validator} */ function removed(msg) { return (input) => { if (input !== undefined) { e.options_removed(null, msg); } return /** @type {any} */ (undefined); }; } const warned = new Set(); /** @param {(node: null) => void} fn */ function warn_once(fn) { if (!warned.has(fn)) { warned.add(fn); fn(null); } } /** * @param {(node: null) => void} fn * @returns {Validator} */ function warn_removed(fn) { return (input) => { if (input !== undefined) warn_once(fn); return /** @type {any} */ (undefined); }; } /** * @param {(node: null) => void} fn * @param {Validator} validator * @returns {Validator} */ function deprecate(fn, validator) { return (input, keypath) => { if (input !== undefined) warn_once(fn); return validator(input, keypath); }; } /** * @param {Record<string, Validator>} children * @param {boolean} [allow_unknown] * @returns {Validator} */ function object(children, allow_unknown = false) { return (input, keypath) => { /** @type {Record<string, any>} */ const output = {}; if ((input && typeof input !== 'object') || Array.isArray(input)) { throw_error(`${keypath} should be an object`); } for (const key in input) { if (!(key in children)) { if (allow_unknown) { output[key] = input[key]; } else { e.options_unrecognised(null, `${keypath ? `${keypath}.${key}` : key}`); } } } for (const key in children) { const validator = children[key]; output[key] = validator(input && input[key], keypath ? `${keypath}.${key}` : key); } return output; }; } /** * @param {any} fallback * @param {(value: any, keypath: string) => any} fn * @returns {Validator} */ function validator(fallback, fn) { return (input, keypath) => { return input === undefined ? fallback : fn(input, keypath); }; } /** * @param {string | undefined} fallback * @param {boolean} allow_empty * @returns {Validator} */ function string(fallback, allow_empty = true) { return validator(fallback, (input, keypath) => { if (typeof input !== 'string') { throw_error(`${keypath} should be a string, if specified`); } if (!allow_empty && input === '') { throw_error(`${keypath} cannot be empty`); } return input; }); } /** * @param {boolean | undefined} fallback * @returns {Validator} */ function boolean(fallback) { return validator(fallback, (input, keypath) => { if (typeof input !== 'boolean') { throw_error(`${keypath} should be true or false, if specified`); } return input; }); } /** * @param {Array<boolean | string | number>} options * @returns {Validator} */ function list(options, fallback = options[0]) { return validator(fallback, (input, keypath) => { if (!options.includes(input)) { // prettier-ignore const msg = options.length > 2 ? `${keypath} should be one of ${options.slice(0, -1).map(input => `"${input}"`).join(', ')} or "${options[options.length - 1]}"` : `${keypath} should be either "${options[0]}" or "${options[1]}"`; throw_error(msg); } return input; }); } /** * @param {(...args: any) => any} fallback * @returns {Validator} */ function fun(fallback) { return validator(fallback, (input, keypath) => { if (typeof input !== 'function') { throw_error(`${keypath} should be a function, if specified`); } return input; }); } /** @param {string} msg */ function throw_error(msg) { e.options_invalid_value(null, msg); }
```

# compiler/warnings.js

```js
/* This file is generated by scripts/process-messages/index.js. Do not edit! */ import { warnings, ignore_stack, ignore_map, warning_filter } from './state.js'; import { CompileDiagnostic } from './utils/compile_diagnostic.js'; /** @typedef {{ start?: number, end?: number }} NodeLike */ class InternalCompileWarning extends CompileDiagnostic { name = 'CompileWarning'; /** * @param {string} code * @param {string} message * @param {[number, number] | undefined} position */ constructor(code, message, position) { super(code, message, position); } } /** * @param {null | NodeLike} node * @param {string} code * @param {string} message */ function w(node, code, message) { let stack = ignore_stack; if (node) { stack = ignore_map.get(node) ?? ignore_stack; } if (stack && stack.at(-1)?.has(code)) return; const warning = new InternalCompileWarning(code, message, node && node.start !== undefined ? [node.start, node.end ?? node.start] : undefined); if (!warning_filter(warning)) return; warnings.push(warning); } export const codes = [ 'a11y_accesskey', 'a11y_aria_activedescendant_has_tabindex', 'a11y_aria_attributes', 'a11y_autocomplete_valid', 'a11y_autofocus', 'a11y_click_events_have_key_events', 'a11y_consider_explicit_label', 'a11y_distracting_elements', 'a11y_figcaption_index', 'a11y_figcaption_parent', 'a11y_hidden', 'a11y_img_redundant_alt', 'a11y_incorrect_aria_attribute_type', 'a11y_incorrect_aria_attribute_type_boolean', 'a11y_incorrect_aria_attribute_type_id', 'a11y_incorrect_aria_attribute_type_idlist', 'a11y_incorrect_aria_attribute_type_integer', 'a11y_incorrect_aria_attribute_type_token', 'a11y_incorrect_aria_attribute_type_tokenlist', 'a11y_incorrect_aria_attribute_type_tristate', 'a11y_interactive_supports_focus', 'a11y_invalid_attribute', 'a11y_label_has_associated_control', 'a11y_media_has_caption', 'a11y_misplaced_role', 'a11y_misplaced_scope', 'a11y_missing_attribute', 'a11y_missing_content', 'a11y_mouse_events_have_key_events', 'a11y_no_abstract_role', 'a11y_no_interactive_element_to_noninteractive_role', 'a11y_no_noninteractive_element_interactions', 'a11y_no_noninteractive_element_to_interactive_role', 'a11y_no_noninteractive_tabindex', 'a11y_no_redundant_roles', 'a11y_no_static_element_interactions', 'a11y_positive_tabindex', 'a11y_role_has_required_aria_props', 'a11y_role_supports_aria_props', 'a11y_role_supports_aria_props_implicit', 'a11y_unknown_aria_attribute', 'a11y_unknown_role', 'bidirectional_control_characters', 'legacy_code', 'unknown_code', 'options_deprecated_accessors', 'options_deprecated_immutable', 'options_missing_custom_element', 'options_removed_enable_sourcemap', 'options_removed_hydratable', 'options_removed_loop_guard_timeout', 'options_renamed_ssr_dom', 'custom_element_props_identifier', 'export_let_unused', 'legacy_component_creation', 'non_reactive_update', 'perf_avoid_inline_class', 'perf_avoid_nested_class', 'reactive_declaration_invalid_placement', 'reactive_declaration_module_script_dependency', 'state_referenced_locally', 'store_rune_conflict', 'css_unused_selector', 'attribute_avoid_is', 'attribute_global_event_reference', 'attribute_illegal_colon', 'attribute_invalid_property_name', 'attribute_quoted', 'bind_invalid_each_rest', 'block_empty', 'component_name_lowercase', 'element_implicitly_closed', 'element_invalid_self_closing_tag', 'event_directive_deprecated', 'node_invalid_placement_ssr', 'script_context_deprecated', 'script_unknown_attribute', 'slot_element_deprecated', 'svelte_component_deprecated', 'svelte_element_invalid_this', 'svelte_self_deprecated' ]; /** * Avoid using accesskey * @param {null | NodeLike} node */ export function a11y_accesskey(node) { w(node, 'a11y_accesskey', `Avoid using accesskey\nhttps://svelte.dev/e/a11y_accesskey`); } /** * An element with an aria-activedescendant attribute should have a tabindex value * @param {null | NodeLike} node */ export function a11y_aria_activedescendant_has_tabindex(node) { w(node, 'a11y_aria_activedescendant_has_tabindex', `An element with an aria-activedescendant attribute should have a tabindex value\nhttps://svelte.dev/e/a11y_aria_activedescendant_has_tabindex`); } /** * `<%name%>` should not have aria-* attributes * @param {null | NodeLike} node * @param {string} name */ export function a11y_aria_attributes(node, name) { w(node, 'a11y_aria_attributes', `\`<${name}>\` should not have aria-* attributes\nhttps://svelte.dev/e/a11y_aria_attributes`); } /** * '%value%' is an invalid value for 'autocomplete' on `<input type="%type%">` * @param {null | NodeLike} node * @param {string} value * @param {string} type */ export function a11y_autocomplete_valid(node, value, type) { w(node, 'a11y_autocomplete_valid', `'${value}' is an invalid value for 'autocomplete' on \`<input type="${type}">\`\nhttps://svelte.dev/e/a11y_autocomplete_valid`); } /** * Avoid using autofocus * @param {null | NodeLike} node */ export function a11y_autofocus(node) { w(node, 'a11y_autofocus', `Avoid using autofocus\nhttps://svelte.dev/e/a11y_autofocus`); } /** * Visible, non-interactive elements with a click event must be accompanied by a keyboard event handler. Consider whether an interactive element such as `<button type="button">` or `<a>` might be more appropriate * @param {null | NodeLike} node */ export function a11y_click_events_have_key_events(node) { w(node, 'a11y_click_events_have_key_events', `Visible, non-interactive elements with a click event must be accompanied by a keyboard event handler. Consider whether an interactive element such as \`<button type="button">\` or \`<a>\` might be more appropriate\nhttps://svelte.dev/e/a11y_click_events_have_key_events`); } /** * Buttons and links should either contain text or have an `aria-label` or `aria-labelledby` attribute * @param {null | NodeLike} node */ export function a11y_consider_explicit_label(node) { w(node, 'a11y_consider_explicit_label', `Buttons and links should either contain text or have an \`aria-label\` or \`aria-labelledby\` attribute\nhttps://svelte.dev/e/a11y_consider_explicit_label`); } /** * Avoid `<%name%>` elements * @param {null | NodeLike} node * @param {string} name */ export function a11y_distracting_elements(node, name) { w(node, 'a11y_distracting_elements', `Avoid \`<${name}>\` elements\nhttps://svelte.dev/e/a11y_distracting_elements`); } /** * `<figcaption>` must be first or last child of `<figure>` * @param {null | NodeLike} node */ export function a11y_figcaption_index(node) { w(node, 'a11y_figcaption_index', `\`<figcaption>\` must be first or last child of \`<figure>\`\nhttps://svelte.dev/e/a11y_figcaption_index`); } /** * `<figcaption>` must be an immediate child of `<figure>` * @param {null | NodeLike} node */ export function a11y_figcaption_parent(node) { w(node, 'a11y_figcaption_parent', `\`<figcaption>\` must be an immediate child of \`<figure>\`\nhttps://svelte.dev/e/a11y_figcaption_parent`); } /** * `<%name%>` element should not be hidden * @param {null | NodeLike} node * @param {string} name */ export function a11y_hidden(node, name) { w(node, 'a11y_hidden', `\`<${name}>\` element should not be hidden\nhttps://svelte.dev/e/a11y_hidden`); } /** * Screenreaders already announce `<img>` elements as an image * @param {null | NodeLike} node */ export function a11y_img_redundant_alt(node) { w(node, 'a11y_img_redundant_alt', `Screenreaders already announce \`<img>\` elements as an image\nhttps://svelte.dev/e/a11y_img_redundant_alt`); } /** * The value of '%attribute%' must be a %type% * @param {null | NodeLike} node * @param {string} attribute * @param {string} type */ export function a11y_incorrect_aria_attribute_type(node, attribute, type) { w(node, 'a11y_incorrect_aria_attribute_type', `The value of '${attribute}' must be a ${type}\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type`); } /** * The value of '%attribute%' must be either 'true' or 'false'. It cannot be empty * @param {null | NodeLike} node * @param {string} attribute */ export function a11y_incorrect_aria_attribute_type_boolean(node, attribute) { w(node, 'a11y_incorrect_aria_attribute_type_boolean', `The value of '${attribute}' must be either 'true' or 'false'. It cannot be empty\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_boolean`); } /** * The value of '%attribute%' must be a string that represents a DOM element ID * @param {null | NodeLike} node * @param {string} attribute */ export function a11y_incorrect_aria_attribute_type_id(node, attribute) { w(node, 'a11y_incorrect_aria_attribute_type_id', `The value of '${attribute}' must be a string that represents a DOM element ID\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_id`); } /** * The value of '%attribute%' must be a space-separated list of strings that represent DOM element IDs * @param {null | NodeLike} node * @param {string} attribute */ export function a11y_incorrect_aria_attribute_type_idlist(node, attribute) { w(node, 'a11y_incorrect_aria_attribute_type_idlist', `The value of '${attribute}' must be a space-separated list of strings that represent DOM element IDs\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_idlist`); } /** * The value of '%attribute%' must be an integer * @param {null | NodeLike} node * @param {string} attribute */ export function a11y_incorrect_aria_attribute_type_integer(node, attribute) { w(node, 'a11y_incorrect_aria_attribute_type_integer', `The value of '${attribute}' must be an integer\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_integer`); } /** * The value of '%attribute%' must be exactly one of %values% * @param {null | NodeLike} node * @param {string} attribute * @param {string} values */ export function a11y_incorrect_aria_attribute_type_token(node, attribute, values) { w(node, 'a11y_incorrect_aria_attribute_type_token', `The value of '${attribute}' must be exactly one of ${values}\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_token`); } /** * The value of '%attribute%' must be a space-separated list of one or more of %values% * @param {null | NodeLike} node * @param {string} attribute * @param {string} values */ export function a11y_incorrect_aria_attribute_type_tokenlist(node, attribute, values) { w(node, 'a11y_incorrect_aria_attribute_type_tokenlist', `The value of '${attribute}' must be a space-separated list of one or more of ${values}\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_tokenlist`); } /** * The value of '%attribute%' must be exactly one of true, false, or mixed * @param {null | NodeLike} node * @param {string} attribute */ export function a11y_incorrect_aria_attribute_type_tristate(node, attribute) { w(node, 'a11y_incorrect_aria_attribute_type_tristate', `The value of '${attribute}' must be exactly one of true, false, or mixed\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_tristate`); } /** * Elements with the '%role%' interactive role must have a tabindex value * @param {null | NodeLike} node * @param {string} role */ export function a11y_interactive_supports_focus(node, role) { w(node, 'a11y_interactive_supports_focus', `Elements with the '${role}' interactive role must have a tabindex value\nhttps://svelte.dev/e/a11y_interactive_supports_focus`); } /** * '%href_value%' is not a valid %href_attribute% attribute * @param {null | NodeLike} node * @param {string} href_value * @param {string} href_attribute */ export function a11y_invalid_attribute(node, href_value, href_attribute) { w(node, 'a11y_invalid_attribute', `'${href_value}' is not a valid ${href_attribute} attribute\nhttps://svelte.dev/e/a11y_invalid_attribute`); } /** * A form label must be associated with a control * @param {null | NodeLike} node */ export function a11y_label_has_associated_control(node) { w(node, 'a11y_label_has_associated_control', `A form label must be associated with a control\nhttps://svelte.dev/e/a11y_label_has_associated_control`); } /** * `<video>` elements must have a `<track kind="captions">` * @param {null | NodeLike} node */ export function a11y_media_has_caption(node) { w(node, 'a11y_media_has_caption', `\`<video>\` elements must have a \`<track kind="captions">\`\nhttps://svelte.dev/e/a11y_media_has_caption`); } /** * `<%name%>` should not have role attribute * @param {null | NodeLike} node * @param {string} name */ export function a11y_misplaced_role(node, name) { w(node, 'a11y_misplaced_role', `\`<${name}>\` should not have role attribute\nhttps://svelte.dev/e/a11y_misplaced_role`); } /** * The scope attribute should only be used with `<th>` elements * @param {null | NodeLike} node */ export function a11y_misplaced_scope(node) { w(node, 'a11y_misplaced_scope', `The scope attribute should only be used with \`<th>\` elements\nhttps://svelte.dev/e/a11y_misplaced_scope`); } /** * `<%name%>` element should have %article% %sequence% attribute * @param {null | NodeLike} node * @param {string} name * @param {string} article * @param {string} sequence */ export function a11y_missing_attribute(node, name, article, sequence) { w(node, 'a11y_missing_attribute', `\`<${name}>\` element should have ${article} ${sequence} attribute\nhttps://svelte.dev/e/a11y_missing_attribute`); } /** * `<%name%>` element should contain text * @param {null | NodeLike} node * @param {string} name */ export function a11y_missing_content(node, name) { w(node, 'a11y_missing_content', `\`<${name}>\` element should contain text\nhttps://svelte.dev/e/a11y_missing_content`); } /** * '%event%' event must be accompanied by '%accompanied_by%' event * @param {null | NodeLike} node * @param {string} event * @param {string} accompanied_by */ export function a11y_mouse_events_have_key_events(node, event, accompanied_by) { w(node, 'a11y_mouse_events_have_key_events', `'${event}' event must be accompanied by '${accompanied_by}' event\nhttps://svelte.dev/e/a11y_mouse_events_have_key_events`); } /** * Abstract role '%role%' is forbidden * @param {null | NodeLike} node * @param {string} role */ export function a11y_no_abstract_role(node, role) { w(node, 'a11y_no_abstract_role', `Abstract role '${role}' is forbidden\nhttps://svelte.dev/e/a11y_no_abstract_role`); } /** * `<%element%>` cannot have role '%role%' * @param {null | NodeLike} node * @param {string} element * @param {string} role */ export function a11y_no_interactive_element_to_noninteractive_role(node, element, role) { w(node, 'a11y_no_interactive_element_to_noninteractive_role', `\`<${element}>\` cannot have role '${role}'\nhttps://svelte.dev/e/a11y_no_interactive_element_to_noninteractive_role`); } /** * Non-interactive element `<%element%>` should not be assigned mouse or keyboard event listeners * @param {null | NodeLike} node * @param {string} element */ export function a11y_no_noninteractive_element_interactions(node, element) { w(node, 'a11y_no_noninteractive_element_interactions', `Non-interactive element \`<${element}>\` should not be assigned mouse or keyboard event listeners\nhttps://svelte.dev/e/a11y_no_noninteractive_element_interactions`); } /** * Non-interactive element `<%element%>` cannot have interactive role '%role%' * @param {null | NodeLike} node * @param {string} element * @param {string} role */ export function a11y_no_noninteractive_element_to_interactive_role(node, element, role) { w(node, 'a11y_no_noninteractive_element_to_interactive_role', `Non-interactive element \`<${element}>\` cannot have interactive role '${role}'\nhttps://svelte.dev/e/a11y_no_noninteractive_element_to_interactive_role`); } /** * noninteractive element cannot have nonnegative tabIndex value * @param {null | NodeLike} node */ export function a11y_no_noninteractive_tabindex(node) { w(node, 'a11y_no_noninteractive_tabindex', `noninteractive element cannot have nonnegative tabIndex value\nhttps://svelte.dev/e/a11y_no_noninteractive_tabindex`); } /** * Redundant role '%role%' * @param {null | NodeLike} node * @param {string} role */ export function a11y_no_redundant_roles(node, role) { w(node, 'a11y_no_redundant_roles', `Redundant role '${role}'\nhttps://svelte.dev/e/a11y_no_redundant_roles`); } /** * `<%element%>` with a %handler% handler must have an ARIA role * @param {null | NodeLike} node * @param {string} element * @param {string} handler */ export function a11y_no_static_element_interactions(node, element, handler) { w(node, 'a11y_no_static_element_interactions', `\`<${element}>\` with a ${handler} handler must have an ARIA role\nhttps://svelte.dev/e/a11y_no_static_element_interactions`); } /** * Avoid tabindex values above zero * @param {null | NodeLike} node */ export function a11y_positive_tabindex(node) { w(node, 'a11y_positive_tabindex', `Avoid tabindex values above zero\nhttps://svelte.dev/e/a11y_positive_tabindex`); } /** * Elements with the ARIA role "%role%" must have the following attributes defined: %props% * @param {null | NodeLike} node * @param {string} role * @param {string} props */ export function a11y_role_has_required_aria_props(node, role, props) { w(node, 'a11y_role_has_required_aria_props', `Elements with the ARIA role "${role}" must have the following attributes defined: ${props}\nhttps://svelte.dev/e/a11y_role_has_required_aria_props`); } /** * The attribute '%attribute%' is not supported by the role '%role%' * @param {null | NodeLike} node * @param {string} attribute * @param {string} role */ export function a11y_role_supports_aria_props(node, attribute, role) { w(node, 'a11y_role_supports_aria_props', `The attribute '${attribute}' is not supported by the role '${role}'\nhttps://svelte.dev/e/a11y_role_supports_aria_props`); } /** * The attribute '%attribute%' is not supported by the role '%role%'. This role is implicit on the element `<%name%>` * @param {null | NodeLike} node * @param {string} attribute * @param {string} role * @param {string} name */ export function a11y_role_supports_aria_props_implicit(node, attribute, role, name) { w(node, 'a11y_role_supports_aria_props_implicit', `The attribute '${attribute}' is not supported by the role '${role}'. This role is implicit on the element \`<${name}>\`\nhttps://svelte.dev/e/a11y_role_supports_aria_props_implicit`); } /** * Unknown aria attribute 'aria-%attribute%'. Did you mean '%suggestion%'? * @param {null | NodeLike} node * @param {string} attribute * @param {string | undefined | null} [suggestion] */ export function a11y_unknown_aria_attribute(node, attribute, suggestion) { w(node, 'a11y_unknown_aria_attribute', `${suggestion ? `Unknown aria attribute 'aria-${attribute}'. Did you mean '${suggestion}'?` : `Unknown aria attribute 'aria-${attribute}'`}\nhttps://svelte.dev/e/a11y_unknown_aria_attribute`); } /** * Unknown role '%role%'. Did you mean '%suggestion%'? * @param {null | NodeLike} node * @param {string} role * @param {string | undefined | null} [suggestion] */ export function a11y_unknown_role(node, role, suggestion) { w(node, 'a11y_unknown_role', `${suggestion ? `Unknown role '${role}'. Did you mean '${suggestion}'?` : `Unknown role '${role}'`}\nhttps://svelte.dev/e/a11y_unknown_role`); } /** * A bidirectional control character was detected in your code. These characters can be used to alter the visual direction of your code and could have unintended consequences * @param {null | NodeLike} node */ export function bidirectional_control_characters(node) { w(node, 'bidirectional_control_characters', `A bidirectional control character was detected in your code. These characters can be used to alter the visual direction of your code and could have unintended consequences\nhttps://svelte.dev/e/bidirectional_control_characters`); } /** * `%code%` is no longer valid — please use `%suggestion%` instead * @param {null | NodeLike} node * @param {string} code * @param {string} suggestion */ export function legacy_code(node, code, suggestion) { w(node, 'legacy_code', `\`${code}\` is no longer valid — please use \`${suggestion}\` instead\nhttps://svelte.dev/e/legacy_code`); } /** * `%code%` is not a recognised code (did you mean `%suggestion%`?) * @param {null | NodeLike} node * @param {string} code * @param {string | undefined | null} [suggestion] */ export function unknown_code(node, code, suggestion) { w(node, 'unknown_code', `${suggestion ? `\`${code}\` is not a recognised code (did you mean \`${suggestion}\`?)` : `\`${code}\` is not a recognised code`}\nhttps://svelte.dev/e/unknown_code`); } /** * The `accessors` option has been deprecated. It will have no effect in runes mode * @param {null | NodeLike} node */ export function options_deprecated_accessors(node) { w(node, 'options_deprecated_accessors', `The \`accessors\` option has been deprecated. It will have no effect in runes mode\nhttps://svelte.dev/e/options_deprecated_accessors`); } /** * The `immutable` option has been deprecated. It will have no effect in runes mode * @param {null | NodeLike} node */ export function options_deprecated_immutable(node) { w(node, 'options_deprecated_immutable', `The \`immutable\` option has been deprecated. It will have no effect in runes mode\nhttps://svelte.dev/e/options_deprecated_immutable`); } /** * The `customElement` option is used when generating a custom element. Did you forget the `customElement: true` compile option? * @param {null | NodeLike} node */ export function options_missing_custom_element(node) { w(node, 'options_missing_custom_element', `The \`customElement\` option is used when generating a custom element. Did you forget the \`customElement: true\` compile option?\nhttps://svelte.dev/e/options_missing_custom_element`); } /** * The `enableSourcemap` option has been removed. Source maps are always generated now, and tooling can choose to ignore them * @param {null | NodeLike} node */ export function options_removed_enable_sourcemap(node) { w(node, 'options_removed_enable_sourcemap', `The \`enableSourcemap\` option has been removed. Source maps are always generated now, and tooling can choose to ignore them\nhttps://svelte.dev/e/options_removed_enable_sourcemap`); } /** * The `hydratable` option has been removed. Svelte components are always hydratable now * @param {null | NodeLike} node */ export function options_removed_hydratable(node) { w(node, 'options_removed_hydratable', `The \`hydratable\` option has been removed. Svelte components are always hydratable now\nhttps://svelte.dev/e/options_removed_hydratable`); } /** * The `loopGuardTimeout` option has been removed * @param {null | NodeLike} node */ export function options_removed_loop_guard_timeout(node) { w(node, 'options_removed_loop_guard_timeout', `The \`loopGuardTimeout\` option has been removed\nhttps://svelte.dev/e/options_removed_loop_guard_timeout`); } /** * `generate: "dom"` and `generate: "ssr"` options have been renamed to "client" and "server" respectively * @param {null | NodeLike} node */ export function options_renamed_ssr_dom(node) { w(node, 'options_renamed_ssr_dom', `\`generate: "dom"\` and \`generate: "ssr"\` options have been renamed to "client" and "server" respectively\nhttps://svelte.dev/e/options_renamed_ssr_dom`); } /** * Using a rest element or a non-destructured declaration with `$props()` means that Svelte can't infer what properties to expose when creating a custom element. Consider destructuring all the props or explicitly specifying the `customElement.props` option. * @param {null | NodeLike} node */ export function custom_element_props_identifier(node) { w(node, 'custom_element_props_identifier', `Using a rest element or a non-destructured declaration with \`$props()\` means that Svelte can't infer what properties to expose when creating a custom element. Consider destructuring all the props or explicitly specifying the \`customElement.props\` option.\nhttps://svelte.dev/e/custom_element_props_identifier`); } /** * Component has unused export property '%name%'. If it is for external reference only, please consider using `export const %name%` * @param {null | NodeLike} node * @param {string} name */ export function export_let_unused(node, name) { w(node, 'export_let_unused', `Component has unused export property '${name}'. If it is for external reference only, please consider using \`export const ${name}\`\nhttps://svelte.dev/e/export_let_unused`); } /** * Svelte 5 components are no longer classes. Instantiate them using `mount` or `hydrate` (imported from 'svelte') instead. * @param {null | NodeLike} node */ export function legacy_component_creation(node) { w(node, 'legacy_component_creation', `Svelte 5 components are no longer classes. Instantiate them using \`mount\` or \`hydrate\` (imported from 'svelte') instead.\nhttps://svelte.dev/e/legacy_component_creation`); } /** * `%name%` is updated, but is not declared with `$state(...)`. Changing its value will not correctly trigger updates * @param {null | NodeLike} node * @param {string} name */ export function non_reactive_update(node, name) { w(node, 'non_reactive_update', `\`${name}\` is updated, but is not declared with \`$state(...)\`. Changing its value will not correctly trigger updates\nhttps://svelte.dev/e/non_reactive_update`); } /** * Avoid 'new class' — instead, declare the class at the top level scope * @param {null | NodeLike} node */ export function perf_avoid_inline_class(node) { w(node, 'perf_avoid_inline_class', `Avoid 'new class' — instead, declare the class at the top level scope\nhttps://svelte.dev/e/perf_avoid_inline_class`); } /** * Avoid declaring classes below the top level scope * @param {null | NodeLike} node */ export function perf_avoid_nested_class(node) { w(node, 'perf_avoid_nested_class', `Avoid declaring classes below the top level scope\nhttps://svelte.dev/e/perf_avoid_nested_class`); } /** * Reactive declarations only exist at the top level of the instance script * @param {null | NodeLike} node */ export function reactive_declaration_invalid_placement(node) { w(node, 'reactive_declaration_invalid_placement', `Reactive declarations only exist at the top level of the instance script\nhttps://svelte.dev/e/reactive_declaration_invalid_placement`); } /** * Reassignments of module-level declarations will not cause reactive statements to update * @param {null | NodeLike} node */ export function reactive_declaration_module_script_dependency(node) { w(node, 'reactive_declaration_module_script_dependency', `Reassignments of module-level declarations will not cause reactive statements to update\nhttps://svelte.dev/e/reactive_declaration_module_script_dependency`); } /** * This reference only captures the initial value of `%name%`. Did you mean to reference it inside a %type% instead? * @param {null | NodeLike} node * @param {string} name * @param {string} type */ export function state_referenced_locally(node, name, type) { w(node, 'state_referenced_locally', `This reference only captures the initial value of \`${name}\`. Did you mean to reference it inside a ${type} instead?\nhttps://svelte.dev/e/state_referenced_locally`); } /** * It looks like you're using the `$%name%` rune, but there is a local binding called `%name%`. Referencing a local variable with a `$` prefix will create a store subscription. Please rename `%name%` to avoid the ambiguity * @param {null | NodeLike} node * @param {string} name */ export function store_rune_conflict(node, name) { w(node, 'store_rune_conflict', `It looks like you're using the \`$${name}\` rune, but there is a local binding called \`${name}\`. Referencing a local variable with a \`$\` prefix will create a store subscription. Please rename \`${name}\` to avoid the ambiguity\nhttps://svelte.dev/e/store_rune_conflict`); } /** * Unused CSS selector "%name%" * @param {null | NodeLike} node * @param {string} name */ export function css_unused_selector(node, name) { w(node, 'css_unused_selector', `Unused CSS selector "${name}"\nhttps://svelte.dev/e/css_unused_selector`); } /** * The "is" attribute is not supported cross-browser and should be avoided * @param {null | NodeLike} node */ export function attribute_avoid_is(node) { w(node, 'attribute_avoid_is', `The "is" attribute is not supported cross-browser and should be avoided\nhttps://svelte.dev/e/attribute_avoid_is`); } /** * You are referencing `globalThis.%name%`. Did you forget to declare a variable with that name? * @param {null | NodeLike} node * @param {string} name */ export function attribute_global_event_reference(node, name) { w(node, 'attribute_global_event_reference', `You are referencing \`globalThis.${name}\`. Did you forget to declare a variable with that name?\nhttps://svelte.dev/e/attribute_global_event_reference`); } /** * Attributes should not contain ':' characters to prevent ambiguity with Svelte directives * @param {null | NodeLike} node */ export function attribute_illegal_colon(node) { w(node, 'attribute_illegal_colon', `Attributes should not contain ':' characters to prevent ambiguity with Svelte directives\nhttps://svelte.dev/e/attribute_illegal_colon`); } /** * '%wrong%' is not a valid HTML attribute. Did you mean '%right%'? * @param {null | NodeLike} node * @param {string} wrong * @param {string} right */ export function attribute_invalid_property_name(node, wrong, right) { w(node, 'attribute_invalid_property_name', `'${wrong}' is not a valid HTML attribute. Did you mean '${right}'?\nhttps://svelte.dev/e/attribute_invalid_property_name`); } /** * Quoted attributes on components and custom elements will be stringified in a future version of Svelte. If this isn't what you want, remove the quotes * @param {null | NodeLike} node */ export function attribute_quoted(node) { w(node, 'attribute_quoted', `Quoted attributes on components and custom elements will be stringified in a future version of Svelte. If this isn't what you want, remove the quotes\nhttps://svelte.dev/e/attribute_quoted`); } /** * The rest operator (...) will create a new object and binding '%name%' with the original object will not work * @param {null | NodeLike} node * @param {string} name */ export function bind_invalid_each_rest(node, name) { w(node, 'bind_invalid_each_rest', `The rest operator (...) will create a new object and binding '${name}' with the original object will not work\nhttps://svelte.dev/e/bind_invalid_each_rest`); } /** * Empty block * @param {null | NodeLike} node */ export function block_empty(node) { w(node, 'block_empty', `Empty block\nhttps://svelte.dev/e/block_empty`); } /** * `<%name%>` will be treated as an HTML element unless it begins with a capital letter * @param {null | NodeLike} node * @param {string} name */ export function component_name_lowercase(node, name) { w(node, 'component_name_lowercase', `\`<${name}>\` will be treated as an HTML element unless it begins with a capital letter\nhttps://svelte.dev/e/component_name_lowercase`); } /** * This element is implicitly closed by the following `%tag%`, which can cause an unexpected DOM structure. Add an explicit `%closing%` to avoid surprises. * @param {null | NodeLike} node * @param {string} tag * @param {string} closing */ export function element_implicitly_closed(node, tag, closing) { w(node, 'element_implicitly_closed', `This element is implicitly closed by the following \`${tag}\`, which can cause an unexpected DOM structure. Add an explicit \`${closing}\` to avoid surprises.\nhttps://svelte.dev/e/element_implicitly_closed`); } /** * Self-closing HTML tags for non-void elements are ambiguous — use `<%name% ...></%name%>` rather than `<%name% ... />` * @param {null | NodeLike} node * @param {string} name */ export function element_invalid_self_closing_tag(node, name) { w(node, 'element_invalid_self_closing_tag', `Self-closing HTML tags for non-void elements are ambiguous — use \`<${name} ...></${name}>\` rather than \`<${name} ... />\`\nhttps://svelte.dev/e/element_invalid_self_closing_tag`); } /** * Using `on:%name%` to listen to the %name% event is deprecated. Use the event attribute `on%name%` instead * @param {null | NodeLike} node * @param {string} name */ export function event_directive_deprecated(node, name) { w(node, 'event_directive_deprecated', `Using \`on:${name}\` to listen to the ${name} event is deprecated. Use the event attribute \`on${name}\` instead\nhttps://svelte.dev/e/event_directive_deprecated`); } /** * %message%. When rendering this component on the server, the resulting HTML will be modified by the browser (by moving, removing, or inserting elements), likely resulting in a `hydration_mismatch` warning * @param {null | NodeLike} node * @param {string} message */ export function node_invalid_placement_ssr(node, message) { w(node, 'node_invalid_placement_ssr', `${message}. When rendering this component on the server, the resulting HTML will be modified by the browser (by moving, removing, or inserting elements), likely resulting in a \`hydration_mismatch\` warning\nhttps://svelte.dev/e/node_invalid_placement_ssr`); } /** * `context="module"` is deprecated, use the `module` attribute instead * @param {null | NodeLike} node */ export function script_context_deprecated(node) { w(node, 'script_context_deprecated', `\`context="module"\` is deprecated, use the \`module\` attribute instead\nhttps://svelte.dev/e/script_context_deprecated`); } /** * Unrecognized attribute — should be one of `generics`, `lang` or `module`. If this exists for a preprocessor, ensure that the preprocessor removes it * @param {null | NodeLike} node */ export function script_unknown_attribute(node) { w(node, 'script_unknown_attribute', `Unrecognized attribute — should be one of \`generics\`, \`lang\` or \`module\`. If this exists for a preprocessor, ensure that the preprocessor removes it\nhttps://svelte.dev/e/script_unknown_attribute`); } /** * Using `<slot>` to render parent content is deprecated. Use `{@render ...}` tags instead * @param {null | NodeLike} node */ export function slot_element_deprecated(node) { w(node, 'slot_element_deprecated', `Using \`<slot>\` to render parent content is deprecated. Use \`{@render ...}\` tags instead\nhttps://svelte.dev/e/slot_element_deprecated`); } /** * `<svelte:component>` is deprecated in runes mode — components are dynamic by default * @param {null | NodeLike} node */ export function svelte_component_deprecated(node) { w(node, 'svelte_component_deprecated', `\`<svelte:component>\` is deprecated in runes mode — components are dynamic by default\nhttps://svelte.dev/e/svelte_component_deprecated`); } /** * `this` should be an `{expression}`. Using a string attribute value will cause an error in future versions of Svelte * @param {null | NodeLike} node */ export function svelte_element_invalid_this(node) { w(node, 'svelte_element_invalid_this', `\`this\` should be an \`{expression}\`. Using a string attribute value will cause an error in future versions of Svelte\nhttps://svelte.dev/e/svelte_element_invalid_this`); } /** * `<svelte:self>` is deprecated — use self-imports (e.g. `import %name% from './%basename%'`) instead * @param {null | NodeLike} node * @param {string} name * @param {string} basename */ export function svelte_self_deprecated(node, name, basename) { w(node, 'svelte_self_deprecated', `\`<svelte:self>\` is deprecated — use self-imports (e.g. \`import ${name} from './${basename}'\`) instead\nhttps://svelte.dev/e/svelte_self_deprecated`); }
```

# constants.js

```js
export const EACH_ITEM_REACTIVE = 1; export const EACH_INDEX_REACTIVE = 1 << 1; /** See EachBlock interface metadata.is_controlled for an explanation what this is */ export const EACH_IS_CONTROLLED = 1 << 2; export const EACH_IS_ANIMATED = 1 << 3; export const EACH_ITEM_IMMUTABLE = 1 << 4; export const PROPS_IS_IMMUTABLE = 1; export const PROPS_IS_RUNES = 1 << 1; export const PROPS_IS_UPDATED = 1 << 2; export const PROPS_IS_BINDABLE = 1 << 3; export const PROPS_IS_LAZY_INITIAL = 1 << 4; export const TRANSITION_IN = 1; export const TRANSITION_OUT = 1 << 1; export const TRANSITION_GLOBAL = 1 << 2; export const TEMPLATE_FRAGMENT = 1; export const TEMPLATE_USE_IMPORT_NODE = 1 << 1; export const TEMPLATE_USE_SVG = 1 << 2; export const TEMPLATE_USE_MATHML = 1 << 3; export const HYDRATION_START = '['; /** used to indicate that an `{:else}...` block was rendered */ export const HYDRATION_START_ELSE = '[!'; export const HYDRATION_END = ']'; export const HYDRATION_ERROR = {}; export const ELEMENT_IS_NAMESPACED = 1; export const ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1; export const UNINITIALIZED = Symbol(); // Dev-time component properties export const FILENAME = Symbol('filename'); export const HMR = Symbol('hmr'); export const NAMESPACE_HTML = 'http://www.w3.org/1999/xhtml'; export const NAMESPACE_SVG = 'http://www.w3.org/2000/svg'; export const NAMESPACE_MATHML = 'http://www.w3.org/1998/Math/MathML'; // we use a list of ignorable runtime warnings because not every runtime warning // can be ignored and we want to keep the validation for svelte-ignore in place export const IGNORABLE_RUNTIME_WARNINGS = /** @type {const} */ ([ 'await_waterfall', 'await_reactivity_loss', 'state_snapshot_uncloneable', 'binding_property_non_reactive', 'hydration_attribute_changed', 'hydration_html_changed', 'ownership_invalid_binding', 'ownership_invalid_mutation' ]); /** * Whitespace inside one of these elements will not result in * a whitespace node being created in any circumstances. (This * list is almost certainly very incomplete) * TODO this is currently unused */ export const ELEMENTS_WITHOUT_TEXT = ['audio', 'datalist', 'dl', 'optgroup', 'select', 'video']; export const ATTACHMENT_KEY = '@attach';
```

# easing/index.js

```js
/* Adapted from https://github.com/mattdesl Distributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md */ /** * @param {number} t * @returns {number} */ export function linear(t) { return t; } /** * @param {number} t * @returns {number} */ export function backInOut(t) { const s = 1.70158 * 1.525; if ((t *= 2) < 1) return 0.5 * (t * t * ((s + 1) * t - s)); return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2); } /** * @param {number} t * @returns {number} */ export function backIn(t) { const s = 1.70158; return t * t * ((s + 1) * t - s); } /** * @param {number} t * @returns {number} */ export function backOut(t) { const s = 1.70158; return --t * t * ((s + 1) * t + s) + 1; } /** * @param {number} t * @returns {number} */ export function bounceOut(t) { const a = 4.0 / 11.0; const b = 8.0 / 11.0; const c = 9.0 / 10.0; const ca = 4356.0 / 361.0; const cb = 35442.0 / 1805.0; const cc = 16061.0 / 1805.0; const t2 = t * t; return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72; } /** * @param {number} t * @returns {number} */ export function bounceInOut(t) { return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5; } /** * @param {number} t * @returns {number} */ export function bounceIn(t) { return 1.0 - bounceOut(1.0 - t); } /** * @param {number} t * @returns {number} */ export function circInOut(t) { if ((t *= 2) < 1) return -0.5 * (Math.sqrt(1 - t * t) - 1); return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1); } /** * @param {number} t * @returns {number} */ export function circIn(t) { return 1.0 - Math.sqrt(1.0 - t * t); } /** * @param {number} t * @returns {number} */ export function circOut(t) { return Math.sqrt(1 - --t * t); } /** * @param {number} t * @returns {number} */ export function cubicInOut(t) { return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0; } /** * @param {number} t * @returns {number} */ export function cubicIn(t) { return t * t * t; } /** * @param {number} t * @returns {number} */ export function cubicOut(t) { const f = t - 1.0; return f * f * f + 1.0; } /** * @param {number} t * @returns {number} */ export function elasticInOut(t) { return t < 0.5 ? 0.5 * Math.sin(((+13.0 * Math.PI) / 2) * 2.0 * t) * Math.pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * Math.sin(((-13.0 * Math.PI) / 2) * (2.0 * t - 1.0 + 1.0)) * Math.pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0; } /** * @param {number} t * @returns {number} */ export function elasticIn(t) { return Math.sin((13.0 * t * Math.PI) / 2) * Math.pow(2.0, 10.0 * (t - 1.0)); } /** * @param {number} t * @returns {number} */ export function elasticOut(t) { return Math.sin((-13.0 * (t + 1.0) * Math.PI) / 2) * Math.pow(2.0, -10.0 * t) + 1.0; } /** * @param {number} t * @returns {number} */ export function expoInOut(t) { return t === 0.0 || t === 1.0 ? t : t < 0.5 ? +0.5 * Math.pow(2.0, 20.0 * t - 10.0) : -0.5 * Math.pow(2.0, 10.0 - t * 20.0) + 1.0; } /** * @param {number} t * @returns {number} */ export function expoIn(t) { return t === 0.0 ? t : Math.pow(2.0, 10.0 * (t - 1.0)); } /** * @param {number} t * @returns {number} */ export function expoOut(t) { return t === 1.0 ? t : 1.0 - Math.pow(2.0, -10.0 * t); } /** * @param {number} t * @returns {number} */ export function quadInOut(t) { t /= 0.5; if (t < 1) return 0.5 * t * t; t--; return -0.5 * (t * (t - 2) - 1); } /** * @param {number} t * @returns {number} */ export function quadIn(t) { return t * t; } /** * @param {number} t * @returns {number} */ export function quadOut(t) { return -t * (t - 2.0); } /** * @param {number} t * @returns {number} */ export function quartInOut(t) { return t < 0.5 ? +8.0 * Math.pow(t, 4.0) : -8.0 * Math.pow(t - 1.0, 4.0) + 1.0; } /** * @param {number} t * @returns {number} */ export function quartIn(t) { return Math.pow(t, 4.0); } /** * @param {number} t * @returns {number} */ export function quartOut(t) { return Math.pow(t - 1.0, 3.0) * (1.0 - t) + 1.0; } /** * @param {number} t * @returns {number} */ export function quintInOut(t) { if ((t *= 2) < 1) return 0.5 * t * t * t * t * t; return 0.5 * ((t -= 2) * t * t * t * t + 2); } /** * @param {number} t * @returns {number} */ export function quintIn(t) { return t * t * t * t * t; } /** * @param {number} t * @returns {number} */ export function quintOut(t) { return --t * t * t * t * t + 1; } /** * @param {number} t * @returns {number} */ export function sineInOut(t) { return -0.5 * (Math.cos(Math.PI * t) - 1); } /** * @param {number} t * @returns {number} */ export function sineIn(t) { const v = Math.cos(t * Math.PI * 0.5); if (Math.abs(v) < 1e-14) return 1; else return 1 - v; } /** * @param {number} t * @returns {number} */ export function sineOut(t) { return Math.sin((t * Math.PI) / 2); }
```

# escaping.js

```js
const ATTR_REGEX = /[&"<]/g; const CONTENT_REGEX = /[&<]/g; /** * @template V * @param {V} value * @param {boolean} [is_attr] */ export function escape_html(value, is_attr) { const str = String(value ?? ''); const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX; pattern.lastIndex = 0; let escaped = ''; let last = 0; while (pattern.test(str)) { const i = pattern.lastIndex - 1; const ch = str[i]; escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : ch === '"' ? '&quot;' : '&lt;'); last = i + 1; } return escaped + str.substring(last); }
```

# events/index.js

```js
export { on } from '../internal/client/dom/elements/events.js';
```

# events/public.d.ts

```ts
// Once https://github.com/microsoft/TypeScript/issues/59980 is fixed we can put these overloads into the JSDoc comments of the `on` function /** * Attaches an event handler to the window and returns a function that removes the handler. Using this * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively * (with attributes like `onclick`), which use event delegation for performance reasons */ export function on<Type extends keyof WindowEventMap>( window: Window, type: Type, handler: (this: Window, event: WindowEventMap[Type]) => any, options?: AddEventListenerOptions | undefined ): () => void; /** * Attaches an event handler to the document and returns a function that removes the handler. Using this * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively * (with attributes like `onclick`), which use event delegation for performance reasons */ export function on<Type extends keyof DocumentEventMap>( document: Document, type: Type, handler: (this: Document, event: DocumentEventMap[Type]) => any, options?: AddEventListenerOptions | undefined ): () => void; /** * Attaches an event handler to an element and returns a function that removes the handler. Using this * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively * (with attributes like `onclick`), which use event delegation for performance reasons */ export function on<Element extends HTMLElement, Type extends keyof HTMLElementEventMap>( element: Element, type: Type, handler: (this: Element, event: HTMLElementEventMap[Type]) => any, options?: AddEventListenerOptions | undefined ): () => void; /** * Attaches an event handler to an element and returns a function that removes the handler. Using this * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively * (with attributes like `onclick`), which use event delegation for performance reasons */ export function on<Element extends MediaQueryList, Type extends keyof MediaQueryListEventMap>( element: Element, type: Type, handler: (this: Element, event: MediaQueryListEventMap[Type]) => any, options?: AddEventListenerOptions | undefined ): () => void; /** * Attaches an event handler to an element and returns a function that removes the handler. Using this * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively * (with attributes like `onclick`), which use event delegation for performance reasons */ export function on( element: EventTarget, type: string, handler: EventListener, options?: AddEventListenerOptions | undefined ): () => void;
```

# html-tree-validation.js

```js
/** * Map of elements that have certain elements that are not allowed inside them, in the sense that they will auto-close the parent/ancestor element. * Theoretically one could take advantage of it but most of the time it will just result in confusing behavior and break when SSR'd. * There are more elements that are invalid inside other elements, but they're not auto-closed and so don't break SSR and are therefore not listed here. * @type {Record<string, { direct: string[]} | { descendant: string[]; reset_by?: string[] }>} */ const autoclosing_children = { // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission li: { direct: ['li'] }, // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt#technical_summary dt: { descendant: ['dt', 'dd'], reset_by: ['dl'] }, dd: { descendant: ['dt', 'dd'], reset_by: ['dl'] }, p: { descendant: [ 'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'menu', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul' ] }, rt: { descendant: ['rt', 'rp'] }, rp: { descendant: ['rt', 'rp'] }, optgroup: { descendant: ['optgroup'] }, option: { descendant: ['option', 'optgroup'] }, thead: { direct: ['tbody', 'tfoot'] }, tbody: { direct: ['tbody', 'tfoot'] }, tfoot: { direct: ['tbody'] }, tr: { direct: ['tr', 'tbody'] }, td: { direct: ['td', 'th', 'tr'] }, th: { direct: ['td', 'th', 'tr'] } }; /** * Returns true if the tag is either the last in the list of siblings and will be autoclosed, * or not allowed inside the parent tag such that it will auto-close it. The latter results * in the browser repairing the HTML, which will likely result in an error during hydration. * @param {string} current * @param {string} [next] */ export function closing_tag_omitted(current, next) { const disallowed = autoclosing_children[current]; if (disallowed) { if ( !next || ('direct' in disallowed ? disallowed.direct : disallowed.descendant).includes(next) ) { return true; } } return false; } /** * Map of elements that have certain elements that are not allowed inside them, in the sense that the browser will somehow repair the HTML. * There are more elements that are invalid inside other elements, but they're not repaired and so don't break SSR and are therefore not listed here. * @type {Record<string, { direct: string[]} | { descendant: string[]; reset_by?: string[]; only?: string[] } | { only: string[] }>} */ const disallowed_children = { ...autoclosing_children, optgroup: { only: ['option', '#text'] }, // Strictly speaking, seeing an <option> doesn't mean we're in a <select>, but we assume it here option: { only: ['#text'] }, form: { descendant: ['form'] }, a: { descendant: ['a'] }, button: { descendant: ['button'] }, h1: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] }, h2: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] }, h3: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] }, h4: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] }, h5: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] }, h6: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] }, // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect select: { only: ['option', 'optgroup', '#text', 'hr', 'script', 'template'] }, // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption // No special behavior since these rules fall back to "in body" mode for // all except special table nodes which cause bad parsing behavior anyway. // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd tr: { only: ['th', 'td', 'style', 'script', 'template'] }, // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody tbody: { only: ['tr', 'style', 'script', 'template'] }, thead: { only: ['tr', 'style', 'script', 'template'] }, tfoot: { only: ['tr', 'style', 'script', 'template'] }, // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup colgroup: { only: ['col', 'template'] }, // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable table: { only: ['caption', 'colgroup', 'tbody', 'thead', 'tfoot', 'style', 'script', 'template'] }, // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead head: { only: [ 'base', 'basefont', 'bgsound', 'link', 'meta', 'title', 'noscript', 'noframes', 'style', 'script', 'template' ] }, // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element html: { only: ['head', 'body', 'frameset'] }, frameset: { only: ['frame'] }, '#document': { only: ['html'] } }; /** * Returns an error message if the tag is not allowed inside the ancestor tag (which is grandparent and above) such that it will result * in the browser repairing the HTML, which will likely result in an error during hydration. * @param {string} child_tag * @param {string[]} ancestors All nodes starting with the parent, up until the ancestor, which means two entries minimum * @param {string} [child_loc] * @param {string} [ancestor_loc] * @returns {string | null} */ export function is_tag_valid_with_ancestor(child_tag, ancestors, child_loc, ancestor_loc) { if (child_tag.includes('-')) return null; // custom elements can be anything const ancestor_tag = ancestors[ancestors.length - 1]; const disallowed = disallowed_children[ancestor_tag]; if (!disallowed) return null; if ('reset_by' in disallowed && disallowed.reset_by) { for (let i = ancestors.length - 2; i >= 0; i--) { const ancestor = ancestors[i]; if (ancestor.includes('-')) return null; // custom elements can be anything // A reset means that forbidden descendants are allowed again if (disallowed.reset_by.includes(ancestors[i])) { return null; } } } if ('descendant' in disallowed && disallowed.descendant.includes(child_tag)) { const child = child_loc ? `\`<${child_tag}>\` (${child_loc})` : `\`<${child_tag}>\``; const ancestor = ancestor_loc ? `\`<${ancestor_tag}>\` (${ancestor_loc})` : `\`<${ancestor_tag}>\``; return `${child} cannot be a descendant of ${ancestor}`; } return null; } /** * Returns an error message if the tag is not allowed inside the parent tag such that it will result * in the browser repairing the HTML, which will likely result in an error during hydration. * @param {string} child_tag * @param {string} parent_tag * @param {string} [child_loc] * @param {string} [parent_loc] * @returns {string | null} */ export function is_tag_valid_with_parent(child_tag, parent_tag, child_loc, parent_loc) { if (child_tag.includes('-') || parent_tag?.includes('-')) return null; // custom elements can be anything if (parent_tag === 'template') return null; // no errors or warning should be thrown in immediate children of template tags const disallowed = disallowed_children[parent_tag]; const child = child_loc ? `\`<${child_tag}>\` (${child_loc})` : `\`<${child_tag}>\``; const parent = parent_loc ? `\`<${parent_tag}>\` (${parent_loc})` : `\`<${parent_tag}>\``; if (disallowed) { if ('direct' in disallowed && disallowed.direct.includes(child_tag)) { return `${child} cannot be a direct child of ${parent}`; } if ('descendant' in disallowed && disallowed.descendant.includes(child_tag)) { return `${child} cannot be a child of ${parent}`; } if ('only' in disallowed && disallowed.only) { if (disallowed.only.includes(child_tag)) { return null; } else { return `${child} cannot be a child of ${parent}. \`<${parent_tag}>\` only allows these children: ${disallowed.only.map((d) => `\`<${d}>\``).join(', ')}`; } } } // These tags are only valid with a few parents that have special child // parsing rules - if we're down here, then none of those matched and // so we allow it only if we don't know what the parent is, as all other // cases are invalid (and we only get into this function if we know the parent). switch (child_tag) { case 'body': case 'caption': case 'col': case 'colgroup': case 'frameset': case 'frame': case 'head': case 'html': return `${child} cannot be a child of ${parent}`; case 'thead': case 'tbody': case 'tfoot': return `${child} must be the child of a \`<table>\`, not a ${parent}`; case 'td': case 'th': return `${child} must be the child of a \`<tr>\`, not a ${parent}`; case 'tr': return `\`<tr>\` must be the child of a \`<thead>\`, \`<tbody>\`, or \`<tfoot>\`, not a ${parent}`; } return null; }
```

# index-client.js

```js
/** @import { ComponentContext, ComponentContextLegacy } from '#client' */ /** @import { EventDispatcher } from './index.js' */ /** @import { NotFunction } from './internal/types.js' */ import { active_reaction, untrack } from './internal/client/runtime.js'; import { is_array } from './internal/shared/utils.js'; import { user_effect } from './internal/client/index.js'; import * as e from './internal/client/errors.js'; import { legacy_mode_flag } from './internal/flags/index.js'; import { component_context } from './internal/client/context.js'; import { DEV } from 'esm-env'; if (DEV) { /** * @param {string} rune */ function throw_rune_error(rune) { if (!(rune in globalThis)) { // TODO if people start adjusting the "this can contain runes" config through v-p-s more, adjust this message /** @type {any} */ let value; // let's hope noone modifies this global, but belts and braces Object.defineProperty(globalThis, rune, { configurable: true, // eslint-disable-next-line getter-return get: () => { if (value !== undefined) { return value; } e.rune_outside_svelte(rune); }, set: (v) => { value = v; } }); } } throw_rune_error('$state'); throw_rune_error('$effect'); throw_rune_error('$derived'); throw_rune_error('$inspect'); throw_rune_error('$props'); throw_rune_error('$bindable'); } /** * Returns an [`AbortSignal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) that aborts when the current [derived](https://svelte.dev/docs/svelte/$derived) or [effect](https://svelte.dev/docs/svelte/$effect) re-runs or is destroyed. * * Must be called while a derived or effect is running. * * \`\`\`svelte * <script> * import { getAbortSignal } from 'svelte'; * * let { id } = $props(); * * async function getData(id) { * const response = await fetch(`/items/${id}`, { * signal: getAbortSignal() * }); * * return await response.json(); * } * * const data = $derived(await getData(id)); * </script> * \`\`\` */ export function getAbortSignal() { if (active_reaction === null) { e.get_abort_signal_outside_reaction(); } return (active_reaction.ac ??= new AbortController()).signal; } /** * `onMount`, like [`$effect`](https://svelte.dev/docs/svelte/$effect), schedules a function to run as soon as the component has been mounted to the DOM. * Unlike `$effect`, the provided function only runs once. * * It must be called during the component's initialisation (but doesn't need to live _inside_ the component; * it can be called from an external module). If a function is returned _synchronously_ from `onMount`, * it will be called when the component is unmounted. * * `onMount` functions do not run during [server-side rendering](https://svelte.dev/docs/svelte/svelte-server#render). * * @template T * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn * @returns {void} */ export function onMount(fn) { if (component_context === null) { e.lifecycle_outside_component('onMount'); } if (legacy_mode_flag && component_context.l !== null) { init_update_callbacks(component_context).m.push(fn); } else { user_effect(() => { const cleanup = untrack(fn); if (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup); }); } } /** * Schedules a callback to run immediately before the component is unmounted. * * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the * only one that runs inside a server-side component. * * @param {() => any} fn * @returns {void} */ export function onDestroy(fn) { if (component_context === null) { e.lifecycle_outside_component('onDestroy'); } onMount(() => () => untrack(fn)); } /** * @template [T=any] * @param {string} type * @param {T} [detail] * @param {any}params_0 * @returns {CustomEvent<T>} */ function create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) { return new CustomEvent(type, { detail, bubbles, cancelable }); } /** * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs/svelte/legacy-on#Component-events). * Event dispatchers are functions that can take two arguments: `name` and `detail`. * * Component events created with `createEventDispatcher` create a * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent). * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture). * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail) * property and can contain any type of data. * * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument: * \`\`\`ts * const dispatch = createEventDispatcher<{ * loaded: null; // does not take a detail argument * change: string; // takes a detail argument of type string, which is required * optional: number | null; // takes an optional detail argument of type number * }>(); * \`\`\` * * @deprecated Use callback props and/or the `$host()` rune instead — see [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Event-changes-Component-events) * @template {Record<string, any>} [EventMap = any] * @returns {EventDispatcher<EventMap>} */ export function createEventDispatcher() { const active_component_context = component_context; if (active_component_context === null) { e.lifecycle_outside_component('createEventDispatcher'); } return (type, detail, options) => { const events = /** @type {Record<string, Function | Function[]>} */ ( active_component_context.s.$$events )?.[/** @type {any} */ (type)]; if (events) { const callbacks = is_array(events) ? events.slice() : [events]; // TODO are there situations where events could be dispatched // in a server (non-DOM) environment? const event = create_custom_event(/** @type {string} */ (type), detail, options); for (const fn of callbacks) { fn.call(active_component_context.x, event); } return !event.defaultPrevented; } return true; }; } // TODO mark beforeUpdate and afterUpdate as deprecated in Svelte 6 /** * Schedules a callback to run immediately before the component is updated after any state change. * * The first time the callback runs will be before the initial `onMount`. * * In runes mode use `$effect.pre` instead. * * @deprecated Use [`$effect.pre`](https://svelte.dev/docs/svelte/$effect#$effect.pre) instead * @param {() => void} fn * @returns {void} */ export function beforeUpdate(fn) { if (component_context === null) { e.lifecycle_outside_component('beforeUpdate'); } if (component_context.l === null) { e.lifecycle_legacy_only('beforeUpdate'); } init_update_callbacks(component_context).b.push(fn); } /** * Schedules a callback to run immediately after the component has been updated. * * The first time the callback runs will be after the initial `onMount`. * * In runes mode use `$effect` instead. * * @deprecated Use [`$effect`](https://svelte.dev/docs/svelte/$effect) instead * @param {() => void} fn * @returns {void} */ export function afterUpdate(fn) { if (component_context === null) { e.lifecycle_outside_component('afterUpdate'); } if (component_context.l === null) { e.lifecycle_legacy_only('afterUpdate'); } init_update_callbacks(component_context).a.push(fn); } /** * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate * @param {ComponentContext} context */ function init_update_callbacks(context) { var l = /** @type {ComponentContextLegacy} */ (context).l; return (l.u ??= { a: [], b: [], m: [] }); } export { flushSync } from './internal/client/reactivity/batch.js'; export { getContext, getAllContexts, hasContext, setContext } from './internal/client/context.js'; export { hydrate, mount, unmount } from './internal/client/render.js'; export { tick, untrack, settled } from './internal/client/runtime.js'; export { createRawSnippet } from './internal/client/dom/blocks/snippet.js';
```

# index-server.js

```js
/** @import { Component } from '#server' */ import { current_component } from './internal/server/context.js'; import { noop } from './internal/shared/utils.js'; import * as e from './internal/server/errors.js'; /** @param {() => void} fn */ export function onDestroy(fn) { var context = /** @type {Component} */ (current_component); (context.d ??= []).push(fn); } export { noop as beforeUpdate, noop as afterUpdate, noop as onMount, noop as flushSync, run as untrack } from './internal/shared/utils.js'; export function createEventDispatcher() { return noop; } export function mount() { e.lifecycle_function_unavailable('mount'); } export function hydrate() { e.lifecycle_function_unavailable('hydrate'); } export function unmount() { e.lifecycle_function_unavailable('unmount'); } export async function tick() {} export async function settled() {} export { getAbortSignal } from './internal/server/abort-signal.js'; export { getAllContexts, getContext, hasContext, setContext } from './internal/server/context.js'; export { createRawSnippet } from './internal/server/blocks/snippet.js';
```

# index.d.ts

```ts
// This should contain all the public interfaces (not all of them are actually importable, check current Svelte for which ones are). import './ambient.js'; /** * @deprecated In Svelte 4, components are classes. In Svelte 5, they are functions. * Use `mount` instead to instantiate components. * See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes) * for more info. */ export interface ComponentConstructorOptions< Props extends Record<string, any> = Record<string, any> > { target: Element | Document | ShadowRoot; anchor?: Element; props?: Props; context?: Map<any, any>; hydrate?: boolean; intro?: boolean; recover?: boolean; sync?: boolean; idPrefix?: string; $$inline?: boolean; } /** * Utility type for ensuring backwards compatibility on a type level that if there's a default slot, add 'children' to the props */ type Properties<Props, Slots> = Props & (Slots extends { default: any } ? // This is unfortunate because it means "accepts no props" turns into "accepts any prop" // but the alternative is non-fixable type errors because of the way TypeScript index // signatures work (they will always take precedence and make an impossible-to-satisfy children type). Props extends Record<string, never> ? any : { children?: any } : {}); /** * This was the base class for Svelte components in Svelte 4. Svelte 5+ components * are completely different under the hood. For typing, use `Component` instead. * To instantiate components, use `mount` instead. * See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes) for more info. */ export class SvelteComponent< Props extends Record<string, any> = Record<string, any>, Events extends Record<string, any> = any, Slots extends Record<string, any> = any > { /** The custom element version of the component. Only present if compiled with the `customElement` compiler option */ static element?: typeof HTMLElement; [prop: string]: any; /** * @deprecated This constructor only exists when using the `asClassComponent` compatibility helper, which * is a stop-gap solution. Migrate towards using `mount` instead. See * [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes) for more info. */ constructor(options: ComponentConstructorOptions<Properties<Props, Slots>>); /** * For type checking capabilities only. * Does not exist at runtime. * ### DO NOT USE! */ $$prop_def: Props; // Without Properties: unnecessary, causes type bugs /** * For type checking capabilities only. * Does not exist at runtime. * ### DO NOT USE! */ $$events_def: Events; /** * For type checking capabilities only. * Does not exist at runtime. * ### DO NOT USE! */ $$slot_def: Slots; /** * For type checking capabilities only. * Does not exist at runtime. * ### DO NOT USE! */ $$bindings?: string; /** * @deprecated This method only exists when using one of the legacy compatibility helpers, which * is a stop-gap solution. See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes) * for more info. */ $destroy(): void; /** * @deprecated This method only exists when using one of the legacy compatibility helpers, which * is a stop-gap solution. See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes) * for more info. */ $on<K extends Extract<keyof Events, string>>( type: K, callback: (e: Events[K]) => void ): () => void; /** * @deprecated This method only exists when using one of the legacy compatibility helpers, which * is a stop-gap solution. See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes) * for more info. */ $set(props: Partial<Props>): void; } declare const brand: unique symbol; type Brand<B> = { [brand]: B }; type Branded<T, B> = T & Brand<B>; /** * Internal implementation details that vary between environments */ export type ComponentInternals = Branded<{}, 'ComponentInternals'>; /** * Can be used to create strongly typed Svelte components. * * #### Example: * * You have component library on npm called `component-library`, from which * you export a component called `MyComponent`. For Svelte+TypeScript users, * you want to provide typings. Therefore you create a `index.d.ts`: * \`\`\`ts * import type { Component } from 'svelte'; * export declare const MyComponent: Component<{ foo: string }> {} * \`\`\` * Typing this makes it possible for IDEs like VS Code with the Svelte extension * to provide intellisense and to use the component like this in a Svelte file * with TypeScript: * \`\`\`svelte * <script lang="ts"> * import { MyComponent } from "component-library"; * </script> * <MyComponent foo={'bar'} /> * \`\`\` */ export interface Component< Props extends Record<string, any> = {}, Exports extends Record<string, any> = {}, Bindings extends keyof Props | '' = string > { /** * @param internal An internal object used by Svelte. Do not use or modify. * @param props The props passed to the component. */ ( this: void, internals: ComponentInternals, props: Props ): { /** * @deprecated This method only exists when using one of the legacy compatibility helpers, which * is a stop-gap solution. See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes) * for more info. */ $on?(type: string, callback: (e: any) => void): () => void; /** * @deprecated This method only exists when using one of the legacy compatibility helpers, which * is a stop-gap solution. See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes) * for more info. */ $set?(props: Partial<Props>): void; } & Exports; /** The custom element version of the component. Only present if compiled with the `customElement` compiler option */ element?: typeof HTMLElement; /** Does not exist at runtime, for typing capabilities only. DO NOT USE */ z_$$bindings?: Bindings; } /** * @deprecated Use `Component` instead. See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes) for more information. */ export class SvelteComponentTyped< Props extends Record<string, any> = Record<string, any>, Events extends Record<string, any> = any, Slots extends Record<string, any> = any > extends SvelteComponent<Props, Events, Slots> {} /** * @deprecated The new `Component` type does not have a dedicated Events type. Use `ComponentProps` instead. * * @description * Convenience type to get the events the given component expects. Example: * \`\`\`html * <script lang="ts"> * import type { ComponentEvents } from 'svelte'; * import Component from './Component.svelte'; * * function handleCloseEvent(event: ComponentEvents<Component>['close']) { * console.log(event.detail); * } * </script> * * <Component on:close={handleCloseEvent} /> * \`\`\` */ export type ComponentEvents<Comp extends SvelteComponent> = Comp extends SvelteComponent<any, infer Events> ? Events : never; /** * Convenience type to get the props the given component expects. * * Example: Ensure a variable contains the props expected by `MyComponent`: * * \`\`\`ts * import type { ComponentProps } from 'svelte'; * import MyComponent from './MyComponent.svelte'; * * // Errors if these aren't the correct props expected by MyComponent. * const props: ComponentProps<typeof MyComponent> = { foo: 'bar' }; * \`\`\` * * > [!NOTE] In Svelte 4, you would do `ComponentProps<MyComponent>` because `MyComponent` was a class. * * Example: A generic function that accepts some component and infers the type of its props: * * \`\`\`ts * import type { Component, ComponentProps } from 'svelte'; * import MyComponent from './MyComponent.svelte'; * * function withProps<TComponent extends Component<any>>( * component: TComponent, * props: ComponentProps<TComponent> * ) {}; * * // Errors if the second argument is not the correct props expected by the component in the first argument. * withProps(MyComponent, { foo: 'bar' }); * \`\`\` */ export type ComponentProps<Comp extends SvelteComponent | Component<any, any>> = Comp extends SvelteComponent<infer Props> ? Props : Comp extends Component<infer Props, any> ? Props : never; /** * @deprecated This type is obsolete when working with the new `Component` type. * * @description * Convenience type to get the type of a Svelte component. Useful for example in combination with * dynamic components using `<svelte:component>`. * * Example: * \`\`\`html * <script lang="ts"> * import type { ComponentType, SvelteComponent } from 'svelte'; * import Component1 from './Component1.svelte'; * import Component2 from './Component2.svelte'; * * const component: ComponentType = someLogic() ? Component1 : Component2; * const componentOfCertainSubType: ComponentType<SvelteComponent<{ needsThisProp: string }>> = someLogic() ? Component1 : Component2; * </script> * * <svelte:component this={component} /> * <svelte:component this={componentOfCertainSubType} needsThisProp="hello" /> * \`\`\` */ export type ComponentType<Comp extends SvelteComponent = SvelteComponent> = (new ( options: ComponentConstructorOptions< Comp extends SvelteComponent<infer Props> ? Props : Record<string, any> > ) => Comp) & { /** The custom element version of the component. Only present if compiled with the `customElement` compiler option */ element?: typeof HTMLElement; }; declare const SnippetReturn: unique symbol; // Use an interface instead of a type, makes for better intellisense info because the type is named in more situations. /** * The type of a `#snippet` block. You can use it to (for example) express that your component expects a snippet of a certain type: * \`\`\`ts * let { banner }: { banner: Snippet<[{ text: string }]> } = $props(); * \`\`\` * You can only call a snippet through the `{@render ...}` tag. * * See the [snippet documentation](https://svelte.dev/docs/svelte/snippet) for more info. * * @template Parameters the parameters that the snippet expects (if any) as a tuple. */ export interface Snippet<Parameters extends unknown[] = []> { ( this: void, // this conditional allows tuples but not arrays. Arrays would indicate a // rest parameter type, which is not supported. If rest parameters are added // in the future, the condition can be removed. ...args: number extends Parameters['length'] ? never : Parameters ): { '{@render ...} must be called with a Snippet': "import type { Snippet } from 'svelte'"; } & typeof SnippetReturn; } interface DispatchOptions { cancelable?: boolean; } export interface EventDispatcher<EventMap extends Record<string, any>> { // Implementation notes: // - undefined extends X instead of X extends undefined makes this work better with both strict and nonstrict mode // - | null | undefined is added for convenience, as they are equivalent for the custom event constructor (both result in a null detail) <Type extends keyof EventMap>( ...args: null extends EventMap[Type] ? [type: Type, parameter?: EventMap[Type] | null | undefined, options?: DispatchOptions] : undefined extends EventMap[Type] ? [type: Type, parameter?: EventMap[Type] | null | undefined, options?: DispatchOptions] : [type: Type, parameter: EventMap[Type], options?: DispatchOptions] ): boolean; } /** * Defines the options accepted by the `mount()` function. */ export type MountOptions<Props extends Record<string, any> = Record<string, any>> = { /** * Target element where the component will be mounted. */ target: Document | Element | ShadowRoot; /** * Optional node inside `target`. When specified, it is used to render the component immediately before it. */ anchor?: Node; /** * Allows the specification of events. * @deprecated Use callback props instead. */ events?: Record<string, (e: any) => any>; /** * Can be accessed via `getContext()` at the component level. */ context?: Map<any, any>; /** * Whether or not to play transitions on initial render. * @default true */ intro?: boolean; } & ({} extends Props ? { /** * Component properties. */ props?: Props; } : { /** * Component properties. */ props: Props; }); export * from './index-client.js';
```

# internal/client/constants.js

```js
export const DERIVED = 1 << 1; export const EFFECT = 1 << 2; export const RENDER_EFFECT = 1 << 3; export const BLOCK_EFFECT = 1 << 4; export const BRANCH_EFFECT = 1 << 5; export const ROOT_EFFECT = 1 << 6; export const BOUNDARY_EFFECT = 1 << 7; export const UNOWNED = 1 << 8; export const DISCONNECTED = 1 << 9; export const CLEAN = 1 << 10; export const DIRTY = 1 << 11; export const MAYBE_DIRTY = 1 << 12; export const INERT = 1 << 13; export const DESTROYED = 1 << 14; export const EFFECT_RAN = 1 << 15; /** 'Transparent' effects do not create a transition boundary */ export const EFFECT_TRANSPARENT = 1 << 16; export const INSPECT_EFFECT = 1 << 17; export const HEAD_EFFECT = 1 << 18; export const EFFECT_PRESERVED = 1 << 19; export const USER_EFFECT = 1 << 20; // Flags used for async export const REACTION_IS_UPDATING = 1 << 21; export const ASYNC = 1 << 22; export const ERROR_VALUE = 1 << 23; export const STATE_SYMBOL = Symbol('$state'); export const LEGACY_PROPS = Symbol('legacy props'); export const LOADING_ATTR_SYMBOL = Symbol(''); export const PROXY_PATH_SYMBOL = Symbol('proxy path'); /** allow users to ignore aborted signal errors if `reason.name === 'StaleReactionError` */ export const STALE_REACTION = new (class StaleReactionError extends Error { name = 'StaleReactionError'; message = 'The reaction that called `getAbortSignal()` was re-run or destroyed'; })(); export const ELEMENT_NODE = 1; export const TEXT_NODE = 3; export const COMMENT_NODE = 8; export const DOCUMENT_FRAGMENT_NODE = 11;
```

# internal/client/context.js

```js
/** @import { ComponentContext, DevStackEntry, Effect } from '#client' */ import { DEV } from 'esm-env'; import * as e from './errors.js'; import { active_effect, active_reaction } from './runtime.js'; import { create_user_effect } from './reactivity/effects.js'; import { async_mode_flag, legacy_mode_flag } from '../flags/index.js'; import { FILENAME } from '../../constants.js'; import { BRANCH_EFFECT, EFFECT_RAN } from './constants.js'; /** @type {ComponentContext | null} */ export let component_context = null; /** @param {ComponentContext | null} context */ export function set_component_context(context) { component_context = context; } /** @type {DevStackEntry | null} */ export let dev_stack = null; /** @param {DevStackEntry | null} stack */ export function set_dev_stack(stack) { dev_stack = stack; } /** * Execute a callback with a new dev stack entry * @param {() => any} callback - Function to execute * @param {DevStackEntry['type']} type - Type of block/component * @param {any} component - Component function * @param {number} line - Line number * @param {number} column - Column number * @param {Record<string, any>} [additional] - Any additional properties to add to the dev stack entry * @returns {any} */ export function add_svelte_meta(callback, type, component, line, column, additional) { const parent = dev_stack; dev_stack = { type, file: component[FILENAME], line, column, parent, ...additional }; try { return callback(); } finally { dev_stack = parent; } } /** * The current component function. Different from current component context: * \`\`\`html * <!-- App.svelte --> * <Foo> * <Bar /> <!-- context == Foo.svelte, function == App.svelte --> * </Foo> * \`\`\` * @type {ComponentContext['function']} */ export let dev_current_component_function = null; /** @param {ComponentContext['function']} fn */ export function set_dev_current_component_function(fn) { dev_current_component_function = fn; } /** * Retrieves the context that belongs to the closest parent component with the specified `key`. * Must be called during component initialisation. * * @template T * @param {any} key * @returns {T} */ export function getContext(key) { const context_map = get_or_init_context_map('getContext'); const result = /** @type {T} */ (context_map.get(key)); return result; } /** * Associates an arbitrary `context` object with the current component and the specified `key` * and returns that object. The context is then available to children of the component * (including slotted content) with `getContext`. * * Like lifecycle functions, this must be called during component initialisation. * * @template T * @param {any} key * @param {T} context * @returns {T} */ export function setContext(key, context) { const context_map = get_or_init_context_map('setContext'); if (async_mode_flag) { var flags = /** @type {Effect} */ (active_effect).f; var valid = !active_reaction && (flags & BRANCH_EFFECT) !== 0 && (flags & EFFECT_RAN) === 0; if (!valid) { e.set_context_after_init(); } } context_map.set(key, context); return context; } /** * Checks whether a given `key` has been set in the context of a parent component. * Must be called during component initialisation. * * @param {any} key * @returns {boolean} */ export function hasContext(key) { const context_map = get_or_init_context_map('hasContext'); return context_map.has(key); } /** * Retrieves the whole context map that belongs to the closest parent component. * Must be called during component initialisation. Useful, for example, if you * programmatically create a component and want to pass the existing context to it. * * @template {Map<any, any>} [T=Map<any, any>] * @returns {T} */ export function getAllContexts() { const context_map = get_or_init_context_map('getAllContexts'); return /** @type {T} */ (context_map); } /** * @param {Record<string, unknown>} props * @param {any} runes * @param {Function} [fn] * @returns {void} */ export function push(props, runes = false, fn) { component_context = { p: component_context, c: null, e: null, s: props, x: null, l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null }; if (DEV) { // component function component_context.function = fn; dev_current_component_function = fn; } } /** * @template {Record<string, any>} T * @param {T} [component] * @returns {T} */ export function pop(component) { var context = /** @type {ComponentContext} */ (component_context); var effects = context.e; if (effects !== null) { context.e = null; for (var fn of effects) { create_user_effect(fn); } } if (component !== undefined) { context.x = component; } component_context = context.p; if (DEV) { dev_current_component_function = component_context?.function ?? null; } return component ?? /** @type {T} */ ({}); } /** @returns {boolean} */ export function is_runes() { return !legacy_mode_flag || (component_context !== null && component_context.l === null); } /** * @param {string} name * @returns {Map<unknown, unknown>} */ function get_or_init_context_map(name) { if (component_context === null) { e.lifecycle_outside_component(name); } return (component_context.c ??= new Map(get_parent_context(component_context) || undefined)); } /** * @param {ComponentContext} component_context * @returns {Map<unknown, unknown> | null} */ function get_parent_context(component_context) { let parent = component_context.p; while (parent !== null) { const context_map = parent.c; if (context_map !== null) { return context_map; } parent = parent.p; } return null; }
```

# internal/client/dev/assign.js

```js
import { sanitize_location } from '../../../utils.js'; import { untrack } from '../runtime.js'; import * as w from '../warnings.js'; /** * * @param {any} a * @param {any} b * @param {string} property * @param {string} location */ function compare(a, b, property, location) { if (a !== b) { w.assignment_value_stale(property, /** @type {string} */ (sanitize_location(location))); } return a; } /** * @param {any} object * @param {string} property * @param {any} value * @param {string} location */ export function assign(object, property, value, location) { return compare( (object[property] = value), untrack(() => object[property]), property, location ); } /** * @param {any} object * @param {string} property * @param {any} value * @param {string} location */ export function assign_and(object, property, value, location) { return compare( (object[property] &&= value), untrack(() => object[property]), property, location ); } /** * @param {any} object * @param {string} property * @param {any} value * @param {string} location */ export function assign_or(object, property, value, location) { return compare( (object[property] ||= value), untrack(() => object[property]), property, location ); } /** * @param {any} object * @param {string} property * @param {any} value * @param {string} location */ export function assign_nullish(object, property, value, location) { return compare( (object[property] ??= value), untrack(() => object[property]), property, location ); }
```

# internal/client/dev/console-log.js

```js
import { STATE_SYMBOL } from '#client/constants'; import { snapshot } from '../../shared/clone.js'; import * as w from '../warnings.js'; import { untrack } from '../runtime.js'; /** * @param {string} method * @param {...any} objects */ export function log_if_contains_state(method, ...objects) { untrack(() => { try { let has_state = false; const transformed = []; for (const obj of objects) { if (obj && typeof obj === 'object' && STATE_SYMBOL in obj) { transformed.push(snapshot(obj, true)); has_state = true; } else { transformed.push(obj); } } if (has_state) { w.console_log_state(method); // eslint-disable-next-line no-console console.log('%c[snapshot]', 'color: grey', ...transformed); } } catch {} }); return objects; }
```

# internal/client/dev/css.js

```js
/** @type {Map<String, Set<HTMLStyleElement>>} */ var all_styles = new Map(); /** * @param {String} hash * @param {HTMLStyleElement} style */ export function register_style(hash, style) { var styles = all_styles.get(hash); if (!styles) { styles = new Set(); all_styles.set(hash, styles); } styles.add(style); } /** * @param {String} hash */ export function cleanup_styles(hash) { var styles = all_styles.get(hash); if (!styles) return; for (const style of styles) { style.remove(); } all_styles.delete(hash); }
```

# internal/client/dev/debug.js

```js
/** @import { Derived, Effect, Value } from '#client' */ import { BLOCK_EFFECT, BOUNDARY_EFFECT, BRANCH_EFFECT, CLEAN, DERIVED, EFFECT, ASYNC, MAYBE_DIRTY, RENDER_EFFECT, ROOT_EFFECT } from '#client/constants'; /** * * @param {Effect} effect */ export function root(effect) { while (effect.parent !== null) { effect = effect.parent; } return effect; } /** * * @param {Effect} effect */ export function log_effect_tree(effect, depth = 0) { const flags = effect.f; let label = '(unknown)'; if ((flags & ROOT_EFFECT) !== 0) { label = 'root'; } else if ((flags & BOUNDARY_EFFECT) !== 0) { label = 'boundary'; } else if ((flags & BLOCK_EFFECT) !== 0) { label = 'block'; } else if ((flags & ASYNC) !== 0) { label = 'async'; } else if ((flags & BRANCH_EFFECT) !== 0) { label = 'branch'; } else if ((flags & RENDER_EFFECT) !== 0) { label = 'render effect'; } else if ((flags & EFFECT) !== 0) { label = 'effect'; } let status = (flags & CLEAN) !== 0 ? 'clean' : (flags & MAYBE_DIRTY) !== 0 ? 'maybe dirty' : 'dirty'; // eslint-disable-next-line no-console console.group(`%c${label} (${status})`, `font-weight: ${status === 'clean' ? 'normal' : 'bold'}`); if (depth === 0) { const callsite = new Error().stack ?.split('\n')[2] .replace(/\s+at (?: \w+\(?)?(.+)\)?/, (m, $1) => $1.replace(/\?[^:]+/, '')); // eslint-disable-next-line no-console console.log(callsite); } if (effect.deps !== null) { // eslint-disable-next-line no-console console.groupCollapsed('%cdeps', 'font-weight: normal'); for (const dep of effect.deps) { log_dep(dep); } // eslint-disable-next-line no-console console.groupEnd(); } let child = effect.first; while (child !== null) { log_effect_tree(child, depth + 1); child = child.next; } // eslint-disable-next-line no-console console.groupEnd(); } /** * * @param {Value} dep */ function log_dep(dep) { if ((dep.f & DERIVED) !== 0) { const derived = /** @type {Derived} */ (dep); // eslint-disable-next-line no-console console.groupCollapsed('%cderived', 'font-weight: normal', derived.v); if (derived.deps) { for (const d of derived.deps) { log_dep(d); } } // eslint-disable-next-line no-console console.groupEnd(); } else { // eslint-disable-next-line no-console console.log('state', dep.v); } }
```

# internal/client/dev/elements.js

```js
/** @import { SourceLocation } from '#client' */ import { COMMENT_NODE, DOCUMENT_FRAGMENT_NODE, ELEMENT_NODE } from '#client/constants'; import { HYDRATION_END, HYDRATION_START, HYDRATION_START_ELSE } from '../../../constants.js'; import { hydrating } from '../dom/hydration.js'; import { dev_stack } from '../context.js'; /** * @param {any} fn * @param {string} filename * @param {SourceLocation[]} locations * @returns {any} */ export function add_locations(fn, filename, locations) { return (/** @type {any[]} */ ...args) => { const dom = fn(...args); var node = hydrating ? dom : dom.nodeType === DOCUMENT_FRAGMENT_NODE ? dom.firstChild : dom; assign_locations(node, filename, locations); return dom; }; } /** * @param {Element} element * @param {string} filename * @param {SourceLocation} location */ function assign_location(element, filename, location) { // @ts-expect-error element.__svelte_meta = { parent: dev_stack, loc: { file: filename, line: location[0], column: location[1] } }; if (location[2]) { assign_locations(element.firstChild, filename, location[2]); } } /** * @param {Node | null} node * @param {string} filename * @param {SourceLocation[]} locations */ function assign_locations(node, filename, locations) { var i = 0; var depth = 0; while (node && i < locations.length) { if (hydrating && node.nodeType === COMMENT_NODE) { var comment = /** @type {Comment} */ (node); if (comment.data === HYDRATION_START || comment.data === HYDRATION_START_ELSE) depth += 1; else if (comment.data[0] === HYDRATION_END) depth -= 1; } if (depth === 0 && node.nodeType === ELEMENT_NODE) { assign_location(/** @type {Element} */ (node), filename, locations[i++]); } node = node.nextSibling; } }
```

# internal/client/dev/equality.js

```js
import * as w from '../warnings.js'; import { get_proxied_value } from '../proxy.js'; export function init_array_prototype_warnings() { const array_prototype = Array.prototype; // The REPL ends up here over and over, and this prevents it from adding more and more patches // of the same kind to the prototype, which would slow down everything over time. // @ts-expect-error const cleanup = Array.__svelte_cleanup; if (cleanup) { cleanup(); } const { indexOf, lastIndexOf, includes } = array_prototype; array_prototype.indexOf = function (item, from_index) { const index = indexOf.call(this, item, from_index); if (index === -1) { for (let i = from_index ?? 0; i < this.length; i += 1) { if (get_proxied_value(this[i]) === item) { w.state_proxy_equality_mismatch('array.indexOf(...)'); break; } } } return index; }; array_prototype.lastIndexOf = function (item, from_index) { // we need to specify this.length - 1 because it's probably using something like // `arguments` inside so passing undefined is different from not passing anything const index = lastIndexOf.call(this, item, from_index ?? this.length - 1); if (index === -1) { for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) { if (get_proxied_value(this[i]) === item) { w.state_proxy_equality_mismatch('array.lastIndexOf(...)'); break; } } } return index; }; array_prototype.includes = function (item, from_index) { const has = includes.call(this, item, from_index); if (!has) { for (let i = 0; i < this.length; i += 1) { if (get_proxied_value(this[i]) === item) { w.state_proxy_equality_mismatch('array.includes(...)'); break; } } } return has; }; // @ts-expect-error Array.__svelte_cleanup = () => { array_prototype.indexOf = indexOf; array_prototype.lastIndexOf = lastIndexOf; array_prototype.includes = includes; }; } /** * @param {any} a * @param {any} b * @param {boolean} equal * @returns {boolean} */ export function strict_equals(a, b, equal = true) { // try-catch needed because this tries to read properties of `a` and `b`, // which could be disallowed for example in a secure context try { if ((a === b) !== (get_proxied_value(a) === get_proxied_value(b))) { w.state_proxy_equality_mismatch(equal ? '===' : '!=='); } } catch {} return (a === b) === equal; } /** * @param {any} a * @param {any} b * @param {boolean} equal * @returns {boolean} */ export function equals(a, b, equal = true) { if ((a == b) !== (get_proxied_value(a) == get_proxied_value(b))) { w.state_proxy_equality_mismatch(equal ? '==' : '!='); } return (a == b) === equal; }
```

# internal/client/dev/hmr.js

```js
/** @import { Source, Effect, TemplateNode } from '#client' */ import { FILENAME, HMR } from '../../../constants.js'; import { EFFECT_TRANSPARENT } from '#client/constants'; import { hydrate_node, hydrating } from '../dom/hydration.js'; import { block, branch, destroy_effect } from '../reactivity/effects.js'; import { source } from '../reactivity/sources.js'; import { set_should_intro } from '../render.js'; import { get } from '../runtime.js'; /** * @template {(anchor: Comment, props: any) => any} Component * @param {Component} original * @param {() => Source<Component>} get_source */ export function hmr(original, get_source) { /** * @param {TemplateNode} anchor * @param {any} props */ function wrapper(anchor, props) { let instance = {}; /** @type {Effect} */ let effect; let ran = false; block(() => { const source = get_source(); const component = get(source); if (effect) { // @ts-ignore for (var k in instance) delete instance[k]; destroy_effect(effect); } effect = branch(() => { // when the component is invalidated, replace it without transitions if (ran) set_should_intro(false); // preserve getters/setters Object.defineProperties( instance, Object.getOwnPropertyDescriptors( // @ts-expect-error new.target ? new component(anchor, props) : component(anchor, props) ) ); if (ran) set_should_intro(true); }); }, EFFECT_TRANSPARENT); ran = true; if (hydrating) { anchor = hydrate_node; } return instance; } // @ts-expect-error wrapper[FILENAME] = original[FILENAME]; // @ts-expect-error wrapper[HMR] = { // When we accept an update, we set the original source to the new component original, // The `get_source` parameter reads `wrapper[HMR].source`, but in the `accept` // function we always replace it with `previous[HMR].source`, which in practice // means we only ever update the original source: source(original) }; return wrapper; }
```

# internal/client/dev/inspect.js

```js
import { UNINITIALIZED } from '../../../constants.js'; import { snapshot } from '../../shared/clone.js'; import { inspect_effect, validate_effect } from '../reactivity/effects.js'; import { untrack } from '../runtime.js'; /** * @param {() => any[]} get_value * @param {Function} [inspector] */ // eslint-disable-next-line no-console export function inspect(get_value, inspector = console.log) { validate_effect('$inspect'); let initial = true; inspect_effect(() => { /** @type {any} */ var value = UNINITIALIZED; // Capturing the value might result in an exception due to the inspect effect being // sync and thus operating on stale data. In the case we encounter an exception we // can bail-out of reporting the value. Instead we simply console.error the error // so at least it's known that an error occured, but we don't stop execution try { value = get_value(); } catch (error) { // eslint-disable-next-line no-console console.error(error); } if (value !== UNINITIALIZED) { var snap = snapshot(value, true); untrack(() => { inspector(initial ? 'init' : 'update', ...snap); }); } initial = false; }); }
```

# internal/client/dev/legacy.js

```js
import * as e from '../errors.js'; import { component_context } from '../context.js'; import { FILENAME } from '../../../constants.js'; /** @param {Function & { [FILENAME]: string }} target */ export function check_target(target) { if (target) { e.component_api_invalid_new(target[FILENAME] ?? 'a component', target.name); } } export function legacy_api() { const component = component_context?.function; /** @param {string} method */ function error(method) { e.component_api_changed(method, component[FILENAME]); } return { $destroy: () => error('$destroy()'), $on: () => error('$on(...)'), $set: () => error('$set(...)') }; }
```

# internal/client/dev/ownership.js

```js
/** @typedef {{ file: string, line: number, column: number }} Location */ import { get_descriptor } from '../../shared/utils.js'; import { LEGACY_PROPS, STATE_SYMBOL } from '#client/constants'; import { FILENAME } from '../../../constants.js'; import { component_context } from '../context.js'; import * as w from '../warnings.js'; import { sanitize_location } from '../../../utils.js'; /** * Sets up a validator that * - traverses the path of a prop to find out if it is allowed to be mutated * - checks that the binding chain is not interrupted * @param {Record<string, any>} props */ export function create_ownership_validator(props) { const component = component_context?.function; const parent = component_context?.p?.function; return { /** * @param {string} prop * @param {any[]} path * @param {any} result * @param {number} line * @param {number} column */ mutation: (prop, path, result, line, column) => { const name = path[0]; if (is_bound_or_unset(props, name) || !parent) { return result; } /** @type {any} */ let value = props; for (let i = 0; i < path.length - 1; i++) { value = value[path[i]]; if (!value?.[STATE_SYMBOL]) { return result; } } const location = sanitize_location(`${component[FILENAME]}:${line}:${column}`); w.ownership_invalid_mutation(name, location, prop, parent[FILENAME]); return result; }, /** * @param {any} key * @param {any} child_component * @param {() => any} value */ binding: (key, child_component, value) => { if (!is_bound_or_unset(props, key) && parent && value()?.[STATE_SYMBOL]) { w.ownership_invalid_binding( component[FILENAME], key, child_component[FILENAME], parent[FILENAME] ); } } }; } /** * @param {Record<string, any>} props * @param {string} prop_name */ function is_bound_or_unset(props, prop_name) { // Can be the case when someone does `mount(Component, props)` with `let props = $state({...})` // or `createClassComponent(Component, props)` const is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props; return ( !!get_descriptor(props, prop_name)?.set || (is_entry_props && prop_name in props) || !(prop_name in props) ); }
```

# internal/client/dev/tracing.js

```js
/** @import { Derived, Reaction, Value } from '#client' */ import { UNINITIALIZED } from '../../../constants.js'; import { snapshot } from '../../shared/clone.js'; import { define_property } from '../../shared/utils.js'; import { DERIVED, ASYNC, PROXY_PATH_SYMBOL, STATE_SYMBOL } from '#client/constants'; import { effect_tracking } from '../reactivity/effects.js'; import { active_reaction, captured_signals, set_captured_signals, untrack } from '../runtime.js'; /** * @typedef {{ * traces: Error[]; * }} TraceEntry */ /** @type {{ reaction: Reaction | null, entries: Map<Value, TraceEntry> } | null} */ export let tracing_expressions = null; /** * @param {Value} signal * @param {TraceEntry} [entry] */ function log_entry(signal, entry) { const value = signal.v; if (value === UNINITIALIZED) { return; } const type = (signal.f & (DERIVED | ASYNC)) !== 0 ? '$derived' : '$state'; const current_reaction = /** @type {Reaction} */ (active_reaction); const dirty = signal.wv > current_reaction.wv || current_reaction.wv === 0; const style = dirty ? 'color: CornflowerBlue; font-weight: bold' : 'color: grey; font-weight: normal'; // eslint-disable-next-line no-console console.groupCollapsed( signal.label ? `%c${type}%c ${signal.label}` : `%c${type}%c`, style, dirty ? 'font-weight: normal' : style, typeof value === 'object' && value !== null && STATE_SYMBOL in value ? snapshot(value, true) : value ); if (type === '$derived') { const deps = new Set(/** @type {Derived} */ (signal).deps); for (const dep of deps) { log_entry(dep); } } if (signal.created) { // eslint-disable-next-line no-console console.log(signal.created); } if (dirty && signal.updated) { // eslint-disable-next-line no-console console.log(signal.updated); } if (entry) { for (var trace of entry.traces) { // eslint-disable-next-line no-console console.log(trace); } } // eslint-disable-next-line no-console console.groupEnd(); } /** * @template T * @param {() => string} label * @param {() => T} fn */ export function trace(label, fn) { var previously_tracing_expressions = tracing_expressions; try { tracing_expressions = { entries: new Map(), reaction: active_reaction }; var start = performance.now(); var value = fn(); var time = (performance.now() - start).toFixed(2); var prefix = untrack(label); if (!effect_tracking()) { // eslint-disable-next-line no-console console.log(`${prefix} %cran outside of an effect (${time}ms)`, 'color: grey'); } else if (tracing_expressions.entries.size === 0) { // eslint-disable-next-line no-console console.log(`${prefix} %cno reactive dependencies (${time}ms)`, 'color: grey'); } else { // eslint-disable-next-line no-console console.group(`${prefix} %c(${time}ms)`, 'color: grey'); var entries = tracing_expressions.entries; untrack(() => { for (const [signal, traces] of entries) { log_entry(signal, traces); } }); tracing_expressions = null; // eslint-disable-next-line no-console console.groupEnd(); } return value; } finally { tracing_expressions = previously_tracing_expressions; } } /** * @param {string} label */ export function get_stack(label) { let error = Error(); const stack = error.stack; if (stack) { const lines = stack.split('\n'); const new_lines = ['\n']; for (let i = 0; i < lines.length; i++) { const line = lines[i]; if (line === 'Error') { continue; } if (line.includes('validate_each_keys')) { return null; } if (line.includes('svelte/src/internal')) { continue; } new_lines.push(line); } if (new_lines.length === 1) { return null; } define_property(error, 'stack', { value: new_lines.join('\n') }); define_property(error, 'name', { // 'Error' suffix is required for stack traces to be rendered properly value: `${label}Error` }); } return error; } /** * @param {Value} source * @param {string} label */ export function tag(source, label) { source.label = label; tag_proxy(source.v, label); return source; } /** * @param {unknown} value * @param {string} label */ export function tag_proxy(value, label) { // @ts-expect-error value?.[PROXY_PATH_SYMBOL]?.(label); return value; } /** * @param {unknown} value */ export function label(value) { if (typeof value === 'symbol') return `Symbol(${value.description})`; if (typeof value === 'function') return '<function>'; if (typeof value === 'object' && value) return '<object>'; return String(value); }
```

# internal/client/dev/validation.js

```js
import * as e from '../errors.js'; /** * @param {Node} anchor * @param {...(()=>any)[]} args */ export function validate_snippet_args(anchor, ...args) { if (typeof anchor !== 'object' || !(anchor instanceof Node)) { e.invalid_snippet_arguments(); } for (let arg of args) { if (typeof arg !== 'function') { e.invalid_snippet_arguments(); } } }
```

# internal/client/dom/blocks/async.js

```js
/** @import { TemplateNode, Value } from '#client' */ import { flatten } from '../../reactivity/async.js'; import { get } from '../../runtime.js'; import { get_pending_boundary } from './boundary.js'; /** * @param {TemplateNode} node * @param {Array<() => Promise<any>>} expressions * @param {(anchor: TemplateNode, ...deriveds: Value[]) => void} fn */ export function async(node, expressions, fn) { var boundary = get_pending_boundary(); boundary.update_pending_count(1); flatten([], expressions, (values) => { try { // get values eagerly to avoid creating blocks if they reject for (const d of values) get(d); fn(node, ...values); } finally { boundary.update_pending_count(-1); } }); }
```

# internal/client/dom/blocks/await.js

```js
/** @import { Effect, Source, TemplateNode } from '#client' */ import { DEV } from 'esm-env'; import { is_promise } from '../../../shared/utils.js'; import { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js'; import { internal_set, mutable_source, source } from '../../reactivity/sources.js'; import { set_active_effect, set_active_reaction } from '../../runtime.js'; import { hydrate_next, hydrate_node, hydrating, remove_nodes, set_hydrate_node, set_hydrating } from '../hydration.js'; import { queue_micro_task } from '../task.js'; import { HYDRATION_START_ELSE, UNINITIALIZED } from '../../../../constants.js'; import { component_context, dev_stack, is_runes, set_component_context, set_dev_current_component_function, set_dev_stack } from '../../context.js'; import { flushSync } from '../../reactivity/batch.js'; const PENDING = 0; const THEN = 1; const CATCH = 2; /** * @template V * @param {TemplateNode} node * @param {(() => Promise<V>)} get_input * @param {null | ((anchor: Node) => void)} pending_fn * @param {null | ((anchor: Node, value: Source<V>) => void)} then_fn * @param {null | ((anchor: Node, error: unknown) => void)} catch_fn * @returns {void} */ export function await_block(node, get_input, pending_fn, then_fn, catch_fn) { if (hydrating) { hydrate_next(); } var anchor = node; var runes = is_runes(); var active_component_context = component_context; /** @type {any} */ var component_function = DEV ? component_context?.function : null; var dev_original_stack = DEV ? dev_stack : null; /** @type {V | Promise<V> | typeof UNINITIALIZED} */ var input = UNINITIALIZED; /** @type {Effect | null} */ var pending_effect; /** @type {Effect | null} */ var then_effect; /** @type {Effect | null} */ var catch_effect; var input_source = runes ? source(/** @type {V} */ (undefined)) : mutable_source(/** @type {V} */ (undefined), false, false); var error_source = runes ? source(undefined) : mutable_source(undefined, false, false); var resolved = false; /** * @param {PENDING | THEN | CATCH} state * @param {boolean} restore */ function update(state, restore) { resolved = true; if (restore) { set_active_effect(effect); set_active_reaction(effect); // TODO do we need both? set_component_context(active_component_context); if (DEV) { set_dev_current_component_function(component_function); set_dev_stack(dev_original_stack); } } try { if (state === PENDING && pending_fn) { if (pending_effect) resume_effect(pending_effect); else pending_effect = branch(() => pending_fn(anchor)); } if (state === THEN && then_fn) { if (then_effect) resume_effect(then_effect); else then_effect = branch(() => then_fn(anchor, input_source)); } if (state === CATCH && catch_fn) { if (catch_effect) resume_effect(catch_effect); else catch_effect = branch(() => catch_fn(anchor, error_source)); } if (state !== PENDING && pending_effect) { pause_effect(pending_effect, () => (pending_effect = null)); } if (state !== THEN && then_effect) { pause_effect(then_effect, () => (then_effect = null)); } if (state !== CATCH && catch_effect) { pause_effect(catch_effect, () => (catch_effect = null)); } } finally { if (restore) { if (DEV) { set_dev_current_component_function(null); set_dev_stack(null); } set_component_context(null); set_active_reaction(null); set_active_effect(null); // without this, the DOM does not update until two ticks after the promise // resolves, which is unexpected behaviour (and somewhat irksome to test) flushSync(); } } } var effect = block(() => { if (input === (input = get_input())) return; /** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */ // @ts-ignore coercing `anchor` to a `Comment` causes TypeScript and Prettier to fight let mismatch = hydrating && is_promise(input) === (anchor.data === HYDRATION_START_ELSE); if (mismatch) { // Hydration mismatch: remove everything inside the anchor and start fresh anchor = remove_nodes(); set_hydrate_node(anchor); set_hydrating(false); mismatch = true; } if (is_promise(input)) { var promise = input; resolved = false; promise.then( (value) => { if (promise !== input) return; // we technically could use `set` here since it's on the next microtick // but let's use internal_set for consistency and just to be safe internal_set(input_source, value); update(THEN, true); }, (error) => { if (promise !== input) return; // we technically could use `set` here since it's on the next microtick // but let's use internal_set for consistency and just to be safe internal_set(error_source, error); update(CATCH, true); if (!catch_fn) { // Rethrow the error if no catch block exists throw error_source.v; } } ); if (hydrating) { if (pending_fn) { pending_effect = branch(() => pending_fn(anchor)); } } else { // Wait a microtask before checking if we should show the pending state as // the promise might have resolved by the next microtask. queue_micro_task(() => { if (!resolved) update(PENDING, true); }); } } else { internal_set(input_source, input); update(THEN, false); } if (mismatch) { // continue in hydration mode set_hydrating(true); } // Set the input to something else, in order to disable the promise callbacks return () => (input = UNINITIALIZED); }); if (hydrating) { anchor = hydrate_node; } }
```

# internal/client/dom/blocks/boundary.js

```js
/** @import { Effect, Source, TemplateNode, } from '#client' */ import { BOUNDARY_EFFECT, EFFECT_PRESERVED, EFFECT_TRANSPARENT } from '#client/constants'; import { component_context, set_component_context } from '../../context.js'; import { invoke_error_boundary } from '../../error-handling.js'; import { block, branch, destroy_effect, pause_effect } from '../../reactivity/effects.js'; import { active_effect, active_reaction, get, set_active_effect, set_active_reaction } from '../../runtime.js'; import { hydrate_next, hydrate_node, hydrating, next, remove_nodes, set_hydrate_node } from '../hydration.js'; import { get_next_sibling } from '../operations.js'; import { queue_micro_task } from '../task.js'; import * as e from '../../errors.js'; import { DEV } from 'esm-env'; import { Batch } from '../../reactivity/batch.js'; import { internal_set, source } from '../../reactivity/sources.js'; import { tag } from '../../dev/tracing.js'; import { createSubscriber } from '../../../../reactivity/create-subscriber.js'; /** * @typedef {{ * onerror?: (error: unknown, reset: () => void) => void; * failed?: (anchor: Node, error: () => unknown, reset: () => () => void) => void; * pending?: (anchor: Node) => void; * }} BoundaryProps */ var flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT; /** * @param {TemplateNode} node * @param {BoundaryProps} props * @param {((anchor: Node) => void)} children * @returns {void} */ export function boundary(node, props, children) { new Boundary(node, props, children); } export class Boundary { pending = false; /** @type {Boundary | null} */ parent; /** @type {TemplateNode} */ #anchor; /** @type {TemplateNode} */ #hydrate_open; /** @type {BoundaryProps} */ #props; /** @type {((anchor: Node) => void)} */ #children; /** @type {Effect} */ #effect; /** @type {Effect | null} */ #main_effect = null; /** @type {Effect | null} */ #pending_effect = null; /** @type {Effect | null} */ #failed_effect = null; /** @type {DocumentFragment | null} */ #offscreen_fragment = null; #pending_count = 0; #is_creating_fallback = false; /** * A source containing the number of pending async deriveds/expressions. * Only created if `$effect.pending()` is used inside the boundary, * otherwise updating the source results in needless `Batch.ensure()` * calls followed by no-op flushes * @type {Source<number> | null} */ #effect_pending = null; #effect_pending_subscriber = createSubscriber(() => { this.#effect_pending = source(this.#pending_count); if (DEV) { tag(this.#effect_pending, '$effect.pending()'); } return () => { this.#effect_pending = null; }; }); /** * @param {TemplateNode} node * @param {BoundaryProps} props * @param {((anchor: Node) => void)} children */ constructor(node, props, children) { this.#anchor = node; this.#props = props; this.#children = children; this.#hydrate_open = hydrate_node; this.parent = /** @type {Effect} */ (active_effect).b; this.pending = !!this.#props.pending; this.#effect = block(() => { /** @type {Effect} */ (active_effect).b = this; if (hydrating) { hydrate_next(); } const pending = this.#props.pending; if (hydrating && pending) { this.#pending_effect = branch(() => pending(this.#anchor)); // future work: when we have some form of async SSR, we will // need to use hydration boundary comments to report whether // the pending or main block was rendered for a given // boundary, and hydrate accordingly queueMicrotask(() => { this.#main_effect = this.#run(() => { Batch.ensure(); return branch(() => this.#children(this.#anchor)); }); if (this.#pending_count > 0) { this.#show_pending_snippet(); } else { pause_effect(/** @type {Effect} */ (this.#pending_effect), () => { this.#pending_effect = null; }); this.pending = false; } }); } else { try { this.#main_effect = branch(() => children(this.#anchor)); } catch (error) { this.error(error); } if (this.#pending_count > 0) { this.#show_pending_snippet(); } else { this.pending = false; } } }, flags); if (hydrating) { this.#anchor = hydrate_node; } } has_pending_snippet() { return !!this.#props.pending; } /** * @param {() => Effect | null} fn */ #run(fn) { var previous_effect = active_effect; var previous_reaction = active_reaction; var previous_ctx = component_context; set_active_effect(this.#effect); set_active_reaction(this.#effect); set_component_context(this.#effect.ctx); try { return fn(); } finally { set_active_effect(previous_effect); set_active_reaction(previous_reaction); set_component_context(previous_ctx); } } #show_pending_snippet() { const pending = /** @type {(anchor: Node) => void} */ (this.#props.pending); if (this.#main_effect !== null) { this.#offscreen_fragment = document.createDocumentFragment(); move_effect(this.#main_effect, this.#offscreen_fragment); } if (this.#pending_effect === null) { this.#pending_effect = branch(() => pending(this.#anchor)); } } /** @param {1 | -1} d */ #update_pending_count(d) { this.#pending_count += d; if (this.#pending_count === 0) { this.pending = false; if (this.#pending_effect) { pause_effect(this.#pending_effect, () => { this.#pending_effect = null; }); } if (this.#offscreen_fragment) { this.#anchor.before(this.#offscreen_fragment); this.#offscreen_fragment = null; } } } /** @param {1 | -1} d */ update_pending_count(d) { if (this.has_pending_snippet()) { this.#update_pending_count(d); } else if (this.parent) { this.parent.#update_pending_count(d); } queueMicrotask(() => { if (this.#effect_pending) { internal_set(this.#effect_pending, this.#pending_count); } }); } get_effect_pending() { this.#effect_pending_subscriber(); return get(/** @type {Source<number>} */ (this.#effect_pending)); } /** @param {unknown} error */ error(error) { var onerror = this.#props.onerror; let failed = this.#props.failed; const reset = () => { this.#pending_count = 0; if (this.#failed_effect !== null) { pause_effect(this.#failed_effect, () => { this.#failed_effect = null; }); } this.pending = true; this.#main_effect = this.#run(() => { this.#is_creating_fallback = false; return branch(() => this.#children(this.#anchor)); }); if (this.#pending_count > 0) { this.#show_pending_snippet(); } else { this.pending = false; } }; // If we have nothing to capture the error, or if we hit an error while // rendering the fallback, re-throw for another boundary to handle if (this.#is_creating_fallback || (!onerror && !failed)) { throw error; } var previous_reaction = active_reaction; try { set_active_reaction(null); onerror?.(error, reset); } finally { set_active_reaction(previous_reaction); } if (this.#main_effect) { destroy_effect(this.#main_effect); this.#main_effect = null; } if (this.#pending_effect) { destroy_effect(this.#pending_effect); this.#pending_effect = null; } if (this.#failed_effect) { destroy_effect(this.#failed_effect); this.#failed_effect = null; } if (hydrating) { set_hydrate_node(this.#hydrate_open); next(); set_hydrate_node(remove_nodes()); } if (failed) { queue_micro_task(() => { this.#failed_effect = this.#run(() => { this.#is_creating_fallback = true; try { return branch(() => { failed( this.#anchor, () => error, () => reset ); }); } catch (error) { invoke_error_boundary(error, /** @type {Effect} */ (this.#effect.parent)); return null; } finally { this.#is_creating_fallback = false; } }); }); } } } /** * * @param {Effect} effect * @param {DocumentFragment} fragment */ function move_effect(effect, fragment) { var node = effect.nodes_start; var end = effect.nodes_end; while (node !== null) { /** @type {TemplateNode | null} */ var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node)); fragment.append(node); node = next; } } export function get_pending_boundary() { var boundary = /** @type {Effect} */ (active_effect).b; while (boundary !== null && !boundary.has_pending_snippet()) { boundary = boundary.parent; } if (boundary === null) { e.await_outside_boundary(); } return boundary; } export function pending() { if (active_effect === null) { e.effect_pending_outside_reaction(); } var boundary = active_effect.b; if (boundary === null) { return 0; // TODO eventually we will need this to be global } return boundary.get_effect_pending(); }
```

# internal/client/dom/blocks/css-props.js

```js
/** @import { TemplateNode } from '#client' */ import { render_effect, teardown } from '../../reactivity/effects.js'; import { hydrating, set_hydrate_node } from '../hydration.js'; import { get_first_child } from '../operations.js'; /** * @param {HTMLDivElement | SVGGElement} element * @param {() => Record<string, string>} get_styles * @returns {void} */ export function css_props(element, get_styles) { if (hydrating) { set_hydrate_node(/** @type {TemplateNode} */ (get_first_child(element))); } render_effect(() => { var styles = get_styles(); for (var key in styles) { var value = styles[key]; if (value) { element.style.setProperty(key, value); } else { element.style.removeProperty(key); } } }); }
```

# internal/client/dom/blocks/each.js

```js
/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */ /** @import { Batch } from '../../reactivity/batch.js'; */ import { EACH_INDEX_REACTIVE, EACH_IS_ANIMATED, EACH_IS_CONTROLLED, EACH_ITEM_IMMUTABLE, EACH_ITEM_REACTIVE, HYDRATION_END, HYDRATION_START_ELSE } from '../../../../constants.js'; import { hydrate_next, hydrate_node, hydrating, read_hydration_instruction, remove_nodes, set_hydrate_node, set_hydrating } from '../hydration.js'; import { clear_text_content, create_text, get_first_child, get_next_sibling, should_defer_append } from '../operations.js'; import { block, branch, destroy_effect, run_out_transitions, pause_children, pause_effect, resume_effect } from '../../reactivity/effects.js'; import { source, mutable_source, internal_set } from '../../reactivity/sources.js'; import { array_from, is_array } from '../../../shared/utils.js'; import { COMMENT_NODE, INERT } from '#client/constants'; import { queue_micro_task } from '../task.js'; import { active_effect, get } from '../../runtime.js'; import { DEV } from 'esm-env'; import { derived_safe_equal } from '../../reactivity/deriveds.js'; import { current_batch } from '../../reactivity/batch.js'; /** * The row of a keyed each block that is currently updating. We track this * so that `animate:` directives have something to attach themselves to * @type {EachItem | null} */ export let current_each_item = null; /** @param {EachItem | null} item */ export function set_current_each_item(item) { current_each_item = item; } /** * @param {any} _ * @param {number} i */ export function index(_, i) { return i; } /** * Pause multiple effects simultaneously, and coordinate their * subsequent destruction. Used in each blocks * @param {EachState} state * @param {EachItem[]} items * @param {null | Node} controlled_anchor */ function pause_effects(state, items, controlled_anchor) { var items_map = state.items; /** @type {TransitionManager[]} */ var transitions = []; var length = items.length; for (var i = 0; i < length; i++) { pause_children(items[i].e, transitions, true); } var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null; // If we have a controlled anchor, it means that the each block is inside a single // DOM element, so we can apply a fast-path for clearing the contents of the element. if (is_controlled) { var parent_node = /** @type {Element} */ ( /** @type {Element} */ (controlled_anchor).parentNode ); clear_text_content(parent_node); parent_node.append(/** @type {Element} */ (controlled_anchor)); items_map.clear(); link(state, items[0].prev, items[length - 1].next); } run_out_transitions(transitions, () => { for (var i = 0; i < length; i++) { var item = items[i]; if (!is_controlled) { items_map.delete(item.k); link(state, item.prev, item.next); } destroy_effect(item.e, !is_controlled); } }); } /** * @template V * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block * @param {number} flags * @param {() => V[]} get_collection * @param {(value: V, index: number) => any} get_key * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn * @param {null | ((anchor: Node) => void)} fallback_fn * @returns {void} */ export function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) { var anchor = node; /** @type {EachState} */ var state = { flags, items: new Map(), first: null }; var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0; if (is_controlled) { var parent_node = /** @type {Element} */ (node); anchor = hydrating ? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node))) : parent_node.appendChild(create_text()); } if (hydrating) { hydrate_next(); } /** @type {Effect | null} */ var fallback = null; var was_empty = false; /** @type {Map<any, EachItem>} */ var offscreen_items = new Map(); // TODO: ideally we could use derived for runes mode but because of the ability // to use a store which can be mutated, we can't do that here as mutating a store // will still result in the collection array being the same from the store var each_array = derived_safe_equal(() => { var collection = get_collection(); return is_array(collection) ? collection : collection == null ? [] : array_from(collection); }); /** @type {V[]} */ var array; /** @type {Effect} */ var each_effect; function commit() { reconcile( each_effect, array, state, offscreen_items, anchor, render_fn, flags, get_key, get_collection ); if (fallback_fn !== null) { if (array.length === 0) { if (fallback) { resume_effect(fallback); } else { fallback = branch(() => fallback_fn(anchor)); } } else if (fallback !== null) { pause_effect(fallback, () => { fallback = null; }); } } } block(() => { // store a reference to the effect so that we can update the start/end nodes in reconciliation each_effect ??= /** @type {Effect} */ (active_effect); array = get(each_array); var length = array.length; if (was_empty && length === 0) { // ignore updates if the array is empty, // and it already was empty on previous run return; } was_empty = length === 0; /** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */ let mismatch = false; if (hydrating) { var is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE; if (is_else !== (length === 0)) { // hydration mismatch — remove the server-rendered DOM and start over anchor = remove_nodes(); set_hydrate_node(anchor); set_hydrating(false); mismatch = true; } } // this is separate to the previous block because `hydrating` might change if (hydrating) { /** @type {EachItem | null} */ var prev = null; /** @type {EachItem} */ var item; for (var i = 0; i < length; i++) { if ( hydrate_node.nodeType === COMMENT_NODE && /** @type {Comment} */ (hydrate_node).data === HYDRATION_END ) { // The server rendered fewer items than expected, // so break out and continue appending non-hydrated items anchor = /** @type {Comment} */ (hydrate_node); mismatch = true; set_hydrating(false); break; } var value = array[i]; var key = get_key(value, i); item = create_item( hydrate_node, state, prev, null, value, key, i, render_fn, flags, get_collection ); state.items.set(key, item); prev = item; } // remove excess nodes if (length > 0) { set_hydrate_node(remove_nodes()); } } if (hydrating) { if (length === 0 && fallback_fn) { fallback = branch(() => fallback_fn(anchor)); } } else { if (should_defer_append()) { var keys = new Set(); var batch = /** @type {Batch} */ (current_batch); for (i = 0; i < length; i += 1) { value = array[i]; key = get_key(value, i); var existing = state.items.get(key) ?? offscreen_items.get(key); if (existing) { // update before reconciliation, to trigger any async updates if ((flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0) { update_item(existing, value, i, flags); } } else { item = create_item( null, state, null, null, value, key, i, render_fn, flags, get_collection, true ); offscreen_items.set(key, item); } keys.add(key); } for (const [key, item] of state.items) { if (!keys.has(key)) { batch.skipped_effects.add(item.e); } } batch.add_callback(commit); } else { commit(); } } if (mismatch) { // continue in hydration mode set_hydrating(true); } // When we mount the each block for the first time, the collection won't be // connected to this effect as the effect hasn't finished running yet and its deps // won't be assigned. However, it's possible that when reconciling the each block // that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the // collection again can provide consistency to the reactive graph again as the deriveds // will now be `CLEAN`. get(each_array); }); if (hydrating) { anchor = hydrate_node; } } /** * Add, remove, or reorder items output by an each block as its input changes * @template V * @param {Effect} each_effect * @param {Array<V>} array * @param {EachState} state * @param {Map<any, EachItem>} offscreen_items * @param {Element | Comment | Text} anchor * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>, collection: () => V[]) => void} render_fn * @param {number} flags * @param {(value: V, index: number) => any} get_key * @param {() => V[]} get_collection * @returns {void} */ function reconcile( each_effect, array, state, offscreen_items, anchor, render_fn, flags, get_key, get_collection ) { var is_animated = (flags & EACH_IS_ANIMATED) !== 0; var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0; var length = array.length; var items = state.items; var first = state.first; var current = first; /** @type {undefined | Set<EachItem>} */ var seen; /** @type {EachItem | null} */ var prev = null; /** @type {undefined | Set<EachItem>} */ var to_animate; /** @type {EachItem[]} */ var matched = []; /** @type {EachItem[]} */ var stashed = []; /** @type {V} */ var value; /** @type {any} */ var key; /** @type {EachItem | undefined} */ var item; /** @type {number} */ var i; if (is_animated) { for (i = 0; i < length; i += 1) { value = array[i]; key = get_key(value, i); item = items.get(key); if (item !== undefined) { item.a?.measure(); (to_animate ??= new Set()).add(item); } } } for (i = 0; i < length; i += 1) { value = array[i]; key = get_key(value, i); item = items.get(key); if (item === undefined) { var pending = offscreen_items.get(key); if (pending !== undefined) { offscreen_items.delete(key); items.set(key, pending); var next = prev ? prev.next : current; link(state, prev, pending); link(state, pending, next); move(pending, next, anchor); prev = pending; } else { var child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor; prev = create_item( child_anchor, state, prev, prev === null ? state.first : prev.next, value, key, i, render_fn, flags, get_collection ); } items.set(key, prev); matched = []; stashed = []; current = prev.next; continue; } if (should_update) { update_item(item, value, i, flags); } if ((item.e.f & INERT) !== 0) { resume_effect(item.e); if (is_animated) { item.a?.unfix(); (to_animate ??= new Set()).delete(item); } } if (item !== current) { if (seen !== undefined && seen.has(item)) { if (matched.length < stashed.length) { // more efficient to move later items to the front var start = stashed[0]; var j; prev = start.prev; var a = matched[0]; var b = matched[matched.length - 1]; for (j = 0; j < matched.length; j += 1) { move(matched[j], start, anchor); } for (j = 0; j < stashed.length; j += 1) { seen.delete(stashed[j]); } link(state, a.prev, b.next); link(state, prev, a); link(state, b, start); current = start; prev = b; i -= 1; matched = []; stashed = []; } else { // more efficient to move earlier items to the back seen.delete(item); move(item, current, anchor); link(state, item.prev, item.next); link(state, item, prev === null ? state.first : prev.next); link(state, prev, item); prev = item; } continue; } matched = []; stashed = []; while (current !== null && current.k !== key) { // If the each block isn't inert and an item has an effect that is already inert, // skip over adding it to our seen Set as the item is already being handled if ((current.e.f & INERT) === 0) { (seen ??= new Set()).add(current); } stashed.push(current); current = current.next; } if (current === null) { continue; } item = current; } matched.push(item); prev = item; current = item.next; } if (current !== null || seen !== undefined) { var to_destroy = seen === undefined ? [] : array_from(seen); while (current !== null) { // If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished if ((current.e.f & INERT) === 0) { to_destroy.push(current); } current = current.next; } var destroy_length = to_destroy.length; if (destroy_length > 0) { var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null; if (is_animated) { for (i = 0; i < destroy_length; i += 1) { to_destroy[i].a?.measure(); } for (i = 0; i < destroy_length; i += 1) { to_destroy[i].a?.fix(); } } pause_effects(state, to_destroy, controlled_anchor); } } if (is_animated) { queue_micro_task(() => { if (to_animate === undefined) return; for (item of to_animate) { item.a?.apply(); } }); } each_effect.first = state.first && state.first.e; each_effect.last = prev && prev.e; for (var unused of offscreen_items.values()) { destroy_effect(unused.e); } offscreen_items.clear(); } /** * @param {EachItem} item * @param {any} value * @param {number} index * @param {number} type * @returns {void} */ function update_item(item, value, index, type) { if ((type & EACH_ITEM_REACTIVE) !== 0) { internal_set(item.v, value); } if ((type & EACH_INDEX_REACTIVE) !== 0) { internal_set(/** @type {Value<number>} */ (item.i), index); } else { item.i = index; } } /** * @template V * @param {Node | null} anchor * @param {EachState} state * @param {EachItem | null} prev * @param {EachItem | null} next * @param {V} value * @param {unknown} key * @param {number} index * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn * @param {number} flags * @param {() => V[]} get_collection * @param {boolean} [deferred] * @returns {EachItem} */ function create_item( anchor, state, prev, next, value, key, index, render_fn, flags, get_collection, deferred ) { var previous_each_item = current_each_item; var reactive = (flags & EACH_ITEM_REACTIVE) !== 0; var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0; var v = reactive ? (mutable ? mutable_source(value, false, false) : source(value)) : value; var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index); if (DEV && reactive) { // For tracing purposes, we need to link the source signal we create with the // collection + index so that tracing works as intended /** @type {Value} */ (v).trace = () => { var collection_index = typeof i === 'number' ? index : i.v; // eslint-disable-next-line @typescript-eslint/no-unused-expressions get_collection()[collection_index]; }; } /** @type {EachItem} */ var item = { i, v, k: key, a: null, // @ts-expect-error e: null, prev, next }; current_each_item = item; try { if (anchor === null) { var fragment = document.createDocumentFragment(); fragment.append((anchor = create_text())); } item.e = branch(() => render_fn(/** @type {Node} */ (anchor), v, i, get_collection), hydrating); item.e.prev = prev && prev.e; item.e.next = next && next.e; if (prev === null) { if (!deferred) { state.first = item; } } else { prev.next = item; prev.e.next = item.e; } if (next !== null) { next.prev = item; next.e.prev = item.e; } return item; } finally { current_each_item = previous_each_item; } } /** * @param {EachItem} item * @param {EachItem | null} next * @param {Text | Element | Comment} anchor */ function move(item, next, anchor) { var end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor; var dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor; var node = /** @type {TemplateNode} */ (item.e.nodes_start); while (node !== null && node !== end) { var next_node = /** @type {TemplateNode} */ (get_next_sibling(node)); dest.before(node); node = next_node; } } /** * @param {EachState} state * @param {EachItem | null} prev * @param {EachItem | null} next */ function link(state, prev, next) { if (prev === null) { state.first = next; } else { prev.next = next; prev.e.next = next && next.e; } if (next !== null) { next.prev = prev; next.e.prev = prev && prev.e; } }
```

# internal/client/dom/blocks/html.js

```js
/** @import { Effect, TemplateNode } from '#client' */ import { FILENAME, HYDRATION_ERROR } from '../../../../constants.js'; import { remove_effect_dom, template_effect } from '../../reactivity/effects.js'; import { hydrate_next, hydrate_node, hydrating, set_hydrate_node } from '../hydration.js'; import { create_fragment_from_html } from '../reconciler.js'; import { assign_nodes } from '../template.js'; import * as w from '../../warnings.js'; import { hash, sanitize_location } from '../../../../utils.js'; import { DEV } from 'esm-env'; import { dev_current_component_function } from '../../context.js'; import { get_first_child, get_next_sibling } from '../operations.js'; import { active_effect } from '../../runtime.js'; import { COMMENT_NODE } from '#client/constants'; /** * @param {Element} element * @param {string | null} server_hash * @param {string} value */ function check_hash(element, server_hash, value) { if (!server_hash || server_hash === hash(String(value ?? ''))) return; let location; // @ts-expect-error const loc = element.__svelte_meta?.loc; if (loc) { location = `near ${loc.file}:${loc.line}:${loc.column}`; } else if (dev_current_component_function?.[FILENAME]) { location = `in ${dev_current_component_function[FILENAME]}`; } w.hydration_html_changed(sanitize_location(location)); } /** * @param {Element | Text | Comment} node * @param {() => string} get_value * @param {boolean} [svg] * @param {boolean} [mathml] * @param {boolean} [skip_warning] * @returns {void} */ export function html(node, get_value, svg = false, mathml = false, skip_warning = false) { var anchor = node; var value = ''; template_effect(() => { var effect = /** @type {Effect} */ (active_effect); if (value === (value = get_value() ?? '')) { if (hydrating) hydrate_next(); return; } if (effect.nodes_start !== null) { remove_effect_dom(effect.nodes_start, /** @type {TemplateNode} */ (effect.nodes_end)); effect.nodes_start = effect.nodes_end = null; } if (value === '') return; if (hydrating) { // We're deliberately not trying to repair mismatches between server and client, // as it's costly and error-prone (and it's an edge case to have a mismatch anyway) var hash = /** @type {Comment} */ (hydrate_node).data; var next = hydrate_next(); var last = next; while ( next !== null && (next.nodeType !== COMMENT_NODE || /** @type {Comment} */ (next).data !== '') ) { last = next; next = /** @type {TemplateNode} */ (get_next_sibling(next)); } if (next === null) { w.hydration_mismatch(); throw HYDRATION_ERROR; } if (DEV && !skip_warning) { check_hash(/** @type {Element} */ (next.parentNode), hash, value); } assign_nodes(hydrate_node, last); anchor = set_hydrate_node(next); return; } var html = value + ''; if (svg) html = `<svg>${html}</svg>`; else if (mathml) html = `<math>${html}</math>`; // Don't use create_fragment_with_script_from_html here because that would mean script tags are executed. // @html is basically `.innerHTML = ...` and that doesn't execute scripts either due to security reasons. /** @type {DocumentFragment | Element} */ var node = create_fragment_from_html(html); if (svg || mathml) { node = /** @type {Element} */ (get_first_child(node)); } assign_nodes( /** @type {TemplateNode} */ (get_first_child(node)), /** @type {TemplateNode} */ (node.lastChild) ); if (svg || mathml) { while (get_first_child(node)) { anchor.before(/** @type {Node} */ (get_first_child(node))); } } else { anchor.before(node); } }); }
```

# internal/client/dom/blocks/if.js

```js
/** @import { Effect, TemplateNode } from '#client' */ /** @import { Batch } from '../../reactivity/batch.js'; */ import { EFFECT_TRANSPARENT } from '#client/constants'; import { hydrate_next, hydrate_node, hydrating, read_hydration_instruction, remove_nodes, set_hydrate_node, set_hydrating } from '../hydration.js'; import { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js'; import { HYDRATION_START_ELSE, UNINITIALIZED } from '../../../../constants.js'; import { create_text, should_defer_append } from '../operations.js'; import { current_batch } from '../../reactivity/batch.js'; // TODO reinstate https://github.com/sveltejs/svelte/pull/15250 /** * @param {TemplateNode} node * @param {(branch: (fn: (anchor: Node) => void, flag?: boolean) => void) => void} fn * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local' * @returns {void} */ export function if_block(node, fn, elseif = false) { if (hydrating) { hydrate_next(); } var anchor = node; /** @type {Effect | null} */ var consequent_effect = null; /** @type {Effect | null} */ var alternate_effect = null; /** @type {UNINITIALIZED | boolean | null} */ var condition = UNINITIALIZED; var flags = elseif ? EFFECT_TRANSPARENT : 0; var has_branch = false; const set_branch = (/** @type {(anchor: Node) => void} */ fn, flag = true) => { has_branch = true; update_branch(flag, fn); }; /** @type {DocumentFragment | null} */ var offscreen_fragment = null; function commit() { if (offscreen_fragment !== null) { // remove the anchor /** @type {Text} */ (offscreen_fragment.lastChild).remove(); anchor.before(offscreen_fragment); offscreen_fragment = null; } var active = condition ? consequent_effect : alternate_effect; var inactive = condition ? alternate_effect : consequent_effect; if (active) { resume_effect(active); } if (inactive) { pause_effect(inactive, () => { if (condition) { alternate_effect = null; } else { consequent_effect = null; } }); } } const update_branch = ( /** @type {boolean | null} */ new_condition, /** @type {null | ((anchor: Node) => void)} */ fn ) => { if (condition === (condition = new_condition)) return; /** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */ let mismatch = false; if (hydrating) { const is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE; if (!!condition === is_else) { // Hydration mismatch: remove everything inside the anchor and start fresh. // This could happen with `{#if browser}...{/if}`, for example anchor = remove_nodes(); set_hydrate_node(anchor); set_hydrating(false); mismatch = true; } } var defer = should_defer_append(); var target = anchor; if (defer) { offscreen_fragment = document.createDocumentFragment(); offscreen_fragment.append((target = create_text())); } if (condition) { consequent_effect ??= fn && branch(() => fn(target)); } else { alternate_effect ??= fn && branch(() => fn(target)); } if (defer) { var batch = /** @type {Batch} */ (current_batch); var active = condition ? consequent_effect : alternate_effect; var inactive = condition ? alternate_effect : consequent_effect; if (active) batch.skipped_effects.delete(active); if (inactive) batch.skipped_effects.add(inactive); batch.add_callback(commit); } else { commit(); } if (mismatch) { // continue in hydration mode set_hydrating(true); } }; block(() => { has_branch = false; fn(set_branch); if (!has_branch) { update_branch(null, null); } }, flags); if (hydrating) { anchor = hydrate_node; } }
```

# internal/client/dom/blocks/key.js

```js
/** @import { Effect, TemplateNode } from '#client' */ /** @import { Batch } from '../../reactivity/batch.js'; */ import { UNINITIALIZED } from '../../../../constants.js'; import { block, branch, pause_effect } from '../../reactivity/effects.js'; import { not_equal, safe_not_equal } from '../../reactivity/equality.js'; import { is_runes } from '../../context.js'; import { hydrate_next, hydrate_node, hydrating } from '../hydration.js'; import { create_text, should_defer_append } from '../operations.js'; import { current_batch } from '../../reactivity/batch.js'; /** * @template V * @param {TemplateNode} node * @param {() => V} get_key * @param {(anchor: Node) => TemplateNode | void} render_fn * @returns {void} */ export function key(node, get_key, render_fn) { if (hydrating) { hydrate_next(); } var anchor = node; /** @type {V | typeof UNINITIALIZED} */ var key = UNINITIALIZED; /** @type {Effect} */ var effect; /** @type {Effect} */ var pending_effect; /** @type {DocumentFragment | null} */ var offscreen_fragment = null; var changed = is_runes() ? not_equal : safe_not_equal; function commit() { if (effect) { pause_effect(effect); } if (offscreen_fragment !== null) { // remove the anchor /** @type {Text} */ (offscreen_fragment.lastChild).remove(); anchor.before(offscreen_fragment); offscreen_fragment = null; } effect = pending_effect; } block(() => { if (changed(key, (key = get_key()))) { var target = anchor; var defer = should_defer_append(); if (defer) { offscreen_fragment = document.createDocumentFragment(); offscreen_fragment.append((target = create_text())); } pending_effect = branch(() => render_fn(target)); if (defer) { /** @type {Batch} */ (current_batch).add_callback(commit); } else { commit(); } } }); if (hydrating) { anchor = hydrate_node; } }
```

# internal/client/dom/blocks/slot.js

```js
import { hydrate_next, hydrating } from '../hydration.js'; /** * @param {Comment} anchor * @param {Record<string, any>} $$props * @param {string} name * @param {Record<string, unknown>} slot_props * @param {null | ((anchor: Comment) => void)} fallback_fn */ export function slot(anchor, $$props, name, slot_props, fallback_fn) { if (hydrating) { hydrate_next(); } var slot_fn = $$props.$$slots?.[name]; // Interop: Can use snippets to fill slots var is_interop = false; if (slot_fn === true) { slot_fn = $$props[name === 'default' ? 'children' : name]; is_interop = true; } if (slot_fn === undefined) { if (fallback_fn !== null) { fallback_fn(anchor); } } else { slot_fn(anchor, is_interop ? () => slot_props : slot_props); } } /** * @param {Record<string, any>} props * @returns {Record<string, boolean>} */ export function sanitize_slots(props) { /** @type {Record<string, boolean>} */ const sanitized = {}; if (props.children) sanitized.default = true; for (const key in props.$$slots) { sanitized[key] = true; } return sanitized; }
```

# internal/client/dom/blocks/snippet.js

```js
/** @import { Snippet } from 'svelte' */ /** @import { Effect, TemplateNode } from '#client' */ /** @import { Getters } from '#shared' */ import { EFFECT_TRANSPARENT, ELEMENT_NODE } from '#client/constants'; import { branch, block, destroy_effect, teardown } from '../../reactivity/effects.js'; import { dev_current_component_function, set_dev_current_component_function } from '../../context.js'; import { hydrate_next, hydrate_node, hydrating } from '../hydration.js'; import { create_fragment_from_html } from '../reconciler.js'; import { assign_nodes } from '../template.js'; import * as w from '../../warnings.js'; import * as e from '../../errors.js'; import { DEV } from 'esm-env'; import { get_first_child, get_next_sibling } from '../operations.js'; import { noop } from '../../../shared/utils.js'; import { prevent_snippet_stringification } from '../../../shared/validate.js'; /** * @template {(node: TemplateNode, ...args: any[]) => void} SnippetFn * @param {TemplateNode} node * @param {() => SnippetFn | null | undefined} get_snippet * @param {(() => any)[]} args * @returns {void} */ export function snippet(node, get_snippet, ...args) { var anchor = node; /** @type {SnippetFn | null | undefined} */ // @ts-ignore var snippet = noop; /** @type {Effect | null} */ var snippet_effect; block(() => { if (snippet === (snippet = get_snippet())) return; if (snippet_effect) { destroy_effect(snippet_effect); snippet_effect = null; } if (DEV && snippet == null) { e.invalid_snippet(); } snippet_effect = branch(() => /** @type {SnippetFn} */ (snippet)(anchor, ...args)); }, EFFECT_TRANSPARENT); if (hydrating) { anchor = hydrate_node; } } /** * In development, wrap the snippet function so that it passes validation, and so that the * correct component context is set for ownership checks * @param {any} component * @param {(node: TemplateNode, ...args: any[]) => void} fn */ export function wrap_snippet(component, fn) { const snippet = (/** @type {TemplateNode} */ node, /** @type {any[]} */ ...args) => { var previous_component_function = dev_current_component_function; set_dev_current_component_function(component); try { return fn(node, ...args); } finally { set_dev_current_component_function(previous_component_function); } }; prevent_snippet_stringification(snippet); return snippet; } /** * Create a snippet programmatically * @template {unknown[]} Params * @param {(...params: Getters<Params>) => { * render: () => string * setup?: (element: Element) => void | (() => void) * }} fn * @returns {Snippet<Params>} */ export function createRawSnippet(fn) { // @ts-expect-error the types are a lie return (/** @type {TemplateNode} */ anchor, /** @type {Getters<Params>} */ ...params) => { var snippet = fn(...params); /** @type {Element} */ var element; if (hydrating) { element = /** @type {Element} */ (hydrate_node); hydrate_next(); } else { var html = snippet.render().trim(); var fragment = create_fragment_from_html(html); element = /** @type {Element} */ (get_first_child(fragment)); if (DEV && (get_next_sibling(element) !== null || element.nodeType !== ELEMENT_NODE)) { w.invalid_raw_snippet_render(); } anchor.before(element); } const result = snippet.setup?.(element); assign_nodes(element, element); if (typeof result === 'function') { teardown(result); } }; }
```

# internal/client/dom/blocks/svelte-component.js

```js
/** @import { TemplateNode, Dom, Effect } from '#client' */ /** @import { Batch } from '../../reactivity/batch.js'; */ import { EFFECT_TRANSPARENT } from '#client/constants'; import { block, branch, pause_effect } from '../../reactivity/effects.js'; import { current_batch } from '../../reactivity/batch.js'; import { hydrate_next, hydrate_node, hydrating } from '../hydration.js'; import { create_text, should_defer_append } from '../operations.js'; /** * @template P * @template {(props: P) => void} C * @param {TemplateNode} node * @param {() => C} get_component * @param {(anchor: TemplateNode, component: C) => Dom | void} render_fn * @returns {void} */ export function component(node, get_component, render_fn) { if (hydrating) { hydrate_next(); } var anchor = node; /** @type {C} */ var component; /** @type {Effect | null} */ var effect; /** @type {DocumentFragment | null} */ var offscreen_fragment = null; /** @type {Effect | null} */ var pending_effect = null; function commit() { if (effect) { pause_effect(effect); effect = null; } if (offscreen_fragment) { // remove the anchor /** @type {Text} */ (offscreen_fragment.lastChild).remove(); anchor.before(offscreen_fragment); offscreen_fragment = null; } effect = pending_effect; pending_effect = null; } block(() => { if (component === (component = get_component())) return; var defer = should_defer_append(); if (component) { var target = anchor; if (defer) { offscreen_fragment = document.createDocumentFragment(); offscreen_fragment.append((target = create_text())); } pending_effect = branch(() => render_fn(target, component)); } if (defer) { /** @type {Batch} */ (current_batch).add_callback(commit); } else { commit(); } }, EFFECT_TRANSPARENT); if (hydrating) { anchor = hydrate_node; } }
```

# internal/client/dom/blocks/svelte-element.js

```js
/** @import { Effect, TemplateNode } from '#client' */ import { FILENAME, NAMESPACE_SVG } from '../../../../constants.js'; import { hydrate_next, hydrate_node, hydrating, set_hydrate_node, set_hydrating } from '../hydration.js'; import { create_text, get_first_child } from '../operations.js'; import { block, branch, destroy_effect, pause_effect, resume_effect } from '../../reactivity/effects.js'; import { set_should_intro } from '../../render.js'; import { current_each_item, set_current_each_item } from './each.js'; import { active_effect } from '../../runtime.js'; import { component_context, dev_stack } from '../../context.js'; import { DEV } from 'esm-env'; import { EFFECT_TRANSPARENT, ELEMENT_NODE } from '#client/constants'; import { assign_nodes } from '../template.js'; import { is_raw_text_element } from '../../../../utils.js'; /** * @param {Comment | Element} node * @param {() => string} get_tag * @param {boolean} is_svg * @param {undefined | ((element: Element, anchor: Node | null) => void)} render_fn, * @param {undefined | (() => string)} get_namespace * @param {undefined | [number, number]} location * @returns {void} */ export function element(node, get_tag, is_svg, render_fn, get_namespace, location) { let was_hydrating = hydrating; if (hydrating) { hydrate_next(); } var filename = DEV && location && component_context?.function[FILENAME]; /** @type {string | null} */ var tag; /** @type {string | null} */ var current_tag; /** @type {null | Element} */ var element = null; if (hydrating && hydrate_node.nodeType === ELEMENT_NODE) { element = /** @type {Element} */ (hydrate_node); hydrate_next(); } var anchor = /** @type {TemplateNode} */ (hydrating ? hydrate_node : node); /** @type {Effect | null} */ var effect; /** * The keyed `{#each ...}` item block, if any, that this element is inside. * We track this so we can set it when changing the element, allowing any * `animate:` directive to bind itself to the correct block */ var each_item_block = current_each_item; block(() => { const next_tag = get_tag() || null; var ns = get_namespace ? get_namespace() : is_svg || next_tag === 'svg' ? NAMESPACE_SVG : null; // Assumption: Noone changes the namespace but not the tag (what would that even mean?) if (next_tag === tag) return; // See explanation of `each_item_block` above var previous_each_item = current_each_item; set_current_each_item(each_item_block); if (effect) { if (next_tag === null) { // start outro pause_effect(effect, () => { effect = null; current_tag = null; }); } else if (next_tag === current_tag) { // same tag as is currently rendered — abort outro resume_effect(effect); } else { // tag is changing — destroy immediately, render contents without intro transitions destroy_effect(effect); set_should_intro(false); } } if (next_tag && next_tag !== current_tag) { effect = branch(() => { element = hydrating ? /** @type {Element} */ (element) : ns ? document.createElementNS(ns, next_tag) : document.createElement(next_tag); if (DEV && location) { // @ts-expect-error element.__svelte_meta = { parent: dev_stack, loc: { file: filename, line: location[0], column: location[1] } }; } assign_nodes(element, element); if (render_fn) { if (hydrating && is_raw_text_element(next_tag)) { // prevent hydration glitches element.append(document.createComment('')); } // If hydrating, use the existing ssr comment as the anchor so that the // inner open and close methods can pick up the existing nodes correctly var child_anchor = /** @type {TemplateNode} */ ( hydrating ? get_first_child(element) : element.appendChild(create_text()) ); if (hydrating) { if (child_anchor === null) { set_hydrating(false); } else { set_hydrate_node(child_anchor); } } // `child_anchor` is undefined if this is a void element, but we still // need to call `render_fn` in order to run actions etc. If the element // contains children, it's a user error (which is warned on elsewhere) // and the DOM will be silently discarded render_fn(element, child_anchor); } // we do this after calling `render_fn` so that child effects don't override `nodes.end` /** @type {Effect} */ (active_effect).nodes_end = element; anchor.before(element); }); } tag = next_tag; if (tag) current_tag = tag; set_should_intro(true); set_current_each_item(previous_each_item); }, EFFECT_TRANSPARENT); if (was_hydrating) { set_hydrating(true); set_hydrate_node(anchor); } }
```

# internal/client/dom/blocks/svelte-head.js

```js
/** @import { TemplateNode } from '#client' */ import { hydrate_node, hydrating, set_hydrate_node, set_hydrating } from '../hydration.js'; import { create_text, get_first_child, get_next_sibling } from '../operations.js'; import { block } from '../../reactivity/effects.js'; import { COMMENT_NODE, HEAD_EFFECT } from '#client/constants'; import { HYDRATION_START } from '../../../../constants.js'; /** * @type {Node | undefined} */ let head_anchor; export function reset_head_anchor() { head_anchor = undefined; } /** * @param {(anchor: Node) => void} render_fn * @returns {void} */ export function head(render_fn) { // The head function may be called after the first hydration pass and ssr comment nodes may still be present, // therefore we need to skip that when we detect that we're not in hydration mode. let previous_hydrate_node = null; let was_hydrating = hydrating; /** @type {Comment | Text} */ var anchor; if (hydrating) { previous_hydrate_node = hydrate_node; // There might be multiple head blocks in our app, so we need to account for each one needing independent hydration. if (head_anchor === undefined) { head_anchor = /** @type {TemplateNode} */ (get_first_child(document.head)); } while ( head_anchor !== null && (head_anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */ (head_anchor).data !== HYDRATION_START) ) { head_anchor = /** @type {TemplateNode} */ (get_next_sibling(head_anchor)); } // If we can't find an opening hydration marker, skip hydration (this can happen // if a framework rendered body but not head content) if (head_anchor === null) { set_hydrating(false); } else { head_anchor = set_hydrate_node(/** @type {TemplateNode} */ (get_next_sibling(head_anchor))); } } if (!hydrating) { anchor = document.head.appendChild(create_text()); } try { block(() => render_fn(anchor), HEAD_EFFECT); } finally { if (was_hydrating) { set_hydrating(true); head_anchor = hydrate_node; // so that next head block starts from the correct node set_hydrate_node(/** @type {TemplateNode} */ (previous_hydrate_node)); } } }
```

# internal/client/dom/css.js

```js
import { DEV } from 'esm-env'; import { queue_micro_task } from './task.js'; import { register_style } from '../dev/css.js'; /** * @param {Node} anchor * @param {{ hash: string, code: string }} css */ export function append_styles(anchor, css) { // Use `queue_micro_task` to ensure `anchor` is in the DOM, otherwise getRootNode() will yield wrong results queue_micro_task(() => { var root = anchor.getRootNode(); var target = /** @type {ShadowRoot} */ (root).host ? /** @type {ShadowRoot} */ (root) : /** @type {Document} */ (root).head ?? /** @type {Document} */ (root.ownerDocument).head; // Always querying the DOM is roughly the same perf as additionally checking for presence in a map first assuming // that you'll get cache hits half of the time, so we just always query the dom for simplicity and code savings. if (!target.querySelector('#' + css.hash)) { const style = document.createElement('style'); style.id = css.hash; style.textContent = css.code; target.appendChild(style); if (DEV) { register_style(css.hash, style); } } }); }
```

# internal/client/dom/elements/actions.js

```js
/** @import { ActionPayload } from '#client' */ import { effect, render_effect } from '../../reactivity/effects.js'; import { safe_not_equal } from '../../reactivity/equality.js'; import { deep_read_state, untrack } from '../../runtime.js'; /** * @template P * @param {Element} dom * @param {(dom: Element, value?: P) => ActionPayload<P>} action * @param {() => P} [get_value] * @returns {void} */ export function action(dom, action, get_value) { effect(() => { var payload = untrack(() => action(dom, get_value?.()) || {}); if (get_value && payload?.update) { var inited = false; /** @type {P} */ var prev = /** @type {any} */ ({}); // initialize with something so it's never equal on first run render_effect(() => { var value = get_value(); // Action's update method is coarse-grained, i.e. when anything in the passed value changes, update. // This works in legacy mode because of mutable_source being updated as a whole, but when using $state // together with actions and mutation, it wouldn't notice the change without a deep read. deep_read_state(value); if (inited && safe_not_equal(prev, value)) { prev = value; /** @type {Function} */ (payload.update)(value); } }); inited = true; } if (payload?.destroy) { return () => /** @type {Function} */ (payload.destroy)(); } }); }
```

# internal/client/dom/elements/attachments.js

```js
/** @import { Effect } from '#client' */ import { block, branch, effect, destroy_effect } from '../../reactivity/effects.js'; // TODO in 6.0 or 7.0, when we remove legacy mode, we can simplify this by // getting rid of the block/branch stuff and just letting the effect rip. // see https://github.com/sveltejs/svelte/pull/15962 /** * @param {Element} node * @param {() => (node: Element) => void} get_fn */ export function attach(node, get_fn) { /** @type {false | undefined | ((node: Element) => void)} */ var fn = undefined; /** @type {Effect | null} */ var e; block(() => { if (fn !== (fn = get_fn())) { if (e) { destroy_effect(e); e = null; } if (fn) { e = branch(() => { effect(() => /** @type {(node: Element) => void} */ (fn)(node)); }); } } }); }
```

# internal/client/dom/elements/attributes.js

```js
/** @import { Effect } from '#client' */ import { DEV } from 'esm-env'; import { hydrating, set_hydrating } from '../hydration.js'; import { get_descriptors, get_prototype_of } from '../../../shared/utils.js'; import { create_event, delegate } from './events.js'; import { add_form_reset_listener, autofocus } from './misc.js'; import * as w from '../../warnings.js'; import { LOADING_ATTR_SYMBOL } from '#client/constants'; import { queue_idle_task } from '../task.js'; import { is_capture_event, is_delegated, normalize_attribute } from '../../../../utils.js'; import { active_effect, active_reaction, get, set_active_effect, set_active_reaction } from '../../runtime.js'; import { attach } from './attachments.js'; import { clsx } from '../../../shared/attributes.js'; import { set_class } from './class.js'; import { set_style } from './style.js'; import { ATTACHMENT_KEY, NAMESPACE_HTML } from '../../../../constants.js'; import { block, branch, destroy_effect, effect } from '../../reactivity/effects.js'; import { init_select, select_option } from './bindings/select.js'; import { flatten } from '../../reactivity/async.js'; export const CLASS = Symbol('class'); export const STYLE = Symbol('style'); const IS_CUSTOM_ELEMENT = Symbol('is custom element'); const IS_HTML = Symbol('is html'); /** * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need * to remove it upon hydration to avoid a bug when someone resets the form value. * @param {HTMLInputElement} input * @returns {void} */ export function remove_input_defaults(input) { if (!hydrating) return; var already_removed = false; // We try and remove the default attributes later, rather than sync during hydration. // Doing it sync during hydration has a negative impact on performance, but deferring the // work in an idle task alleviates this greatly. If a form reset event comes in before // the idle callback, then we ensure the input defaults are cleared just before. var remove_defaults = () => { if (already_removed) return; already_removed = true; // Remove the attributes but preserve the values if (input.hasAttribute('value')) { var value = input.value; set_attribute(input, 'value', null); input.value = value; } if (input.hasAttribute('checked')) { var checked = input.checked; set_attribute(input, 'checked', null); input.checked = checked; } }; // @ts-expect-error input.__on_r = remove_defaults; queue_idle_task(remove_defaults); add_form_reset_listener(); } /** * @param {Element} element * @param {any} value */ export function set_value(element, value) { var attributes = get_attributes(element); if ( attributes.value === (attributes.value = // treat null and undefined the same for the initial value value ?? undefined) || // @ts-expect-error // `progress` elements always need their value set when it's `0` (element.value === value && (value !== 0 || element.nodeName !== 'PROGRESS')) ) { return; } // @ts-expect-error element.value = value ?? ''; } /** * @param {Element} element * @param {boolean} checked */ export function set_checked(element, checked) { var attributes = get_attributes(element); if ( attributes.checked === (attributes.checked = // treat null and undefined the same for the initial value checked ?? undefined) ) { return; } // @ts-expect-error element.checked = checked; } /** * Sets the `selected` attribute on an `option` element. * Not set through the property because that doesn't reflect to the DOM, * which means it wouldn't be taken into account when a form is reset. * @param {HTMLOptionElement} element * @param {boolean} selected */ export function set_selected(element, selected) { if (selected) { // The selected option could've changed via user selection, and // setting the value without this check would set it back. if (!element.hasAttribute('selected')) { element.setAttribute('selected', ''); } } else { element.removeAttribute('selected'); } } /** * Applies the default checked property without influencing the current checked property. * @param {HTMLInputElement} element * @param {boolean} checked */ export function set_default_checked(element, checked) { const existing_value = element.checked; element.defaultChecked = checked; element.checked = existing_value; } /** * Applies the default value property without influencing the current value property. * @param {HTMLInputElement | HTMLTextAreaElement} element * @param {string} value */ export function set_default_value(element, value) { const existing_value = element.value; element.defaultValue = value; element.value = existing_value; } /** * @param {Element} element * @param {string} attribute * @param {string | null} value * @param {boolean} [skip_warning] */ export function set_attribute(element, attribute, value, skip_warning) { var attributes = get_attributes(element); if (hydrating) { attributes[attribute] = element.getAttribute(attribute); if ( attribute === 'src' || attribute === 'srcset' || (attribute === 'href' && element.nodeName === 'LINK') ) { if (!skip_warning) { check_src_in_dev_hydration(element, attribute, value ?? ''); } // If we reset these attributes, they would result in another network request, which we want to avoid. // We assume they are the same between client and server as checking if they are equal is expensive // (we can't just compare the strings as they can be different between client and server but result in the // same url, so we would need to create hidden anchor elements to compare them) return; } } if (attributes[attribute] === (attributes[attribute] = value)) return; if (attribute === 'loading') { // @ts-expect-error element[LOADING_ATTR_SYMBOL] = value; } if (value == null) { element.removeAttribute(attribute); } else if (typeof value !== 'string' && get_setters(element).includes(attribute)) { // @ts-ignore element[attribute] = value; } else { element.setAttribute(attribute, value); } } /** * @param {Element} dom * @param {string} attribute * @param {string} value */ export function set_xlink_attribute(dom, attribute, value) { dom.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value); } /** * @param {HTMLElement} node * @param {string} prop * @param {any} value */ export function set_custom_element_data(node, prop, value) { // We need to ensure that setting custom element props, which can // invoke lifecycle methods on other custom elements, does not also // associate those lifecycle methods with the current active reaction // or effect var previous_reaction = active_reaction; var previous_effect = active_effect; // If we're hydrating but the custom element is from Svelte, and it already scaffolded, // then it might run block logic in hydration mode, which we have to prevent. let was_hydrating = hydrating; if (hydrating) { set_hydrating(false); } set_active_reaction(null); set_active_effect(null); try { if ( // `style` should use `set_attribute` rather than the setter prop !== 'style' && // Don't compute setters for custom elements while they aren't registered yet, // because during their upgrade/instantiation they might add more setters. // Instead, fall back to a simple "an object, then set as property" heuristic. (setters_cache.has(node.nodeName) || // customElements may not be available in browser extension contexts !customElements || customElements.get(node.tagName.toLowerCase()) ? get_setters(node).includes(prop) : value && typeof value === 'object') ) { // @ts-expect-error node[prop] = value; } else { // We did getters etc checks already, stringify before passing to set_attribute // to ensure it doesn't invoke the same logic again, and potentially populating // the setters cache too early. set_attribute(node, prop, value == null ? value : String(value)); } } finally { set_active_reaction(previous_reaction); set_active_effect(previous_effect); if (was_hydrating) { set_hydrating(true); } } } /** * Spreads attributes onto a DOM element, taking into account the currently set attributes * @param {Element & ElementCSSInlineStyle} element * @param {Record<string | symbol, any> | undefined} prev * @param {Record<string | symbol, any>} next New attributes - this function mutates this object * @param {string} [css_hash] * @param {boolean} [skip_warning] * @returns {Record<string, any>} */ export function set_attributes(element, prev, next, css_hash, skip_warning = false) { var attributes = get_attributes(element); var is_custom_element = attributes[IS_CUSTOM_ELEMENT]; var preserve_attribute_case = !attributes[IS_HTML]; // If we're hydrating but the custom element is from Svelte, and it already scaffolded, // then it might run block logic in hydration mode, which we have to prevent. let is_hydrating_custom_element = hydrating && is_custom_element; if (is_hydrating_custom_element) { set_hydrating(false); } var current = prev || {}; var is_option_element = element.tagName === 'OPTION'; for (var key in prev) { if (!(key in next)) { next[key] = null; } } if (next.class) { next.class = clsx(next.class); } else if (css_hash || next[CLASS]) { next.class = null; /* force call to set_class() */ } if (next[STYLE]) { next.style ??= null; /* force call to set_style() */ } var setters = get_setters(element); // since key is captured we use const for (const key in next) { // let instead of var because referenced in a closure let value = next[key]; // Up here because we want to do this for the initial value, too, even if it's undefined, // and this wouldn't be reached in case of undefined because of the equality check below if (is_option_element && key === 'value' && value == null) { // The <option> element is a special case because removing the value attribute means // the value is set to the text content of the option element, and setting the value // to null or undefined means the value is set to the string "null" or "undefined". // To align with how we handle this case in non-spread-scenarios, this logic is needed. // There's a super-edge-case bug here that is left in in favor of smaller code size: // Because of the "set missing props to null" logic above, we can't differentiate // between a missing value and an explicitly set value of null or undefined. That means // that once set, the value attribute of an <option> element can't be removed. This is // a very rare edge case, and removing the attribute altogether isn't possible either // for the <option value={undefined}> case, so we're not losing any functionality here. // @ts-ignore element.value = element.__value = ''; current[key] = value; continue; } if (key === 'class') { var is_html = element.namespaceURI === 'http://www.w3.org/1999/xhtml'; set_class(element, is_html, value, css_hash, prev?.[CLASS], next[CLASS]); current[key] = value; current[CLASS] = next[CLASS]; continue; } if (key === 'style') { set_style(element, value, prev?.[STYLE], next[STYLE]); current[key] = value; current[STYLE] = next[STYLE]; continue; } var prev_value = current[key]; // Skip if value is unchanged, unless it's `undefined` and the element still has the attribute if (value === prev_value && !(value === undefined && element.hasAttribute(key))) { continue; } current[key] = value; var prefix = key[0] + key[1]; // this is faster than key.slice(0, 2) if (prefix === '$$') continue; if (prefix === 'on') { /** @type {{ capture?: true }} */ const opts = {}; const event_handle_key = '$$' + key; let event_name = key.slice(2); var delegated = is_delegated(event_name); if (is_capture_event(event_name)) { event_name = event_name.slice(0, -7); opts.capture = true; } if (!delegated && prev_value) { // Listening to same event but different handler -> our handle function below takes care of this // If we were to remove and add listeners in this case, it could happen that the event is "swallowed" // (the browser seems to not know yet that a new one exists now) and doesn't reach the handler // https://github.com/sveltejs/svelte/issues/11903 if (value != null) continue; element.removeEventListener(event_name, current[event_handle_key], opts); current[event_handle_key] = null; } if (value != null) { if (!delegated) { /** * @this {any} * @param {Event} evt */ function handle(evt) { current[key].call(this, evt); } current[event_handle_key] = create_event(event_name, element, handle, opts); } else { // @ts-ignore element[`__${event_name}`] = value; delegate([event_name]); } } else if (delegated) { // @ts-ignore element[`__${event_name}`] = undefined; } } else if (key === 'style') { // avoid using the setter set_attribute(element, key, value); } else if (key === 'autofocus') { autofocus(/** @type {HTMLElement} */ (element), Boolean(value)); } else if (!is_custom_element && (key === '__value' || (key === 'value' && value != null))) { // @ts-ignore We're not running this for custom elements because __value is actually // how Lit stores the current value on the element, and messing with that would break things. element.value = element.__value = value; } else if (key === 'selected' && is_option_element) { set_selected(/** @type {HTMLOptionElement} */ (element), value); } else { var name = key; if (!preserve_attribute_case) { name = normalize_attribute(name); } var is_default = name === 'defaultValue' || name === 'defaultChecked'; if (value == null && !is_custom_element && !is_default) { attributes[key] = null; if (name === 'value' || name === 'checked') { // removing value/checked also removes defaultValue/defaultChecked — preserve let input = /** @type {HTMLInputElement} */ (element); const use_default = prev === undefined; if (name === 'value') { let previous = input.defaultValue; input.removeAttribute(name); input.defaultValue = previous; // @ts-ignore input.value = input.__value = use_default ? previous : null; } else { let previous = input.defaultChecked; input.removeAttribute(name); input.defaultChecked = previous; input.checked = use_default ? previous : false; } } else { element.removeAttribute(key); } } else if ( is_default || (setters.includes(name) && (is_custom_element || typeof value !== 'string')) ) { // @ts-ignore element[name] = value; } else if (typeof value !== 'function') { set_attribute(element, name, value, skip_warning); } } } if (is_hydrating_custom_element) { set_hydrating(true); } return current; } /** * @param {Element & ElementCSSInlineStyle} element * @param {(...expressions: any) => Record<string | symbol, any>} fn * @param {Array<() => any>} sync * @param {Array<() => Promise<any>>} async * @param {string} [css_hash] * @param {boolean} [skip_warning] */ export function attribute_effect( element, fn, sync = [], async = [], css_hash, skip_warning = false ) { flatten(sync, async, (values) => { /** @type {Record<string | symbol, any> | undefined} */ var prev = undefined; /** @type {Record<symbol, Effect>} */ var effects = {}; var is_select = element.nodeName === 'SELECT'; var inited = false; block(() => { var next = fn(...values.map(get)); /** @type {Record<string | symbol, any>} */ var current = set_attributes(element, prev, next, css_hash, skip_warning); if (inited && is_select && 'value' in next) { select_option(/** @type {HTMLSelectElement} */ (element), next.value); } for (let symbol of Object.getOwnPropertySymbols(effects)) { if (!next[symbol]) destroy_effect(effects[symbol]); } for (let symbol of Object.getOwnPropertySymbols(next)) { var n = next[symbol]; if (symbol.description === ATTACHMENT_KEY && (!prev || n !== prev[symbol])) { if (effects[symbol]) destroy_effect(effects[symbol]); effects[symbol] = branch(() => attach(element, () => n)); } current[symbol] = n; } prev = current; }); if (is_select) { var select = /** @type {HTMLSelectElement} */ (element); effect(() => { select_option(select, /** @type {Record<string | symbol, any>} */ (prev).value, true); init_select(select); }); } inited = true; }); } /** * * @param {Element} element */ function get_attributes(element) { return /** @type {Record<string | symbol, unknown>} **/ ( // @ts-expect-error element.__attributes ??= { [IS_CUSTOM_ELEMENT]: element.nodeName.includes('-'), [IS_HTML]: element.namespaceURI === NAMESPACE_HTML } ); } /** @type {Map<string, string[]>} */ var setters_cache = new Map(); /** @param {Element} element */ function get_setters(element) { var setters = setters_cache.get(element.nodeName); if (setters) return setters; setters_cache.set(element.nodeName, (setters = [])); var descriptors; var proto = element; // In the case of custom elements there might be setters on the instance var element_proto = Element.prototype; // Stop at Element, from there on there's only unnecessary setters we're not interested in // Do not use contructor.name here as that's unreliable in some browser environments while (element_proto !== proto) { descriptors = get_descriptors(proto); for (var key in descriptors) { if (descriptors[key].set) { setters.push(key); } } proto = get_prototype_of(proto); } return setters; } /** * @param {any} element * @param {string} attribute * @param {string} value */ function check_src_in_dev_hydration(element, attribute, value) { if (!DEV) return; if (attribute === 'srcset' && srcset_url_equal(element, value)) return; if (src_url_equal(element.getAttribute(attribute) ?? '', value)) return; w.hydration_attribute_changed( attribute, element.outerHTML.replace(element.innerHTML, element.innerHTML && '...'), String(value) ); } /** * @param {string} element_src * @param {string} url * @returns {boolean} */ function src_url_equal(element_src, url) { if (element_src === url) return true; return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href; } /** @param {string} srcset */ function split_srcset(srcset) { return srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean)); } /** * @param {HTMLSourceElement | HTMLImageElement} element * @param {string} srcset * @returns {boolean} */ function srcset_url_equal(element, srcset) { var element_urls = split_srcset(element.srcset); var urls = split_srcset(srcset); return ( urls.length === element_urls.length && urls.every( ([url, width], i) => width === element_urls[i][1] && // We need to test both ways because Vite will create an a full URL with // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the // relative URLs inside srcset are not automatically resolved to absolute URLs by // browsers (in contrast to img.src). This means both SSR and DOM code could // contain relative or absolute URLs. (src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0])) ) ); }
```

# internal/client/dom/elements/bindings/document.js

```js
import { listen } from './shared.js'; /** * @param {(activeElement: Element | null) => void} update * @returns {void} */ export function bind_active_element(update) { listen(document, ['focusin', 'focusout'], (event) => { if (event && event.type === 'focusout' && /** @type {FocusEvent} */ (event).relatedTarget) { // The tests still pass if we remove this, because of JSDOM limitations, but it is necessary // to avoid temporarily resetting to `document.body` return; } update(document.activeElement); }); }
```

# internal/client/dom/elements/bindings/input.js

```js
import { DEV } from 'esm-env'; import { render_effect, teardown } from '../../../reactivity/effects.js'; import { listen_to_event_and_reset_event } from './shared.js'; import * as e from '../../../errors.js'; import { is } from '../../../proxy.js'; import { queue_micro_task } from '../../task.js'; import { hydrating } from '../../hydration.js'; import { untrack } from '../../../runtime.js'; import { is_runes } from '../../../context.js'; /** * @param {HTMLInputElement} input * @param {() => unknown} get * @param {(value: unknown) => void} set * @returns {void} */ export function bind_value(input, get, set = get) { var runes = is_runes(); listen_to_event_and_reset_event(input, 'input', (is_reset) => { if (DEV && input.type === 'checkbox') { // TODO should this happen in prod too? e.bind_invalid_checkbox_value(); } /** @type {any} */ var value = is_reset ? input.defaultValue : input.value; value = is_numberlike_input(input) ? to_number(value) : value; set(value); // In runes mode, respect any validation in accessors (doesn't apply in legacy mode, // because we use mutable state which ensures the render effect always runs) if (runes && value !== (value = get())) { var start = input.selectionStart; var end = input.selectionEnd; // the value is coerced on assignment input.value = value ?? ''; // Restore selection if (end !== null) { input.selectionStart = start; input.selectionEnd = Math.min(end, input.value.length); } } }); if ( // If we are hydrating and the value has since changed, // then use the updated value from the input instead. (hydrating && input.defaultValue !== input.value) || // If defaultValue is set, then value == defaultValue // TODO Svelte 6: remove input.value check and set to empty string? (untrack(get) == null && input.value) ) { set(is_numberlike_input(input) ? to_number(input.value) : input.value); } render_effect(() => { if (DEV && input.type === 'checkbox') { // TODO should this happen in prod too? e.bind_invalid_checkbox_value(); } var value = get(); if (input === document.activeElement) { // Never rewrite the contents of a focused input. We can get here if, for example, // an update is deferred because of async work depending on the input: // // <input bind:value={query}> // <p>{await find(query)}</p> return; } if (is_numberlike_input(input) && value === to_number(input.value)) { // handles 0 vs 00 case (see https://github.com/sveltejs/svelte/issues/9959) return; } if (input.type === 'date' && !value && !input.value) { // Handles the case where a temporarily invalid date is set (while typing, for example with a leading 0 for the day) // and prevents this state from clearing the other parts of the date input (see https://github.com/sveltejs/svelte/issues/7897) return; } // don't set the value of the input if it's the same to allow // minlength to work properly if (value !== input.value) { // @ts-expect-error the value is coerced on assignment input.value = value ?? ''; } }); } /** @type {Set<HTMLInputElement[]>} */ const pending = new Set(); /** * @param {HTMLInputElement[]} inputs * @param {null | [number]} group_index * @param {HTMLInputElement} input * @param {() => unknown} get * @param {(value: unknown) => void} set * @returns {void} */ export function bind_group(inputs, group_index, input, get, set = get) { var is_checkbox = input.getAttribute('type') === 'checkbox'; var binding_group = inputs; // needs to be let or related code isn't treeshaken out if it's always false let hydration_mismatch = false; if (group_index !== null) { for (var index of group_index) { // @ts-expect-error binding_group = binding_group[index] ??= []; } } binding_group.push(input); listen_to_event_and_reset_event( input, 'change', () => { // @ts-ignore var value = input.__value; if (is_checkbox) { value = get_binding_group_value(binding_group, value, input.checked); } set(value); }, // TODO better default value handling () => set(is_checkbox ? [] : null) ); render_effect(() => { var value = get(); // If we are hydrating and the value has since changed, then use the update value // from the input instead. if (hydrating && input.defaultChecked !== input.checked) { hydration_mismatch = true; return; } if (is_checkbox) { value = value || []; // @ts-ignore input.checked = value.includes(input.__value); } else { // @ts-ignore input.checked = is(input.__value, value); } }); teardown(() => { var index = binding_group.indexOf(input); if (index !== -1) { binding_group.splice(index, 1); } }); if (!pending.has(binding_group)) { pending.add(binding_group); queue_micro_task(() => { // necessary to maintain binding group order in all insertion scenarios binding_group.sort((a, b) => (a.compareDocumentPosition(b) === 4 ? -1 : 1)); pending.delete(binding_group); }); } queue_micro_task(() => { if (hydration_mismatch) { var value; if (is_checkbox) { value = get_binding_group_value(binding_group, value, input.checked); } else { var hydration_input = binding_group.find((input) => input.checked); // @ts-ignore value = hydration_input?.__value; } set(value); } }); } /** * @param {HTMLInputElement} input * @param {() => unknown} get * @param {(value: unknown) => void} set * @returns {void} */ export function bind_checked(input, get, set = get) { listen_to_event_and_reset_event(input, 'change', (is_reset) => { var value = is_reset ? input.defaultChecked : input.checked; set(value); }); if ( // If we are hydrating and the value has since changed, // then use the update value from the input instead. (hydrating && input.defaultChecked !== input.checked) || // If defaultChecked is set, then checked == defaultChecked untrack(get) == null ) { set(input.checked); } render_effect(() => { var value = get(); input.checked = Boolean(value); }); } /** * @template V * @param {Array<HTMLInputElement>} group * @param {V} __value * @param {boolean} checked * @returns {V[]} */ function get_binding_group_value(group, __value, checked) { var value = new Set(); for (var i = 0; i < group.length; i += 1) { if (group[i].checked) { // @ts-ignore value.add(group[i].__value); } } if (!checked) { value.delete(__value); } return Array.from(value); } /** * @param {HTMLInputElement} input */ function is_numberlike_input(input) { var type = input.type; return type === 'number' || type === 'range'; } /** * @param {string} value */ function to_number(value) { return value === '' ? null : +value; } /** * @param {HTMLInputElement} input * @param {() => FileList | null} get * @param {(value: FileList | null) => void} set */ export function bind_files(input, get, set = get) { listen_to_event_and_reset_event(input, 'change', () => { set(input.files); }); if ( // If we are hydrating and the value has since changed, // then use the updated value from the input instead. hydrating && input.files ) { set(input.files); } render_effect(() => { input.files = get(); }); }
```

# internal/client/dom/elements/bindings/media.js

```js
import { render_effect, effect, teardown } from '../../../reactivity/effects.js'; import { listen } from './shared.js'; /** @param {TimeRanges} ranges */ function time_ranges_to_array(ranges) { var array = []; for (var i = 0; i < ranges.length; i += 1) { array.push({ start: ranges.start(i), end: ranges.end(i) }); } return array; } /** * @param {HTMLVideoElement | HTMLAudioElement} media * @param {() => number | undefined} get * @param {(value: number) => void} set * @returns {void} */ export function bind_current_time(media, get, set = get) { /** @type {number} */ var raf_id; /** @type {number} */ var value; // Ideally, listening to timeupdate would be enough, but it fires too infrequently for the currentTime // binding, which is why we use a raf loop, too. We additionally still listen to timeupdate because // the user could be scrubbing through the video using the native controls when the media is paused. var callback = () => { cancelAnimationFrame(raf_id); if (!media.paused) { raf_id = requestAnimationFrame(callback); } var next_value = media.currentTime; if (value !== next_value) { set((value = next_value)); } }; raf_id = requestAnimationFrame(callback); media.addEventListener('timeupdate', callback); render_effect(() => { var next_value = Number(get()); if (value !== next_value && !isNaN(/** @type {any} */ (next_value))) { media.currentTime = value = next_value; } }); teardown(() => { cancelAnimationFrame(raf_id); media.removeEventListener('timeupdate', callback); }); } /** * @param {HTMLVideoElement | HTMLAudioElement} media * @param {(array: Array<{ start: number; end: number }>) => void} set */ export function bind_buffered(media, set) { /** @type {{ start: number; end: number; }[]} */ var current; // `buffered` can update without emitting any event, so we check it on various events. // By specs, `buffered` always returns a new object, so we have to compare deeply. listen(media, ['loadedmetadata', 'progress', 'timeupdate', 'seeking'], () => { var ranges = media.buffered; if ( !current || current.length !== ranges.length || current.some((range, i) => ranges.start(i) !== range.start || ranges.end(i) !== range.end) ) { current = time_ranges_to_array(ranges); set(current); } }); } /** * @param {HTMLVideoElement | HTMLAudioElement} media * @param {(array: Array<{ start: number; end: number }>) => void} set */ export function bind_seekable(media, set) { listen(media, ['loadedmetadata'], () => set(time_ranges_to_array(media.seekable))); } /** * @param {HTMLVideoElement | HTMLAudioElement} media * @param {(array: Array<{ start: number; end: number }>) => void} set */ export function bind_played(media, set) { listen(media, ['timeupdate'], () => set(time_ranges_to_array(media.played))); } /** * @param {HTMLVideoElement | HTMLAudioElement} media * @param {(seeking: boolean) => void} set */ export function bind_seeking(media, set) { listen(media, ['seeking', 'seeked'], () => set(media.seeking)); } /** * @param {HTMLVideoElement | HTMLAudioElement} media * @param {(seeking: boolean) => void} set */ export function bind_ended(media, set) { listen(media, ['timeupdate', 'ended'], () => set(media.ended)); } /** * @param {HTMLVideoElement | HTMLAudioElement} media * @param {(ready_state: number) => void} set */ export function bind_ready_state(media, set) { listen( media, ['loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'emptied'], () => set(media.readyState) ); } /** * @param {HTMLVideoElement | HTMLAudioElement} media * @param {() => number | undefined} get * @param {(playback_rate: number) => void} set */ export function bind_playback_rate(media, get, set = get) { // Needs to happen after element is inserted into the dom (which is guaranteed by using effect), // else playback will be set back to 1 by the browser effect(() => { var value = Number(get()); if (value !== media.playbackRate && !isNaN(value)) { media.playbackRate = value; } }); // Start listening to ratechange events after the element is inserted into the dom, // else playback will be set to 1 by the browser effect(() => { listen(media, ['ratechange'], () => { set(media.playbackRate); }); }); } /** * @param {HTMLVideoElement | HTMLAudioElement} media * @param {() => boolean | undefined} get * @param {(paused: boolean) => void} set */ export function bind_paused(media, get, set = get) { var paused = get(); var update = () => { if (paused !== media.paused) { set((paused = media.paused)); } }; // If someone switches the src while media is playing, the player will pause. // Listen to the canplay event to get notified of this situation. listen(media, ['play', 'pause', 'canplay'], update, paused == null); // Needs to be an effect to ensure media element is mounted: else, if paused is `false` (i.e. should play right away) // a "The play() request was interrupted by a new load request" error would be thrown because the resource isn't loaded yet. effect(() => { if ((paused = !!get()) !== media.paused) { if (paused) { media.pause(); } else { media.play().catch(() => { set((paused = true)); }); } } }); } /** * @param {HTMLVideoElement | HTMLAudioElement} media * @param {() => number | undefined} get * @param {(volume: number) => void} set */ export function bind_volume(media, get, set = get) { var callback = () => { set(media.volume); }; if (get() == null) { callback(); } listen(media, ['volumechange'], callback, false); render_effect(() => { var value = Number(get()); if (value !== media.volume && !isNaN(value)) { media.volume = value; } }); } /** * @param {HTMLVideoElement | HTMLAudioElement} media * @param {() => boolean | undefined} get * @param {(muted: boolean) => void} set */ export function bind_muted(media, get, set = get) { var callback = () => { set(media.muted); }; if (get() == null) { callback(); } listen(media, ['volumechange'], callback, false); render_effect(() => { var value = !!get(); if (media.muted !== value) media.muted = value; }); }
```

# internal/client/dom/elements/bindings/navigator.js

```js
import { listen } from './shared.js'; /** * @param {(online: boolean) => void} update * @returns {void} */ export function bind_online(update) { listen(window, ['online', 'offline'], () => { update(navigator.onLine); }); }
```

# internal/client/dom/elements/bindings/props.js

```js
import { teardown } from '../../../reactivity/effects.js'; import { get_descriptor } from '../../../../shared/utils.js'; /** * Makes an `export`ed (non-prop) variable available on the `$$props` object * so that consumers can do `bind:x` on the component. * @template V * @param {Record<string, unknown>} props * @param {string} prop * @param {V} value * @returns {void} */ export function bind_prop(props, prop, value) { var desc = get_descriptor(props, prop); if (desc && desc.set) { props[prop] = value; teardown(() => { props[prop] = null; }); } }
```

# internal/client/dom/elements/bindings/select.js

```js
import { effect, teardown } from '../../../reactivity/effects.js'; import { listen_to_event_and_reset_event } from './shared.js'; import { is } from '../../../proxy.js'; import { is_array } from '../../../../shared/utils.js'; import * as w from '../../../warnings.js'; /** * Selects the correct option(s) (depending on whether this is a multiple select) * @template V * @param {HTMLSelectElement} select * @param {V} value * @param {boolean} mounting */ export function select_option(select, value, mounting = false) { if (select.multiple) { // If value is null or undefined, keep the selection as is if (value == undefined) { return; } // If not an array, warn and keep the selection as is if (!is_array(value)) { return w.select_multiple_invalid_value(); } // Otherwise, update the selection for (var option of select.options) { option.selected = value.includes(get_option_value(option)); } return; } for (option of select.options) { var option_value = get_option_value(option); if (is(option_value, value)) { option.selected = true; return; } } if (!mounting || value !== undefined) { select.selectedIndex = -1; // no option should be selected } } /** * Selects the correct option(s) if `value` is given, * and then sets up a mutation observer to sync the * current selection to the dom when it changes. Such * changes could for example occur when options are * inside an `#each` block. * @param {HTMLSelectElement} select */ export function init_select(select) { var observer = new MutationObserver(() => { // @ts-ignore select_option(select, select.__value); // Deliberately don't update the potential binding value, // the model should be preserved unless explicitly changed }); observer.observe(select, { // Listen to option element changes childList: true, subtree: true, // because of <optgroup> // Listen to option element value attribute changes // (doesn't get notified of select value changes, // because that property is not reflected as an attribute) attributes: true, attributeFilter: ['value'] }); teardown(() => { observer.disconnect(); }); } /** * @param {HTMLSelectElement} select * @param {() => unknown} get * @param {(value: unknown) => void} set * @returns {void} */ export function bind_select_value(select, get, set = get) { var mounting = true; listen_to_event_and_reset_event(select, 'change', (is_reset) => { var query = is_reset ? '[selected]' : ':checked'; /** @type {unknown} */ var value; if (select.multiple) { value = [].map.call(select.querySelectorAll(query), get_option_value); } else { /** @type {HTMLOptionElement | null} */ var selected_option = select.querySelector(query) ?? // will fall back to first non-disabled option if no option is selected select.querySelector('option:not([disabled])'); value = selected_option && get_option_value(selected_option); } set(value); }); // Needs to be an effect, not a render_effect, so that in case of each loops the logic runs after the each block has updated effect(() => { var value = get(); select_option(select, value, mounting); // Mounting and value undefined -> take selection from dom if (mounting && value === undefined) { /** @type {HTMLOptionElement | null} */ var selected_option = select.querySelector(':checked'); if (selected_option !== null) { value = get_option_value(selected_option); set(value); } } // @ts-ignore select.__value = value; mounting = false; }); init_select(select); } /** @param {HTMLOptionElement} option */ function get_option_value(option) { // __value only exists if the <option> has a value attribute if ('__value' in option) { return option.__value; } else { return option.value; } }
```

# internal/client/dom/elements/bindings/shared.js

```js
import { teardown } from '../../../reactivity/effects.js'; import { active_effect, active_reaction, set_active_effect, set_active_reaction } from '../../../runtime.js'; import { add_form_reset_listener } from '../misc.js'; /** * Fires the handler once immediately (unless corresponding arg is set to `false`), * then listens to the given events until the render effect context is destroyed * @param {EventTarget} target * @param {Array<string>} events * @param {(event?: Event) => void} handler * @param {any} call_handler_immediately */ export function listen(target, events, handler, call_handler_immediately = true) { if (call_handler_immediately) { handler(); } for (var name of events) { target.addEventListener(name, handler); } teardown(() => { for (var name of events) { target.removeEventListener(name, handler); } }); } /** * @template T * @param {() => T} fn */ export function without_reactive_context(fn) { var previous_reaction = active_reaction; var previous_effect = active_effect; set_active_reaction(null); set_active_effect(null); try { return fn(); } finally { set_active_reaction(previous_reaction); set_active_effect(previous_effect); } } /** * Listen to the given event, and then instantiate a global form reset listener if not already done, * to notify all bindings when the form is reset * @param {HTMLElement} element * @param {string} event * @param {(is_reset?: true) => void} handler * @param {(is_reset?: true) => void} [on_reset] */ export function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) { element.addEventListener(event, () => without_reactive_context(handler)); // @ts-expect-error const prev = element.__on_r; if (prev) { // special case for checkbox that can have multiple binds (group & checked) // @ts-expect-error element.__on_r = () => { prev(); on_reset(true); }; } else { // @ts-expect-error element.__on_r = () => on_reset(true); } add_form_reset_listener(); }
```

# internal/client/dom/elements/bindings/size.js

```js
import { effect, teardown } from '../../../reactivity/effects.js'; import { untrack } from '../../../runtime.js'; /** * Resize observer singleton. * One listener per element only! * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ */ class ResizeObserverSingleton { /** */ #listeners = new WeakMap(); /** @type {ResizeObserver | undefined} */ #observer; /** @type {ResizeObserverOptions} */ #options; /** @static */ static entries = new WeakMap(); /** @param {ResizeObserverOptions} options */ constructor(options) { this.#options = options; } /** * @param {Element} element * @param {(entry: ResizeObserverEntry) => any} listener */ observe(element, listener) { var listeners = this.#listeners.get(element) || new Set(); listeners.add(listener); this.#listeners.set(element, listeners); this.#getObserver().observe(element, this.#options); return () => { var listeners = this.#listeners.get(element); listeners.delete(listener); if (listeners.size === 0) { this.#listeners.delete(element); /** @type {ResizeObserver} */ (this.#observer).unobserve(element); } }; } #getObserver() { return ( this.#observer ?? (this.#observer = new ResizeObserver( /** @param {any} entries */ (entries) => { for (var entry of entries) { ResizeObserverSingleton.entries.set(entry.target, entry); for (var listener of this.#listeners.get(entry.target) || []) { listener(entry); } } } )) ); } } var resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'content-box' }); var resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'border-box' }); var resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'device-pixel-content-box' }); /** * @param {Element} element * @param {'contentRect' | 'contentBoxSize' | 'borderBoxSize' | 'devicePixelContentBoxSize'} type * @param {(entry: keyof ResizeObserverEntry) => void} set */ export function bind_resize_observer(element, type, set) { var observer = type === 'contentRect' || type === 'contentBoxSize' ? resize_observer_content_box : type === 'borderBoxSize' ? resize_observer_border_box : resize_observer_device_pixel_content_box; var unsub = observer.observe(element, /** @param {any} entry */ (entry) => set(entry[type])); teardown(unsub); } /** * @param {HTMLElement} element * @param {'clientWidth' | 'clientHeight' | 'offsetWidth' | 'offsetHeight'} type * @param {(size: number) => void} set */ export function bind_element_size(element, type, set) { var unsub = resize_observer_border_box.observe(element, () => set(element[type])); effect(() => { // The update could contain reads which should be ignored untrack(() => set(element[type])); return unsub; }); }
```

# internal/client/dom/elements/bindings/this.js

```js
import { STATE_SYMBOL } from '#client/constants'; import { effect, render_effect } from '../../../reactivity/effects.js'; import { untrack } from '../../../runtime.js'; import { queue_micro_task } from '../../task.js'; /** * @param {any} bound_value * @param {Element} element_or_component * @returns {boolean} */ function is_bound_this(bound_value, element_or_component) { return ( bound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component ); } /** * @param {any} element_or_component * @param {(value: unknown, ...parts: unknown[]) => void} update * @param {(...parts: unknown[]) => unknown} get_value * @param {() => unknown[]} [get_parts] Set if the this binding is used inside an each block, * returns all the parts of the each block context that are used in the expression * @returns {void} */ export function bind_this(element_or_component = {}, update, get_value, get_parts) { effect(() => { /** @type {unknown[]} */ var old_parts; /** @type {unknown[]} */ var parts; render_effect(() => { old_parts = parts; // We only track changes to the parts, not the value itself to avoid unnecessary reruns. parts = get_parts?.() || []; untrack(() => { if (element_or_component !== get_value(...parts)) { update(element_or_component, ...parts); // If this is an effect rerun (cause: each block context changes), then nullfiy the binding at // the previous position if it isn't already taken over by a different effect. if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) { update(null, ...old_parts); } } }); }); return () => { // We cannot use effects in the teardown phase, we we use a microtask instead. queue_micro_task(() => { if (parts && is_bound_this(get_value(...parts), element_or_component)) { update(null, ...parts); } }); }; }); return element_or_component; }
```

# internal/client/dom/elements/bindings/universal.js

```js
import { render_effect, teardown } from '../../../reactivity/effects.js'; import { listen } from './shared.js'; /** * @param {'innerHTML' | 'textContent' | 'innerText'} property * @param {HTMLElement} element * @param {() => unknown} get * @param {(value: unknown) => void} set * @returns {void} */ export function bind_content_editable(property, element, get, set = get) { element.addEventListener('input', () => { // @ts-ignore set(element[property]); }); render_effect(() => { var value = get(); if (element[property] !== value) { if (value == null) { // @ts-ignore var non_null_value = element[property]; set(non_null_value); } else { // @ts-ignore element[property] = value + ''; } } }); } /** * @param {string} property * @param {string} event_name * @param {Element} element * @param {(value: unknown) => void} set * @param {() => unknown} [get] * @returns {void} */ export function bind_property(property, event_name, element, set, get) { var handler = () => { // @ts-ignore set(element[property]); }; element.addEventListener(event_name, handler); if (get) { render_effect(() => { // @ts-ignore element[property] = get(); }); } else { handler(); } // @ts-ignore if (element === document.body || element === window || element === document) { teardown(() => { element.removeEventListener(event_name, handler); }); } } /** * @param {HTMLElement} element * @param {(value: unknown) => void} set * @returns {void} */ export function bind_focused(element, set) { listen(element, ['focus', 'blur'], () => { set(element === document.activeElement); }); }
```

# internal/client/dom/elements/bindings/window.js

```js
import { effect, render_effect, teardown } from '../../../reactivity/effects.js'; import { listen, without_reactive_context } from './shared.js'; /** * @param {'x' | 'y'} type * @param {() => number} get * @param {(value: number) => void} set * @returns {void} */ export function bind_window_scroll(type, get, set = get) { var is_scrolling_x = type === 'x'; var target_handler = () => without_reactive_context(() => { scrolling = true; clearTimeout(timeout); timeout = setTimeout(clear, 100); // TODO use scrollend event if supported (or when supported everywhere?) set(window[is_scrolling_x ? 'scrollX' : 'scrollY']); }); addEventListener('scroll', target_handler, { passive: true }); var scrolling = false; /** @type {ReturnType<typeof setTimeout>} */ var timeout; var clear = () => { scrolling = false; }; var first = true; render_effect(() => { var latest_value = get(); // Don't scroll to the initial value for accessibility reasons if (first) { first = false; } else if (!scrolling && latest_value != null) { scrolling = true; clearTimeout(timeout); if (is_scrolling_x) { scrollTo(latest_value, window.scrollY); } else { scrollTo(window.scrollX, latest_value); } timeout = setTimeout(clear, 100); } }); // Browsers don't fire the scroll event for the initial scroll position when scroll style isn't set to smooth effect(target_handler); teardown(() => { removeEventListener('scroll', target_handler); }); } /** * @param {'innerWidth' | 'innerHeight' | 'outerWidth' | 'outerHeight'} type * @param {(size: number) => void} set */ export function bind_window_size(type, set) { listen(window, ['resize'], () => without_reactive_context(() => set(window[type]))); }
```

# internal/client/dom/elements/class.js

```js
import { to_class } from '../../../shared/attributes.js'; import { hydrating } from '../hydration.js'; /** * @param {Element} dom * @param {boolean | number} is_html * @param {string | null} value * @param {string} [hash] * @param {Record<string, any>} [prev_classes] * @param {Record<string, any>} [next_classes] * @returns {Record<string, boolean> | undefined} */ export function set_class(dom, is_html, value, hash, prev_classes, next_classes) { // @ts-expect-error need to add __className to patched prototype var prev = dom.__className; if ( hydrating || prev !== value || prev === undefined // for edge case of `class={undefined}` ) { var next_class_name = to_class(value, hash, next_classes); if (!hydrating || next_class_name !== dom.getAttribute('class')) { // Removing the attribute when the value is only an empty string causes // performance issues vs simply making the className an empty string. So // we should only remove the class if the value is nullish // and there no hash/directives : if (next_class_name == null) { dom.removeAttribute('class'); } else if (is_html) { dom.className = next_class_name; } else { dom.setAttribute('class', next_class_name); } } // @ts-expect-error need to add __className to patched prototype dom.__className = value; } else if (next_classes && prev_classes !== next_classes) { for (var key in next_classes) { var is_present = !!next_classes[key]; if (prev_classes == null || is_present !== !!prev_classes[key]) { dom.classList.toggle(key, is_present); } } } return next_classes; }
```

# internal/client/dom/elements/custom-element.js

```js
import { createClassComponent } from '../../../../legacy/legacy-client.js'; import { effect_root, render_effect } from '../../reactivity/effects.js'; import { append } from '../template.js'; import { define_property, get_descriptor, object_keys } from '../../../shared/utils.js'; /** * @typedef {Object} CustomElementPropDefinition * @property {string} [attribute] * @property {boolean} [reflect] * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type] */ /** @type {any} */ let SvelteElement; if (typeof HTMLElement === 'function') { SvelteElement = class extends HTMLElement { /** The Svelte component constructor */ $$ctor; /** Slots */ $$s; /** @type {any} The Svelte component instance */ $$c; /** Whether or not the custom element is connected */ $$cn = false; /** @type {Record<string, any>} Component props data */ $$d = {}; /** `true` if currently in the process of reflecting component props back to attributes */ $$r = false; /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */ $$p_d = {}; /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */ $$l = {}; /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */ $$l_u = new Map(); /** @type {any} The managed render effect for reflecting attributes */ $$me; /** * @param {*} $$componentCtor * @param {*} $$slots * @param {*} use_shadow_dom */ constructor($$componentCtor, $$slots, use_shadow_dom) { super(); this.$$ctor = $$componentCtor; this.$$s = $$slots; if (use_shadow_dom) { this.attachShadow({ mode: 'open' }); } } /** * @param {string} type * @param {EventListenerOrEventListenerObject} listener * @param {boolean | AddEventListenerOptions} [options] */ addEventListener(type, listener, options) { // We can't determine upfront if the event is a custom event or not, so we have to // listen to both. If someone uses a custom event with the same name as a regular // browser event, this fires twice - we can't avoid that. this.$$l[type] = this.$$l[type] || []; this.$$l[type].push(listener); if (this.$$c) { const unsub = this.$$c.$on(type, listener); this.$$l_u.set(listener, unsub); } super.addEventListener(type, listener, options); } /** * @param {string} type * @param {EventListenerOrEventListenerObject} listener * @param {boolean | AddEventListenerOptions} [options] */ removeEventListener(type, listener, options) { super.removeEventListener(type, listener, options); if (this.$$c) { const unsub = this.$$l_u.get(listener); if (unsub) { unsub(); this.$$l_u.delete(listener); } } } async connectedCallback() { this.$$cn = true; if (!this.$$c) { // We wait one tick to let possible child slot elements be created/mounted await Promise.resolve(); if (!this.$$cn || this.$$c) { return; } /** @param {string} name */ function create_slot(name) { /** * @param {Element} anchor */ return (anchor) => { const slot = document.createElement('slot'); if (name !== 'default') slot.name = name; append(anchor, slot); }; } /** @type {Record<string, any>} */ const $$slots = {}; const existing_slots = get_custom_elements_slots(this); for (const name of this.$$s) { if (name in existing_slots) { if (name === 'default' && !this.$$d.children) { this.$$d.children = create_slot(name); $$slots.default = true; } else { $$slots[name] = create_slot(name); } } } for (const attribute of this.attributes) { // this.$$data takes precedence over this.attributes const name = this.$$g_p(attribute.name); if (!(name in this.$$d)) { this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp'); } } // Port over props that were set programmatically before ce was initialized for (const key in this.$$p_d) { // @ts-expect-error if (!(key in this.$$d) && this[key] !== undefined) { // @ts-expect-error this.$$d[key] = this[key]; // don't transform, these were set through JavaScript // @ts-expect-error delete this[key]; // remove the property that shadows the getter/setter } } this.$$c = createClassComponent({ component: this.$$ctor, target: this.shadowRoot || this, props: { ...this.$$d, $$slots, $$host: this } }); // Reflect component props as attributes this.$$me = effect_root(() => { render_effect(() => { this.$$r = true; for (const key of object_keys(this.$$c)) { if (!this.$$p_d[key]?.reflect) continue; this.$$d[key] = this.$$c[key]; const attribute_value = get_custom_element_value( key, this.$$d[key], this.$$p_d, 'toAttribute' ); if (attribute_value == null) { this.removeAttribute(this.$$p_d[key].attribute || key); } else { this.setAttribute(this.$$p_d[key].attribute || key, attribute_value); } } this.$$r = false; }); }); for (const type in this.$$l) { for (const listener of this.$$l[type]) { const unsub = this.$$c.$on(type, listener); this.$$l_u.set(listener, unsub); } } this.$$l = {}; } } // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte // and setting attributes through setAttribute etc, this is helpful /** * @param {string} attr * @param {string} _oldValue * @param {string} newValue */ attributeChangedCallback(attr, _oldValue, newValue) { if (this.$$r) return; attr = this.$$g_p(attr); this.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp'); this.$$c?.$set({ [attr]: this.$$d[attr] }); } disconnectedCallback() { this.$$cn = false; // In a microtask, because this could be a move within the DOM Promise.resolve().then(() => { if (!this.$$cn && this.$$c) { this.$$c.$destroy(); this.$$me(); this.$$c = undefined; } }); } /** * @param {string} attribute_name */ $$g_p(attribute_name) { return ( object_keys(this.$$p_d).find( (key) => this.$$p_d[key].attribute === attribute_name || (!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name) ) || attribute_name ); } }; } /** * @param {string} prop * @param {any} value * @param {Record<string, CustomElementPropDefinition>} props_definition * @param {'toAttribute' | 'toProp'} [transform] */ function get_custom_element_value(prop, value, props_definition, transform) { const type = props_definition[prop]?.type; value = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value; if (!transform || !props_definition[prop]) { return value; } else if (transform === 'toAttribute') { switch (type) { case 'Object': case 'Array': return value == null ? null : JSON.stringify(value); case 'Boolean': return value ? '' : null; case 'Number': return value == null ? null : value; default: return value; } } else { switch (type) { case 'Object': case 'Array': return value && JSON.parse(value); case 'Boolean': return value; // conversion already handled above case 'Number': return value != null ? +value : value; default: return value; } } } /** * @param {HTMLElement} element */ function get_custom_elements_slots(element) { /** @type {Record<string, true>} */ const result = {}; element.childNodes.forEach((node) => { result[/** @type {Element} node */ (node).slot || 'default'] = true; }); return result; } /** * @internal * * Turn a Svelte component into a custom element. * @param {any} Component A Svelte component function * @param {Record<string, CustomElementPropDefinition>} props_definition The props to observe * @param {string[]} slots The slots to create * @param {string[]} exports Explicitly exported values, other than props * @param {boolean} use_shadow_dom Whether to use shadow DOM * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend] */ export function create_custom_element( Component, props_definition, slots, exports, use_shadow_dom, extend ) { let Class = class extends SvelteElement { constructor() { super(Component, slots, use_shadow_dom); this.$$p_d = props_definition; } static get observedAttributes() { return object_keys(props_definition).map((key) => (props_definition[key].attribute || key).toLowerCase() ); } }; object_keys(props_definition).forEach((prop) => { define_property(Class.prototype, prop, { get() { return this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop]; }, set(value) { value = get_custom_element_value(prop, value, props_definition); this.$$d[prop] = value; var component = this.$$c; if (component) { // // If the instance has an accessor, use that instead var setter = get_descriptor(component, prop)?.get; if (setter) { component[prop] = value; } else { component.$set({ [prop]: value }); } } } }); }); exports.forEach((property) => { define_property(Class.prototype, property, { get() { return this.$$c?.[property]; } }); }); if (extend) { // @ts-expect-error - assigning here is fine Class = extend(Class); } Component.element = /** @type {any} */ Class; return Class; }
```

# internal/client/dom/elements/events.js

```js
import { teardown } from '../../reactivity/effects.js'; import { define_property, is_array } from '../../../shared/utils.js'; import { hydrating } from '../hydration.js'; import { queue_micro_task } from '../task.js'; import { FILENAME } from '../../../../constants.js'; import * as w from '../../warnings.js'; import { active_effect, active_reaction, set_active_effect, set_active_reaction } from '../../runtime.js'; import { without_reactive_context } from './bindings/shared.js'; /** @type {Set<string>} */ export const all_registered_events = new Set(); /** @type {Set<(events: Array<string>) => void>} */ export const root_event_handles = new Set(); /** * SSR adds onload and onerror attributes to catch those events before the hydration. * This function detects those cases, removes the attributes and replays the events. * @param {HTMLElement} dom */ export function replay_events(dom) { if (!hydrating) return; dom.removeAttribute('onload'); dom.removeAttribute('onerror'); // @ts-expect-error const event = dom.__e; if (event !== undefined) { // @ts-expect-error dom.__e = undefined; queueMicrotask(() => { if (dom.isConnected) { dom.dispatchEvent(event); } }); } } /** * @param {string} event_name * @param {EventTarget} dom * @param {EventListener} [handler] * @param {AddEventListenerOptions} [options] */ export function create_event(event_name, dom, handler, options = {}) { /** * @this {EventTarget} */ function target_handler(/** @type {Event} */ event) { if (!options.capture) { // Only call in the bubble phase, else delegated events would be called before the capturing events handle_event_propagation.call(dom, event); } if (!event.cancelBubble) { return without_reactive_context(() => { return handler?.call(this, event); }); } } // Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned // with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we // defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes // this bug. The same applies to wheel events and touch events. if ( event_name.startsWith('pointer') || event_name.startsWith('touch') || event_name === 'wheel' ) { queue_micro_task(() => { dom.addEventListener(event_name, target_handler, options); }); } else { dom.addEventListener(event_name, target_handler, options); } return target_handler; } /** * Attaches an event handler to an element and returns a function that removes the handler. Using this * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively * (with attributes like `onclick`), which use event delegation for performance reasons * * @param {EventTarget} element * @param {string} type * @param {EventListener} handler * @param {AddEventListenerOptions} [options] */ export function on(element, type, handler, options = {}) { var target_handler = create_event(type, element, handler, options); return () => { element.removeEventListener(type, target_handler, options); }; } /** * @param {string} event_name * @param {Element} dom * @param {EventListener} [handler] * @param {boolean} [capture] * @param {boolean} [passive] * @returns {void} */ export function event(event_name, dom, handler, capture, passive) { var options = { capture, passive }; var target_handler = create_event(event_name, dom, handler, options); if ( dom === document.body || // @ts-ignore dom === window || // @ts-ignore dom === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed dom instanceof HTMLMediaElement ) { teardown(() => { dom.removeEventListener(event_name, target_handler, options); }); } } /** * @param {Array<string>} events * @returns {void} */ export function delegate(events) { for (var i = 0; i < events.length; i++) { all_registered_events.add(events[i]); } for (var fn of root_event_handles) { fn(events); } } /** * @this {EventTarget} * @param {Event} event * @returns {void} */ export function handle_event_propagation(event) { var handler_element = this; var owner_document = /** @type {Node} */ (handler_element).ownerDocument; var event_name = event.type; var path = event.composedPath?.() || []; var current_target = /** @type {null | Element} */ (path[0] || event.target); // composedPath contains list of nodes the event has propagated through. // We check __root to skip all nodes below it in case this is a // parent of the __root node, which indicates that there's nested // mounted apps. In this case we don't want to trigger events multiple times. var path_idx = 0; // @ts-expect-error is added below var handled_at = event.__root; if (handled_at) { var at_idx = path.indexOf(handled_at); if ( at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */ (window)) ) { // This is the fallback document listener or a window listener, but the event was already handled // -> ignore, but set handle_at to document/window so that we're resetting the event // chain in case someone manually dispatches the same event object again. // @ts-expect-error event.__root = handler_element; return; } // We're deliberately not skipping if the index is higher, because // someone could create an event programmatically and emit it multiple times, // in which case we want to handle the whole propagation chain properly each time. // (this will only be a false negative if the event is dispatched multiple times and // the fallback document listener isn't reached in between, but that's super rare) var handler_idx = path.indexOf(handler_element); if (handler_idx === -1) { // handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object) // so guard against that, too, and assume that everything was handled at this point. return; } if (at_idx <= handler_idx) { path_idx = at_idx; } } current_target = /** @type {Element} */ (path[path_idx] || event.target); // there can only be one delegated event per element, and we either already handled the current target, // or this is the very first target in the chain which has a non-delegated listener, in which case it's safe // to handle a possible delegated event on it later (through the root delegation listener for example). if (current_target === handler_element) return; // Proxy currentTarget to correct target define_property(event, 'currentTarget', { configurable: true, get() { return current_target || owner_document; } }); // This started because of Chromium issue https://chromestatus.com/feature/5128696823545856, // where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic // to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection, // it's probably best that all event handled by Svelte have this behaviour, as we don't really want // an event handler to run in the context of another reaction or effect. var previous_reaction = active_reaction; var previous_effect = active_effect; set_active_reaction(null); set_active_effect(null); try { /** * @type {unknown} */ var throw_error; /** * @type {unknown[]} */ var other_errors = []; while (current_target !== null) { /** @type {null | Element} */ var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */ (current_target).host || null; try { // @ts-expect-error var delegated = current_target['__' + event_name]; if ( delegated != null && (!(/** @type {any} */ (current_target).disabled) || // DOM could've been updated already by the time this is reached, so we check this as well // -> the target could not have been disabled because it emits the event in the first place event.target === current_target) ) { if (is_array(delegated)) { var [fn, ...data] = delegated; fn.apply(current_target, [event, ...data]); } else { delegated.call(current_target, event); } } } catch (error) { if (throw_error) { other_errors.push(error); } else { throw_error = error; } } if (event.cancelBubble || parent_element === handler_element || parent_element === null) { break; } current_target = parent_element; } if (throw_error) { for (let error of other_errors) { // Throw the rest of the errors, one-by-one on a microtask queueMicrotask(() => { throw error; }); } throw throw_error; } } finally { // @ts-expect-error is used above event.__root = handler_element; // @ts-ignore remove proxy on currentTarget delete event.currentTarget; set_active_reaction(previous_reaction); set_active_effect(previous_effect); } } /** * In dev, warn if an event handler is not a function, as it means the * user probably called the handler or forgot to add a `() =>` * @param {() => (event: Event, ...args: any) => void} thunk * @param {EventTarget} element * @param {[Event, ...any]} args * @param {any} component * @param {[number, number]} [loc] * @param {boolean} [remove_parens] */ export function apply( thunk, element, args, component, loc, has_side_effects = false, remove_parens = false ) { let handler; let error; try { handler = thunk(); } catch (e) { error = e; } if (typeof handler !== 'function' && (has_side_effects || handler != null || error)) { const filename = component?.[FILENAME]; const location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`; const phase = args[0]?.eventPhase < Event.BUBBLING_PHASE ? 'capture' : ''; const event_name = args[0]?.type + phase; const description = `\`${event_name}\` handler${location}`; const suggestion = remove_parens ? 'remove the trailing `()`' : 'add a leading `() =>`'; w.event_handler_invalid(description, suggestion); if (error) { throw error; } } handler?.apply(element, args); }
```

# internal/client/dom/elements/misc.js

```js
import { hydrating } from '../hydration.js'; import { clear_text_content, get_first_child } from '../operations.js'; import { queue_micro_task } from '../task.js'; /** * @param {HTMLElement} dom * @param {boolean} value * @returns {void} */ export function autofocus(dom, value) { if (value) { const body = document.body; dom.autofocus = true; queue_micro_task(() => { if (document.activeElement === body) { dom.focus(); } }); } } /** * The child of a textarea actually corresponds to the defaultValue property, so we need * to remove it upon hydration to avoid a bug when someone resets the form value. * @param {HTMLTextAreaElement} dom * @returns {void} */ export function remove_textarea_child(dom) { if (hydrating && get_first_child(dom) !== null) { clear_text_content(dom); } } let listening_to_form_reset = false; export function add_form_reset_listener() { if (!listening_to_form_reset) { listening_to_form_reset = true; document.addEventListener( 'reset', (evt) => { // Needs to happen one tick later or else the dom properties of the form // elements have not updated to their reset values yet Promise.resolve().then(() => { if (!evt.defaultPrevented) { for (const e of /**@type {HTMLFormElement} */ (evt.target).elements) { // @ts-expect-error e.__on_r?.(); } } }); }, // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation) { capture: true } ); } }
```

# internal/client/dom/elements/style.js

```js
import { to_style } from '../../../shared/attributes.js'; import { hydrating } from '../hydration.js'; /** * @param {Element & ElementCSSInlineStyle} dom * @param {Record<string, any>} prev * @param {Record<string, any>} next * @param {string} [priority] */ function update_styles(dom, prev = {}, next, priority) { for (var key in next) { var value = next[key]; if (prev[key] !== value) { if (next[key] == null) { dom.style.removeProperty(key); } else { dom.style.setProperty(key, value, priority); } } } } /** * @param {Element & ElementCSSInlineStyle} dom * @param {string | null} value * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [prev_styles] * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [next_styles] */ export function set_style(dom, value, prev_styles, next_styles) { // @ts-expect-error var prev = dom.__style; if (hydrating || prev !== value) { var next_style_attr = to_style(value, next_styles); if (!hydrating || next_style_attr !== dom.getAttribute('style')) { if (next_style_attr == null) { dom.removeAttribute('style'); } else { dom.style.cssText = next_style_attr; } } // @ts-expect-error dom.__style = value; } else if (next_styles) { if (Array.isArray(next_styles)) { update_styles(dom, prev_styles?.[0], next_styles[0]); update_styles(dom, prev_styles?.[1], next_styles[1], 'important'); } else { update_styles(dom, prev_styles, next_styles); } } return next_styles; }
```

# internal/client/dom/elements/transitions.js

```js
/** @import { AnimateFn, Animation, AnimationConfig, EachItem, Effect, TransitionFn, TransitionManager } from '#client' */ import { noop, is_function } from '../../../shared/utils.js'; import { effect } from '../../reactivity/effects.js'; import { active_effect, active_reaction, set_active_effect, set_active_reaction, untrack } from '../../runtime.js'; import { loop } from '../../loop.js'; import { should_intro } from '../../render.js'; import { current_each_item } from '../blocks/each.js'; import { TRANSITION_GLOBAL, TRANSITION_IN, TRANSITION_OUT } from '../../../../constants.js'; import { BLOCK_EFFECT, EFFECT_RAN, EFFECT_TRANSPARENT } from '#client/constants'; import { queue_micro_task } from '../task.js'; import { without_reactive_context } from './bindings/shared.js'; /** * @param {Element} element * @param {'introstart' | 'introend' | 'outrostart' | 'outroend'} type * @returns {void} */ function dispatch_event(element, type) { without_reactive_context(() => { element.dispatchEvent(new CustomEvent(type)); }); } /** * Converts a property to the camel-case format expected by Element.animate(), KeyframeEffect(), and KeyframeEffect.setKeyframes(). * @param {string} style * @returns {string} */ function css_property_to_camelcase(style) { // in compliance with spec if (style === 'float') return 'cssFloat'; if (style === 'offset') return 'cssOffset'; // do not rename custom @properties if (style.startsWith('--')) return style; const parts = style.split('-'); if (parts.length === 1) return parts[0]; return ( parts[0] + parts .slice(1) .map(/** @param {any} word */ (word) => word[0].toUpperCase() + word.slice(1)) .join('') ); } /** * @param {string} css * @returns {Keyframe} */ function css_to_keyframe(css) { /** @type {Keyframe} */ const keyframe = {}; const parts = css.split(';'); for (const part of parts) { const [property, value] = part.split(':'); if (!property || value === undefined) break; const formatted_property = css_property_to_camelcase(property.trim()); keyframe[formatted_property] = value.trim(); } return keyframe; } /** @param {number} t */ const linear = (t) => t; /** * Called inside keyed `{#each ...}` blocks (as `$.animation(...)`). This creates an animation manager * and attaches it to the block, so that moves can be animated following reconciliation. * @template P * @param {Element} element * @param {() => AnimateFn<P | undefined>} get_fn * @param {(() => P) | null} get_params */ export function animation(element, get_fn, get_params) { var item = /** @type {EachItem} */ (current_each_item); /** @type {DOMRect} */ var from; /** @type {DOMRect} */ var to; /** @type {Animation | undefined} */ var animation; /** @type {null | { position: string, width: string, height: string, transform: string }} */ var original_styles = null; item.a ??= { element, measure() { from = this.element.getBoundingClientRect(); }, apply() { animation?.abort(); to = this.element.getBoundingClientRect(); if ( from.left !== to.left || from.right !== to.right || from.top !== to.top || from.bottom !== to.bottom ) { const options = get_fn()(this.element, { from, to }, get_params?.()); animation = animate(this.element, options, undefined, 1, () => { animation?.abort(); animation = undefined; }); } }, fix() { // If an animation is already running, transforming the element is likely to fail, // because the styles applied by the animation take precedence. In the case of crossfade, // that means the `translate(...)` of the crossfade transition overrules the `translate(...)` // we would apply below, leading to the element jumping somewhere to the top left. if (element.getAnimations().length) return; // It's important to destructure these to get fixed values - the object itself has getters, // and changing the style to 'absolute' can for example influence the width. var { position, width, height } = getComputedStyle(element); if (position !== 'absolute' && position !== 'fixed') { var style = /** @type {HTMLElement | SVGElement} */ (element).style; original_styles = { position: style.position, width: style.width, height: style.height, transform: style.transform }; style.position = 'absolute'; style.width = width; style.height = height; var to = element.getBoundingClientRect(); if (from.left !== to.left || from.top !== to.top) { var transform = `translate(${from.left - to.left}px, ${from.top - to.top}px)`; style.transform = style.transform ? `${style.transform} ${transform}` : transform; } } }, unfix() { if (original_styles) { var style = /** @type {HTMLElement | SVGElement} */ (element).style; style.position = original_styles.position; style.width = original_styles.width; style.height = original_styles.height; style.transform = original_styles.transform; } } }; // in the case of a `<svelte:element>`, it's possible for `$.animation(...)` to be called // when an animation manager already exists, if the tag changes. in that case, we need to // swap out the element rather than creating a new manager, in case it happened at the same // moment as a reconciliation item.a.element = element; } /** * Called inside block effects as `$.transition(...)`. This creates a transition manager and * attaches it to the current effect — later, inside `pause_effect` and `resume_effect`, we * use this to create `intro` and `outro` transitions. * @template P * @param {number} flags * @param {HTMLElement} element * @param {() => TransitionFn<P | undefined>} get_fn * @param {(() => P) | null} get_params * @returns {void} */ export function transition(flags, element, get_fn, get_params) { var is_intro = (flags & TRANSITION_IN) !== 0; var is_outro = (flags & TRANSITION_OUT) !== 0; var is_both = is_intro && is_outro; var is_global = (flags & TRANSITION_GLOBAL) !== 0; /** @type {'in' | 'out' | 'both'} */ var direction = is_both ? 'both' : is_intro ? 'in' : 'out'; /** @type {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig) | undefined} */ var current_options; var inert = element.inert; /** * The default overflow style, stashed so we can revert changes during the transition * that are necessary to work around a Safari <18 bug * TODO 6.0 remove this, if older versions of Safari have died out enough */ var overflow = element.style.overflow; /** @type {Animation | undefined} */ var intro; /** @type {Animation | undefined} */ var outro; function get_options() { return without_reactive_context(() => { // If a transition is still ongoing, we use the existing options rather than generating // new ones. This ensures that reversible transitions reverse smoothly, rather than // jumping to a new spot because (for example) a different `duration` was used return (current_options ??= get_fn()(element, get_params?.() ?? /** @type {P} */ ({}), { direction })); }); } /** @type {TransitionManager} */ var transition = { is_global, in() { element.inert = inert; if (!is_intro) { outro?.abort(); outro?.reset?.(); return; } if (!is_outro) { // if we intro then outro then intro again, we want to abort the first intro, // if it's not a bidirectional transition intro?.abort(); } dispatch_event(element, 'introstart'); intro = animate(element, get_options(), outro, 1, () => { dispatch_event(element, 'introend'); // Ensure we cancel the animation to prevent leaking intro?.abort(); intro = current_options = undefined; element.style.overflow = overflow; }); }, out(fn) { if (!is_outro) { fn?.(); current_options = undefined; return; } element.inert = true; dispatch_event(element, 'outrostart'); outro = animate(element, get_options(), intro, 0, () => { dispatch_event(element, 'outroend'); fn?.(); }); }, stop: () => { intro?.abort(); outro?.abort(); } }; var e = /** @type {Effect} */ (active_effect); (e.transitions ??= []).push(transition); // if this is a local transition, we only want to run it if the parent (branch) effect's // parent (block) effect is where the state change happened. we can determine that by // looking at whether the block effect is currently initializing if (is_intro && should_intro) { var run = is_global; if (!run) { var block = /** @type {Effect | null} */ (e.parent); // skip over transparent blocks (e.g. snippets, else-if blocks) while (block && (block.f & EFFECT_TRANSPARENT) !== 0) { while ((block = block.parent)) { if ((block.f & BLOCK_EFFECT) !== 0) break; } } run = !block || (block.f & EFFECT_RAN) !== 0; } if (run) { effect(() => { untrack(() => transition.in()); }); } } } /** * Animates an element, according to the provided configuration * @param {Element} element * @param {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig)} options * @param {Animation | undefined} counterpart The corresponding intro/outro to this outro/intro * @param {number} t2 The target `t` value — `1` for intro, `0` for outro * @param {(() => void)} on_finish Called after successfully completing the animation * @returns {Animation} */ function animate(element, options, counterpart, t2, on_finish) { var is_intro = t2 === 1; if (is_function(options)) { // In the case of a deferred transition (such as `crossfade`), `option` will be // a function rather than an `AnimationConfig`. We need to call this function // once the DOM has been updated... /** @type {Animation} */ var a; var aborted = false; queue_micro_task(() => { if (aborted) return; var o = options({ direction: is_intro ? 'in' : 'out' }); a = animate(element, o, counterpart, t2, on_finish); }); // ...but we want to do so without using `async`/`await` everywhere, so // we return a facade that allows everything to remain synchronous return { abort: () => { aborted = true; a?.abort(); }, deactivate: () => a.deactivate(), reset: () => a.reset(), t: () => a.t() }; } counterpart?.deactivate(); if (!options?.duration) { on_finish(); return { abort: noop, deactivate: noop, reset: noop, t: () => t2 }; } const { delay = 0, css, tick, easing = linear } = options; var keyframes = []; if (is_intro && counterpart === undefined) { if (tick) { tick(0, 1); // TODO put in nested effect, to avoid interleaved reads/writes? } if (css) { var styles = css_to_keyframe(css(0, 1)); keyframes.push(styles, styles); } } var get_t = () => 1 - t2; // create a dummy animation that lasts as long as the delay (but with whatever devtools // multiplier is in effect). in the common case that it is `0`, we keep it anyway so that // the CSS keyframes aren't created until the DOM is updated // // fill forwards to prevent the element from rendering without styles applied // see https://github.com/sveltejs/svelte/issues/14732 var animation = element.animate(keyframes, { duration: delay, fill: 'forwards' }); animation.onfinish = () => { // remove dummy animation from the stack to prevent conflict with main animation animation.cancel(); // for bidirectional transitions, we start from the current position, // rather than doing a full intro/outro var t1 = counterpart?.t() ?? 1 - t2; counterpart?.abort(); var delta = t2 - t1; var duration = /** @type {number} */ (options.duration) * Math.abs(delta); var keyframes = []; if (duration > 0) { /** * Whether or not the CSS includes `overflow: hidden`, in which case we need to * add it as an inline style to work around a Safari <18 bug * TODO 6.0 remove this, if possible */ var needs_overflow_hidden = false; if (css) { var n = Math.ceil(duration / (1000 / 60)); // `n` must be an integer, or we risk missing the `t2` value for (var i = 0; i <= n; i += 1) { var t = t1 + delta * easing(i / n); var styles = css_to_keyframe(css(t, 1 - t)); keyframes.push(styles); needs_overflow_hidden ||= styles.overflow === 'hidden'; } } if (needs_overflow_hidden) { /** @type {HTMLElement} */ (element).style.overflow = 'hidden'; } get_t = () => { var time = /** @type {number} */ ( /** @type {globalThis.Animation} */ (animation).currentTime ); return t1 + delta * easing(time / duration); }; if (tick) { loop(() => { if (animation.playState !== 'running') return false; var t = get_t(); tick(t, 1 - t); return true; }); } } animation = element.animate(keyframes, { duration, fill: 'forwards' }); animation.onfinish = () => { get_t = () => t2; tick?.(t2, 1 - t2); on_finish(); }; }; return { abort: () => { if (animation) { animation.cancel(); // This prevents memory leaks in Chromium animation.effect = null; // This prevents onfinish to be launched after cancel(), // which can happen in some rare cases // see https://github.com/sveltejs/svelte/issues/13681 animation.onfinish = noop; } }, deactivate: () => { on_finish = noop; }, reset: () => { if (t2 === 0) { tick?.(1, 0); } }, t: () => get_t() }; }
```

# internal/client/dom/hydration.js

```js
/** @import { TemplateNode } from '#client' */ import { COMMENT_NODE } from '#client/constants'; import { HYDRATION_END, HYDRATION_ERROR, HYDRATION_START, HYDRATION_START_ELSE } from '../../../constants.js'; import * as w from '../warnings.js'; import { get_next_sibling } from './operations.js'; /** * Use this variable to guard everything related to hydration code so it can be treeshaken out * if the user doesn't use the `hydrate` method and these code paths are therefore not needed. */ export let hydrating = false; /** @param {boolean} value */ export function set_hydrating(value) { hydrating = value; } /** * The node that is currently being hydrated. This starts out as the first node inside the opening * <!--[--> comment, and updates each time a component calls `$.child(...)` or `$.sibling(...)`. * When entering a block (e.g. `{#if ...}`), `hydrate_node` is the block opening comment; by the * time we leave the block it is the closing comment, which serves as the block's anchor. * @type {TemplateNode} */ export let hydrate_node; /** @param {TemplateNode} node */ export function set_hydrate_node(node) { if (node === null) { w.hydration_mismatch(); throw HYDRATION_ERROR; } return (hydrate_node = node); } export function hydrate_next() { return set_hydrate_node(/** @type {TemplateNode} */ (get_next_sibling(hydrate_node))); } /** @param {TemplateNode} node */ export function reset(node) { if (!hydrating) return; // If the node has remaining siblings, something has gone wrong if (get_next_sibling(hydrate_node) !== null) { w.hydration_mismatch(); throw HYDRATION_ERROR; } hydrate_node = node; } /** * @param {HTMLTemplateElement} template */ export function hydrate_template(template) { if (hydrating) { // @ts-expect-error TemplateNode doesn't include DocumentFragment, but it's actually fine hydrate_node = template.content; } } export function next(count = 1) { if (hydrating) { var i = count; var node = hydrate_node; while (i--) { node = /** @type {TemplateNode} */ (get_next_sibling(node)); } hydrate_node = node; } } /** * Removes all nodes starting at `hydrate_node` up until the next hydration end comment */ export function remove_nodes() { var depth = 0; var node = hydrate_node; while (true) { if (node.nodeType === COMMENT_NODE) { var data = /** @type {Comment} */ (node).data; if (data === HYDRATION_END) { if (depth === 0) return node; depth -= 1; } else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) { depth += 1; } } var next = /** @type {TemplateNode} */ (get_next_sibling(node)); node.remove(); node = next; } } /** * * @param {TemplateNode} node */ export function read_hydration_instruction(node) { if (!node || node.nodeType !== COMMENT_NODE) { w.hydration_mismatch(); throw HYDRATION_ERROR; } return /** @type {Comment} */ (node).data; }
```

# internal/client/dom/legacy/event-modifiers.js

```js
import { noop } from '../../../shared/utils.js'; import { user_pre_effect } from '../../reactivity/effects.js'; import { on } from '../elements/events.js'; /** * Substitute for the `trusted` event modifier * @deprecated * @param {(event: Event, ...args: Array<unknown>) => void} fn * @returns {(event: Event, ...args: unknown[]) => void} */ export function trusted(fn) { return function (...args) { var event = /** @type {Event} */ (args[0]); if (event.isTrusted) { // @ts-ignore fn?.apply(this, args); } }; } /** * Substitute for the `self` event modifier * @deprecated * @param {(event: Event, ...args: Array<unknown>) => void} fn * @returns {(event: Event, ...args: unknown[]) => void} */ export function self(fn) { return function (...args) { var event = /** @type {Event} */ (args[0]); // @ts-ignore if (event.target === this) { // @ts-ignore fn?.apply(this, args); } }; } /** * Substitute for the `stopPropagation` event modifier * @deprecated * @param {(event: Event, ...args: Array<unknown>) => void} fn * @returns {(event: Event, ...args: unknown[]) => void} */ export function stopPropagation(fn) { return function (...args) { var event = /** @type {Event} */ (args[0]); event.stopPropagation(); // @ts-ignore return fn?.apply(this, args); }; } /** * Substitute for the `once` event modifier * @deprecated * @param {(event: Event, ...args: Array<unknown>) => void} fn * @returns {(event: Event, ...args: unknown[]) => void} */ export function once(fn) { var ran = false; return function (...args) { if (ran) return; ran = true; // @ts-ignore return fn?.apply(this, args); }; } /** * Substitute for the `stopImmediatePropagation` event modifier * @deprecated * @param {(event: Event, ...args: Array<unknown>) => void} fn * @returns {(event: Event, ...args: unknown[]) => void} */ export function stopImmediatePropagation(fn) { return function (...args) { var event = /** @type {Event} */ (args[0]); event.stopImmediatePropagation(); // @ts-ignore return fn?.apply(this, args); }; } /** * Substitute for the `preventDefault` event modifier * @deprecated * @param {(event: Event, ...args: Array<unknown>) => void} fn * @returns {(event: Event, ...args: unknown[]) => void} */ export function preventDefault(fn) { return function (...args) { var event = /** @type {Event} */ (args[0]); event.preventDefault(); // @ts-ignore return fn?.apply(this, args); }; } /** * Substitute for the `passive` event modifier, implemented as an action * @deprecated * @param {HTMLElement} node * @param {[event: string, handler: () => EventListener]} options */ export function passive(node, [event, handler]) { user_pre_effect(() => { return on(node, event, handler() ?? noop, { passive: true }); }); } /** * Substitute for the `nonpassive` event modifier, implemented as an action * @deprecated * @param {HTMLElement} node * @param {[event: string, handler: () => EventListener]} options */ export function nonpassive(node, [event, handler]) { user_pre_effect(() => { return on(node, event, handler() ?? noop, { passive: false }); }); }
```

# internal/client/dom/legacy/lifecycle.js

```js
/** @import { ComponentContextLegacy } from '#client' */ import { run, run_all } from '../../../shared/utils.js'; import { component_context } from '../../context.js'; import { derived } from '../../reactivity/deriveds.js'; import { user_pre_effect, user_effect } from '../../reactivity/effects.js'; import { deep_read_state, get, untrack } from '../../runtime.js'; /** * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects * @param {boolean} [immutable] */ export function init(immutable = false) { const context = /** @type {ComponentContextLegacy} */ (component_context); const callbacks = context.l.u; if (!callbacks) return; let props = () => deep_read_state(context.s); if (immutable) { let version = 0; let prev = /** @type {Record<string, any>} */ ({}); // In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes const d = derived(() => { let changed = false; const props = context.s; for (const key in props) { if (props[key] !== prev[key]) { prev[key] = props[key]; changed = true; } } if (changed) version++; return version; }); props = () => get(d); } // beforeUpdate if (callbacks.b.length) { user_pre_effect(() => { observe_all(context, props); run_all(callbacks.b); }); } // onMount (must run before afterUpdate) user_effect(() => { const fns = untrack(() => callbacks.m.map(run)); return () => { for (const fn of fns) { if (typeof fn === 'function') { fn(); } } }; }); // afterUpdate if (callbacks.a.length) { user_effect(() => { observe_all(context, props); run_all(callbacks.a); }); } } /** * Invoke the getter of all signals associated with a component * so they can be registered to the effect this function is called in. * @param {ComponentContextLegacy} context * @param {(() => void)} props */ function observe_all(context, props) { if (context.l.s) { for (const signal of context.l.s) get(signal); } props(); }
```

# internal/client/dom/legacy/misc.js

```js
import { set, source } from '../../reactivity/sources.js'; import { get } from '../../runtime.js'; import { is_array } from '../../../shared/utils.js'; /** * Under some circumstances, imports may be reactive in legacy mode. In that case, * they should be using `reactive_import` as part of the transformation * @param {() => any} fn */ export function reactive_import(fn) { var s = source(0); return function () { if (arguments.length === 1) { set(s, get(s) + 1); return arguments[0]; } else { get(s); return fn(); } }; } /** * @this {any} * @param {Record<string, unknown>} $$props * @param {Event} event * @returns {void} */ export function bubble_event($$props, event) { var events = /** @type {Record<string, Function[] | Function>} */ ($$props.$$events)?.[ event.type ]; var callbacks = is_array(events) ? events.slice() : events == null ? [] : [events]; for (var fn of callbacks) { // Preserve "this" context fn.call(this, event); } } /** * Used to simulate `$on` on a component instance when `compatibility.componentApi === 4` * @param {Record<string, any>} $$props * @param {string} event_name * @param {Function} event_callback */ export function add_legacy_event_listener($$props, event_name, event_callback) { $$props.$$events ||= {}; $$props.$$events[event_name] ||= []; $$props.$$events[event_name].push(event_callback); } /** * Used to simulate `$set` on a component instance when `compatibility.componentApi === 4`. * Needs component accessors so that it can call the setter of the prop. Therefore doesn't * work for updating props in `$$props` or `$$restProps`. * @this {Record<string, any>} * @param {Record<string, any>} $$new_props */ export function update_legacy_props($$new_props) { for (var key in $$new_props) { if (key in this) { this[key] = $$new_props[key]; } } }
```

# internal/client/dom/operations.js

```js
/** @import { Effect, TemplateNode } from '#client' */ import { hydrate_node, hydrating, set_hydrate_node } from './hydration.js'; import { DEV } from 'esm-env'; import { init_array_prototype_warnings } from '../dev/equality.js'; import { get_descriptor, is_extensible } from '../../shared/utils.js'; import { active_effect } from '../runtime.js'; import { async_mode_flag } from '../../flags/index.js'; import { TEXT_NODE, EFFECT_RAN } from '#client/constants'; // export these for reference in the compiled code, making global name deduplication unnecessary /** @type {Window} */ export var $window; /** @type {Document} */ export var $document; /** @type {boolean} */ export var is_firefox; /** @type {() => Node | null} */ var first_child_getter; /** @type {() => Node | null} */ var next_sibling_getter; /** * Initialize these lazily to avoid issues when using the runtime in a server context * where these globals are not available while avoiding a separate server entry point */ export function init_operations() { if ($window !== undefined) { return; } $window = window; $document = document; is_firefox = /Firefox/.test(navigator.userAgent); var element_prototype = Element.prototype; var node_prototype = Node.prototype; var text_prototype = Text.prototype; // @ts-ignore first_child_getter = get_descriptor(node_prototype, 'firstChild').get; // @ts-ignore next_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get; if (is_extensible(element_prototype)) { // the following assignments improve perf of lookups on DOM nodes // @ts-expect-error element_prototype.__click = undefined; // @ts-expect-error element_prototype.__className = undefined; // @ts-expect-error element_prototype.__attributes = null; // @ts-expect-error element_prototype.__style = undefined; // @ts-expect-error element_prototype.__e = undefined; } if (is_extensible(text_prototype)) { // @ts-expect-error text_prototype.__t = undefined; } if (DEV) { // @ts-expect-error element_prototype.__svelte_meta = null; init_array_prototype_warnings(); } } /** * @param {string} value * @returns {Text} */ export function create_text(value = '') { return document.createTextNode(value); } /** * @template {Node} N * @param {N} node * @returns {Node | null} */ /*@__NO_SIDE_EFFECTS__*/ export function get_first_child(node) { return first_child_getter.call(node); } /** * @template {Node} N * @param {N} node * @returns {Node | null} */ /*@__NO_SIDE_EFFECTS__*/ export function get_next_sibling(node) { return next_sibling_getter.call(node); } /** * Don't mark this as side-effect-free, hydration needs to walk all nodes * @template {Node} N * @param {N} node * @param {boolean} is_text * @returns {Node | null} */ export function child(node, is_text) { if (!hydrating) { return get_first_child(node); } var child = /** @type {TemplateNode} */ (get_first_child(hydrate_node)); // Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty if (child === null) { child = hydrate_node.appendChild(create_text()); } else if (is_text && child.nodeType !== TEXT_NODE) { var text = create_text(); child?.before(text); set_hydrate_node(text); return text; } set_hydrate_node(child); return child; } /** * Don't mark this as side-effect-free, hydration needs to walk all nodes * @param {DocumentFragment | TemplateNode[]} fragment * @param {boolean} is_text * @returns {Node | null} */ export function first_child(fragment, is_text) { if (!hydrating) { // when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`) var first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment))); // TODO prevent user comments with the empty string when preserveComments is true if (first instanceof Comment && first.data === '') return get_next_sibling(first); return first; } // if an {expression} is empty during SSR, there might be no // text node to hydrate — we must therefore create one if (is_text && hydrate_node?.nodeType !== TEXT_NODE) { var text = create_text(); hydrate_node?.before(text); set_hydrate_node(text); return text; } return hydrate_node; } /** * Don't mark this as side-effect-free, hydration needs to walk all nodes * @param {TemplateNode} node * @param {number} count * @param {boolean} is_text * @returns {Node | null} */ export function sibling(node, count = 1, is_text = false) { let next_sibling = hydrating ? hydrate_node : node; var last_sibling; while (count--) { last_sibling = next_sibling; next_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling)); } if (!hydrating) { return next_sibling; } // if a sibling {expression} is empty during SSR, there might be no // text node to hydrate — we must therefore create one if (is_text && next_sibling?.nodeType !== TEXT_NODE) { var text = create_text(); // If the next sibling is `null` and we're handling text then it's because // the SSR content was empty for the text, so we need to generate a new text // node and insert it after the last sibling if (next_sibling === null) { last_sibling?.after(text); } else { next_sibling.before(text); } set_hydrate_node(text); return text; } set_hydrate_node(next_sibling); return /** @type {TemplateNode} */ (next_sibling); } /** * @template {Node} N * @param {N} node * @returns {void} */ export function clear_text_content(node) { node.textContent = ''; } /** * Returns `true` if we're updating the current block, for example `condition` in * an `{#if condition}` block just changed. In this case, the branch should be * appended (or removed) at the same time as other updates within the * current `<svelte:boundary>` */ export function should_defer_append() { if (!async_mode_flag) return false; var flags = /** @type {Effect} */ (active_effect).f; return (flags & EFFECT_RAN) !== 0; } /** * * @param {string} tag * @param {string} [namespace] * @param {string} [is] * @returns */ export function create_element(tag, namespace, is) { let options = is ? { is } : undefined; if (namespace) { return document.createElementNS(namespace, tag, options); } return document.createElement(tag, options); } export function create_fragment() { return document.createDocumentFragment(); } /** * @param {string} data * @returns */ export function create_comment(data = '') { return document.createComment(data); } /** * @param {Element} element * @param {string} key * @param {string} value * @returns */ export function set_attribute(element, key, value = '') { if (key.startsWith('xlink:')) { element.setAttributeNS('http://www.w3.org/1999/xlink', key, value); return; } return element.setAttribute(key, value); }
```

# internal/client/dom/reconciler.js

```js
/** @param {string} html */ export function create_fragment_from_html(html) { var elem = document.createElement('template'); elem.innerHTML = html.replaceAll('<!>', '<!---->'); // XHTML compliance return elem.content; }
```

# internal/client/dom/task.js

```js
import { run_all } from '../../shared/utils.js'; // Fallback for when requestIdleCallback is not available const request_idle_callback = typeof requestIdleCallback === 'undefined' ? (/** @type {() => void} */ cb) => setTimeout(cb, 1) : requestIdleCallback; /** @type {Array<() => void>} */ let micro_tasks = []; /** @type {Array<() => void>} */ let idle_tasks = []; function run_micro_tasks() { var tasks = micro_tasks; micro_tasks = []; run_all(tasks); } function run_idle_tasks() { var tasks = idle_tasks; idle_tasks = []; run_all(tasks); } /** * @param {() => void} fn */ export function queue_micro_task(fn) { if (micro_tasks.length === 0) { queueMicrotask(run_micro_tasks); } micro_tasks.push(fn); } /** * @param {() => void} fn */ export function queue_idle_task(fn) { if (idle_tasks.length === 0) { request_idle_callback(run_idle_tasks); } idle_tasks.push(fn); } /** * Synchronously run any queued tasks. */ export function flush_tasks() { if (micro_tasks.length > 0) { run_micro_tasks(); } if (idle_tasks.length > 0) { run_idle_tasks(); } }
```

# internal/client/dom/template.js

```js
/** @import { Effect, TemplateNode } from '#client' */ /** @import { TemplateStructure } from './types' */ import { hydrate_next, hydrate_node, hydrating, set_hydrate_node } from './hydration.js'; import { create_text, get_first_child, is_firefox, create_element, create_fragment, create_comment, set_attribute } from './operations.js'; import { create_fragment_from_html } from './reconciler.js'; import { active_effect } from '../runtime.js'; import { NAMESPACE_MATHML, NAMESPACE_SVG, TEMPLATE_FRAGMENT, TEMPLATE_USE_IMPORT_NODE, TEMPLATE_USE_MATHML, TEMPLATE_USE_SVG } from '../../../constants.js'; import { COMMENT_NODE, DOCUMENT_FRAGMENT_NODE, TEXT_NODE } from '#client/constants'; /** * @param {TemplateNode} start * @param {TemplateNode | null} end */ export function assign_nodes(start, end) { var effect = /** @type {Effect} */ (active_effect); if (effect.nodes_start === null) { effect.nodes_start = start; effect.nodes_end = end; } } /** * @param {string} content * @param {number} flags * @returns {() => Node | Node[]} */ /*#__NO_SIDE_EFFECTS__*/ export function from_html(content, flags) { var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0; var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0; /** @type {Node} */ var node; /** * Whether or not the first item is a text/element node. If not, we need to * create an additional comment node to act as `effect.nodes.start` */ var has_start = !content.startsWith('<!>'); return () => { if (hydrating) { assign_nodes(hydrate_node, null); return hydrate_node; } if (node === undefined) { node = create_fragment_from_html(has_start ? content : '<!>' + content); if (!is_fragment) node = /** @type {Node} */ (get_first_child(node)); } var clone = /** @type {TemplateNode} */ ( use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true) ); if (is_fragment) { var start = /** @type {TemplateNode} */ (get_first_child(clone)); var end = /** @type {TemplateNode} */ (clone.lastChild); assign_nodes(start, end); } else { assign_nodes(clone, clone); } return clone; }; } /** * @param {string} content * @param {number} flags * @param {'svg' | 'math'} ns * @returns {() => Node | Node[]} */ /*#__NO_SIDE_EFFECTS__*/ function from_namespace(content, flags, ns = 'svg') { /** * Whether or not the first item is a text/element node. If not, we need to * create an additional comment node to act as `effect.nodes.start` */ var has_start = !content.startsWith('<!>'); var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0; var wrapped = `<${ns}>${has_start ? content : '<!>' + content}</${ns}>`; /** @type {Element | DocumentFragment} */ var node; return () => { if (hydrating) { assign_nodes(hydrate_node, null); return hydrate_node; } if (!node) { var fragment = /** @type {DocumentFragment} */ (create_fragment_from_html(wrapped)); var root = /** @type {Element} */ (get_first_child(fragment)); if (is_fragment) { node = document.createDocumentFragment(); while (get_first_child(root)) { node.appendChild(/** @type {Node} */ (get_first_child(root))); } } else { node = /** @type {Element} */ (get_first_child(root)); } } var clone = /** @type {TemplateNode} */ (node.cloneNode(true)); if (is_fragment) { var start = /** @type {TemplateNode} */ (get_first_child(clone)); var end = /** @type {TemplateNode} */ (clone.lastChild); assign_nodes(start, end); } else { assign_nodes(clone, clone); } return clone; }; } /** * @param {string} content * @param {number} flags */ /*#__NO_SIDE_EFFECTS__*/ export function from_svg(content, flags) { return from_namespace(content, flags, 'svg'); } /** * @param {string} content * @param {number} flags */ /*#__NO_SIDE_EFFECTS__*/ export function from_mathml(content, flags) { return from_namespace(content, flags, 'math'); } /** * @param {TemplateStructure[]} structure * @param {NAMESPACE_SVG | NAMESPACE_MATHML | undefined} [ns] */ function fragment_from_tree(structure, ns) { var fragment = create_fragment(); for (var item of structure) { if (typeof item === 'string') { fragment.append(create_text(item)); continue; } // if `preserveComments === true`, comments are represented as `['// <data>']` if (item === undefined || item[0][0] === '/') { fragment.append(create_comment(item ? item[0].slice(3) : '')); continue; } const [name, attributes, ...children] = item; const namespace = name === 'svg' ? NAMESPACE_SVG : name === 'math' ? NAMESPACE_MATHML : ns; var element = create_element(name, namespace, attributes?.is); for (var key in attributes) { set_attribute(element, key, attributes[key]); } if (children.length > 0) { var target = element.tagName === 'TEMPLATE' ? /** @type {HTMLTemplateElement} */ (element).content : element; target.append( fragment_from_tree(children, element.tagName === 'foreignObject' ? undefined : namespace) ); } fragment.append(element); } return fragment; } /** * @param {TemplateStructure[]} structure * @param {number} flags * @returns {() => Node | Node[]} */ /*#__NO_SIDE_EFFECTS__*/ export function from_tree(structure, flags) { var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0; var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0; /** @type {Node} */ var node; return () => { if (hydrating) { assign_nodes(hydrate_node, null); return hydrate_node; } if (node === undefined) { const ns = (flags & TEMPLATE_USE_SVG) !== 0 ? NAMESPACE_SVG : (flags & TEMPLATE_USE_MATHML) !== 0 ? NAMESPACE_MATHML : undefined; node = fragment_from_tree(structure, ns); if (!is_fragment) node = /** @type {Node} */ (get_first_child(node)); } var clone = /** @type {TemplateNode} */ ( use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true) ); if (is_fragment) { var start = /** @type {TemplateNode} */ (get_first_child(clone)); var end = /** @type {TemplateNode} */ (clone.lastChild); assign_nodes(start, end); } else { assign_nodes(clone, clone); } return clone; }; } /** * @param {() => Element | DocumentFragment} fn */ export function with_script(fn) { return () => run_scripts(fn()); } /** * Creating a document fragment from HTML that contains script tags will not execute * the scripts. We need to replace the script tags with new ones so that they are executed. * @param {Element | DocumentFragment} node * @returns {Node | Node[]} */ function run_scripts(node) { // scripts were SSR'd, in which case they will run if (hydrating) return node; const is_fragment = node.nodeType === DOCUMENT_FRAGMENT_NODE; const scripts = /** @type {HTMLElement} */ (node).tagName === 'SCRIPT' ? [/** @type {HTMLScriptElement} */ (node)] : node.querySelectorAll('script'); const effect = /** @type {Effect} */ (active_effect); for (const script of scripts) { const clone = document.createElement('script'); for (var attribute of script.attributes) { clone.setAttribute(attribute.name, attribute.value); } clone.textContent = script.textContent; // The script has changed - if it's at the edges, the effect now points at dead nodes if (is_fragment ? node.firstChild === script : node === script) { effect.nodes_start = clone; } if (is_fragment ? node.lastChild === script : node === script) { effect.nodes_end = clone; } script.replaceWith(clone); } return node; } /** * Don't mark this as side-effect-free, hydration needs to walk all nodes * @param {any} value */ export function text(value = '') { if (!hydrating) { var t = create_text(value + ''); assign_nodes(t, t); return t; } var node = hydrate_node; if (node.nodeType !== TEXT_NODE) { // if an {expression} is empty during SSR, we need to insert an empty text node node.before((node = create_text())); set_hydrate_node(node); } assign_nodes(node, node); return node; } export function comment() { // we're not delegating to `template` here for performance reasons if (hydrating) { assign_nodes(hydrate_node, null); return hydrate_node; } var frag = document.createDocumentFragment(); var start = document.createComment(''); var anchor = create_text(); frag.append(start, anchor); assign_nodes(start, anchor); return frag; } /** * Assign the created (or in hydration mode, traversed) dom elements to the current block * and insert the elements into the dom (in client mode). * @param {Text | Comment | Element} anchor * @param {DocumentFragment | Element} dom */ export function append(anchor, dom) { if (hydrating) { /** @type {Effect} */ (active_effect).nodes_end = hydrate_node; hydrate_next(); return; } if (anchor === null) { // edge case — void `<svelte:element>` with content return; } anchor.before(/** @type {Node} */ (dom)); } /** * Create (or hydrate) an unique UID for the component instance. */ export function props_id() { if ( hydrating && hydrate_node && hydrate_node.nodeType === COMMENT_NODE && hydrate_node.textContent?.startsWith(`#`) ) { const id = hydrate_node.textContent.substring(1); hydrate_next(); return id; } // @ts-expect-error This way we ensure the id is unique even across Svelte runtimes (window.__svelte ??= {}).uid ??= 1; // @ts-expect-error return `c${window.__svelte.uid++}`; }
```

# internal/client/dom/types.d.ts

```ts
export type TemplateStructure = | string | undefined | [string, Record<string, string> | undefined, ...TemplateStructure[]];
```

# internal/client/error-handling.js

```js
/** @import { Derived, Effect } from '#client' */ /** @import { Boundary } from './dom/blocks/boundary.js' */ import { DEV } from 'esm-env'; import { FILENAME } from '../../constants.js'; import { is_firefox } from './dom/operations.js'; import { ERROR_VALUE, BOUNDARY_EFFECT, EFFECT_RAN } from './constants.js'; import { define_property, get_descriptor } from '../shared/utils.js'; import { active_effect, active_reaction } from './runtime.js'; const adjustments = new WeakMap(); /** * @param {unknown} error */ export function handle_error(error) { var effect = active_effect; // for unowned deriveds, don't throw until we read the value if (effect === null) { /** @type {Derived} */ (active_reaction).f |= ERROR_VALUE; return error; } if (DEV && error instanceof Error && !adjustments.has(error)) { adjustments.set(error, get_adjustments(error, effect)); } if ((effect.f & EFFECT_RAN) === 0) { // if the error occurred while creating this subtree, we let it // bubble up until it hits a boundary that can handle it if ((effect.f & BOUNDARY_EFFECT) === 0) { if (!effect.parent && error instanceof Error) { apply_adjustments(error); } throw error; } /** @type {Boundary} */ (effect.b).error(error); } else { // otherwise we bubble up the effect tree ourselves invoke_error_boundary(error, effect); } } /** * @param {unknown} error * @param {Effect | null} effect */ export function invoke_error_boundary(error, effect) { while (effect !== null) { if ((effect.f & BOUNDARY_EFFECT) !== 0) { try { /** @type {Boundary} */ (effect.b).error(error); return; } catch {} } effect = effect.parent; } if (error instanceof Error) { apply_adjustments(error); } throw error; } /** * Add useful information to the error message/stack in development * @param {Error} error * @param {Effect} effect */ function get_adjustments(error, effect) { const message_descriptor = get_descriptor(error, 'message'); // if the message was already changed and it's not configurable we can't change it // or it will throw a different error swallowing the original error if (message_descriptor && !message_descriptor.configurable) return; var indent = is_firefox ? ' ' : '\t'; var component_stack = `\n${indent}in ${effect.fn?.name || '<unknown>'}`; var context = effect.ctx; while (context !== null) { component_stack += `\n${indent}in ${context.function?.[FILENAME].split('/').pop()}`; context = context.p; } return { message: error.message + `\n${component_stack}\n`, stack: error.stack ?.split('\n') .filter((line) => !line.includes('svelte/src/internal')) .join('\n') }; } /** * @param {Error} error */ function apply_adjustments(error) { const adjusted = adjustments.get(error); if (adjusted) { define_property(error, 'message', { value: adjusted.message }); define_property(error, 'stack', { value: adjusted.stack }); } }
```

# internal/client/errors.js

```js
/* This file is generated by scripts/process-messages/index.js. Do not edit! */ import { DEV } from 'esm-env'; export * from '../shared/errors.js'; /** * Cannot create a `$derived(...)` with an `await` expression outside of an effect tree * @returns {never} */ export function async_derived_orphan() { if (DEV) { const error = new Error(`async_derived_orphan\nCannot create a \`$derived(...)\` with an \`await\` expression outside of an effect tree\nhttps://svelte.dev/e/async_derived_orphan`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/async_derived_orphan`); } } /** * Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead * @returns {never} */ export function bind_invalid_checkbox_value() { if (DEV) { const error = new Error(`bind_invalid_checkbox_value\nUsing \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead\nhttps://svelte.dev/e/bind_invalid_checkbox_value`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/bind_invalid_checkbox_value`); } } /** * Component %component% has an export named `%key%` that a consumer component is trying to access using `bind:%key%`, which is disallowed. Instead, use `bind:this` (e.g. `<%name% bind:this={component} />`) and then access the property on the bound component instance (e.g. `component.%key%`) * @param {string} component * @param {string} key * @param {string} name * @returns {never} */ export function bind_invalid_export(component, key, name) { if (DEV) { const error = new Error(`bind_invalid_export\nComponent ${component} has an export named \`${key}\` that a consumer component is trying to access using \`bind:${key}\`, which is disallowed. Instead, use \`bind:this\` (e.g. \`<${name} bind:this={component} />\`) and then access the property on the bound component instance (e.g. \`component.${key}\`)\nhttps://svelte.dev/e/bind_invalid_export`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/bind_invalid_export`); } } /** * A component is attempting to bind to a non-bindable property `%key%` belonging to %component% (i.e. `<%name% bind:%key%={...}>`). To mark a property as bindable: `let { %key% = $bindable() } = $props()` * @param {string} key * @param {string} component * @param {string} name * @returns {never} */ export function bind_not_bindable(key, component, name) { if (DEV) { const error = new Error(`bind_not_bindable\nA component is attempting to bind to a non-bindable property \`${key}\` belonging to ${component} (i.e. \`<${name} bind:${key}={...}>\`). To mark a property as bindable: \`let { ${key} = $bindable() } = $props()\`\nhttps://svelte.dev/e/bind_not_bindable`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/bind_not_bindable`); } } /** * Calling `%method%` on a component instance (of %component%) is no longer valid in Svelte 5 * @param {string} method * @param {string} component * @returns {never} */ export function component_api_changed(method, component) { if (DEV) { const error = new Error(`component_api_changed\nCalling \`${method}\` on a component instance (of ${component}) is no longer valid in Svelte 5\nhttps://svelte.dev/e/component_api_changed`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/component_api_changed`); } } /** * Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `compatibility.componentApi` compiler option to `4` to keep it working. * @param {string} component * @param {string} name * @returns {never} */ export function component_api_invalid_new(component, name) { if (DEV) { const error = new Error(`component_api_invalid_new\nAttempted to instantiate ${component} with \`new ${name}\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \`compatibility.componentApi\` compiler option to \`4\` to keep it working.\nhttps://svelte.dev/e/component_api_invalid_new`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/component_api_invalid_new`); } } /** * A derived value cannot reference itself recursively * @returns {never} */ export function derived_references_self() { if (DEV) { const error = new Error(`derived_references_self\nA derived value cannot reference itself recursively\nhttps://svelte.dev/e/derived_references_self`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/derived_references_self`); } } /** * Keyed each block has duplicate key `%value%` at indexes %a% and %b% * @param {string} a * @param {string} b * @param {string | undefined | null} [value] * @returns {never} */ export function each_key_duplicate(a, b, value) { if (DEV) { const error = new Error(`each_key_duplicate\n${value ? `Keyed each block has duplicate key \`${value}\` at indexes ${a} and ${b}` : `Keyed each block has duplicate key at indexes ${a} and ${b}`}\nhttps://svelte.dev/e/each_key_duplicate`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/each_key_duplicate`); } } /** * `%rune%` cannot be used inside an effect cleanup function * @param {string} rune * @returns {never} */ export function effect_in_teardown(rune) { if (DEV) { const error = new Error(`effect_in_teardown\n\`${rune}\` cannot be used inside an effect cleanup function\nhttps://svelte.dev/e/effect_in_teardown`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/effect_in_teardown`); } } /** * Effect cannot be created inside a `$derived` value that was not itself created inside an effect * @returns {never} */ export function effect_in_unowned_derived() { if (DEV) { const error = new Error(`effect_in_unowned_derived\nEffect cannot be created inside a \`$derived\` value that was not itself created inside an effect\nhttps://svelte.dev/e/effect_in_unowned_derived`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`); } } /** * `%rune%` can only be used inside an effect (e.g. during component initialisation) * @param {string} rune * @returns {never} */ export function effect_orphan(rune) { if (DEV) { const error = new Error(`effect_orphan\n\`${rune}\` can only be used inside an effect (e.g. during component initialisation)\nhttps://svelte.dev/e/effect_orphan`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/effect_orphan`); } } /** * `$effect.pending()` can only be called inside an effect or derived * @returns {never} */ export function effect_pending_outside_reaction() { if (DEV) { const error = new Error(`effect_pending_outside_reaction\n\`$effect.pending()\` can only be called inside an effect or derived\nhttps://svelte.dev/e/effect_pending_outside_reaction`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/effect_pending_outside_reaction`); } } /** * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops * @returns {never} */ export function effect_update_depth_exceeded() { if (DEV) { const error = new Error(`effect_update_depth_exceeded\nMaximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\nhttps://svelte.dev/e/effect_update_depth_exceeded`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`); } } /** * Cannot use `flushSync` inside an effect * @returns {never} */ export function flush_sync_in_effect() { if (DEV) { const error = new Error(`flush_sync_in_effect\nCannot use \`flushSync\` inside an effect\nhttps://svelte.dev/e/flush_sync_in_effect`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/flush_sync_in_effect`); } } /** * `getAbortSignal()` can only be called inside an effect or derived * @returns {never} */ export function get_abort_signal_outside_reaction() { if (DEV) { const error = new Error(`get_abort_signal_outside_reaction\n\`getAbortSignal()\` can only be called inside an effect or derived\nhttps://svelte.dev/e/get_abort_signal_outside_reaction`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/get_abort_signal_outside_reaction`); } } /** * Failed to hydrate the application * @returns {never} */ export function hydration_failed() { if (DEV) { const error = new Error(`hydration_failed\nFailed to hydrate the application\nhttps://svelte.dev/e/hydration_failed`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/hydration_failed`); } } /** * Could not `{@render}` snippet due to the expression being `null` or `undefined`. Consider using optional chaining `{@render snippet?.()}` * @returns {never} */ export function invalid_snippet() { if (DEV) { const error = new Error(`invalid_snippet\nCould not \`{@render}\` snippet due to the expression being \`null\` or \`undefined\`. Consider using optional chaining \`{@render snippet?.()}\`\nhttps://svelte.dev/e/invalid_snippet`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/invalid_snippet`); } } /** * `%name%(...)` cannot be used in runes mode * @param {string} name * @returns {never} */ export function lifecycle_legacy_only(name) { if (DEV) { const error = new Error(`lifecycle_legacy_only\n\`${name}(...)\` cannot be used in runes mode\nhttps://svelte.dev/e/lifecycle_legacy_only`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/lifecycle_legacy_only`); } } /** * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value * @param {string} key * @returns {never} */ export function props_invalid_value(key) { if (DEV) { const error = new Error(`props_invalid_value\nCannot do \`bind:${key}={undefined}\` when \`${key}\` has a fallback value\nhttps://svelte.dev/e/props_invalid_value`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/props_invalid_value`); } } /** * Rest element properties of `$props()` such as `%property%` are readonly * @param {string} property * @returns {never} */ export function props_rest_readonly(property) { if (DEV) { const error = new Error(`props_rest_readonly\nRest element properties of \`$props()\` such as \`${property}\` are readonly\nhttps://svelte.dev/e/props_rest_readonly`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/props_rest_readonly`); } } /** * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files * @param {string} rune * @returns {never} */ export function rune_outside_svelte(rune) { if (DEV) { const error = new Error(`rune_outside_svelte\nThe \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files\nhttps://svelte.dev/e/rune_outside_svelte`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/rune_outside_svelte`); } } /** * `setContext` must be called when a component first initializes, not in a subsequent effect or after an `await` expression * @returns {never} */ export function set_context_after_init() { if (DEV) { const error = new Error(`set_context_after_init\n\`setContext\` must be called when a component first initializes, not in a subsequent effect or after an \`await\` expression\nhttps://svelte.dev/e/set_context_after_init`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/set_context_after_init`); } } /** * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`. * @returns {never} */ export function state_descriptors_fixed() { if (DEV) { const error = new Error(`state_descriptors_fixed\nProperty descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.\nhttps://svelte.dev/e/state_descriptors_fixed`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/state_descriptors_fixed`); } } /** * Cannot set prototype of `$state` object * @returns {never} */ export function state_prototype_fixed() { if (DEV) { const error = new Error(`state_prototype_fixed\nCannot set prototype of \`$state\` object\nhttps://svelte.dev/e/state_prototype_fixed`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/state_prototype_fixed`); } } /** * Updating state inside `$derived(...)`, `$inspect(...)` or a template expression is forbidden. If the value should not be reactive, declare it without `$state` * @returns {never} */ export function state_unsafe_mutation() { if (DEV) { const error = new Error(`state_unsafe_mutation\nUpdating state inside \`$derived(...)\`, \`$inspect(...)\` or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`\nhttps://svelte.dev/e/state_unsafe_mutation`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/state_unsafe_mutation`); } }
```

# internal/client/index.js

```js
export { createAttachmentKey as attachment } from '../../attachments/index.js'; export { FILENAME, HMR, NAMESPACE_SVG } from '../../constants.js'; export { push, pop, add_svelte_meta } from './context.js'; export { assign, assign_and, assign_or, assign_nullish } from './dev/assign.js'; export { cleanup_styles } from './dev/css.js'; export { add_locations } from './dev/elements.js'; export { hmr } from './dev/hmr.js'; export { create_ownership_validator } from './dev/ownership.js'; export { check_target, legacy_api } from './dev/legacy.js'; export { trace, tag, tag_proxy } from './dev/tracing.js'; export { inspect } from './dev/inspect.js'; export { async } from './dom/blocks/async.js'; export { validate_snippet_args } from './dev/validation.js'; export { await_block as await } from './dom/blocks/await.js'; export { if_block as if } from './dom/blocks/if.js'; export { key } from './dom/blocks/key.js'; export { css_props } from './dom/blocks/css-props.js'; export { index, each } from './dom/blocks/each.js'; export { html } from './dom/blocks/html.js'; export { sanitize_slots, slot } from './dom/blocks/slot.js'; export { snippet, wrap_snippet } from './dom/blocks/snippet.js'; export { component } from './dom/blocks/svelte-component.js'; export { element } from './dom/blocks/svelte-element.js'; export { head } from './dom/blocks/svelte-head.js'; export { append_styles } from './dom/css.js'; export { action } from './dom/elements/actions.js'; export { attach } from './dom/elements/attachments.js'; export { remove_input_defaults, set_attribute, set_attributes, attribute_effect, set_custom_element_data, set_xlink_attribute, set_value, set_checked, set_selected, set_default_checked, set_default_value, CLASS, STYLE } from './dom/elements/attributes.js'; export { set_class } from './dom/elements/class.js'; export { apply, event, delegate, replay_events } from './dom/elements/events.js'; export { autofocus, remove_textarea_child } from './dom/elements/misc.js'; export { set_style } from './dom/elements/style.js'; export { animation, transition } from './dom/elements/transitions.js'; export { bind_active_element } from './dom/elements/bindings/document.js'; export { bind_checked, bind_files, bind_group, bind_value } from './dom/elements/bindings/input.js'; export { bind_buffered, bind_current_time, bind_ended, bind_muted, bind_paused, bind_playback_rate, bind_played, bind_ready_state, bind_seekable, bind_seeking, bind_volume } from './dom/elements/bindings/media.js'; export { bind_online } from './dom/elements/bindings/navigator.js'; export { bind_prop } from './dom/elements/bindings/props.js'; export { bind_select_value, init_select, select_option } from './dom/elements/bindings/select.js'; export { bind_element_size, bind_resize_observer } from './dom/elements/bindings/size.js'; export { bind_this } from './dom/elements/bindings/this.js'; export { bind_content_editable, bind_property, bind_focused } from './dom/elements/bindings/universal.js'; export { bind_window_scroll, bind_window_size } from './dom/elements/bindings/window.js'; export { hydrate_template, next, reset } from './dom/hydration.js'; export { once, preventDefault, self, stopImmediatePropagation, stopPropagation, trusted } from './dom/legacy/event-modifiers.js'; export { init } from './dom/legacy/lifecycle.js'; export { add_legacy_event_listener, bubble_event, reactive_import, update_legacy_props } from './dom/legacy/misc.js'; export { append, comment, from_html, from_mathml, from_svg, from_tree, text, props_id, with_script } from './dom/template.js'; export { save, track_reactivity_loss } from './reactivity/async.js'; export { flushSync as flush, suspend } from './reactivity/batch.js'; export { async_derived, user_derived as derived, derived_safe_equal } from './reactivity/deriveds.js'; export { aborted, effect_tracking, effect_root, legacy_pre_effect, legacy_pre_effect_reset, render_effect, template_effect, effect, user_effect, user_pre_effect } from './reactivity/effects.js'; export { mutable_source, mutate, set, state, update, update_pre } from './reactivity/sources.js'; export { prop, rest_props, legacy_rest_props, spread_props, update_pre_prop, update_prop } from './reactivity/props.js'; export { invalidate_store, store_mutate, setup_stores, store_get, store_set, store_unsub, update_pre_store, update_store, mark_store_binding } from './reactivity/store.js'; export { boundary, pending } from './dom/blocks/boundary.js'; export { set_text } from './render.js'; export { get, safe_get, invalidate_inner_signals, tick, untrack, exclude_from_object, deep_read, deep_read_state } from './runtime.js'; export { validate_binding, validate_each_keys } from './validate.js'; export { raf } from './timing.js'; export { proxy } from './proxy.js'; export { create_custom_element } from './dom/elements/custom-element.js'; export { child, first_child, sibling, $window as window, $document as document } from './dom/operations.js'; export { attr, clsx } from '../shared/attributes.js'; export { snapshot } from '../shared/clone.js'; export { noop, fallback, to_array } from '../shared/utils.js'; export { invalid_default_snippet, validate_dynamic_element_tag, validate_store, validate_void_dynamic_element, prevent_snippet_stringification } from '../shared/validate.js'; export { strict_equals, equals } from './dev/equality.js'; export { log_if_contains_state } from './dev/console-log.js';
```

# internal/client/loop.js

```js
/** @import { TaskCallback, Task, TaskEntry } from '#client' */ import { raf } from './timing.js'; // TODO move this into timing.js where it probably belongs /** * @returns {void} */ function run_tasks() { // use `raf.now()` instead of the `requestAnimationFrame` callback argument, because // otherwise things can get wonky https://github.com/sveltejs/svelte/pull/14541 const now = raf.now(); raf.tasks.forEach((task) => { if (!task.c(now)) { raf.tasks.delete(task); task.f(); } }); if (raf.tasks.size !== 0) { raf.tick(run_tasks); } } /** * Creates a new task that runs on each raf frame * until it returns a falsy value or is aborted * @param {TaskCallback} callback * @returns {Task} */ export function loop(callback) { /** @type {TaskEntry} */ let task; if (raf.tasks.size === 0) { raf.tick(run_tasks); } return { promise: new Promise((fulfill) => { raf.tasks.add((task = { c: callback, f: fulfill })); }), abort() { raf.tasks.delete(task); } }; }
```

# internal/client/proxy.js

```js
/** @import { Source } from '#client' */ import { DEV } from 'esm-env'; import { get, active_effect, update_version, active_reaction, set_update_version, set_active_reaction } from './runtime.js'; import { array_prototype, get_descriptor, get_prototype_of, is_array, object_prototype } from '../shared/utils.js'; import { state as source, set, increment } from './reactivity/sources.js'; import { PROXY_PATH_SYMBOL, STATE_SYMBOL } from '#client/constants'; import { UNINITIALIZED } from '../../constants.js'; import * as e from './errors.js'; import { get_stack, tag } from './dev/tracing.js'; import { tracing_mode_flag } from '../flags/index.js'; // TODO move all regexes into shared module? const regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/; /** * @template T * @param {T} value * @returns {T} */ export function proxy(value) { // if non-proxyable, or is already a proxy, return `value` if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) { return value; } const prototype = get_prototype_of(value); if (prototype !== object_prototype && prototype !== array_prototype) { return value; } /** @type {Map<any, Source<any>>} */ var sources = new Map(); var is_proxied_array = is_array(value); var version = source(0); var stack = DEV && tracing_mode_flag ? get_stack('CreatedAt') : null; var parent_version = update_version; /** * Executes the proxy in the context of the reaction it was originally created in, if any * @template T * @param {() => T} fn */ var with_parent = (fn) => { if (update_version === parent_version) { return fn(); } // child source is being created after the initial proxy — // prevent it from being associated with the current reaction var reaction = active_reaction; var version = update_version; set_active_reaction(null); set_update_version(parent_version); var result = fn(); set_active_reaction(reaction); set_update_version(version); return result; }; if (is_proxied_array) { // We need to create the length source eagerly to ensure that // mutations to the array are properly synced with our proxy sources.set('length', source(/** @type {any[]} */ (value).length, stack)); } /** Used in dev for $inspect.trace() */ var path = ''; /** @param {string} new_path */ function update_path(new_path) { path = new_path; tag(version, `${path} version`); // rename all child sources and child proxies for (const [prop, source] of sources) { tag(source, get_label(path, prop)); } } return new Proxy(/** @type {any} */ (value), { defineProperty(_, prop, descriptor) { if ( !('value' in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false ) { // we disallow non-basic descriptors, because unless they are applied to the // target object — which we avoid, so that state can be forked — we will run // afoul of the various invariants // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants e.state_descriptors_fixed(); } var s = sources.get(prop); if (s === undefined) { s = with_parent(() => { var s = source(descriptor.value, stack); sources.set(prop, s); if (DEV && typeof prop === 'string') { tag(s, get_label(path, prop)); } return s; }); } else { set(s, descriptor.value, true); } return true; }, deleteProperty(target, prop) { var s = sources.get(prop); if (s === undefined) { if (prop in target) { const s = with_parent(() => source(UNINITIALIZED, stack)); sources.set(prop, s); increment(version); if (DEV) { tag(s, get_label(path, prop)); } } } else { // When working with arrays, we need to also ensure we update the length when removing // an indexed property if (is_proxied_array && typeof prop === 'string') { var ls = /** @type {Source<number>} */ (sources.get('length')); var n = Number(prop); if (Number.isInteger(n) && n < ls.v) { set(ls, n); } } set(s, UNINITIALIZED); increment(version); } return true; }, get(target, prop, receiver) { if (prop === STATE_SYMBOL) { return value; } if (DEV && prop === PROXY_PATH_SYMBOL) { return update_path; } var s = sources.get(prop); var exists = prop in target; // create a source, but only if it's an own property and not a prototype property if (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) { s = with_parent(() => { var p = proxy(exists ? target[prop] : UNINITIALIZED); var s = source(p, stack); if (DEV) { tag(s, get_label(path, prop)); } return s; }); sources.set(prop, s); } if (s !== undefined) { var v = get(s); return v === UNINITIALIZED ? undefined : v; } return Reflect.get(target, prop, receiver); }, getOwnPropertyDescriptor(target, prop) { var descriptor = Reflect.getOwnPropertyDescriptor(target, prop); if (descriptor && 'value' in descriptor) { var s = sources.get(prop); if (s) descriptor.value = get(s); } else if (descriptor === undefined) { var source = sources.get(prop); var value = source?.v; if (source !== undefined && value !== UNINITIALIZED) { return { enumerable: true, configurable: true, value, writable: true }; } } return descriptor; }, has(target, prop) { if (prop === STATE_SYMBOL) { return true; } var s = sources.get(prop); var has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop); if ( s !== undefined || (active_effect !== null && (!has || get_descriptor(target, prop)?.writable)) ) { if (s === undefined) { s = with_parent(() => { var p = has ? proxy(target[prop]) : UNINITIALIZED; var s = source(p, stack); if (DEV) { tag(s, get_label(path, prop)); } return s; }); sources.set(prop, s); } var value = get(s); if (value === UNINITIALIZED) { return false; } } return has; }, set(target, prop, value, receiver) { var s = sources.get(prop); var has = prop in target; // variable.length = value -> clear all signals with index >= value if (is_proxied_array && prop === 'length') { for (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) { var other_s = sources.get(i + ''); if (other_s !== undefined) { set(other_s, UNINITIALIZED); } else if (i in target) { // If the item exists in the original, we need to create a uninitialized source, // else a later read of the property would result in a source being created with // the value of the original item at that index. other_s = with_parent(() => source(UNINITIALIZED, stack)); sources.set(i + '', other_s); if (DEV) { tag(other_s, get_label(path, i)); } } } } // If we haven't yet created a source for this property, we need to ensure // we do so otherwise if we read it later, then the write won't be tracked and // the heuristics of effects will be different vs if we had read the proxied // object property before writing to that property. if (s === undefined) { if (!has || get_descriptor(target, prop)?.writable) { s = with_parent(() => source(undefined, stack)); set(s, proxy(value)); sources.set(prop, s); if (DEV) { tag(s, get_label(path, prop)); } } } else { has = s.v !== UNINITIALIZED; var p = with_parent(() => proxy(value)); set(s, p); } var descriptor = Reflect.getOwnPropertyDescriptor(target, prop); // Set the new value before updating any signals so that any listeners get the new value if (descriptor?.set) { descriptor.set.call(receiver, value); } if (!has) { // If we have mutated an array directly, we might need to // signal that length has also changed. Do it before updating metadata // to ensure that iterating over the array as a result of a metadata update // will not cause the length to be out of sync. if (is_proxied_array && typeof prop === 'string') { var ls = /** @type {Source<number>} */ (sources.get('length')); var n = Number(prop); if (Number.isInteger(n) && n >= ls.v) { set(ls, n + 1); } } increment(version); } return true; }, ownKeys(target) { get(version); var own_keys = Reflect.ownKeys(target).filter((key) => { var source = sources.get(key); return source === undefined || source.v !== UNINITIALIZED; }); for (var [key, source] of sources) { if (source.v !== UNINITIALIZED && !(key in target)) { own_keys.push(key); } } return own_keys; }, setPrototypeOf() { e.state_prototype_fixed(); } }); } /** * @param {string} path * @param {string | symbol} prop */ function get_label(path, prop) { if (typeof prop === 'symbol') return `${path}[Symbol(${prop.description ?? ''})]`; if (regex_is_valid_identifier.test(prop)) return `${path}.${prop}`; return /^\d+$/.test(prop) ? `${path}[${prop}]` : `${path}['${prop}']`; } /** * @param {any} value */ export function get_proxied_value(value) { try { if (value !== null && typeof value === 'object' && STATE_SYMBOL in value) { return value[STATE_SYMBOL]; } } catch { // the above if check can throw an error if the value in question // is the contentWindow of an iframe on another domain, in which // case we want to just return the value (because it's definitely // not a proxied value) so we don't break any JavaScript interacting // with that iframe (such as various payment companies client side // JavaScript libraries interacting with their iframes on the same // domain) } return value; } /** * @param {any} a * @param {any} b */ export function is(a, b) { return Object.is(get_proxied_value(a), get_proxied_value(b)); }
```

# internal/client/proxy.test.ts

```ts
import { proxy } from './proxy'; import { assert, test } from 'vitest'; test('does not mutate the original object', () => { const original = { x: 1 }; const state = proxy(original); state.x = 2; assert.equal(original.x, 1); assert.equal(state.x, 2); }); test('preserves getters', () => { let count = 0; const original = { count: 0, get x() { this.count += 1; count += 1; return 42; } }; const state = proxy(original); // eslint-disable-next-line @typescript-eslint/no-unused-expressions state.x; // eslint-disable-next-line @typescript-eslint/no-unused-expressions state.x; assert.equal(original.count, 0); assert.equal(count, 2); assert.equal(state.count, 2); }); test('defines a property', () => { const original = { y: 0 }; const state = proxy<any>(original); let value = 0; Object.defineProperty(state, 'x', { value: 1 }); Object.defineProperty(state, 'y', { value: 1 }); assert.equal(state.x, 1); assert.deepEqual(Object.getOwnPropertyDescriptor(state, 'x'), { configurable: true, writable: true, value: 1, enumerable: true }); assert.ok(!('x' in original)); assert.deepEqual(Object.getOwnPropertyDescriptor(original, 'y'), { configurable: true, writable: true, value: 0, enumerable: true }); assert.throws( () => Object.defineProperty(state, 'x', { get: () => value, set: (v) => (value = v) }), /state_descriptors_fixed/ ); }); test('does not re-proxy proxies', () => { const inner = proxy({ count: 0 }); const outer = proxy({ inner }); assert.equal(inner.count, 0); assert.equal(outer.inner.count, 0); inner.count += 1; assert.equal(inner.count, 1); assert.equal(outer.inner.count, 1); }); test('deletes a property', () => { const state = proxy({ a: 1, b: 2 } as { a?: number; b?: number; c?: number }); delete state.a; assert.equal(JSON.stringify(state), '{"b":2}'); delete state.a; // deleting a non-existent property should succeed delete state.c; }); test('handles array.push', () => { const original = [1, 2, 3]; const state = proxy(original); state.push(4); assert.deepEqual(original.length, 3); assert.deepEqual(original, [1, 2, 3]); assert.deepEqual(state.length, 4); assert.deepEqual(state, [1, 2, 3, 4]); }); test('handles array mutation', () => { const original = [1, 2, 3]; const state = proxy(original); state[3] = 4; assert.deepEqual(original.length, 3); assert.deepEqual(original, [1, 2, 3]); assert.deepEqual(state.length, 4); assert.deepEqual(state, [1, 2, 3, 4]); }); test('handles array length mutation', () => { const original = [1, 2, 3]; const state = proxy(original); state.length = 0; assert.deepEqual(original.length, 3); assert.deepEqual(original, [1, 2, 3]); assert.deepEqual(original[0], 1); assert.deepEqual(state.length, 0); assert.deepEqual(state, []); assert.deepEqual(state[0], undefined); });
```

# internal/client/reactivity/async.js

```js
/** @import { Effect, Value } from '#client' */ import { DESTROYED } from '#client/constants'; import { DEV } from 'esm-env'; import { component_context, is_runes, set_component_context } from '../context.js'; import { get_pending_boundary } from '../dom/blocks/boundary.js'; import { invoke_error_boundary } from '../error-handling.js'; import { active_effect, active_reaction, set_active_effect, set_active_reaction } from '../runtime.js'; import { current_batch } from './batch.js'; import { async_derived, current_async_effect, derived, derived_safe_equal, set_from_async_derived } from './deriveds.js'; /** * * @param {Array<() => any>} sync * @param {Array<() => Promise<any>>} async * @param {(values: Value[]) => any} fn */ export function flatten(sync, async, fn) { const d = is_runes() ? derived : derived_safe_equal; if (async.length === 0) { fn(sync.map(d)); return; } var batch = current_batch; var parent = /** @type {Effect} */ (active_effect); var restore = capture(); var boundary = get_pending_boundary(); Promise.all(async.map((expression) => async_derived(expression))) .then((result) => { batch?.activate(); restore(); try { fn([...sync.map(d), ...result]); } catch (error) { // ignore errors in blocks that have already been destroyed if ((parent.f & DESTROYED) === 0) { invoke_error_boundary(error, parent); } } batch?.deactivate(); unset_context(); }) .catch((error) => { boundary.error(error); }); } /** * Captures the current effect context so that we can restore it after * some asynchronous work has happened (so that e.g. `await a + b` * causes `b` to be registered as a dependency). */ function capture() { var previous_effect = active_effect; var previous_reaction = active_reaction; var previous_component_context = component_context; return function restore() { set_active_effect(previous_effect); set_active_reaction(previous_reaction); set_component_context(previous_component_context); if (DEV) { set_from_async_derived(null); } }; } /** * Wraps an `await` expression in such a way that the effect context that was * active before the expression evaluated can be reapplied afterwards — * `await a + b` becomes `(await $.save(a))() + b` * @template T * @param {Promise<T>} promise * @returns {Promise<() => T>} */ export async function save(promise) { var restore = capture(); var value = await promise; return () => { restore(); return value; }; } /** * Reset `current_async_effect` after the `promise` resolves, so * that we can emit `await_reactivity_loss` warnings * @template T * @param {Promise<T>} promise * @returns {Promise<() => T>} */ export async function track_reactivity_loss(promise) { var previous_async_effect = current_async_effect; var value = await promise; return () => { set_from_async_derived(previous_async_effect); return value; }; } export function unset_context() { set_active_effect(null); set_active_reaction(null); set_component_context(null); if (DEV) set_from_async_derived(null); }
```

# internal/client/reactivity/batch.js

```js
/** @import { Derived, Effect, Source } from '#client' */ import { BLOCK_EFFECT, BRANCH_EFFECT, CLEAN, DESTROYED, DIRTY, EFFECT, ASYNC, INERT, RENDER_EFFECT, ROOT_EFFECT, USER_EFFECT } from '#client/constants'; import { async_mode_flag } from '../../flags/index.js'; import { deferred, define_property } from '../../shared/utils.js'; import { get_pending_boundary } from '../dom/blocks/boundary.js'; import { active_effect, is_dirty, is_updating_effect, set_is_updating_effect, set_signal_status, update_effect, write_version } from '../runtime.js'; import * as e from '../errors.js'; import { flush_tasks } from '../dom/task.js'; import { DEV } from 'esm-env'; import { invoke_error_boundary } from '../error-handling.js'; import { old_values } from './sources.js'; import { unlink_effect } from './effects.js'; import { unset_context } from './async.js'; /** @type {Set<Batch>} */ const batches = new Set(); /** @type {Batch | null} */ export let current_batch = null; /** * When time travelling, we re-evaluate deriveds based on the temporary * values of their dependencies rather than their actual values, and cache * the results in this map rather than on the deriveds themselves * @type {Map<Derived, any> | null} */ export let batch_deriveds = null; /** @type {Effect[]} Stack of effects, dev only */ export let dev_effect_stack = []; /** @type {Effect[]} */ let queued_root_effects = []; /** @type {Effect | null} */ let last_scheduled_effect = null; let is_flushing = false; export class Batch { /** * The current values of any sources that are updated in this batch * They keys of this map are identical to `this.#previous` * @type {Map<Source, any>} */ #current = new Map(); /** * The values of any sources that are updated in this batch _before_ those updates took place. * They keys of this map are identical to `this.#current` * @type {Map<Source, any>} */ #previous = new Map(); /** * When the batch is committed (and the DOM is updated), we need to remove old branches * and append new ones by calling the functions added inside (if/each/key/etc) blocks * @type {Set<() => void>} */ #callbacks = new Set(); /** * The number of async effects that are currently in flight */ #pending = 0; /** * A deferred that resolves when the batch is committed, used with `settled()` * TODO replace with Promise.withResolvers once supported widely enough * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null} */ #deferred = null; /** * True if an async effect inside this batch resolved and * its parent branch was already deleted */ #neutered = false; /** * Async effects (created inside `async_derived`) encountered during processing. * These run after the rest of the batch has updated, since they should * always have the latest values * @type {Effect[]} */ #async_effects = []; /** * The same as `#async_effects`, but for effects inside a newly-created * `<svelte:boundary>` — these do not prevent the batch from committing * @type {Effect[]} */ #boundary_async_effects = []; /** * Template effects and `$effect.pre` effects, which run when * a batch is committed * @type {Effect[]} */ #render_effects = []; /** * The same as `#render_effects`, but for `$effect` (which runs after) * @type {Effect[]} */ #effects = []; /** * Block effects, which may need to re-run on subsequent flushes * in order to update internal sources (e.g. each block items) * @type {Effect[]} */ #block_effects = []; /** * A set of branches that still exist, but will be destroyed when this batch * is committed — we skip over these during `process` * @type {Set<Effect>} */ skipped_effects = new Set(); /** * * @param {Effect[]} root_effects */ #process(root_effects) { queued_root_effects = []; /** @type {Map<Source, { v: unknown, wv: number }> | null} */ var current_values = null; // if there are multiple batches, we are 'time travelling' — // we need to undo the changes belonging to any batch // other than the current one if (batches.size > 1) { current_values = new Map(); batch_deriveds = new Map(); for (const [source, current] of this.#current) { current_values.set(source, { v: source.v, wv: source.wv }); source.v = current; } for (const batch of batches) { if (batch === this) continue; for (const [source, previous] of batch.#previous) { if (!current_values.has(source)) { current_values.set(source, { v: source.v, wv: source.wv }); source.v = previous; } } } } for (const root of root_effects) { this.#traverse_effect_tree(root); } // if we didn't start any new async work, and no async work // is outstanding from a previous flush, commit if (this.#async_effects.length === 0 && this.#pending === 0) { var render_effects = this.#render_effects; var effects = this.#effects; this.#render_effects = []; this.#effects = []; this.#block_effects = []; this.#commit(); flush_queued_effects(render_effects); flush_queued_effects(effects); this.#deferred?.resolve(); } else { // otherwise mark effects clean so they get scheduled on the next run for (const e of this.#render_effects) set_signal_status(e, CLEAN); for (const e of this.#effects) set_signal_status(e, CLEAN); for (const e of this.#block_effects) set_signal_status(e, CLEAN); } if (current_values) { for (const [source, { v, wv }] of current_values) { // reset the source to the current value (unless // it got a newer value as a result of effects running) if (source.wv <= wv) { source.v = v; } } batch_deriveds = null; } for (const effect of this.#async_effects) { update_effect(effect); } for (const effect of this.#boundary_async_effects) { update_effect(effect); } this.#async_effects = []; this.#boundary_async_effects = []; } /** * Traverse the effect tree, executing effects or stashing * them for later execution as appropriate * @param {Effect} root */ #traverse_effect_tree(root) { root.f ^= CLEAN; var effect = root.first; while (effect !== null) { var flags = effect.f; var is_branch = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0; var is_skippable_branch = is_branch && (flags & CLEAN) !== 0; var skip = is_skippable_branch || (flags & INERT) !== 0 || this.skipped_effects.has(effect); if (!skip && effect.fn !== null) { if (is_branch) { effect.f ^= CLEAN; } else if ((flags & EFFECT) !== 0) { this.#effects.push(effect); } else if (async_mode_flag && (flags & RENDER_EFFECT) !== 0) { this.#render_effects.push(effect); } else if (is_dirty(effect)) { if ((flags & ASYNC) !== 0) { var effects = effect.b?.pending ? this.#boundary_async_effects : this.#async_effects; effects.push(effect); } else { if ((effect.f & BLOCK_EFFECT) !== 0) this.#block_effects.push(effect); update_effect(effect); } } var child = effect.first; if (child !== null) { effect = child; continue; } } var parent = effect.parent; effect = effect.next; while (effect === null && parent !== null) { effect = parent.next; parent = parent.parent; } } } /** * Associate a change to a given source with the current * batch, noting its previous and current values * @param {Source} source * @param {any} value */ capture(source, value) { if (!this.#previous.has(source)) { this.#previous.set(source, value); } this.#current.set(source, source.v); } activate() { current_batch = this; } deactivate() { current_batch = null; } neuter() { this.#neutered = true; } flush() { if (queued_root_effects.length > 0) { this.flush_effects(); } else { this.#commit(); } if (current_batch !== this) { // this can happen if a `flushSync` occurred during `this.flush_effects()`, // which is permitted in legacy mode despite being a terrible idea return; } if (this.#pending === 0) { batches.delete(this); } current_batch = null; } flush_effects() { var was_updating_effect = is_updating_effect; is_flushing = true; try { var flush_count = 0; set_is_updating_effect(true); while (queued_root_effects.length > 0) { if (flush_count++ > 1000) { infinite_loop_guard(); } this.#process(queued_root_effects); old_values.clear(); } } finally { is_flushing = false; set_is_updating_effect(was_updating_effect); last_scheduled_effect = null; if (DEV) { dev_effect_stack = []; } } } /** * Append and remove branches to/from the DOM */ #commit() { if (!this.#neutered) { for (const fn of this.#callbacks) { fn(); } } this.#callbacks.clear(); } increment() { this.#pending += 1; } decrement() { this.#pending -= 1; if (this.#pending === 0) { for (const e of this.#render_effects) { set_signal_status(e, DIRTY); schedule_effect(e); } for (const e of this.#effects) { set_signal_status(e, DIRTY); schedule_effect(e); } for (const e of this.#block_effects) { set_signal_status(e, DIRTY); schedule_effect(e); } this.#render_effects = []; this.#effects = []; this.flush(); } } /** @param {() => void} fn */ add_callback(fn) { this.#callbacks.add(fn); } settled() { return (this.#deferred ??= deferred()).promise; } static ensure() { if (current_batch === null) { const batch = (current_batch = new Batch()); batches.add(current_batch); queueMicrotask(() => { if (current_batch !== batch) { // a flushSync happened in the meantime return; } batch.flush(); }); } return current_batch; } } /** * Synchronously flush any pending updates. * Returns void if no callback is provided, otherwise returns the result of calling the callback. * @template [T=void] * @param {(() => T) | undefined} [fn] * @returns {T} */ export function flushSync(fn) { if (async_mode_flag && active_effect !== null) { e.flush_sync_in_effect(); } var result; const batch = Batch.ensure(); if (fn) { batch.flush_effects(); result = fn(); } while (true) { flush_tasks(); if (queued_root_effects.length === 0) { if (batch === current_batch) { batch.flush(); } // this would be reset in `batch.flush_effects()` but since we are early returning here, // we need to reset it here as well in case the first time there's 0 queued root effects last_scheduled_effect = null; if (DEV) { dev_effect_stack = []; } return /** @type {T} */ (result); } batch.flush_effects(); } } function log_effect_stack() { // eslint-disable-next-line no-console console.error( 'Last ten effects were: ', dev_effect_stack.slice(-10).map((d) => d.fn) ); dev_effect_stack = []; } function infinite_loop_guard() { try { e.effect_update_depth_exceeded(); } catch (error) { if (DEV) { // stack is garbage, ignore. Instead add a console.error message. define_property(error, 'stack', { value: '' }); } // Try and handle the error so it can be caught at a boundary, that's // if there's an effect available from when it was last scheduled if (last_scheduled_effect !== null) { if (DEV) { try { invoke_error_boundary(error, last_scheduled_effect); } catch (e) { // Only log the effect stack if the error is re-thrown log_effect_stack(); throw e; } } else { invoke_error_boundary(error, last_scheduled_effect); } } else { if (DEV) { log_effect_stack(); } throw error; } } } /** * @param {Array<Effect>} effects * @returns {void} */ function flush_queued_effects(effects) { var length = effects.length; if (length === 0) return; for (var i = 0; i < length; i++) { var effect = effects[i]; if ((effect.f & (DESTROYED | INERT)) === 0) { if (is_dirty(effect)) { var wv = write_version; update_effect(effect); // Effects with no dependencies or teardown do not get added to the effect tree. // Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we // don't know if we need to keep them until they are executed. Doing the check // here (rather than in `update_effect`) allows us to skip the work for // immediate effects. if (effect.deps === null && effect.first === null && effect.nodes_start === null) { if (effect.teardown === null) { // remove this effect from the graph unlink_effect(effect); } else { // keep the effect in the graph, but free up some memory effect.fn = null; } } // if state is written in a user effect, abort and re-schedule, lest we run // effects that should be removed as a result of the state change if (write_version > wv && (effect.f & USER_EFFECT) !== 0) { break; } } } } for (; i < length; i += 1) { schedule_effect(effects[i]); } } /** * @param {Effect} signal * @returns {void} */ export function schedule_effect(signal) { var effect = (last_scheduled_effect = signal); while (effect.parent !== null) { effect = effect.parent; var flags = effect.f; // if the effect is being scheduled because a parent (each/await/etc) block // updated an internal source, bail out or we'll cause a second flush if (is_flushing && effect === active_effect && (flags & BLOCK_EFFECT) !== 0) { return; } if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) { if ((flags & CLEAN) === 0) return; effect.f ^= CLEAN; } } queued_root_effects.push(effect); } export function suspend() { var boundary = get_pending_boundary(); var batch = /** @type {Batch} */ (current_batch); var pending = boundary.pending; boundary.update_pending_count(1); if (!pending) batch.increment(); return function unsuspend() { boundary.update_pending_count(-1); if (!pending) batch.decrement(); unset_context(); }; } /** * Forcibly remove all current batches, to prevent cross-talk between tests */ export function clear() { batches.clear(); }
```

# internal/client/reactivity/deriveds.js

```js
/** @import { Derived, Effect, Source } from '#client' */ /** @import { Batch } from './batch.js'; */ import { DEV } from 'esm-env'; import { ERROR_VALUE, CLEAN, DERIVED, DIRTY, EFFECT_PRESERVED, MAYBE_DIRTY, STALE_REACTION, UNOWNED, ASYNC } from '#client/constants'; import { active_reaction, active_effect, set_signal_status, skip_reaction, update_reaction, increment_write_version, set_active_effect, push_reaction_value, is_destroying_effect } from '../runtime.js'; import { equals, safe_equals } from './equality.js'; import * as e from '../errors.js'; import * as w from '../warnings.js'; import { async_effect, destroy_effect } from './effects.js'; import { inspect_effects, internal_set, set_inspect_effects, source } from './sources.js'; import { get_stack } from '../dev/tracing.js'; import { tracing_mode_flag } from '../../flags/index.js'; import { Boundary } from '../dom/blocks/boundary.js'; import { component_context } from '../context.js'; import { UNINITIALIZED } from '../../../constants.js'; import { batch_deriveds, current_batch } from './batch.js'; import { unset_context } from './async.js'; /** @type {Effect | null} */ export let current_async_effect = null; /** @param {Effect | null} v */ export function set_from_async_derived(v) { current_async_effect = v; } export const recent_async_deriveds = new Set(); /** * @template V * @param {() => V} fn * @returns {Derived<V>} */ /*#__NO_SIDE_EFFECTS__*/ export function derived(fn) { var flags = DERIVED | DIRTY; var parent_derived = active_reaction !== null && (active_reaction.f & DERIVED) !== 0 ? /** @type {Derived} */ (active_reaction) : null; if (active_effect === null || (parent_derived !== null && (parent_derived.f & UNOWNED) !== 0)) { flags |= UNOWNED; } else { // Since deriveds are evaluated lazily, any effects created inside them are // created too late to ensure that the parent effect is added to the tree active_effect.f |= EFFECT_PRESERVED; } /** @type {Derived<V>} */ const signal = { ctx: component_context, deps: null, effects: null, equals, f: flags, fn, reactions: null, rv: 0, v: /** @type {V} */ (UNINITIALIZED), wv: 0, parent: parent_derived ?? active_effect, ac: null }; if (DEV && tracing_mode_flag) { signal.created = get_stack('CreatedAt'); } return signal; } /** * @template V * @param {() => V | Promise<V>} fn * @param {string} [location] If provided, print a warning if the value is not read immediately after update * @returns {Promise<Source<V>>} */ /*#__NO_SIDE_EFFECTS__*/ export function async_derived(fn, location) { let parent = /** @type {Effect | null} */ (active_effect); if (parent === null) { e.async_derived_orphan(); } var boundary = /** @type {Boundary} */ (parent.b); var promise = /** @type {Promise<V>} */ (/** @type {unknown} */ (undefined)); var signal = source(/** @type {V} */ (UNINITIALIZED)); /** @type {Promise<V> | null} */ var prev = null; // only suspend in async deriveds created on initialisation var should_suspend = !active_reaction; async_effect(() => { if (DEV) current_async_effect = active_effect; try { var p = fn(); } catch (error) { p = Promise.reject(error); } if (DEV) current_async_effect = null; var r = () => p; promise = prev?.then(r, r) ?? Promise.resolve(p); prev = promise; var batch = /** @type {Batch} */ (current_batch); var pending = boundary.pending; if (should_suspend) { boundary.update_pending_count(1); if (!pending) batch.increment(); } /** * @param {any} value * @param {unknown} error */ const handler = (value, error = undefined) => { prev = null; current_async_effect = null; if (!pending) batch.activate(); if (error) { if (error !== STALE_REACTION) { signal.f |= ERROR_VALUE; // @ts-expect-error the error is the wrong type, but we don't care internal_set(signal, error); } } else { if ((signal.f & ERROR_VALUE) !== 0) { signal.f ^= ERROR_VALUE; } internal_set(signal, value); if (DEV && location !== undefined) { recent_async_deriveds.add(signal); setTimeout(() => { if (recent_async_deriveds.has(signal)) { w.await_waterfall(/** @type {string} */ (signal.label), location); recent_async_deriveds.delete(signal); } }); } } if (should_suspend) { boundary.update_pending_count(-1); if (!pending) batch.decrement(); } unset_context(); }; promise.then(handler, (e) => handler(null, e || 'unknown')); if (batch) { return () => { queueMicrotask(() => batch.neuter()); }; } }); if (DEV) { // add a flag that lets this be printed as a derived // when using `$inspect.trace()` signal.f |= ASYNC; } return new Promise((fulfil) => { /** @param {Promise<V>} p */ function next(p) { function go() { if (p === promise) { fulfil(signal); } else { // if the effect re-runs before the initial promise // resolves, delay resolution until we have a value next(promise); } } p.then(go, go); } next(promise); }); } /** * @template V * @param {() => V} fn * @returns {Derived<V>} */ /*#__NO_SIDE_EFFECTS__*/ export function user_derived(fn) { const d = derived(fn); push_reaction_value(d); return d; } /** * @template V * @param {() => V} fn * @returns {Derived<V>} */ /*#__NO_SIDE_EFFECTS__*/ export function derived_safe_equal(fn) { const signal = derived(fn); signal.equals = safe_equals; return signal; } /** * @param {Derived} derived * @returns {void} */ export function destroy_derived_effects(derived) { var effects = derived.effects; if (effects !== null) { derived.effects = null; for (var i = 0; i < effects.length; i += 1) { destroy_effect(/** @type {Effect} */ (effects[i])); } } } /** * The currently updating deriveds, used to detect infinite recursion * in dev mode and provide a nicer error than 'too much recursion' * @type {Derived[]} */ let stack = []; /** * @param {Derived} derived * @returns {Effect | null} */ function get_derived_parent_effect(derived) { var parent = derived.parent; while (parent !== null) { if ((parent.f & DERIVED) === 0) { return /** @type {Effect} */ (parent); } parent = parent.parent; } return null; } /** * @template T * @param {Derived} derived * @returns {T} */ export function execute_derived(derived) { var value; var prev_active_effect = active_effect; set_active_effect(get_derived_parent_effect(derived)); if (DEV) { let prev_inspect_effects = inspect_effects; set_inspect_effects(new Set()); try { if (stack.includes(derived)) { e.derived_references_self(); } stack.push(derived); destroy_derived_effects(derived); value = update_reaction(derived); } finally { set_active_effect(prev_active_effect); set_inspect_effects(prev_inspect_effects); stack.pop(); } } else { try { destroy_derived_effects(derived); value = update_reaction(derived); } finally { set_active_effect(prev_active_effect); } } return value; } /** * @param {Derived} derived * @returns {void} */ export function update_derived(derived) { var value = execute_derived(derived); if (!derived.equals(value)) { derived.v = value; derived.wv = increment_write_version(); } // don't mark derived clean if we're reading it inside a // cleanup function, or it will cache a stale value if (is_destroying_effect) return; if (batch_deriveds !== null) { batch_deriveds.set(derived, derived.v); } else { var status = (skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN; set_signal_status(derived, status); } }
```

# internal/client/reactivity/effects.js

```js
/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */ import { is_dirty, active_effect, active_reaction, update_effect, get, is_destroying_effect, remove_reactions, set_active_reaction, set_is_destroying_effect, set_signal_status, untrack, untracking } from '../runtime.js'; import { DIRTY, BRANCH_EFFECT, RENDER_EFFECT, EFFECT, DESTROYED, INERT, EFFECT_RAN, BLOCK_EFFECT, ROOT_EFFECT, EFFECT_TRANSPARENT, DERIVED, UNOWNED, CLEAN, INSPECT_EFFECT, HEAD_EFFECT, MAYBE_DIRTY, EFFECT_PRESERVED, STALE_REACTION, USER_EFFECT, ASYNC } from '#client/constants'; import * as e from '../errors.js'; import { DEV } from 'esm-env'; import { define_property } from '../../shared/utils.js'; import { get_next_sibling } from '../dom/operations.js'; import { component_context, dev_current_component_function, dev_stack } from '../context.js'; import { Batch, schedule_effect } from './batch.js'; import { flatten } from './async.js'; /** * @param {'$effect' | '$effect.pre' | '$inspect'} rune */ export function validate_effect(rune) { if (active_effect === null && active_reaction === null) { e.effect_orphan(rune); } if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) { e.effect_in_unowned_derived(); } if (is_destroying_effect) { e.effect_in_teardown(rune); } } /** * @param {Effect} effect * @param {Effect} parent_effect */ function push_effect(effect, parent_effect) { var parent_last = parent_effect.last; if (parent_last === null) { parent_effect.last = parent_effect.first = effect; } else { parent_last.next = effect; effect.prev = parent_last; parent_effect.last = effect; } } /** * @param {number} type * @param {null | (() => void | (() => void))} fn * @param {boolean} sync * @param {boolean} push * @returns {Effect} */ function create_effect(type, fn, sync, push = true) { var parent = active_effect; if (DEV) { // Ensure the parent is never an inspect effect while (parent !== null && (parent.f & INSPECT_EFFECT) !== 0) { parent = parent.parent; } } if (parent !== null && (parent.f & INERT) !== 0) { type |= INERT; } /** @type {Effect} */ var effect = { ctx: component_context, deps: null, nodes_start: null, nodes_end: null, f: type | DIRTY, first: null, fn, last: null, next: null, parent, b: parent && parent.b, prev: null, teardown: null, transitions: null, wv: 0, ac: null }; if (DEV) { effect.component_function = dev_current_component_function; } if (sync) { try { update_effect(effect); effect.f |= EFFECT_RAN; } catch (e) { destroy_effect(effect); throw e; } } else if (fn !== null) { schedule_effect(effect); } // if an effect has no dependencies, no DOM and no teardown function, // don't bother adding it to the effect tree var inert = sync && effect.deps === null && effect.first === null && effect.nodes_start === null && effect.teardown === null && (effect.f & EFFECT_PRESERVED) === 0; if (!inert && push) { if (parent !== null) { push_effect(effect, parent); } // if we're in a derived, add the effect there too if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) { var derived = /** @type {Derived} */ (active_reaction); (derived.effects ??= []).push(effect); } } return effect; } /** * Internal representation of `$effect.tracking()` * @returns {boolean} */ export function effect_tracking() { return active_reaction !== null && !untracking; } /** * @param {() => void} fn */ export function teardown(fn) { const effect = create_effect(RENDER_EFFECT, null, false); set_signal_status(effect, CLEAN); effect.teardown = fn; return effect; } /** * Internal representation of `$effect(...)` * @param {() => void | (() => void)} fn */ export function user_effect(fn) { validate_effect('$effect'); if (DEV) { define_property(fn, 'name', { value: '$effect' }); } // Non-nested `$effect(...)` in a component should be deferred // until the component is mounted var flags = /** @type {Effect} */ (active_effect).f; var defer = !active_reaction && (flags & BRANCH_EFFECT) !== 0 && (flags & EFFECT_RAN) === 0; if (defer) { // Top-level `$effect(...)` in an unmounted component — defer until mount var context = /** @type {ComponentContext} */ (component_context); (context.e ??= []).push(fn); } else { // Everything else — create immediately return create_user_effect(fn); } } /** * @param {() => void | (() => void)} fn */ export function create_user_effect(fn) { return create_effect(EFFECT | USER_EFFECT, fn, false); } /** * Internal representation of `$effect.pre(...)` * @param {() => void | (() => void)} fn * @returns {Effect} */ export function user_pre_effect(fn) { validate_effect('$effect.pre'); if (DEV) { define_property(fn, 'name', { value: '$effect.pre' }); } return create_effect(RENDER_EFFECT | USER_EFFECT, fn, true); } /** @param {() => void | (() => void)} fn */ export function inspect_effect(fn) { return create_effect(INSPECT_EFFECT, fn, true); } /** * Internal representation of `$effect.root(...)` * @param {() => void | (() => void)} fn * @returns {() => void} */ export function effect_root(fn) { Batch.ensure(); const effect = create_effect(ROOT_EFFECT, fn, true); return () => { destroy_effect(effect); }; } /** * An effect root whose children can transition out * @param {() => void} fn * @returns {(options?: { outro?: boolean }) => Promise<void>} */ export function component_root(fn) { Batch.ensure(); const effect = create_effect(ROOT_EFFECT, fn, true); return (options = {}) => { return new Promise((fulfil) => { if (options.outro) { pause_effect(effect, () => { destroy_effect(effect); fulfil(undefined); }); } else { destroy_effect(effect); fulfil(undefined); } }); }; } /** * @param {() => void | (() => void)} fn * @returns {Effect} */ export function effect(fn) { return create_effect(EFFECT, fn, false); } /** * Internal representation of `$: ..` * @param {() => any} deps * @param {() => void | (() => void)} fn */ export function legacy_pre_effect(deps, fn) { var context = /** @type {ComponentContextLegacy} */ (component_context); /** @type {{ effect: null | Effect, ran: boolean, deps: () => any }} */ var token = { effect: null, ran: false, deps }; context.l.$.push(token); token.effect = render_effect(() => { deps(); // If this legacy pre effect has already run before the end of the reset, then // bail out to emulate the same behavior. if (token.ran) return; token.ran = true; untrack(fn); }); } export function legacy_pre_effect_reset() { var context = /** @type {ComponentContextLegacy} */ (component_context); render_effect(() => { // Run dirty `$:` statements for (var token of context.l.$) { token.deps(); var effect = token.effect; // If the effect is CLEAN, then make it MAYBE_DIRTY. This ensures we traverse through // the effects dependencies and correctly ensure each dependency is up-to-date. if ((effect.f & CLEAN) !== 0) { set_signal_status(effect, MAYBE_DIRTY); } if (is_dirty(effect)) { update_effect(effect); } token.ran = false; } }); } /** * @param {() => void | (() => void)} fn * @returns {Effect} */ export function async_effect(fn) { return create_effect(ASYNC | EFFECT_PRESERVED, fn, true); } /** * @param {() => void | (() => void)} fn * @returns {Effect} */ export function render_effect(fn, flags = 0) { return create_effect(RENDER_EFFECT | flags, fn, true); } /** * @param {(...expressions: any) => void | (() => void)} fn * @param {Array<() => any>} sync * @param {Array<() => Promise<any>>} async */ export function template_effect(fn, sync = [], async = []) { flatten(sync, async, (values) => { create_effect(RENDER_EFFECT, () => fn(...values.map(get)), true); }); } /** * @param {(() => void)} fn * @param {number} flags */ export function block(fn, flags = 0) { var effect = create_effect(BLOCK_EFFECT | flags, fn, true); if (DEV) { effect.dev_stack = dev_stack; } return effect; } /** * @param {(() => void)} fn * @param {boolean} [push] */ export function branch(fn, push = true) { return create_effect(BRANCH_EFFECT, fn, true, push); } /** * @param {Effect} effect */ export function execute_effect_teardown(effect) { var teardown = effect.teardown; if (teardown !== null) { const previously_destroying_effect = is_destroying_effect; const previous_reaction = active_reaction; set_is_destroying_effect(true); set_active_reaction(null); try { teardown.call(null); } finally { set_is_destroying_effect(previously_destroying_effect); set_active_reaction(previous_reaction); } } } /** * @param {Effect} signal * @param {boolean} remove_dom * @returns {void} */ export function destroy_effect_children(signal, remove_dom = false) { var effect = signal.first; signal.first = signal.last = null; while (effect !== null) { effect.ac?.abort(STALE_REACTION); var next = effect.next; if ((effect.f & ROOT_EFFECT) !== 0) { // this is now an independent root effect.parent = null; } else { destroy_effect(effect, remove_dom); } effect = next; } } /** * @param {Effect} signal * @returns {void} */ export function destroy_block_effect_children(signal) { var effect = signal.first; while (effect !== null) { var next = effect.next; if ((effect.f & BRANCH_EFFECT) === 0) { destroy_effect(effect); } effect = next; } } /** * @param {Effect} effect * @param {boolean} [remove_dom] * @returns {void} */ export function destroy_effect(effect, remove_dom = true) { var removed = false; if ( (remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null && effect.nodes_end !== null ) { remove_effect_dom(effect.nodes_start, /** @type {TemplateNode} */ (effect.nodes_end)); removed = true; } destroy_effect_children(effect, remove_dom && !removed); remove_reactions(effect, 0); set_signal_status(effect, DESTROYED); var transitions = effect.transitions; if (transitions !== null) { for (const transition of transitions) { transition.stop(); } } execute_effect_teardown(effect); var parent = effect.parent; // If the parent doesn't have any children, then skip this work altogether if (parent !== null && parent.first !== null) { unlink_effect(effect); } if (DEV) { effect.component_function = null; } // `first` and `child` are nulled out in destroy_effect_children // we don't null out `parent` so that error propagation can work correctly effect.next = effect.prev = effect.teardown = effect.ctx = effect.deps = effect.fn = effect.nodes_start = effect.nodes_end = effect.ac = null; } /** * * @param {TemplateNode | null} node * @param {TemplateNode} end */ export function remove_effect_dom(node, end) { while (node !== null) { /** @type {TemplateNode | null} */ var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node)); node.remove(); node = next; } } /** * Detach an effect from the effect tree, freeing up memory and * reducing the amount of work that happens on subsequent traversals * @param {Effect} effect */ export function unlink_effect(effect) { var parent = effect.parent; var prev = effect.prev; var next = effect.next; if (prev !== null) prev.next = next; if (next !== null) next.prev = prev; if (parent !== null) { if (parent.first === effect) parent.first = next; if (parent.last === effect) parent.last = prev; } } /** * When a block effect is removed, we don't immediately destroy it or yank it * out of the DOM, because it might have transitions. Instead, we 'pause' it. * It stays around (in memory, and in the DOM) until outro transitions have * completed, and if the state change is reversed then we _resume_ it. * A paused effect does not update, and the DOM subtree becomes inert. * @param {Effect} effect * @param {() => void} [callback] */ export function pause_effect(effect, callback) { /** @type {TransitionManager[]} */ var transitions = []; pause_children(effect, transitions, true); run_out_transitions(transitions, () => { destroy_effect(effect); if (callback) callback(); }); } /** * @param {TransitionManager[]} transitions * @param {() => void} fn */ export function run_out_transitions(transitions, fn) { var remaining = transitions.length; if (remaining > 0) { var check = () => --remaining || fn(); for (var transition of transitions) { transition.out(check); } } else { fn(); } } /** * @param {Effect} effect * @param {TransitionManager[]} transitions * @param {boolean} local */ export function pause_children(effect, transitions, local) { if ((effect.f & INERT) !== 0) return; effect.f ^= INERT; if (effect.transitions !== null) { for (const transition of effect.transitions) { if (transition.is_global || local) { transitions.push(transition); } } } var child = effect.first; while (child !== null) { var sibling = child.next; var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0; // TODO we don't need to call pause_children recursively with a linked list in place // it's slightly more involved though as we have to account for `transparent` changing // through the tree. pause_children(child, transitions, transparent ? local : false); child = sibling; } } /** * The opposite of `pause_effect`. We call this if (for example) * `x` becomes falsy then truthy: `{#if x}...{/if}` * @param {Effect} effect */ export function resume_effect(effect) { resume_children(effect, true); } /** * @param {Effect} effect * @param {boolean} local */ function resume_children(effect, local) { if ((effect.f & INERT) === 0) return; effect.f ^= INERT; // If a dependency of this effect changed while it was paused, // schedule the effect to update. we don't use `is_dirty` // here because we don't want to eagerly recompute a derived like // `{#if foo}{foo.bar()}{/if}` if `foo` is now `undefined if ((effect.f & CLEAN) === 0) { set_signal_status(effect, DIRTY); schedule_effect(effect); } var child = effect.first; while (child !== null) { var sibling = child.next; var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0; // TODO we don't need to call resume_children recursively with a linked list in place // it's slightly more involved though as we have to account for `transparent` changing // through the tree. resume_children(child, transparent ? local : false); child = sibling; } if (effect.transitions !== null) { for (const transition of effect.transitions) { if (transition.is_global || local) { transition.in(); } } } } export function aborted() { var effect = /** @type {Effect} */ (active_effect); return (effect.f & DESTROYED) !== 0; }
```

# internal/client/reactivity/equality.js

```js
/** @import { Equals } from '#client' */ /** @type {Equals} */ export function equals(value) { return value === this.v; } /** * @param {unknown} a * @param {unknown} b * @returns {boolean} */ export function safe_not_equal(a, b) { return a != a ? b == b : a !== b || (a !== null && typeof a === 'object') || typeof a === 'function'; } /** * @param {unknown} a * @param {unknown} b * @returns {boolean} */ export function not_equal(a, b) { return a !== b; } /** @type {Equals} */ export function safe_equals(value) { return !safe_not_equal(value, this.v); }
```

# internal/client/reactivity/props.js

```js
/** @import { ComponentContext } from '#client' */ /** @import { Derived, Effect, Source } from './types.js' */ import { DEV } from 'esm-env'; import { PROPS_IS_BINDABLE, PROPS_IS_IMMUTABLE, PROPS_IS_LAZY_INITIAL, PROPS_IS_RUNES, PROPS_IS_UPDATED, UNINITIALIZED } from '../../../constants.js'; import { get_descriptor, is_function } from '../../shared/utils.js'; import { set, source, update } from './sources.js'; import { derived, derived_safe_equal } from './deriveds.js'; import { active_effect, get, is_destroying_effect, set_active_effect, untrack } from '../runtime.js'; import * as e from '../errors.js'; import { DESTROYED, LEGACY_PROPS, STATE_SYMBOL } from '#client/constants'; import { proxy } from '../proxy.js'; import { capture_store_binding } from './store.js'; import { legacy_mode_flag } from '../../flags/index.js'; /** * @param {((value?: number) => number)} fn * @param {1 | -1} [d] * @returns {number} */ export function update_prop(fn, d = 1) { const value = fn(); fn(value + d); return value; } /** * @param {((value?: number) => number)} fn * @param {1 | -1} [d] * @returns {number} */ export function update_pre_prop(fn, d = 1) { const value = fn() + d; fn(value); return value; } /** * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`). * Is passed the full `$$props` object and excludes the named props. * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}} */ const rest_props_handler = { get(target, key) { if (target.exclude.includes(key)) return; return target.props[key]; }, set(target, key) { if (DEV) { // TODO should this happen in prod too? e.props_rest_readonly(`${target.name}.${String(key)}`); } return false; }, getOwnPropertyDescriptor(target, key) { if (target.exclude.includes(key)) return; if (key in target.props) { return { enumerable: true, configurable: true, value: target.props[key] }; } }, has(target, key) { if (target.exclude.includes(key)) return false; return key in target.props; }, ownKeys(target) { return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key)); } }; /** * @param {Record<string, unknown>} props * @param {string[]} exclude * @param {string} [name] * @returns {Record<string, unknown>} */ /*#__NO_SIDE_EFFECTS__*/ export function rest_props(props, exclude, name) { return new Proxy( DEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude }, rest_props_handler ); } /** * The proxy handler for legacy $$restProps and $$props * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number>, parent_effect: Effect }>}} */ const legacy_rest_props_handler = { get(target, key) { if (target.exclude.includes(key)) return; get(target.version); return key in target.special ? target.special[key]() : target.props[key]; }, set(target, key, value) { if (!(key in target.special)) { var previous_effect = active_effect; try { set_active_effect(target.parent_effect); // Handle props that can temporarily get out of sync with the parent /** @type {Record<string, (v?: unknown) => unknown>} */ target.special[key] = prop( { get [key]() { return target.props[key]; } }, /** @type {string} */ (key), PROPS_IS_UPDATED ); } finally { set_active_effect(previous_effect); } } target.special[key](value); update(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun return true; }, getOwnPropertyDescriptor(target, key) { if (target.exclude.includes(key)) return; if (key in target.props) { return { enumerable: true, configurable: true, value: target.props[key] }; } }, deleteProperty(target, key) { // Svelte 4 allowed for deletions on $$restProps if (target.exclude.includes(key)) return true; target.exclude.push(key); update(target.version); return true; }, has(target, key) { if (target.exclude.includes(key)) return false; return key in target.props; }, ownKeys(target) { return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key)); } }; /** * @param {Record<string, unknown>} props * @param {string[]} exclude * @returns {Record<string, unknown>} */ export function legacy_rest_props(props, exclude) { return new Proxy( { props, exclude, special: {}, version: source(0), // TODO this is only necessary because we need to track component // destruction inside `prop`, because of `bind:this`, but it // seems likely that we can simplify `bind:this` instead parent_effect: /** @type {Effect} */ (active_effect) }, legacy_rest_props_handler ); } /** * The proxy handler for spread props. Handles the incoming array of props * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps * them so that the whole thing is passed to the component as the `$$props` argument. * @template {Record<string | symbol, unknown>} T * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}} */ const spread_props_handler = { get(target, key) { let i = target.props.length; while (i--) { let p = target.props[i]; if (is_function(p)) p = p(); if (typeof p === 'object' && p !== null && key in p) return p[key]; } }, set(target, key, value) { let i = target.props.length; while (i--) { let p = target.props[i]; if (is_function(p)) p = p(); const desc = get_descriptor(p, key); if (desc && desc.set) { desc.set(value); return true; } } return false; }, getOwnPropertyDescriptor(target, key) { let i = target.props.length; while (i--) { let p = target.props[i]; if (is_function(p)) p = p(); if (typeof p === 'object' && p !== null && key in p) { const descriptor = get_descriptor(p, key); if (descriptor && !descriptor.configurable) { // Prevent a "Non-configurability Report Error": The target is an array, it does // not actually contain this property. If it is now described as non-configurable, // the proxy throws a validation error. Setting it to true avoids that. descriptor.configurable = true; } return descriptor; } } }, has(target, key) { // To prevent a false positive `is_entry_props` in the `prop` function if (key === STATE_SYMBOL || key === LEGACY_PROPS) return false; for (let p of target.props) { if (is_function(p)) p = p(); if (p != null && key in p) return true; } return false; }, ownKeys(target) { /** @type {Array<string | symbol>} */ const keys = []; for (let p of target.props) { if (is_function(p)) p = p(); if (!p) continue; for (const key in p) { if (!keys.includes(key)) keys.push(key); } for (const key of Object.getOwnPropertySymbols(p)) { if (!keys.includes(key)) keys.push(key); } } return keys; } }; /** * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props * @returns {any} */ export function spread_props(...props) { return new Proxy({ props }, spread_props_handler); } /** * This function is responsible for synchronizing a possibly bound prop with the inner component state. * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value. * @template V * @param {Record<string, unknown>} props * @param {string} key * @param {number} flags * @param {V | (() => V)} [fallback] * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))} */ export function prop(props, key, flags, fallback) { var runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0; var bindable = (flags & PROPS_IS_BINDABLE) !== 0; var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0; var fallback_value = /** @type {V} */ (fallback); var fallback_dirty = true; var get_fallback = () => { if (fallback_dirty) { fallback_dirty = false; fallback_value = lazy ? untrack(/** @type {() => V} */ (fallback)) : /** @type {V} */ (fallback); } return fallback_value; }; /** @type {((v: V) => void) | undefined} */ var setter; if (bindable) { // Can be the case when someone does `mount(Component, props)` with `let props = $state({...})` // or `createClassComponent(Component, props)` var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props; setter = get_descriptor(props, key)?.set ?? (is_entry_props && key in props ? (v) => (props[key] = v) : undefined); } var initial_value; var is_store_sub = false; if (bindable) { [initial_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key])); } else { initial_value = /** @type {V} */ (props[key]); } if (initial_value === undefined && fallback !== undefined) { initial_value = get_fallback(); if (setter) { if (runes) e.props_invalid_value(key); setter(initial_value); } } /** @type {() => V} */ var getter; if (runes) { getter = () => { var value = /** @type {V} */ (props[key]); if (value === undefined) return get_fallback(); fallback_dirty = true; return value; }; } else { getter = () => { var value = /** @type {V} */ (props[key]); if (value !== undefined) { // in legacy mode, we don't revert to the fallback value // if the prop goes from defined to undefined. The easiest // way to model this is to make the fallback undefined // as soon as the prop has a value fallback_value = /** @type {V} */ (undefined); } return value === undefined ? fallback_value : value; }; } // prop is never written to — we only need a getter if (runes && (flags & PROPS_IS_UPDATED) === 0) { return getter; } // prop is written to, but the parent component had `bind:foo` which // means we can just call `$$props.foo = value` directly if (setter) { var legacy_parent = props.$$legacy; return function (/** @type {any} */ value, /** @type {boolean} */ mutation) { if (arguments.length > 0) { // We don't want to notify if the value was mutated and the parent is in runes mode. // In that case the state proxy (if it exists) should take care of the notification. // If the parent is not in runes mode, we need to notify on mutation, too, that the prop // has changed because the parent will not be able to detect the change otherwise. if (!runes || !mutation || legacy_parent || is_store_sub) { /** @type {Function} */ (setter)(mutation ? getter() : value); } return value; } return getter(); }; } // Either prop is written to, but there's no binding, which means we // create a derived that we can write to locally. // Or we are in legacy mode where we always create a derived to replicate that // Svelte 4 did not trigger updates when a primitive value was updated to the same value. var overridden = false; var d = ((flags & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(() => { overridden = false; return getter(); }); // Capture the initial value if it's bindable if (bindable) get(d); var parent_effect = /** @type {Effect} */ (active_effect); return function (/** @type {any} */ value, /** @type {boolean} */ mutation) { if (arguments.length > 0) { const new_value = mutation ? get(d) : runes && bindable ? proxy(value) : value; set(d, new_value); overridden = true; if (fallback_value !== undefined) { fallback_value = new_value; } return value; } // special case — avoid recalculating the derived if we're in a // teardown function and the prop was overridden locally, or the // component was already destroyed (this latter part is necessary // because `bind:this` can read props after the component has // been destroyed. TODO simplify `bind:this` if ((is_destroying_effect && overridden) || (parent_effect.f & DESTROYED) !== 0) { return d.v; } return get(d); }; }
```

# internal/client/reactivity/sources.js

```js
/** @import { Derived, Effect, Source, Value } from '#client' */ import { DEV } from 'esm-env'; import { active_reaction, active_effect, untracked_writes, get, set_untracked_writes, set_signal_status, untrack, increment_write_version, update_effect, current_sources, is_dirty, untracking, is_destroying_effect, push_reaction_value } from '../runtime.js'; import { equals, safe_equals } from './equality.js'; import { CLEAN, DERIVED, DIRTY, BRANCH_EFFECT, INSPECT_EFFECT, UNOWNED, MAYBE_DIRTY, BLOCK_EFFECT, ROOT_EFFECT, ASYNC } from '#client/constants'; import * as e from '../errors.js'; import { legacy_mode_flag, tracing_mode_flag } from '../../flags/index.js'; import { get_stack, tag_proxy } from '../dev/tracing.js'; import { component_context, is_runes } from '../context.js'; import { Batch, schedule_effect } from './batch.js'; import { proxy } from '../proxy.js'; import { execute_derived } from './deriveds.js'; export let inspect_effects = new Set(); /** @type {Map<Source, any>} */ export const old_values = new Map(); /** * @param {Set<any>} v */ export function set_inspect_effects(v) { inspect_effects = v; } /** * @template V * @param {V} v * @param {Error | null} [stack] * @returns {Source<V>} */ // TODO rename this to `state` throughout the codebase export function source(v, stack) { /** @type {Value} */ var signal = { f: 0, // TODO ideally we could skip this altogether, but it causes type errors v, reactions: null, equals, rv: 0, wv: 0 }; if (DEV && tracing_mode_flag) { signal.created = stack ?? get_stack('CreatedAt'); signal.updated = null; signal.set_during_effect = false; signal.trace = null; } return signal; } /** * @template V * @param {V} v * @param {Error | null} [stack] */ /*#__NO_SIDE_EFFECTS__*/ export function state(v, stack) { const s = source(v, stack); push_reaction_value(s); return s; } /** * @template V * @param {V} initial_value * @param {boolean} [immutable] * @returns {Source<V>} */ /*#__NO_SIDE_EFFECTS__*/ export function mutable_source(initial_value, immutable = false, trackable = true) { const s = source(initial_value); if (!immutable) { s.equals = safe_equals; } // bind the signal to the component context, in case we need to // track updates to trigger beforeUpdate/afterUpdate callbacks if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) { (component_context.l.s ??= []).push(s); } return s; } /** * @template V * @param {Value<V>} source * @param {V} value */ export function mutate(source, value) { set( source, untrack(() => get(source)) ); return value; } /** * @template V * @param {Source<V>} source * @param {V} value * @param {boolean} [should_proxy] * @returns {V} */ export function set(source, value, should_proxy = false) { if ( active_reaction !== null && // since we are untracking the function inside `$inspect.with` we need to add this check // to ensure we error if state is set inside an inspect effect (!untracking || (active_reaction.f & INSPECT_EFFECT) !== 0) && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | INSPECT_EFFECT)) !== 0 && !current_sources?.includes(source) ) { e.state_unsafe_mutation(); } let new_value = should_proxy ? proxy(value) : value; if (DEV) { tag_proxy(new_value, /** @type {string} */ (source.label)); } return internal_set(source, new_value); } /** * @template V * @param {Source<V>} source * @param {V} value * @returns {V} */ export function internal_set(source, value) { if (!source.equals(value)) { var old_value = source.v; if (is_destroying_effect) { old_values.set(source, value); } else { old_values.set(source, old_value); } source.v = value; const batch = Batch.ensure(); batch.capture(source, old_value); if (DEV && tracing_mode_flag) { source.updated = get_stack('UpdatedAt'); if (active_effect !== null) { source.set_during_effect = true; } } if ((source.f & DERIVED) !== 0) { // if we are assigning to a dirty derived we set it to clean/maybe dirty but we also eagerly execute it to track the dependencies if ((source.f & DIRTY) !== 0) { execute_derived(/** @type {Derived} */ (source)); } set_signal_status(source, (source.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY); } source.wv = increment_write_version(); mark_reactions(source, DIRTY); // It's possible that the current reaction might not have up-to-date dependencies // whilst it's actively running. So in the case of ensuring it registers the reaction // properly for itself, we need to ensure the current effect actually gets // scheduled. i.e: `$effect(() => x++)` if ( is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ) { if (untracked_writes === null) { set_untracked_writes([source]); } else { untracked_writes.push(source); } } if (DEV && inspect_effects.size > 0) { const inspects = Array.from(inspect_effects); for (const effect of inspects) { // Mark clean inspect-effects as maybe dirty and then check their dirtiness // instead of just updating the effects - this way we avoid overfiring. if ((effect.f & CLEAN) !== 0) { set_signal_status(effect, MAYBE_DIRTY); } if (is_dirty(effect)) { update_effect(effect); } } inspect_effects.clear(); } } return value; } /** * @template {number | bigint} T * @param {Source<T>} source * @param {1 | -1} [d] * @returns {T} */ export function update(source, d = 1) { var value = get(source); var result = d === 1 ? value++ : value--; set(source, value); // @ts-expect-error return result; } /** * @template {number | bigint} T * @param {Source<T>} source * @param {1 | -1} [d] * @returns {T} */ export function update_pre(source, d = 1) { var value = get(source); // @ts-expect-error return set(source, d === 1 ? ++value : --value); } /** * Silently (without using `get`) increment a source * @param {Source<number>} source */ export function increment(source) { set(source, source.v + 1); } /** * @param {Value} signal * @param {number} status should be DIRTY or MAYBE_DIRTY * @returns {void} */ function mark_reactions(signal, status) { var reactions = signal.reactions; if (reactions === null) return; var runes = is_runes(); var length = reactions.length; for (var i = 0; i < length; i++) { var reaction = reactions[i]; var flags = reaction.f; // Skip any effects that are already dirty if ((flags & DIRTY) !== 0) continue; // In legacy mode, skip the current effect to prevent infinite loops if (!runes && reaction === active_effect) continue; // Inspect effects need to run immediately, so that the stack trace makes sense if (DEV && (flags & INSPECT_EFFECT) !== 0) { inspect_effects.add(reaction); continue; } set_signal_status(reaction, status); // If the signal a) was previously clean or b) is an unowned derived, then mark it if ((flags & (CLEAN | UNOWNED)) !== 0) { if ((flags & DERIVED) !== 0) { mark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY); } else { schedule_effect(/** @type {Effect} */ (reaction)); } } } }
```

# internal/client/reactivity/store.js

```js
/** @import { StoreReferencesContainer } from '#client' */ /** @import { Store } from '#shared' */ import { subscribe_to_store } from '../../../store/utils.js'; import { get as get_store } from '../../../store/shared/index.js'; import { define_property, noop } from '../../shared/utils.js'; import { get } from '../runtime.js'; import { teardown } from './effects.js'; import { mutable_source, set } from './sources.js'; /** * Whether or not the prop currently being read is a store binding, as in * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in * runes mode, and skip `binding_property_non_reactive` validation */ let is_store_binding = false; let IS_UNMOUNTED = Symbol(); /** * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy * signal that will be updated when the store is. The store references container is needed to * track reassignments to stores and to track the correct component context. * @template V * @param {Store<V> | null | undefined} store * @param {string} store_name * @param {StoreReferencesContainer} stores * @returns {V} */ export function store_get(store, store_name, stores) { const entry = (stores[store_name] ??= { store: null, source: mutable_source(undefined), unsubscribe: noop }); // if the component that setup this is already unmounted we don't want to register a subscription if (entry.store !== store && !(IS_UNMOUNTED in stores)) { entry.unsubscribe(); entry.store = store ?? null; if (store == null) { entry.source.v = undefined; // see synchronous callback comment below entry.unsubscribe = noop; } else { var is_synchronous_callback = true; entry.unsubscribe = subscribe_to_store(store, (v) => { if (is_synchronous_callback) { // If the first updates to the store value (possibly multiple of them) are synchronously // inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value entry.source.v = v; } else { set(entry.source, v); } }); is_synchronous_callback = false; } } // if the component that setup this stores is already unmounted the source will be out of sync // so we just use the `get` for the stores, less performant but it avoids to create a memory leak // and it will keep the value consistent if (store && IS_UNMOUNTED in stores) { return get_store(store); } return get(entry.source); } /** * Unsubscribe from a store if it's not the same as the one in the store references container. * We need this in addition to `store_get` because someone could unsubscribe from a store but * then never subscribe to the new one (if any), causing the subscription to stay open wrongfully. * @param {Store<any> | null | undefined} store * @param {string} store_name * @param {StoreReferencesContainer} stores */ export function store_unsub(store, store_name, stores) { /** @type {StoreReferencesContainer[''] | undefined} */ let entry = stores[store_name]; if (entry && entry.store !== store) { // Don't reset store yet, so that store_get above can resubscribe to new store if necessary entry.unsubscribe(); entry.unsubscribe = noop; } return store; } /** * Sets the new value of a store and returns that value. * @template V * @param {Store<V>} store * @param {V} value * @returns {V} */ export function store_set(store, value) { store.set(value); return value; } /** * @param {StoreReferencesContainer} stores * @param {string} store_name */ export function invalidate_store(stores, store_name) { var entry = stores[store_name]; if (entry.store !== null) { store_set(entry.store, entry.source.v); } } /** * Unsubscribes from all auto-subscribed stores on destroy * @returns {[StoreReferencesContainer, ()=>void]} */ export function setup_stores() { /** @type {StoreReferencesContainer} */ const stores = {}; function cleanup() { teardown(() => { for (var store_name in stores) { const ref = stores[store_name]; ref.unsubscribe(); } define_property(stores, IS_UNMOUNTED, { enumerable: false, value: true }); }); } return [stores, cleanup]; } /** * Updates a store with a new value. * @param {Store<V>} store the store to update * @param {any} expression the expression that mutates the store * @param {V} new_value the new store value * @template V */ export function store_mutate(store, expression, new_value) { store.set(new_value); return expression; } /** * @param {Store<number>} store * @param {number} store_value * @param {1 | -1} [d] * @returns {number} */ export function update_store(store, store_value, d = 1) { store.set(store_value + d); return store_value; } /** * @param {Store<number>} store * @param {number} store_value * @param {1 | -1} [d] * @returns {number} */ export function update_pre_store(store, store_value, d = 1) { const value = store_value + d; store.set(value); return value; } /** * Called inside prop getters to communicate that the prop is a store binding */ export function mark_store_binding() { is_store_binding = true; } /** * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding. * Used to prevent `binding_property_non_reactive` validation false positives and * ensure that these props are treated as mutable even in runes mode * @template T * @param {() => T} fn * @returns {[T, boolean]} */ export function capture_store_binding(fn) { var previous_is_store_binding = is_store_binding; try { is_store_binding = false; return [fn(), is_store_binding]; } finally { is_store_binding = previous_is_store_binding; } }
```

# internal/client/reactivity/types.d.ts

```ts
import type { ComponentContext, DevStackEntry, Equals, TemplateNode, TransitionManager } from '#client'; import type { Boundary } from '../dom/blocks/boundary'; export interface Signal { /** Flags bitmask */ f: number; /** Write version */ wv: number; } export interface Value<V = unknown> extends Signal { /** Equality function */ equals: Equals; /** Signals that read from this signal */ reactions: null | Reaction[]; /** Read version */ rv: number; /** The latest value for this signal */ v: V; // dev-only /** A label (e.g. the `foo` in `let foo = $state(...)`) used for `$inspect.trace()` */ label?: string; /** An error with a stack trace showing when the source was created */ created?: Error | null; /** An error with a stack trace showing when the source was last updated */ updated?: Error | null; /** * Whether or not the source was set while running an effect — if so, we need to * increment the write version so that it shows up as dirty when the effect re-runs */ set_during_effect?: boolean; /** A function that retrieves the underlying source, used for each block item signals */ trace?: null | (() => void); } export interface Reaction extends Signal { /** The associated component context */ ctx: null | ComponentContext; /** The reaction function */ fn: null | Function; /** Signals that this signal reads from */ deps: null | Value[]; /** An AbortController that aborts when the signal is destroyed */ ac: null | AbortController; } export interface Derived<V = unknown> extends Value<V>, Reaction { /** The derived function */ fn: () => V; /** Effects created inside this signal */ effects: null | Effect[]; /** Parent effect or derived */ parent: Effect | Derived | null; } export interface Effect extends Reaction { /** * Branch effects store their start/end nodes so that they can be * removed when the effect is destroyed, or moved when an `each` * block is reconciled. In the case of a single text/element node, * `start` and `end` will be the same. */ nodes_start: null | TemplateNode; nodes_end: null | TemplateNode; /** The effect function */ fn: null | (() => void | (() => void)); /** The teardown function returned from the effect function */ teardown: null | (() => void); /** Transition managers created with `$.transition` */ transitions: null | TransitionManager[]; /** Next sibling child effect created inside the parent signal */ prev: null | Effect; /** Next sibling child effect created inside the parent signal */ next: null | Effect; /** First child effect created inside this signal */ first: null | Effect; /** Last child effect created inside this signal */ last: null | Effect; /** Parent effect */ parent: Effect | null; /** The boundary this effect belongs to */ b: Boundary | null; /** Dev only */ component_function?: any; /** Dev only. Only set for certain block effects. Contains a reference to the stack that represents the render tree */ dev_stack?: DevStackEntry | null; } export type Source<V = unknown> = Value<V>; export type MaybeSource<T = unknown> = T | Source<T>;
```

# internal/client/render.js

```js
/** @import { ComponentContext, Effect, TemplateNode } from '#client' */ /** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */ import { DEV } from 'esm-env'; import { clear_text_content, create_text, get_first_child, get_next_sibling, init_operations } from './dom/operations.js'; import { HYDRATION_END, HYDRATION_ERROR, HYDRATION_START } from '../../constants.js'; import { active_effect } from './runtime.js'; import { push, pop, component_context } from './context.js'; import { component_root, branch } from './reactivity/effects.js'; import { hydrate_next, hydrate_node, hydrating, set_hydrate_node, set_hydrating } from './dom/hydration.js'; import { array_from } from '../shared/utils.js'; import { all_registered_events, handle_event_propagation, root_event_handles } from './dom/elements/events.js'; import { reset_head_anchor } from './dom/blocks/svelte-head.js'; import * as w from './warnings.js'; import * as e from './errors.js'; import { assign_nodes } from './dom/template.js'; import { is_passive_event } from '../../utils.js'; import { COMMENT_NODE } from './constants.js'; /** * This is normally true — block effects should run their intro transitions — * but is false during hydration (unless `options.intro` is `true`) and * when creating the children of a `<svelte:element>` that just changed tag */ export let should_intro = true; /** @param {boolean} value */ export function set_should_intro(value) { should_intro = value; } /** * @param {Element} text * @param {string} value * @returns {void} */ export function set_text(text, value) { // For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing var str = value == null ? '' : typeof value === 'object' ? value + '' : value; // @ts-expect-error if (str !== (text.__t ??= text.nodeValue)) { // @ts-expect-error text.__t = str; text.nodeValue = str + ''; } } /** * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component. * Transitions will play during the initial render unless the `intro` option is set to `false`. * * @template {Record<string, any>} Props * @template {Record<string, any>} Exports * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component * @param {MountOptions<Props>} options * @returns {Exports} */ export function mount(component, options) { return _mount(component, options); } /** * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component * * @template {Record<string, any>} Props * @template {Record<string, any>} Exports * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component * @param {{} extends Props ? { * target: Document | Element | ShadowRoot; * props?: Props; * events?: Record<string, (e: any) => any>; * context?: Map<any, any>; * intro?: boolean; * recover?: boolean; * } : { * target: Document | Element | ShadowRoot; * props: Props; * events?: Record<string, (e: any) => any>; * context?: Map<any, any>; * intro?: boolean; * recover?: boolean; * }} options * @returns {Exports} */ export function hydrate(component, options) { init_operations(); options.intro = options.intro ?? false; const target = options.target; const was_hydrating = hydrating; const previous_hydrate_node = hydrate_node; try { var anchor = /** @type {TemplateNode} */ (get_first_child(target)); while ( anchor && (anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */ (anchor).data !== HYDRATION_START) ) { anchor = /** @type {TemplateNode} */ (get_next_sibling(anchor)); } if (!anchor) { throw HYDRATION_ERROR; } set_hydrating(true); set_hydrate_node(/** @type {Comment} */ (anchor)); hydrate_next(); const instance = _mount(component, { ...options, anchor }); if ( hydrate_node === null || hydrate_node.nodeType !== COMMENT_NODE || /** @type {Comment} */ (hydrate_node).data !== HYDRATION_END ) { w.hydration_mismatch(); throw HYDRATION_ERROR; } set_hydrating(false); return /** @type {Exports} */ (instance); } catch (error) { if (error === HYDRATION_ERROR) { if (options.recover === false) { e.hydration_failed(); } // If an error occured above, the operations might not yet have been initialised. init_operations(); clear_text_content(target); set_hydrating(false); return mount(component, options); } throw error; } finally { set_hydrating(was_hydrating); set_hydrate_node(previous_hydrate_node); reset_head_anchor(); } } /** @type {Map<string, number>} */ const document_listeners = new Map(); /** * @template {Record<string, any>} Exports * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component * @param {MountOptions} options * @returns {Exports} */ function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) { init_operations(); var registered_events = new Set(); /** @param {Array<string>} events */ var event_handle = (events) => { for (var i = 0; i < events.length; i++) { var event_name = events[i]; if (registered_events.has(event_name)) continue; registered_events.add(event_name); var passive = is_passive_event(event_name); // Add the event listener to both the container and the document. // The container listener ensures we catch events from within in case // the outer content stops propagation of the event. target.addEventListener(event_name, handle_event_propagation, { passive }); var n = document_listeners.get(event_name); if (n === undefined) { // The document listener ensures we catch events that originate from elements that were // manually moved outside of the container (e.g. via manual portals). document.addEventListener(event_name, handle_event_propagation, { passive }); document_listeners.set(event_name, 1); } else { document_listeners.set(event_name, n + 1); } } }; event_handle(array_from(all_registered_events)); root_event_handles.add(event_handle); /** @type {Exports} */ // @ts-expect-error will be defined because the render effect runs synchronously var component = undefined; var unmount = component_root(() => { var anchor_node = anchor ?? target.appendChild(create_text()); branch(() => { if (context) { push({}); var ctx = /** @type {ComponentContext} */ (component_context); ctx.c = context; } if (events) { // We can't spread the object or else we'd lose the state proxy stuff, if it is one /** @type {any} */ (props).$$events = events; } if (hydrating) { assign_nodes(/** @type {TemplateNode} */ (anchor_node), null); } should_intro = intro; // @ts-expect-error the public typings are not what the actual function looks like component = Component(anchor_node, props) || {}; should_intro = true; if (hydrating) { /** @type {Effect} */ (active_effect).nodes_end = hydrate_node; } if (context) { pop(); } }); return () => { for (var event_name of registered_events) { target.removeEventListener(event_name, handle_event_propagation); var n = /** @type {number} */ (document_listeners.get(event_name)); if (--n === 0) { document.removeEventListener(event_name, handle_event_propagation); document_listeners.delete(event_name); } else { document_listeners.set(event_name, n); } } root_event_handles.delete(event_handle); if (anchor_node !== anchor) { anchor_node.parentNode?.removeChild(anchor_node); } }; }); mounted_components.set(component, unmount); return component; } /** * References of the components that were mounted or hydrated. * Uses a `WeakMap` to avoid memory leaks. */ let mounted_components = new WeakMap(); /** * Unmounts a component that was previously mounted using `mount` or `hydrate`. * * Since 5.13.0, if `options.outro` is `true`, [transitions](https://svelte.dev/docs/svelte/transition) will play before the component is removed from the DOM. * * Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`). * * \`\`\`js * import { mount, unmount } from 'svelte'; * import App from './App.svelte'; * * const app = mount(App, { target: document.body }); * * // later... * unmount(app, { outro: true }); * \`\`\` * @param {Record<string, any>} component * @param {{ outro?: boolean }} [options] * @returns {Promise<void>} */ export function unmount(component, options) { const fn = mounted_components.get(component); if (fn) { mounted_components.delete(component); return fn(options); } if (DEV) { w.lifecycle_double_unmount(); } return Promise.resolve(); }
```

# internal/client/runtime.js

```js
/** @import { Derived, Effect, Reaction, Signal, Source, Value } from '#client' */ import { DEV } from 'esm-env'; import { get_descriptors, get_prototype_of, index_of } from '../shared/utils.js'; import { destroy_block_effect_children, destroy_effect_children, execute_effect_teardown } from './reactivity/effects.js'; import { DIRTY, MAYBE_DIRTY, CLEAN, DERIVED, UNOWNED, DESTROYED, BRANCH_EFFECT, STATE_SYMBOL, BLOCK_EFFECT, ROOT_EFFECT, DISCONNECTED, REACTION_IS_UPDATING, STALE_REACTION, ERROR_VALUE } from './constants.js'; import { internal_set, old_values } from './reactivity/sources.js'; import { destroy_derived_effects, execute_derived, current_async_effect, recent_async_deriveds, update_derived } from './reactivity/deriveds.js'; import { async_mode_flag, tracing_mode_flag } from '../flags/index.js'; import { tracing_expressions, get_stack } from './dev/tracing.js'; import { component_context, dev_current_component_function, dev_stack, is_runes, set_component_context, set_dev_current_component_function, set_dev_stack } from './context.js'; import * as w from './warnings.js'; import { Batch, batch_deriveds, dev_effect_stack, flushSync, schedule_effect } from './reactivity/batch.js'; import { handle_error } from './error-handling.js'; import { UNINITIALIZED } from '../../constants.js'; export let is_updating_effect = false; /** @param {boolean} value */ export function set_is_updating_effect(value) { is_updating_effect = value; } export let is_destroying_effect = false; /** @param {boolean} value */ export function set_is_destroying_effect(value) { is_destroying_effect = value; } /** @type {null | Reaction} */ export let active_reaction = null; export let untracking = false; /** @param {null | Reaction} reaction */ export function set_active_reaction(reaction) { active_reaction = reaction; } /** @type {null | Effect} */ export let active_effect = null; /** @param {null | Effect} effect */ export function set_active_effect(effect) { active_effect = effect; } /** * When sources are created within a reaction, reading and writing * them within that reaction should not cause a re-run * @type {null | Source[]} */ export let current_sources = null; /** @param {Value} value */ export function push_reaction_value(value) { if (active_reaction !== null && (!async_mode_flag || (active_reaction.f & DERIVED) !== 0)) { if (current_sources === null) { current_sources = [value]; } else { current_sources.push(value); } } } /** * The dependencies of the reaction that is currently being executed. In many cases, * the dependencies are unchanged between runs, and so this will be `null` unless * and until a new dependency is accessed — we track this via `skipped_deps` * @type {null | Value[]} */ let new_deps = null; let skipped_deps = 0; /** * Tracks writes that the effect it's executed in doesn't listen to yet, * so that the dependency can be added to the effect later on if it then reads it * @type {null | Source[]} */ export let untracked_writes = null; /** @param {null | Source[]} value */ export function set_untracked_writes(value) { untracked_writes = value; } /** * @type {number} Used by sources and deriveds for handling updates. * Version starts from 1 so that unowned deriveds differentiate between a created effect and a run one for tracing **/ export let write_version = 1; /** @type {number} Used to version each read of a source of derived to avoid duplicating depedencies inside a reaction */ let read_version = 0; export let update_version = read_version; /** @param {number} value */ export function set_update_version(value) { update_version = value; } // If we are working with a get() chain that has no active container, // to prevent memory leaks, we skip adding the reaction. export let skip_reaction = false; // Handle collecting all signals which are read during a specific time frame /** @type {Set<Value> | null} */ export let captured_signals = null; /** @param {Set<Value> | null} value */ export function set_captured_signals(value) { captured_signals = value; } export function increment_write_version() { return ++write_version; } /** * Determines whether a derived or effect is dirty. * If it is MAYBE_DIRTY, will set the status to CLEAN * @param {Reaction} reaction * @returns {boolean} */ export function is_dirty(reaction) { var flags = reaction.f; if ((flags & DIRTY) !== 0) { return true; } if ((flags & MAYBE_DIRTY) !== 0) { var dependencies = reaction.deps; var is_unowned = (flags & UNOWNED) !== 0; if (dependencies !== null) { var i; var dependency; var is_disconnected = (flags & DISCONNECTED) !== 0; var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction; var length = dependencies.length; // If we are working with a disconnected or an unowned signal that is now connected (due to an active effect) // then we need to re-connect the reaction to the dependency, unless the effect has already been destroyed // (which can happen if the derived is read by an async derived) if ( (is_disconnected || is_unowned_connected) && (active_effect === null || (active_effect.f & DESTROYED) === 0) ) { var derived = /** @type {Derived} */ (reaction); var parent = derived.parent; for (i = 0; i < length; i++) { dependency = dependencies[i]; // We always re-add all reactions (even duplicates) if the derived was // previously disconnected, however we don't if it was unowned as we // de-duplicate dependencies in that case if (is_disconnected || !dependency?.reactions?.includes(derived)) { (dependency.reactions ??= []).push(derived); } } if (is_disconnected) { derived.f ^= DISCONNECTED; } // If the unowned derived is now fully connected to the graph again (it's unowned and reconnected, has a parent // and the parent is not unowned), then we can mark it as connected again, removing the need for the unowned // flag if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) { derived.f ^= UNOWNED; } } for (i = 0; i < length; i++) { dependency = dependencies[i]; if (is_dirty(/** @type {Derived} */ (dependency))) { update_derived(/** @type {Derived} */ (dependency)); } if (dependency.wv > reaction.wv) { return true; } } } // Unowned signals should never be marked as clean unless they // are used within an active_effect without skip_reaction if (!is_unowned || (active_effect !== null && !skip_reaction)) { set_signal_status(reaction, CLEAN); } } return false; } /** * @param {Value} signal * @param {Effect} effect * @param {boolean} [root] */ function schedule_possible_effect_self_invalidation(signal, effect, root = true) { var reactions = signal.reactions; if (reactions === null) return; if (!async_mode_flag && current_sources?.includes(signal)) { return; } for (var i = 0; i < reactions.length; i++) { var reaction = reactions[i]; if ((reaction.f & DERIVED) !== 0) { schedule_possible_effect_self_invalidation(/** @type {Derived} */ (reaction), effect, false); } else if (effect === reaction) { if (root) { set_signal_status(reaction, DIRTY); } else if ((reaction.f & CLEAN) !== 0) { set_signal_status(reaction, MAYBE_DIRTY); } schedule_effect(/** @type {Effect} */ (reaction)); } } } /** @param {Reaction} reaction */ export function update_reaction(reaction) { var previous_deps = new_deps; var previous_skipped_deps = skipped_deps; var previous_untracked_writes = untracked_writes; var previous_reaction = active_reaction; var previous_skip_reaction = skip_reaction; var previous_sources = current_sources; var previous_component_context = component_context; var previous_untracking = untracking; var previous_update_version = update_version; var flags = reaction.f; new_deps = /** @type {null | Value[]} */ (null); skipped_deps = 0; untracked_writes = null; skip_reaction = (flags & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null); active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null; current_sources = null; set_component_context(reaction.ctx); untracking = false; update_version = ++read_version; if (reaction.ac !== null) { reaction.ac.abort(STALE_REACTION); reaction.ac = null; } try { reaction.f |= REACTION_IS_UPDATING; var result = /** @type {Function} */ (0, reaction.fn)(); var deps = reaction.deps; if (new_deps !== null) { var i; remove_reactions(reaction, skipped_deps); if (deps !== null && skipped_deps > 0) { deps.length = skipped_deps + new_deps.length; for (i = 0; i < new_deps.length; i++) { deps[skipped_deps + i] = new_deps[i]; } } else { reaction.deps = deps = new_deps; } if ( !skip_reaction || // Deriveds that already have reactions can cleanup, so we still add them as reactions ((flags & DERIVED) !== 0 && /** @type {import('#client').Derived} */ (reaction).reactions !== null) ) { for (i = skipped_deps; i < deps.length; i++) { (deps[i].reactions ??= []).push(reaction); } } } else if (deps !== null && skipped_deps < deps.length) { remove_reactions(reaction, skipped_deps); deps.length = skipped_deps; } // If we're inside an effect and we have untracked writes, then we need to // ensure that if any of those untracked writes result in re-invalidation // of the current effect, then that happens accordingly if ( is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0 ) { for (i = 0; i < /** @type {Source[]} */ (untracked_writes).length; i++) { schedule_possible_effect_self_invalidation( untracked_writes[i], /** @type {Effect} */ (reaction) ); } } // If we are returning to an previous reaction then // we need to increment the read version to ensure that // any dependencies in this reaction aren't marked with // the same version if (previous_reaction !== null && previous_reaction !== reaction) { read_version++; if (untracked_writes !== null) { if (previous_untracked_writes === null) { previous_untracked_writes = untracked_writes; } else { previous_untracked_writes.push(.../** @type {Source[]} */ (untracked_writes)); } } } if ((reaction.f & ERROR_VALUE) !== 0) { reaction.f ^= ERROR_VALUE; } return result; } catch (error) { return handle_error(error); } finally { reaction.f ^= REACTION_IS_UPDATING; new_deps = previous_deps; skipped_deps = previous_skipped_deps; untracked_writes = previous_untracked_writes; active_reaction = previous_reaction; skip_reaction = previous_skip_reaction; current_sources = previous_sources; set_component_context(previous_component_context); untracking = previous_untracking; update_version = previous_update_version; } } /** * @template V * @param {Reaction} signal * @param {Value<V>} dependency * @returns {void} */ function remove_reaction(signal, dependency) { let reactions = dependency.reactions; if (reactions !== null) { var index = index_of.call(reactions, signal); if (index !== -1) { var new_length = reactions.length - 1; if (new_length === 0) { reactions = dependency.reactions = null; } else { // Swap with last element and then remove. reactions[index] = reactions[new_length]; reactions.pop(); } } } // If the derived has no reactions, then we can disconnect it from the graph, // allowing it to either reconnect in the future, or be GC'd by the VM. if ( reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps` // allows us to skip the expensive work of disconnecting and immediately reconnecting it (new_deps === null || !new_deps.includes(dependency)) ) { set_signal_status(dependency, MAYBE_DIRTY); // If we are working with a derived that is owned by an effect, then mark it as being // disconnected. if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) { dependency.f ^= DISCONNECTED; } // Disconnect any reactions owned by this reaction destroy_derived_effects(/** @type {Derived} **/ (dependency)); remove_reactions(/** @type {Derived} **/ (dependency), 0); } } /** * @param {Reaction} signal * @param {number} start_index * @returns {void} */ export function remove_reactions(signal, start_index) { var dependencies = signal.deps; if (dependencies === null) return; for (var i = start_index; i < dependencies.length; i++) { remove_reaction(signal, dependencies[i]); } } /** * @param {Effect} effect * @returns {void} */ export function update_effect(effect) { var flags = effect.f; if ((flags & DESTROYED) !== 0) { return; } set_signal_status(effect, CLEAN); var previous_effect = active_effect; var was_updating_effect = is_updating_effect; active_effect = effect; is_updating_effect = true; if (DEV) { var previous_component_fn = dev_current_component_function; set_dev_current_component_function(effect.component_function); var previous_stack = /** @type {any} */ (dev_stack); // only block effects have a dev stack, keep the current one otherwise set_dev_stack(effect.dev_stack ?? dev_stack); } try { if ((flags & BLOCK_EFFECT) !== 0) { destroy_block_effect_children(effect); } else { destroy_effect_children(effect); } execute_effect_teardown(effect); var teardown = update_reaction(effect); effect.teardown = typeof teardown === 'function' ? teardown : null; effect.wv = write_version; // In DEV, increment versions of any sources that were written to during the effect, // so that they are correctly marked as dirty when the effect re-runs if (DEV && tracing_mode_flag && (effect.f & DIRTY) !== 0 && effect.deps !== null) { for (var dep of effect.deps) { if (dep.set_during_effect) { dep.wv = increment_write_version(); dep.set_during_effect = false; } } } if (DEV) { dev_effect_stack.push(effect); } } finally { is_updating_effect = was_updating_effect; active_effect = previous_effect; if (DEV) { set_dev_current_component_function(previous_component_fn); set_dev_stack(previous_stack); } } } /** * Returns a promise that resolves once any pending state changes have been applied. * @returns {Promise<void>} */ export async function tick() { if (async_mode_flag) { return new Promise((f) => requestAnimationFrame(() => f())); } await Promise.resolve(); // By calling flushSync we guarantee that any pending state changes are applied after one tick. // TODO look into whether we can make flushing subsequent updates synchronously in the future. flushSync(); } /** * Returns a promise that resolves once any state changes, and asynchronous work resulting from them, * have resolved and the DOM has been updated * @returns {Promise<void>} */ export function settled() { return Batch.ensure().settled(); } /** * @template V * @param {Value<V>} signal * @returns {V} */ export function get(signal) { var flags = signal.f; var is_derived = (flags & DERIVED) !== 0; if (captured_signals !== null) { captured_signals.add(signal); } // Register the dependency on the current reaction signal. if (active_reaction !== null && !untracking) { // if we're in a derived that is being read inside an _async_ derived, // it's possible that the effect was already destroyed. In this case, // we don't add the dependency, because that would create a memory leak var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0; if (!destroyed && !current_sources?.includes(signal)) { var deps = active_reaction.deps; if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) { // we're in the effect init/update cycle if (signal.rv < read_version) { signal.rv = read_version; // If the signal is accessing the same dependencies in the same // order as it did last time, increment `skipped_deps` // rather than updating `new_deps`, which creates GC cost if (new_deps === null && deps !== null && deps[skipped_deps] === signal) { skipped_deps++; } else if (new_deps === null) { new_deps = [signal]; } else if (!skip_reaction || !new_deps.includes(signal)) { // Normally we can push duplicated dependencies to `new_deps`, but if we're inside // an unowned derived because skip_reaction is true, then we need to ensure that // we don't have duplicates new_deps.push(signal); } } } else { // we're adding a dependency outside the init/update cycle // (i.e. after an `await`) (active_reaction.deps ??= []).push(signal); var reactions = signal.reactions; if (reactions === null) { signal.reactions = [active_reaction]; } else if (!reactions.includes(active_reaction)) { reactions.push(active_reaction); } } } } else if ( is_derived && /** @type {Derived} */ (signal).deps === null && /** @type {Derived} */ (signal).effects === null ) { var derived = /** @type {Derived} */ (signal); var parent = derived.parent; if (parent !== null && (parent.f & UNOWNED) === 0) { // If the derived is owned by another derived then mark it as unowned // as the derived value might have been referenced in a different context // since and thus its parent might not be its true owner anymore derived.f ^= UNOWNED; } } if (DEV) { if (current_async_effect) { var tracking = (current_async_effect.f & REACTION_IS_UPDATING) !== 0; var was_read = current_async_effect.deps?.includes(signal); if (!tracking && !was_read) { w.await_reactivity_loss(/** @type {string} */ (signal.label)); var trace = get_stack('TracedAt'); // eslint-disable-next-line no-console if (trace) console.warn(trace); } } recent_async_deriveds.delete(signal); if ( tracing_mode_flag && !untracking && tracing_expressions !== null && active_reaction !== null && tracing_expressions.reaction === active_reaction ) { // Used when mapping state between special blocks like `each` if (signal.trace) { signal.trace(); } else { trace = get_stack('TracedAt'); if (trace) { var entry = tracing_expressions.entries.get(signal); if (entry === undefined) { entry = { traces: [] }; tracing_expressions.entries.set(signal, entry); } var last = entry.traces[entry.traces.length - 1]; // traces can be duplicated, e.g. by `snapshot` invoking both // both `getOwnPropertyDescriptor` and `get` traps at once if (trace.stack !== last?.stack) { entry.traces.push(trace); } } } } } if (is_destroying_effect) { if (old_values.has(signal)) { return old_values.get(signal); } if (is_derived) { derived = /** @type {Derived} */ (signal); var value = derived.v; // if the derived is dirty, or depends on the values that just changed, re-execute if ((derived.f & CLEAN) !== 0 || depends_on_old_values(derived)) { value = execute_derived(derived); } old_values.set(derived, value); return value; } } else if (is_derived) { derived = /** @type {Derived} */ (signal); if (batch_deriveds?.has(derived)) { return batch_deriveds.get(derived); } if (is_dirty(derived)) { update_derived(derived); } } if ((signal.f & ERROR_VALUE) !== 0) { throw signal.v; } return signal.v; } /** @param {Derived} derived */ function depends_on_old_values(derived) { if (derived.v === UNINITIALIZED) return true; // we don't know, so assume the worst if (derived.deps === null) return false; for (const dep of derived.deps) { if (old_values.has(dep)) { return true; } if ((dep.f & DERIVED) !== 0 && depends_on_old_values(/** @type {Derived} */ (dep))) { return true; } } return false; } /** * Like `get`, but checks for `undefined`. Used for `var` declarations because they can be accessed before being declared * @template V * @param {Value<V> | undefined} signal * @returns {V | undefined} */ export function safe_get(signal) { return signal && get(signal); } /** * Capture an array of all the signals that are read when `fn` is called * @template T * @param {() => T} fn */ function capture_signals(fn) { var previous_captured_signals = captured_signals; captured_signals = new Set(); var captured = captured_signals; var signal; try { untrack(fn); if (previous_captured_signals !== null) { for (signal of captured_signals) { previous_captured_signals.add(signal); } } } finally { captured_signals = previous_captured_signals; } return captured; } /** * Invokes a function and captures all signals that are read during the invocation, * then invalidates them. * @param {() => any} fn */ export function invalidate_inner_signals(fn) { var captured = capture_signals(() => untrack(fn)); for (var signal of captured) { internal_set(signal, signal.v); } } /** * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect), * any state read inside `fn` will not be treated as a dependency. * * \`\`\`ts * $effect(() => { * // this will run when `data` changes, but not when `time` changes * save(data, { * timestamp: untrack(() => time) * }); * }); * \`\`\` * @template T * @param {() => T} fn * @returns {T} */ export function untrack(fn) { var previous_untracking = untracking; try { untracking = true; return fn(); } finally { untracking = previous_untracking; } } const STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN); /** * @param {Signal} signal * @param {number} status * @returns {void} */ export function set_signal_status(signal, status) { signal.f = (signal.f & STATUS_MASK) | status; } /** * @param {Record<string, unknown>} obj * @param {string[]} keys * @returns {Record<string, unknown>} */ export function exclude_from_object(obj, keys) { /** @type {Record<string, unknown>} */ var result = {}; for (var key in obj) { if (!keys.includes(key)) { result[key] = obj[key]; } } return result; } /** * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`. * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases). * @param {any} value * @returns {void} */ export function deep_read_state(value) { if (typeof value !== 'object' || !value || value instanceof EventTarget) { return; } if (STATE_SYMBOL in value) { deep_read(value); } else if (!Array.isArray(value)) { for (let key in value) { const prop = value[key]; if (typeof prop === 'object' && prop && STATE_SYMBOL in prop) { deep_read(prop); } } } } /** * Deeply traverse an object and read all its properties * so that they're all reactive in case this is `$state` * @param {any} value * @param {Set<any>} visited * @returns {void} */ export function deep_read(value, visited = new Set()) { if ( typeof value === 'object' && value !== null && // We don't want to traverse DOM elements !(value instanceof EventTarget) && !visited.has(value) ) { visited.add(value); // When working with a possible SvelteDate, this // will ensure we capture changes to it. if (value instanceof Date) { value.getTime(); } for (let key in value) { try { deep_read(value[key], visited); } catch (e) { // continue } } const proto = get_prototype_of(value); if ( proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype ) { const descriptors = get_descriptors(proto); for (let key in descriptors) { const get = descriptors[key].get; if (get) { try { get.call(value); } catch (e) { // continue } } } } } }
```

# internal/client/timing.js

```js
/** @import { Raf } from '#client' */ import { noop } from '../shared/utils.js'; import { BROWSER } from 'esm-env'; const now = BROWSER ? () => performance.now() : () => Date.now(); /** @type {Raf} */ export const raf = { // don't access requestAnimationFrame eagerly outside method // this allows basic testing of user code without JSDOM // bunder will eval and remove ternary when the user's app is built tick: /** @param {any} _ */ (_) => (BROWSER ? requestAnimationFrame : noop)(_), now: () => now(), tasks: new Set() };
```

# internal/client/types.d.ts

```ts
import type { Store } from '#shared'; import { STATE_SYMBOL } from './constants.js'; import type { Effect, Source, Value, Reaction } from './reactivity/types.js'; type EventCallback = (event: Event) => boolean; export type EventCallbackMap = Record<string, EventCallback | EventCallback[]>; // For all the core internal objects, we use single-character property strings. // This not only reduces code-size and parsing, but it also improves the performance // when the JS VM JITs the code. export type ComponentContext = { /** parent */ p: null | ComponentContext; /** context */ c: null | Map<unknown, unknown>; /** deferred effects */ e: null | Array<() => void | (() => void)>; /** * props — needed for legacy mode lifecycle functions, and for `createEventDispatcher` * @deprecated remove in 6.0 */ s: Record<string, unknown>; /** * exports (and props, if `accessors: true`) — needed for `createEventDispatcher` * @deprecated remove in 6.0 */ x: Record<string, any> | null; /** * legacy stuff * @deprecated remove in 6.0 */ l: null | { /** local signals (needed for beforeUpdate/afterUpdate) */ s: null | Source[]; /** update_callbacks */ u: null | { /** afterUpdate callbacks */ a: Array<() => void>; /** beforeUpdate callbacks */ b: Array<() => void>; /** onMount callbacks */ m: Array<() => any>; }; /** `$:` statements */ $: any[]; }; /** * dev mode only: the component function */ function?: any; }; export type ComponentContextLegacy = ComponentContext & { l: NonNullable<ComponentContext['l']>; }; export type Equals = (this: Value, value: unknown) => boolean; export type TemplateNode = Text | Element | Comment; export type Dom = TemplateNode | TemplateNode[]; export type EachState = { /** flags */ flags: number; /** a key -> item lookup */ items: Map<any, EachItem>; /** head of the linked list of items */ first: EachItem | null; }; export type EachItem = { /** animation manager */ a: AnimationManager | null; /** effect */ e: Effect; /** item */ v: any | Source<any>; /** index */ i: number | Source<number>; /** key */ k: unknown; prev: EachItem | null; next: EachItem | null; }; export interface TransitionManager { /** Whether the `global` modifier was used (i.e. `transition:fade|global`) */ is_global: boolean; /** Called inside `resume_effect` */ in: () => void; /** Called inside `pause_effect` */ out: (callback?: () => void) => void; /** Called inside `destroy_effect` */ stop: () => void; } export interface AnimationManager { /** An element with an `animate:` directive */ element: Element; /** Called during keyed each block reconciliation, before updates */ measure: () => void; /** Called during keyed each block reconciliation, after updates — this triggers the animation */ apply: () => void; /** Fix the element position, so that siblings can move to the correct destination */ fix: () => void; /** Unfix the element position if the outro is aborted */ unfix: () => void; } export interface Animation { /** Abort the animation */ abort: () => void; /** Allow the animation to continue running, but remove any callback. This prevents the removal of an outroing block if the corresponding intro has a `delay` */ deactivate: () => void; /** Resets an animation to its starting state, if it uses `tick`. Exposed as a separate method so that an aborted `out:` can still reset even if the `outro` had already completed */ reset: () => void; /** Get the `t` value (between `0` and `1`) of the animation, so that its counterpart can start from the right place */ t: () => number; } export type TransitionFn<P> = ( element: Element, props: P, options: { direction?: 'in' | 'out' | 'both' } ) => AnimationConfig | ((options: { direction?: 'in' | 'out' }) => AnimationConfig); export type AnimateFn<P> = ( element: Element, rects: { from: DOMRect; to: DOMRect }, props: P ) => AnimationConfig; export type AnimationConfig = { delay?: number; duration?: number; easing?: (t: number) => number; css?: (t: number, u: number) => string; tick?: (t: number, u: number) => string; }; export type StoreReferencesContainer = Record< string, { store: Store<any> | null; unsubscribe: Function; source: Source<any>; } >; export type ActionPayload<P> = { destroy?: () => void; update?: (value: P) => void }; export type Raf = { /** Alias for `requestAnimationFrame`, exposed in such a way that we can override in tests */ tick: (callback: (time: DOMHighResTimeStamp) => void) => any; /** Alias for `performance.now()`, exposed in such a way that we can override in tests */ now: () => number; /** A set of tasks that will run to completion, unless aborted */ tasks: Set<TaskEntry>; }; export interface Task { abort(): void; promise: Promise<void>; } export type TaskCallback = (now: number) => boolean | void; export type TaskEntry = { c: TaskCallback; f: () => void }; export type ProxyStateObject<T = Record<string | symbol, any>> = T & { [STATE_SYMBOL]: T; }; export type SourceLocation = | [line: number, column: number] | [line: number, column: number, SourceLocation[]]; export interface DevStackEntry { file: string; type: 'component' | 'if' | 'each' | 'await' | 'key' | 'render'; line: number; column: number; parent: DevStackEntry | null; componentTag?: string; } export * from './reactivity/types';
```

# internal/client/validate.js

```js
import { dev_current_component_function } from './context.js'; import { is_array } from '../shared/utils.js'; import * as e from './errors.js'; import { FILENAME } from '../../constants.js'; import { render_effect } from './reactivity/effects.js'; import * as w from './warnings.js'; import { capture_store_binding } from './reactivity/store.js'; /** * @param {() => any} collection * @param {(item: any, index: number) => string} key_fn * @returns {void} */ export function validate_each_keys(collection, key_fn) { render_effect(() => { const keys = new Map(); const maybe_array = collection(); const array = is_array(maybe_array) ? maybe_array : maybe_array == null ? [] : Array.from(maybe_array); const length = array.length; for (let i = 0; i < length; i++) { const key = key_fn(array[i], i); if (keys.has(key)) { const a = String(keys.get(key)); const b = String(i); /** @type {string | null} */ let k = String(key); if (k.startsWith('[object ')) k = null; e.each_key_duplicate(a, b, k); } keys.set(key, i); } }); } /** * @param {string} binding * @param {() => Record<string, any>} get_object * @param {() => string} get_property * @param {number} line * @param {number} column */ export function validate_binding(binding, get_object, get_property, line, column) { var warned = false; var filename = dev_current_component_function?.[FILENAME]; render_effect(() => { if (warned) return; var [object, is_store_sub] = capture_store_binding(get_object); if (is_store_sub) return; var property = get_property(); var ran = false; // by making the (possibly false, but it would be an extreme edge case) assumption // that a getter has a corresponding setter, we can determine if a property is // reactive by seeing if this effect has dependencies var effect = render_effect(() => { if (ran) return; // eslint-disable-next-line @typescript-eslint/no-unused-expressions object[property]; }); ran = true; if (effect.deps === null) { var location = `${filename}:${line}:${column}`; w.binding_property_non_reactive(binding, location); warned = true; } }); }
```

# internal/client/warnings.js

```js
/* This file is generated by scripts/process-messages/index.js. Do not edit! */ import { DEV } from 'esm-env'; var bold = 'font-weight: bold'; var normal = 'font-weight: normal'; /** * Assignment to `%property%` property (%location%) will evaluate to the right-hand side, not the value of `%property%` following the assignment. This may result in unexpected behaviour. * @param {string} property * @param {string} location */ export function assignment_value_stale(property, location) { if (DEV) { console.warn(`%c[svelte] assignment_value_stale\n%cAssignment to \`${property}\` property (${location}) will evaluate to the right-hand side, not the value of \`${property}\` following the assignment. This may result in unexpected behaviour.\nhttps://svelte.dev/e/assignment_value_stale`, bold, normal); } else { console.warn(`https://svelte.dev/e/assignment_value_stale`); } } /** * Detected reactivity loss when reading `%name%`. This happens when state is read in an async function after an earlier `await` * @param {string} name */ export function await_reactivity_loss(name) { if (DEV) { console.warn(`%c[svelte] await_reactivity_loss\n%cDetected reactivity loss when reading \`${name}\`. This happens when state is read in an async function after an earlier \`await\`\nhttps://svelte.dev/e/await_reactivity_loss`, bold, normal); } else { console.warn(`https://svelte.dev/e/await_reactivity_loss`); } } /** * An async derived, `%name%` (%location%) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app * @param {string} name * @param {string} location */ export function await_waterfall(name, location) { if (DEV) { console.warn(`%c[svelte] await_waterfall\n%cAn async derived, \`${name}\` (${location}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app\nhttps://svelte.dev/e/await_waterfall`, bold, normal); } else { console.warn(`https://svelte.dev/e/await_waterfall`); } } /** * `%binding%` (%location%) is binding to a non-reactive property * @param {string} binding * @param {string | undefined | null} [location] */ export function binding_property_non_reactive(binding, location) { if (DEV) { console.warn( `%c[svelte] binding_property_non_reactive\n%c${location ? `\`${binding}\` (${location}) is binding to a non-reactive property` : `\`${binding}\` is binding to a non-reactive property`}\nhttps://svelte.dev/e/binding_property_non_reactive`, bold, normal ); } else { console.warn(`https://svelte.dev/e/binding_property_non_reactive`); } } /** * Your `console.%method%` contained `$state` proxies. Consider using `$inspect(...)` or `$state.snapshot(...)` instead * @param {string} method */ export function console_log_state(method) { if (DEV) { console.warn(`%c[svelte] console_log_state\n%cYour \`console.${method}\` contained \`$state\` proxies. Consider using \`$inspect(...)\` or \`$state.snapshot(...)\` instead\nhttps://svelte.dev/e/console_log_state`, bold, normal); } else { console.warn(`https://svelte.dev/e/console_log_state`); } } /** * %handler% should be a function. Did you mean to %suggestion%? * @param {string} handler * @param {string} suggestion */ export function event_handler_invalid(handler, suggestion) { if (DEV) { console.warn(`%c[svelte] event_handler_invalid\n%c${handler} should be a function. Did you mean to ${suggestion}?\nhttps://svelte.dev/e/event_handler_invalid`, bold, normal); } else { console.warn(`https://svelte.dev/e/event_handler_invalid`); } } /** * The `%attribute%` attribute on `%html%` changed its value between server and client renders. The client value, `%value%`, will be ignored in favour of the server value * @param {string} attribute * @param {string} html * @param {string} value */ export function hydration_attribute_changed(attribute, html, value) { if (DEV) { console.warn(`%c[svelte] hydration_attribute_changed\n%cThe \`${attribute}\` attribute on \`${html}\` changed its value between server and client renders. The client value, \`${value}\`, will be ignored in favour of the server value\nhttps://svelte.dev/e/hydration_attribute_changed`, bold, normal); } else { console.warn(`https://svelte.dev/e/hydration_attribute_changed`); } } /** * The value of an `{@html ...}` block %location% changed between server and client renders. The client value will be ignored in favour of the server value * @param {string | undefined | null} [location] */ export function hydration_html_changed(location) { if (DEV) { console.warn( `%c[svelte] hydration_html_changed\n%c${location ? `The value of an \`{@html ...}\` block ${location} changed between server and client renders. The client value will be ignored in favour of the server value` : 'The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value'}\nhttps://svelte.dev/e/hydration_html_changed`, bold, normal ); } else { console.warn(`https://svelte.dev/e/hydration_html_changed`); } } /** * Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near %location% * @param {string | undefined | null} [location] */ export function hydration_mismatch(location) { if (DEV) { console.warn( `%c[svelte] hydration_mismatch\n%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : 'Hydration failed because the initial UI does not match what was rendered on the server'}\nhttps://svelte.dev/e/hydration_mismatch`, bold, normal ); } else { console.warn(`https://svelte.dev/e/hydration_mismatch`); } } /** * The `render` function passed to `createRawSnippet` should return HTML for a single element */ export function invalid_raw_snippet_render() { if (DEV) { console.warn(`%c[svelte] invalid_raw_snippet_render\n%cThe \`render\` function passed to \`createRawSnippet\` should return HTML for a single element\nhttps://svelte.dev/e/invalid_raw_snippet_render`, bold, normal); } else { console.warn(`https://svelte.dev/e/invalid_raw_snippet_render`); } } /** * Detected a migrated `$:` reactive block in `%filename%` that both accesses and updates the same reactive value. This may cause recursive updates when converted to an `$effect`. * @param {string} filename */ export function legacy_recursive_reactive_block(filename) { if (DEV) { console.warn(`%c[svelte] legacy_recursive_reactive_block\n%cDetected a migrated \`$:\` reactive block in \`${filename}\` that both accesses and updates the same reactive value. This may cause recursive updates when converted to an \`$effect\`.\nhttps://svelte.dev/e/legacy_recursive_reactive_block`, bold, normal); } else { console.warn(`https://svelte.dev/e/legacy_recursive_reactive_block`); } } /** * Tried to unmount a component that was not mounted */ export function lifecycle_double_unmount() { if (DEV) { console.warn(`%c[svelte] lifecycle_double_unmount\n%cTried to unmount a component that was not mounted\nhttps://svelte.dev/e/lifecycle_double_unmount`, bold, normal); } else { console.warn(`https://svelte.dev/e/lifecycle_double_unmount`); } } /** * %parent% passed property `%prop%` to %child% with `bind:`, but its parent component %owner% did not declare `%prop%` as a binding. Consider creating a binding between %owner% and %parent% (e.g. `bind:%prop%={...}` instead of `%prop%={...}`) * @param {string} parent * @param {string} prop * @param {string} child * @param {string} owner */ export function ownership_invalid_binding(parent, prop, child, owner) { if (DEV) { console.warn(`%c[svelte] ownership_invalid_binding\n%c${parent} passed property \`${prop}\` to ${child} with \`bind:\`, but its parent component ${owner} did not declare \`${prop}\` as a binding. Consider creating a binding between ${owner} and ${parent} (e.g. \`bind:${prop}={...}\` instead of \`${prop}={...}\`)\nhttps://svelte.dev/e/ownership_invalid_binding`, bold, normal); } else { console.warn(`https://svelte.dev/e/ownership_invalid_binding`); } } /** * Mutating unbound props (`%name%`, at %location%) is strongly discouraged. Consider using `bind:%prop%={...}` in %parent% (or using a callback) instead * @param {string} name * @param {string} location * @param {string} prop * @param {string} parent */ export function ownership_invalid_mutation(name, location, prop, parent) { if (DEV) { console.warn(`%c[svelte] ownership_invalid_mutation\n%cMutating unbound props (\`${name}\`, at ${location}) is strongly discouraged. Consider using \`bind:${prop}={...}\` in ${parent} (or using a callback) instead\nhttps://svelte.dev/e/ownership_invalid_mutation`, bold, normal); } else { console.warn(`https://svelte.dev/e/ownership_invalid_mutation`); } } /** * The `value` property of a `<select multiple>` element should be an array, but it received a non-array value. The selection will be kept as is. */ export function select_multiple_invalid_value() { if (DEV) { console.warn(`%c[svelte] select_multiple_invalid_value\n%cThe \`value\` property of a \`<select multiple>\` element should be an array, but it received a non-array value. The selection will be kept as is.\nhttps://svelte.dev/e/select_multiple_invalid_value`, bold, normal); } else { console.warn(`https://svelte.dev/e/select_multiple_invalid_value`); } } /** * Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results * @param {string} operator */ export function state_proxy_equality_mismatch(operator) { if (DEV) { console.warn(`%c[svelte] state_proxy_equality_mismatch\n%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results\nhttps://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal); } else { console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`); } } /** * The `slide` transition does not work correctly for elements with `display: %value%` * @param {string} value */ export function transition_slide_display(value) { if (DEV) { console.warn(`%c[svelte] transition_slide_display\n%cThe \`slide\` transition does not work correctly for elements with \`display: ${value}\`\nhttps://svelte.dev/e/transition_slide_display`, bold, normal); } else { console.warn(`https://svelte.dev/e/transition_slide_display`); } }
```

# internal/disclose-version.js

```js
import { PUBLIC_VERSION } from '../version.js'; if (typeof window !== 'undefined') { // @ts-expect-error ((window.__svelte ??= {}).v ??= new Set()).add(PUBLIC_VERSION); }
```

# internal/flags/async.js

```js
import { enable_async_mode_flag } from './index.js'; enable_async_mode_flag();
```

# internal/flags/index.js

```js
export let async_mode_flag = false; export let legacy_mode_flag = false; export let tracing_mode_flag = false; export function enable_async_mode_flag() { async_mode_flag = true; } /** ONLY USE THIS DURING TESTING */ export function disable_async_mode_flag() { async_mode_flag = false; } export function enable_legacy_mode_flag() { legacy_mode_flag = true; } export function enable_tracing_mode_flag() { tracing_mode_flag = true; }
```

# internal/flags/legacy.js

```js
import { enable_legacy_mode_flag } from './index.js'; enable_legacy_mode_flag();
```

# internal/flags/tracing.js

```js
import { enable_tracing_mode_flag } from './index.js'; enable_tracing_mode_flag();
```

# internal/index.js

```js
// TODO we may, on a best-effort basis, reimplement some of the legacy private APIs here so that certain libraries continue to work. Those APIs will be marked as deprecated (and should noisily warn the user) and will be removed in a future version of Svelte. throw new Error( `Your application, or one of its dependencies, imported from 'svelte/internal', which was a private module used by Svelte 4 components that no longer exists in Svelte 5. It is not intended to be public API. If you're a library author and you used 'svelte/internal' deliberately, please raise an issue on https://github.com/sveltejs/svelte/issues detailing your use case.` );
```

# internal/server/abort-signal.js

```js
import { STALE_REACTION } from '#client/constants'; /** @type {AbortController | null} */ let controller = null; export function abort() { controller?.abort(STALE_REACTION); controller = null; } export function getAbortSignal() { return (controller ??= new AbortController()).signal; }
```

# internal/server/blocks/html.js

```js
import { DEV } from 'esm-env'; import { hash } from '../../../utils.js'; /** * @param {string} value */ export function html(value) { var html = String(value ?? ''); var open = DEV ? `<!--${hash(html)}-->` : '<!---->'; return open + html + '<!---->'; }
```

# internal/server/blocks/snippet.js

```js
/** @import { Snippet } from 'svelte' */ /** @import { Payload } from '../payload' */ /** @import { Getters } from '#shared' */ /** * Create a snippet programmatically * @template {unknown[]} Params * @param {(...params: Getters<Params>) => { * render: () => string * setup?: (element: Element) => void | (() => void) * }} fn * @returns {Snippet<Params>} */ export function createRawSnippet(fn) { // @ts-expect-error the types are a lie return (/** @type {Payload} */ payload, /** @type {Params} */ ...args) => { var getters = /** @type {Getters<Params>} */ (args.map((value) => () => value)); payload.out += fn(...getters) .render() .trim(); }; }
```

# internal/server/context.js

```js
/** @import { Component } from '#server' */ import { DEV } from 'esm-env'; import { on_destroy } from './index.js'; import * as e from './errors.js'; /** @type {Component | null} */ export var current_component = null; /** * @template T * @param {any} key * @returns {T} */ export function getContext(key) { const context_map = get_or_init_context_map('getContext'); const result = /** @type {T} */ (context_map.get(key)); return result; } /** * @template T * @param {any} key * @param {T} context * @returns {T} */ export function setContext(key, context) { get_or_init_context_map('setContext').set(key, context); return context; } /** * @param {any} key * @returns {boolean} */ export function hasContext(key) { return get_or_init_context_map('hasContext').has(key); } /** @returns {Map<any, any>} */ export function getAllContexts() { return get_or_init_context_map('getAllContexts'); } /** * @param {string} name * @returns {Map<unknown, unknown>} */ function get_or_init_context_map(name) { if (current_component === null) { e.lifecycle_outside_component(name); } return (current_component.c ??= new Map(get_parent_context(current_component) || undefined)); } /** * @param {Function} [fn] */ export function push(fn) { current_component = { p: current_component, c: null, d: null }; if (DEV) { // component function current_component.function = fn; } } export function pop() { var component = /** @type {Component} */ (current_component); var ondestroy = component.d; if (ondestroy) { on_destroy.push(...ondestroy); } current_component = component.p; } /** * @param {Component} component_context * @returns {Map<unknown, unknown> | null} */ function get_parent_context(component_context) { let parent = component_context.p; while (parent !== null) { const context_map = parent.c; if (context_map !== null) { return context_map; } parent = parent.p; } return null; }
```

# internal/server/dev.js

```js
/** @import { Component } from '#server' */ import { FILENAME } from '../../constants.js'; import { is_tag_valid_with_ancestor, is_tag_valid_with_parent } from '../../html-tree-validation.js'; import { current_component } from './context.js'; import * as e from './errors.js'; import { HeadPayload, Payload } from './payload.js'; /** * @typedef {{ * tag: string; * parent: null | Element; * filename: null | string; * line: number; * column: number; * }} Element */ /** * @type {Element | null} */ let parent = null; /** @type {Set<string>} */ let seen; /** * @param {Payload} payload * @param {string} message */ function print_error(payload, message) { message = `node_invalid_placement_ssr: ${message}\n\n` + 'This can cause content to shift around as the browser repairs the HTML, and will likely result in a `hydration_mismatch` warning.'; if ((seen ??= new Set()).has(message)) return; seen.add(message); // eslint-disable-next-line no-console console.error(message); payload.head.out += `<script>console.error(${JSON.stringify(message)})</script>`; } export function reset_elements() { let old_parent = parent; parent = null; return () => { parent = old_parent; }; } /** * @param {Payload} payload * @param {string} tag * @param {number} line * @param {number} column */ export function push_element(payload, tag, line, column) { var filename = /** @type {Component} */ (current_component).function[FILENAME]; var child = { tag, parent, filename, line, column }; if (parent !== null) { var ancestor = parent.parent; var ancestors = [parent.tag]; const child_loc = filename ? `${filename}:${line}:${column}` : undefined; const parent_loc = parent.filename ? `${parent.filename}:${parent.line}:${parent.column}` : undefined; const message = is_tag_valid_with_parent(tag, parent.tag, child_loc, parent_loc); if (message) print_error(payload, message); while (ancestor != null) { ancestors.push(ancestor.tag); const ancestor_loc = ancestor.filename ? `${ancestor.filename}:${ancestor.line}:${ancestor.column}` : undefined; const message = is_tag_valid_with_ancestor(tag, ancestors, child_loc, ancestor_loc); if (message) print_error(payload, message); ancestor = ancestor.parent; } } parent = child; } export function pop_element() { parent = /** @type {Element} */ (parent).parent; } /** * @param {Payload} payload */ export function validate_snippet_args(payload) { if ( typeof payload !== 'object' || // for some reason typescript consider the type of payload as never after the first instanceof !(payload instanceof Payload || /** @type {any} */ (payload) instanceof HeadPayload) ) { e.invalid_snippet_arguments(); } }
```

# internal/server/errors.js

```js
/* This file is generated by scripts/process-messages/index.js. Do not edit! */ export * from '../shared/errors.js'; /** * `%name%(...)` is not available on the server * @param {string} name * @returns {never} */ export function lifecycle_function_unavailable(name) { const error = new Error(`lifecycle_function_unavailable\n\`${name}(...)\` is not available on the server\nhttps://svelte.dev/e/lifecycle_function_unavailable`); error.name = 'Svelte error'; throw error; }
```

# internal/server/hydration.js

```js
import { HYDRATION_END, HYDRATION_START, HYDRATION_START_ELSE } from '../../constants.js'; export const BLOCK_OPEN = `<!--${HYDRATION_START}-->`; export const BLOCK_OPEN_ELSE = `<!--${HYDRATION_START_ELSE}-->`; export const BLOCK_CLOSE = `<!--${HYDRATION_END}-->`; export const EMPTY_COMMENT = `<!---->`;
```

# internal/server/index.js

```js
/** @import { ComponentType, SvelteComponent } from 'svelte' */ /** @import { Component, RenderOutput } from '#server' */ /** @import { Store } from '#shared' */ export { FILENAME, HMR } from '../../constants.js'; import { attr, clsx, to_class, to_style } from '../shared/attributes.js'; import { is_promise, noop } from '../shared/utils.js'; import { subscribe_to_store } from '../../store/utils.js'; import { UNINITIALIZED, ELEMENT_PRESERVE_ATTRIBUTE_CASE, ELEMENT_IS_NAMESPACED } from '../../constants.js'; import { escape_html } from '../../escaping.js'; import { DEV } from 'esm-env'; import { current_component, pop, push } from './context.js'; import { EMPTY_COMMENT, BLOCK_CLOSE, BLOCK_OPEN, BLOCK_OPEN_ELSE } from './hydration.js'; import { validate_store } from '../shared/validate.js'; import { is_boolean_attribute, is_raw_text_element, is_void } from '../../utils.js'; import { reset_elements } from './dev.js'; import { Payload } from './payload.js'; import { abort } from './abort-signal.js'; // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2 // https://infra.spec.whatwg.org/#noncharacter const INVALID_ATTR_NAME_CHAR_REGEX = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u; /** * @param {Payload} payload * @param {string} tag * @param {() => void} attributes_fn * @param {() => void} children_fn * @returns {void} */ export function element(payload, tag, attributes_fn = noop, children_fn = noop) { payload.out += '<!---->'; if (tag) { payload.out += `<${tag}`; attributes_fn(); payload.out += `>`; if (!is_void(tag)) { children_fn(); if (!is_raw_text_element(tag)) { payload.out += EMPTY_COMMENT; } payload.out += `</${tag}>`; } } payload.out += '<!---->'; } /** * Array of `onDestroy` callbacks that should be called at the end of the server render function * @type {Function[]} */ export let on_destroy = []; /** * Only available on the server and when compiling with the `server` option. * Takes a component and returns an object with `body` and `head` properties on it, which you can use to populate the HTML when server-rendering your app. * @template {Record<string, any>} Props * @param {import('svelte').Component<Props> | ComponentType<SvelteComponent<Props>>} component * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} [options] * @returns {RenderOutput} */ export function render(component, options = {}) { try { const payload = new Payload(options.idPrefix ? options.idPrefix + '-' : ''); const prev_on_destroy = on_destroy; on_destroy = []; payload.out += BLOCK_OPEN; let reset_reset_element; if (DEV) { // prevent parent/child element state being corrupted by a bad render reset_reset_element = reset_elements(); } if (options.context) { push(); /** @type {Component} */ (current_component).c = options.context; } // @ts-expect-error component(payload, options.props ?? {}, {}, {}); if (options.context) { pop(); } if (reset_reset_element) { reset_reset_element(); } payload.out += BLOCK_CLOSE; for (const cleanup of on_destroy) cleanup(); on_destroy = prev_on_destroy; let head = payload.head.out + payload.head.title; for (const { hash, code } of payload.css) { head += `<style id="${hash}">${code}</style>`; } return { head, html: payload.out, body: payload.out }; } finally { abort(); } } /** * @param {Payload} payload * @param {(head_payload: Payload['head']) => void} fn * @returns {void} */ export function head(payload, fn) { const head_payload = payload.head; head_payload.out += BLOCK_OPEN; fn(head_payload); head_payload.out += BLOCK_CLOSE; } /** * @param {Payload} payload * @param {boolean} is_html * @param {Record<string, string>} props * @param {() => void} component * @param {boolean} dynamic * @returns {void} */ export function css_props(payload, is_html, props, component, dynamic = false) { const styles = style_object_to_string(props); if (is_html) { payload.out += `<svelte-css-wrapper style="display: contents; ${styles}">`; } else { payload.out += `<g style="${styles}">`; } if (dynamic) { payload.out += '<!---->'; } component(); if (is_html) { payload.out += `<!----></svelte-css-wrapper>`; } else { payload.out += `<!----></g>`; } } /** * @param {Record<string, unknown>} attrs * @param {string | null} css_hash * @param {Record<string, boolean>} [classes] * @param {Record<string, string>} [styles] * @param {number} [flags] * @returns {string} */ export function spread_attributes(attrs, css_hash, classes, styles, flags = 0) { if (styles) { attrs.style = to_style(attrs.style, styles); } if (attrs.class) { attrs.class = clsx(attrs.class); } if (css_hash || classes) { attrs.class = to_class(attrs.class, css_hash, classes); } let attr_str = ''; let name; const is_html = (flags & ELEMENT_IS_NAMESPACED) === 0; const lowercase = (flags & ELEMENT_PRESERVE_ATTRIBUTE_CASE) === 0; for (name in attrs) { // omit functions, internal svelte properties and invalid attribute names if (typeof attrs[name] === 'function') continue; if (name[0] === '$' && name[1] === '$') continue; // faster than name.startsWith('$$') if (INVALID_ATTR_NAME_CHAR_REGEX.test(name)) continue; var value = attrs[name]; if (lowercase) { name = name.toLowerCase(); } attr_str += attr(name, value, is_html && is_boolean_attribute(name)); } return attr_str; } /** * @param {Record<string, unknown>[]} props * @returns {Record<string, unknown>} */ export function spread_props(props) { /** @type {Record<string, unknown>} */ const merged_props = {}; let key; for (let i = 0; i < props.length; i++) { const obj = props[i]; for (key in obj) { const desc = Object.getOwnPropertyDescriptor(obj, key); if (desc) { Object.defineProperty(merged_props, key, desc); } else { merged_props[key] = obj[key]; } } } return merged_props; } /** * @param {unknown} value * @returns {string} */ export function stringify(value) { return typeof value === 'string' ? value : value == null ? '' : value + ''; } /** @param {Record<string, string>} style_object */ function style_object_to_string(style_object) { return Object.keys(style_object) .filter(/** @param {any} key */ (key) => style_object[key] != null && style_object[key] !== '') .map(/** @param {any} key */ (key) => `${key}: ${escape_html(style_object[key], true)};`) .join(' '); } /** * @param {any} value * @param {string | undefined} [hash] * @param {Record<string, boolean>} [directives] */ export function attr_class(value, hash, directives) { var result = to_class(value, hash, directives); return result ? ` class="${escape_html(result, true)}"` : ''; } /** * @param {any} value * @param {Record<string,any>|[Record<string,any>,Record<string,any>]} [directives] */ export function attr_style(value, directives) { var result = to_style(value, directives); return result ? ` style="${escape_html(result, true)}"` : ''; } /** * @template V * @param {Record<string, [any, any, any]>} store_values * @param {string} store_name * @param {Store<V> | null | undefined} store * @returns {V} */ export function store_get(store_values, store_name, store) { if (DEV) { validate_store(store, store_name.slice(1)); } // it could be that someone eagerly updates the store in the instance script, so // we should only reuse the store value in the template if (store_name in store_values && store_values[store_name][0] === store) { return store_values[store_name][2]; } store_values[store_name]?.[1](); // if store was switched, unsubscribe from old store store_values[store_name] = [store, null, undefined]; const unsub = subscribe_to_store( store, /** @param {any} v */ (v) => (store_values[store_name][2] = v) ); store_values[store_name][1] = unsub; return store_values[store_name][2]; } /** * Sets the new value of a store and returns that value. * @template V * @param {Store<V>} store * @param {V} value * @returns {V} */ export function store_set(store, value) { store.set(value); return value; } /** * Updates a store with a new value. * @template V * @param {Record<string, [any, any, any]>} store_values * @param {string} store_name * @param {Store<V>} store * @param {any} expression */ export function store_mutate(store_values, store_name, store, expression) { store_set(store, store_get(store_values, store_name, store)); return expression; } /** * @param {Record<string, [any, any, any]>} store_values * @param {string} store_name * @param {Store<number>} store * @param {1 | -1} [d] * @returns {number} */ export function update_store(store_values, store_name, store, d = 1) { let store_value = store_get(store_values, store_name, store); store.set(store_value + d); return store_value; } /** * @param {Record<string, [any, any, any]>} store_values * @param {string} store_name * @param {Store<number>} store * @param {1 | -1} [d] * @returns {number} */ export function update_store_pre(store_values, store_name, store, d = 1) { const value = store_get(store_values, store_name, store) + d; store.set(value); return value; } /** @param {Record<string, [any, any, any]>} store_values */ export function unsubscribe_stores(store_values) { for (const store_name in store_values) { store_values[store_name][1](); } } /** * @param {Payload} payload * @param {Record<string, any>} $$props * @param {string} name * @param {Record<string, unknown>} slot_props * @param {null | (() => void)} fallback_fn * @returns {void} */ export function slot(payload, $$props, name, slot_props, fallback_fn) { var slot_fn = $$props.$$slots?.[name]; // Interop: Can use snippets to fill slots if (slot_fn === true) { slot_fn = $$props[name === 'default' ? 'children' : name]; } if (slot_fn !== undefined) { slot_fn(payload, slot_props); } else { fallback_fn?.(); } } /** * @param {Record<string, unknown>} props * @param {string[]} rest * @returns {Record<string, unknown>} */ export function rest_props(props, rest) { /** @type {Record<string, unknown>} */ const rest_props = {}; let key; for (key in props) { if (!rest.includes(key)) { rest_props[key] = props[key]; } } return rest_props; } /** * @param {Record<string, unknown>} props * @returns {Record<string, unknown>} */ export function sanitize_props(props) { const { children, $$slots, ...sanitized } = props; return sanitized; } /** * @param {Record<string, any>} props * @returns {Record<string, boolean>} */ export function sanitize_slots(props) { /** @type {Record<string, boolean>} */ const sanitized = {}; if (props.children) sanitized.default = true; for (const key in props.$$slots) { sanitized[key] = true; } return sanitized; } /** * Legacy mode: If the prop has a fallback and is bound in the * parent component, propagate the fallback value upwards. * @param {Record<string, unknown>} props_parent * @param {Record<string, unknown>} props_now */ export function bind_props(props_parent, props_now) { for (const key in props_now) { const initial_value = props_parent[key]; const value = props_now[key]; if ( initial_value === undefined && value !== undefined && Object.getOwnPropertyDescriptor(props_parent, key)?.set ) { props_parent[key] = value; } } } /** * @template V * @param {Payload} payload * @param {Promise<V>} promise * @param {null | (() => void)} pending_fn * @param {(value: V) => void} then_fn * @returns {void} */ function await_block(payload, promise, pending_fn, then_fn) { if (is_promise(promise)) { payload.out += BLOCK_OPEN; promise.then(null, noop); if (pending_fn !== null) { pending_fn(); } } else if (then_fn !== null) { payload.out += BLOCK_OPEN_ELSE; then_fn(promise); } } export { await_block as await }; /** @param {any} array_like_or_iterator */ export function ensure_array_like(array_like_or_iterator) { if (array_like_or_iterator) { return array_like_or_iterator.length !== undefined ? array_like_or_iterator : Array.from(array_like_or_iterator); } return []; } /** * @param {any[]} args * @param {Function} [inspect] */ // eslint-disable-next-line no-console export function inspect(args, inspect = console.log) { inspect('init', ...args); } /** * @template V * @param {() => V} get_value */ export function once(get_value) { let value = /** @type {V} */ (UNINITIALIZED); return () => { if (value === UNINITIALIZED) { value = get_value(); } return value; }; } /** * Create an unique ID * @param {Payload} payload * @returns {string} */ export function props_id(payload) { const uid = payload.uid(); payload.out += '<!--#' + uid + '-->'; return uid; } export { attr, clsx }; export { html } from './blocks/html.js'; export { push, pop } from './context.js'; export { push_element, pop_element, validate_snippet_args } from './dev.js'; export { assign_payload, copy_payload } from './payload.js'; export { snapshot } from '../shared/clone.js'; export { fallback, to_array } from '../shared/utils.js'; export { invalid_default_snippet, validate_dynamic_element_tag, validate_void_dynamic_element, prevent_snippet_stringification } from '../shared/validate.js'; export { escape_html as escape }; export { await_outside_boundary } from '../shared/errors.js'; /** * @template T * @param {()=>T} fn * @returns {(new_value?: T) => (T | void)} */ export function derived(fn) { const get_value = once(fn); /** * @type {T | undefined} */ let updated_value; return function (new_value) { if (arguments.length === 0) { return updated_value ?? get_value(); } updated_value = new_value; return updated_value; }; } /** * * @param {Payload} payload * @param {*} value */ export function maybe_selected(payload, value) { return value === payload.select_value ? ' selected' : ''; } /** * @param {Payload} payload * @param {() => void} children * @returns {void} */ export function valueless_option(payload, children) { var i = payload.out.length; children(); var body = payload.out.slice(i); if (body.replace(/<!---->/g, '') === payload.select_value) { // replace '>' with ' selected>' (closing tag will be added later) payload.out = payload.out.slice(0, i - 1) + ' selected>' + body; } }
```

# internal/server/payload.js

```js
export class HeadPayload { /** @type {Set<{ hash: string; code: string }>} */ css = new Set(); out = ''; uid = () => ''; title = ''; constructor(css = new Set(), out = '', title = '', uid = () => '') { this.css = css; this.out = out; this.title = title; this.uid = uid; } } export class Payload { /** @type {Set<{ hash: string; code: string }>} */ css = new Set(); out = ''; uid = () => ''; select_value = undefined; head = new HeadPayload(); constructor(id_prefix = '') { this.uid = props_id_generator(id_prefix); this.head.uid = this.uid; } } /** * Used in legacy mode to handle bindings * @param {Payload} to_copy * @returns {Payload} */ export function copy_payload({ out, css, head, uid }) { const payload = new Payload(); payload.out = out; payload.css = new Set(css); payload.uid = uid; payload.head = new HeadPayload(); payload.head.out = head.out; payload.head.css = new Set(head.css); payload.head.title = head.title; payload.head.uid = head.uid; return payload; } /** * Assigns second payload to first * @param {Payload} p1 * @param {Payload} p2 * @returns {void} */ export function assign_payload(p1, p2) { p1.out = p2.out; p1.css = p2.css; p1.head = p2.head; p1.uid = p2.uid; } /** * Creates an ID generator * @param {string} prefix * @returns {() => string} */ function props_id_generator(prefix) { let uid = 1; return () => `${prefix}s${uid++}`; }
```

# internal/server/types.d.ts

```ts
export interface Component { /** parent */ p: null | Component; /** context */ c: null | Map<unknown, unknown>; /** ondestroy */ d: null | Array<() => void>; /** * dev mode only: the component function */ function?: any; } export interface RenderOutput { /** HTML that goes into the `<head>` */ head: string; /** @deprecated use `body` instead */ html: string; /** HTML that goes somewhere into the `<body>` */ body: string; }
```

# internal/shared/attributes.js

```js
import { escape_html } from '../../escaping.js'; import { clsx as _clsx } from 'clsx'; /** * `<div translate={false}>` should be rendered as `<div translate="no">` and _not_ * `<div translate="false">`, which is equivalent to `<div translate="yes">`. There * may be other odd cases that need to be added to this list in future * @type {Record<string, Map<any, string>>} */ const replacements = { translate: new Map([ [true, 'yes'], [false, 'no'] ]) }; /** * @template V * @param {string} name * @param {V} value * @param {boolean} [is_boolean] * @returns {string} */ export function attr(name, value, is_boolean = false) { if (value == null || (!value && is_boolean)) return ''; const normalized = (name in replacements && replacements[name].get(value)) || value; const assignment = is_boolean ? '' : `="${escape_html(normalized, true)}"`; return ` ${name}${assignment}`; } /** * Small wrapper around clsx to preserve Svelte's (weird) handling of falsy values. * TODO Svelte 6 revisit this, and likely turn all falsy values into the empty string (what clsx also does) * @param {any} value */ export function clsx(value) { if (typeof value === 'object') { return _clsx(value); } else { return value ?? ''; } } const whitespace = [...' \t\n\r\f\u00a0\u000b\ufeff']; /** * @param {any} value * @param {string | null} [hash] * @param {Record<string, boolean>} [directives] * @returns {string | null} */ export function to_class(value, hash, directives) { var classname = value == null ? '' : '' + value; if (hash) { classname = classname ? classname + ' ' + hash : hash; } if (directives) { for (var key in directives) { if (directives[key]) { classname = classname ? classname + ' ' + key : key; } else if (classname.length) { var len = key.length; var a = 0; while ((a = classname.indexOf(key, a)) >= 0) { var b = a + len; if ( (a === 0 || whitespace.includes(classname[a - 1])) && (b === classname.length || whitespace.includes(classname[b])) ) { classname = (a === 0 ? '' : classname.substring(0, a)) + classname.substring(b + 1); } else { a = b; } } } } } return classname === '' ? null : classname; } /** * * @param {Record<string,any>} styles * @param {boolean} important */ function append_styles(styles, important = false) { var separator = important ? ' !important;' : ';'; var css = ''; for (var key in styles) { var value = styles[key]; if (value != null && value !== '') { css += ' ' + key + ': ' + value + separator; } } return css; } /** * @param {string} name * @returns {string} */ function to_css_name(name) { if (name[0] !== '-' || name[1] !== '-') { return name.toLowerCase(); } return name; } /** * @param {any} value * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [styles] * @returns {string | null} */ export function to_style(value, styles) { if (styles) { var new_style = ''; /** @type {Record<string,any> | undefined} */ var normal_styles; /** @type {Record<string,any> | undefined} */ var important_styles; if (Array.isArray(styles)) { normal_styles = styles[0]; important_styles = styles[1]; } else { normal_styles = styles; } if (value) { value = String(value) .replaceAll(/\s*\/\*.*?\*\/\s*/g, '') .trim(); /** @type {boolean | '"' | "'"} */ var in_str = false; var in_apo = 0; var in_comment = false; var reserved_names = []; if (normal_styles) { reserved_names.push(...Object.keys(normal_styles).map(to_css_name)); } if (important_styles) { reserved_names.push(...Object.keys(important_styles).map(to_css_name)); } var start_index = 0; var name_index = -1; const len = value.length; for (var i = 0; i < len; i++) { var c = value[i]; if (in_comment) { if (c === '/' && value[i - 1] === '*') { in_comment = false; } } else if (in_str) { if (in_str === c) { in_str = false; } } else if (c === '/' && value[i + 1] === '*') { in_comment = true; } else if (c === '"' || c === "'") { in_str = c; } else if (c === '(') { in_apo++; } else if (c === ')') { in_apo--; } if (!in_comment && in_str === false && in_apo === 0) { if (c === ':' && name_index === -1) { name_index = i; } else if (c === ';' || i === len - 1) { if (name_index !== -1) { var name = to_css_name(value.substring(start_index, name_index).trim()); if (!reserved_names.includes(name)) { if (c !== ';') { i++; } var property = value.substring(start_index, i).trim(); new_style += ' ' + property + ';'; } } start_index = i + 1; name_index = -1; } } } } if (normal_styles) { new_style += append_styles(normal_styles); } if (important_styles) { new_style += append_styles(important_styles, true); } new_style = new_style.trim(); return new_style === '' ? null : new_style; } return value == null ? null : String(value); }
```

# internal/shared/clone.js

```js
/** @import { Snapshot } from './types' */ import { DEV } from 'esm-env'; import * as w from './warnings.js'; import { get_prototype_of, is_array, object_prototype } from './utils.js'; /** * In dev, we keep track of which properties could not be cloned. In prod * we don't bother, but we keep a dummy array around so that the * signature stays the same * @type {string[]} */ const empty = []; /** * @template T * @param {T} value * @param {boolean} [skip_warning] * @returns {Snapshot<T>} */ export function snapshot(value, skip_warning = false) { if (DEV && !skip_warning) { /** @type {string[]} */ const paths = []; const copy = clone(value, new Map(), '', paths); if (paths.length === 1 && paths[0] === '') { // value could not be cloned w.state_snapshot_uncloneable(); } else if (paths.length > 0) { // some properties could not be cloned const slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10); const excess = paths.length - slice.length; let uncloned = slice.map((path) => `- <value>${path}`).join('\n'); if (excess > 0) uncloned += `\n- ...and ${excess} more`; w.state_snapshot_uncloneable(uncloned); } return copy; } return clone(value, new Map(), '', empty); } /** * @template T * @param {T} value * @param {Map<T, Snapshot<T>>} cloned * @param {string} path * @param {string[]} paths * @param {null | T} original The original value, if `value` was produced from a `toJSON` call * @returns {Snapshot<T>} */ function clone(value, cloned, path, paths, original = null) { if (typeof value === 'object' && value !== null) { var unwrapped = cloned.get(value); if (unwrapped !== undefined) return unwrapped; if (value instanceof Map) return /** @type {Snapshot<T>} */ (new Map(value)); if (value instanceof Set) return /** @type {Snapshot<T>} */ (new Set(value)); if (is_array(value)) { var copy = /** @type {Snapshot<any>} */ (Array(value.length)); cloned.set(value, copy); if (original !== null) { cloned.set(original, copy); } for (var i = 0; i < value.length; i += 1) { var element = value[i]; if (i in value) { copy[i] = clone(element, cloned, DEV ? `${path}[${i}]` : path, paths); } } return copy; } if (get_prototype_of(value) === object_prototype) { /** @type {Snapshot<any>} */ copy = {}; cloned.set(value, copy); if (original !== null) { cloned.set(original, copy); } for (var key in value) { // @ts-expect-error copy[key] = clone(value[key], cloned, DEV ? `${path}.${key}` : path, paths); } return copy; } if (value instanceof Date) { return /** @type {Snapshot<T>} */ (structuredClone(value)); } if (typeof (/** @type {T & { toJSON?: any } } */ (value).toJSON) === 'function') { return clone( /** @type {T & { toJSON(): any } } */ (value).toJSON(), cloned, DEV ? `${path}.toJSON()` : path, paths, // Associate the instance with the toJSON clone value ); } } if (value instanceof EventTarget) { // can't be cloned return /** @type {Snapshot<T>} */ (value); } try { return /** @type {Snapshot<T>} */ (structuredClone(value)); } catch (e) { if (DEV) { paths.push(path); } return /** @type {Snapshot<T>} */ (value); } }
```

# internal/shared/clone.test.ts

```ts
import { snapshot } from './clone'; import { assert, test } from 'vitest'; import { proxy } from '../client/proxy'; function capture_warnings() { const warnings: string[] = []; // eslint-disable-next-line no-console const warn = console.warn; // eslint-disable-next-line no-console console.warn = (message) => warnings.push(message); return () => { // eslint-disable-next-line no-console console.warn = warn; return warnings; }; } test('primitive', () => { assert.equal(42, snapshot(42)); }); test('array', () => { const array = [1, 2, 3]; const copy = snapshot(array); assert.deepEqual(copy, array); assert.notEqual(copy, array); }); test('object', () => { const object = { a: 1, b: 2, c: 3 }; const copy = snapshot(object); assert.deepEqual(copy, object); assert.notEqual(copy, object); }); test('proxied state', () => { const object = proxy({ a: { b: { c: 1 } } }); const copy = snapshot(object); assert.deepEqual(copy, object); assert.notEqual(copy, object); object.a.b.c = 2; assert.equal(copy.a.b.c, 1); }); test('cycles', () => { const object: { self?: any } = {}; object.self = object; const copy = snapshot(object); assert.equal(copy.self, copy); }); test('class with state field', () => { class Foo { x = 1; #y = 2; get y() { return this.#y; } } const copy = snapshot(new Foo()); // @ts-expect-error I can't figure out a way to exclude prototype properties assert.deepEqual(copy, { x: 1 }); }); test('class with toJSON', () => { class Foo { x = 1; #y = 2; get y() { return this.#y; } toJSON() { return { x: this.x, y: this.y }; } } const copy = snapshot(new Foo()); assert.deepEqual(copy, { x: 1, y: 2 }); }); test('reactive class', () => { class SvelteMap<T, U> extends Map<T, U> { constructor(init?: Iterable<[T, U]>) { super(init); } } const map = new SvelteMap([[1, 2]]); const copy = snapshot(map); assert.ok(copy instanceof Map); assert.notOk(copy instanceof SvelteMap); assert.equal(copy.get(1), 2); }); test('uncloneable value', () => { const fn = () => {}; const warnings = capture_warnings(); const copy = snapshot(fn); assert.equal(fn, copy); assert.deepEqual(warnings(), [ '%c[svelte] state_snapshot_uncloneable\n%cValue cannot be cloned with `$state.snapshot` — the original value was returned\nhttps://svelte.dev/e/state_snapshot_uncloneable' ]); }); test('uncloneable properties', () => { const object = { a: () => {}, b: () => {}, c: [() => {}, () => {}, () => {}, () => {}, () => {}, () => {}, () => {}, () => {}] }; const warnings = capture_warnings(); const copy = snapshot(object); assert.notEqual(object, copy); assert.equal(object.a, copy.a); assert.equal(object.b, copy.b); assert.notEqual(object.c, copy.c); assert.equal(object.c[0], copy.c[0]); assert.deepEqual(warnings(), [ `%c[svelte] state_snapshot_uncloneable %cThe following properties cannot be cloned with \`$state.snapshot\` — the return value contains the originals: - <value>.a - <value>.b - <value>.c[0] - <value>.c[1] - <value>.c[2] - <value>.c[3] - <value>.c[4] - <value>.c[5] - <value>.c[6] - <value>.c[7] https://svelte.dev/e/state_snapshot_uncloneable` ]); }); test('many uncloneable properties', () => { const array = Array.from({ length: 100 }, () => () => {}); const warnings = capture_warnings(); snapshot(array); assert.deepEqual(warnings(), [ `%c[svelte] state_snapshot_uncloneable %cThe following properties cannot be cloned with \`$state.snapshot\` — the return value contains the originals: - <value>[0] - <value>[1] - <value>[2] - <value>[3] - <value>[4] - <value>[5] - <value>[6] - ...and 93 more https://svelte.dev/e/state_snapshot_uncloneable` ]); });
```

# internal/shared/errors.js

```js
/* This file is generated by scripts/process-messages/index.js. Do not edit! */ import { DEV } from 'esm-env'; /** * Cannot await outside a `<svelte:boundary>` with a `pending` snippet * @returns {never} */ export function await_outside_boundary() { if (DEV) { const error = new Error(`await_outside_boundary\nCannot await outside a \`<svelte:boundary>\` with a \`pending\` snippet\nhttps://svelte.dev/e/await_outside_boundary`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/await_outside_boundary`); } } /** * Cannot use `{@render children(...)}` if the parent component uses `let:` directives. Consider using a named snippet instead * @returns {never} */ export function invalid_default_snippet() { if (DEV) { const error = new Error(`invalid_default_snippet\nCannot use \`{@render children(...)}\` if the parent component uses \`let:\` directives. Consider using a named snippet instead\nhttps://svelte.dev/e/invalid_default_snippet`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/invalid_default_snippet`); } } /** * A snippet function was passed invalid arguments. Snippets should only be instantiated via `{@render ...}` * @returns {never} */ export function invalid_snippet_arguments() { if (DEV) { const error = new Error(`invalid_snippet_arguments\nA snippet function was passed invalid arguments. Snippets should only be instantiated via \`{@render ...}\`\nhttps://svelte.dev/e/invalid_snippet_arguments`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/invalid_snippet_arguments`); } } /** * `%name%(...)` can only be used during component initialisation * @param {string} name * @returns {never} */ export function lifecycle_outside_component(name) { if (DEV) { const error = new Error(`lifecycle_outside_component\n\`${name}(...)\` can only be used during component initialisation\nhttps://svelte.dev/e/lifecycle_outside_component`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/lifecycle_outside_component`); } } /** * Attempted to render a snippet without a `{@render}` block. This would cause the snippet code to be stringified instead of its content being rendered to the DOM. To fix this, change `{snippet}` to `{@render snippet()}`. * @returns {never} */ export function snippet_without_render_tag() { if (DEV) { const error = new Error(`snippet_without_render_tag\nAttempted to render a snippet without a \`{@render}\` block. This would cause the snippet code to be stringified instead of its content being rendered to the DOM. To fix this, change \`{snippet}\` to \`{@render snippet()}\`.\nhttps://svelte.dev/e/snippet_without_render_tag`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/snippet_without_render_tag`); } } /** * `%name%` is not a store with a `subscribe` method * @param {string} name * @returns {never} */ export function store_invalid_shape(name) { if (DEV) { const error = new Error(`store_invalid_shape\n\`${name}\` is not a store with a \`subscribe\` method\nhttps://svelte.dev/e/store_invalid_shape`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/store_invalid_shape`); } } /** * The `this` prop on `<svelte:element>` must be a string, if defined * @returns {never} */ export function svelte_element_invalid_this_value() { if (DEV) { const error = new Error(`svelte_element_invalid_this_value\nThe \`this\` prop on \`<svelte:element>\` must be a string, if defined\nhttps://svelte.dev/e/svelte_element_invalid_this_value`); error.name = 'Svelte error'; throw error; } else { throw new Error(`https://svelte.dev/e/svelte_element_invalid_this_value`); } }
```

# internal/shared/types.d.ts

```ts
export type Store<V> = { subscribe: (run: (value: V) => void) => () => void; set(value: V): void; }; export type Getters<T> = { [K in keyof T]: () => T[K]; }; export type Snapshot<T> = ReturnType<typeof $state.snapshot<T>>;
```

# internal/shared/utils.js

```js
// Store the references to globals in case someone tries to monkey patch these, causing the below // to de-opt (this occurs often when using popular extensions). export var is_array = Array.isArray; export var index_of = Array.prototype.indexOf; export var array_from = Array.from; export var object_keys = Object.keys; export var define_property = Object.defineProperty; export var get_descriptor = Object.getOwnPropertyDescriptor; export var get_descriptors = Object.getOwnPropertyDescriptors; export var object_prototype = Object.prototype; export var array_prototype = Array.prototype; export var get_prototype_of = Object.getPrototypeOf; export var is_extensible = Object.isExtensible; /** * @param {any} thing * @returns {thing is Function} */ export function is_function(thing) { return typeof thing === 'function'; } export const noop = () => {}; // Adapted from https://github.com/then/is-promise/blob/master/index.js // Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE /** * @template [T=any] * @param {any} value * @returns {value is PromiseLike<T>} */ export function is_promise(value) { return typeof value?.then === 'function'; } /** @param {Function} fn */ export function run(fn) { return fn(); } /** @param {Array<() => void>} arr */ export function run_all(arr) { for (var i = 0; i < arr.length; i++) { arr[i](); } } /** * TODO replace with Promise.withResolvers once supported widely enough * @template T */ export function deferred() { /** @type {(value: T) => void} */ var resolve; /** @type {(reason: any) => void} */ var reject; /** @type {Promise<T>} */ var promise = new Promise((res, rej) => { resolve = res; reject = rej; }); // @ts-expect-error return { promise, resolve, reject }; } /** * @template V * @param {V} value * @param {V | (() => V)} fallback * @param {boolean} [lazy] * @returns {V} */ export function fallback(value, fallback, lazy = false) { return value === undefined ? lazy ? /** @type {() => V} */ (fallback)() : /** @type {V} */ (fallback) : value; } /** * When encountering a situation like `let [a, b, c] = $derived(blah())`, * we need to stash an intermediate value that `a`, `b`, and `c` derive * from, in case it's an iterable * @template T * @param {ArrayLike<T> | Iterable<T>} value * @param {number} [n] * @returns {Array<T>} */ export function to_array(value, n) { // return arrays unchanged if (Array.isArray(value)) { return value; } // if value is not iterable, or `n` is unspecified (indicates a rest // element, which means we're not concerned about unbounded iterables) // convert to an array with `Array.from` if (n === undefined || !(Symbol.iterator in value)) { return Array.from(value); } // otherwise, populate an array with `n` values /** @type {T[]} */ const array = []; for (const element of value) { array.push(element); if (array.length === n) break; } return array; }
```

# internal/shared/validate.js

```js
import { is_void } from '../../utils.js'; import * as w from './warnings.js'; import * as e from './errors.js'; export { invalid_default_snippet } from './errors.js'; /** * @param {() => string} tag_fn * @returns {void} */ export function validate_void_dynamic_element(tag_fn) { const tag = tag_fn(); if (tag && is_void(tag)) { w.dynamic_void_element_content(tag); } } /** @param {() => unknown} tag_fn */ export function validate_dynamic_element_tag(tag_fn) { const tag = tag_fn(); const is_string = typeof tag === 'string'; if (tag && !is_string) { e.svelte_element_invalid_this_value(); } } /** * @param {any} store * @param {string} name */ export function validate_store(store, name) { if (store != null && typeof store.subscribe !== 'function') { e.store_invalid_shape(name); } } /** * @template {() => unknown} T * @param {T} fn */ export function prevent_snippet_stringification(fn) { fn.toString = () => { e.snippet_without_render_tag(); return ''; }; return fn; }
```

# internal/shared/warnings.js

```js
/* This file is generated by scripts/process-messages/index.js. Do not edit! */ import { DEV } from 'esm-env'; var bold = 'font-weight: bold'; var normal = 'font-weight: normal'; /** * `<svelte:element this="%tag%">` is a void element — it cannot have content * @param {string} tag */ export function dynamic_void_element_content(tag) { if (DEV) { console.warn(`%c[svelte] dynamic_void_element_content\n%c\`<svelte:element this="${tag}">\` is a void element — it cannot have content\nhttps://svelte.dev/e/dynamic_void_element_content`, bold, normal); } else { console.warn(`https://svelte.dev/e/dynamic_void_element_content`); } } /** * The following properties cannot be cloned with `$state.snapshot` — the return value contains the originals: * * %properties% * @param {string | undefined | null} [properties] */ export function state_snapshot_uncloneable(properties) { if (DEV) { console.warn( `%c[svelte] state_snapshot_uncloneable\n%c${properties ? `The following properties cannot be cloned with \`$state.snapshot\` — the return value contains the originals: ${properties}` : 'Value cannot be cloned with `$state.snapshot` — the original value was returned'}\nhttps://svelte.dev/e/state_snapshot_uncloneable`, bold, normal ); } else { console.warn(`https://svelte.dev/e/state_snapshot_uncloneable`); } }
```

# internal/types.d.ts

```ts
/** Anything except a function */ export type NotFunction<T> = T extends Function ? never : T;
```

# legacy/legacy-client.js

```js
/** @import { ComponentConstructorOptions, ComponentType, SvelteComponent, Component } from 'svelte' */ import { DIRTY, LEGACY_PROPS, MAYBE_DIRTY } from '../internal/client/constants.js'; import { user_pre_effect } from '../internal/client/reactivity/effects.js'; import { mutable_source, set } from '../internal/client/reactivity/sources.js'; import { hydrate, mount, unmount } from '../internal/client/render.js'; import { active_effect, get, set_signal_status } from '../internal/client/runtime.js'; import { flushSync } from '../internal/client/reactivity/batch.js'; import { define_property, is_array } from '../internal/shared/utils.js'; import * as e from '../internal/client/errors.js'; import * as w from '../internal/client/warnings.js'; import { DEV } from 'esm-env'; import { FILENAME } from '../constants.js'; import { component_context, dev_current_component_function } from '../internal/client/context.js'; import { async_mode_flag } from '../internal/flags/index.js'; /** * Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component. * * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5. * * @template {Record<string, any>} Props * @template {Record<string, any>} Exports * @template {Record<string, any>} Events * @template {Record<string, any>} Slots * * @param {ComponentConstructorOptions<Props> & { * component: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>; * }} options * @returns {SvelteComponent<Props, Events, Slots> & Exports} */ export function createClassComponent(options) { // @ts-expect-error $$prop_def etc are not actually defined return new Svelte4Component(options); } /** * Takes the component function and returns a Svelte 4 compatible component constructor. * * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5. * * @template {Record<string, any>} Props * @template {Record<string, any>} Exports * @template {Record<string, any>} Events * @template {Record<string, any>} Slots * * @param {SvelteComponent<Props, Events, Slots> | Component<Props>} component * @returns {ComponentType<SvelteComponent<Props, Events, Slots> & Exports>} */ export function asClassComponent(component) { // @ts-expect-error $$prop_def etc are not actually defined return class extends Svelte4Component { /** @param {any} options */ constructor(options) { super({ component, ...options }); } }; } /** * Support using the component as both a class and function during the transition period * @typedef {{new (o: ComponentConstructorOptions): SvelteComponent;(...args: Parameters<Component<Record<string, any>>>): ReturnType<Component<Record<string, any>, Record<string, any>>>;}} LegacyComponentType */ class Svelte4Component { /** @type {any} */ #events; /** @type {Record<string, any>} */ #instance; /** * @param {ComponentConstructorOptions & { * component: any; * }} options */ constructor(options) { var sources = new Map(); /** * @param {string | symbol} key * @param {unknown} value */ var add_source = (key, value) => { var s = mutable_source(value, false, false); sources.set(key, s); return s; }; // Replicate coarse-grained props through a proxy that has a version source for // each property, which is incremented on updates to the property itself. Do not // use our $state proxy because that one has fine-grained reactivity. const props = new Proxy( { ...(options.props || {}), $$events: {} }, { get(target, prop) { return get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop))); }, has(target, prop) { // Necessary to not throw "invalid binding" validation errors on the component side if (prop === LEGACY_PROPS) return true; get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop))); return Reflect.has(target, prop); }, set(target, prop, value) { set(sources.get(prop) ?? add_source(prop, value), value); return Reflect.set(target, prop, value); } } ); this.#instance = (options.hydrate ? hydrate : mount)(options.component, { target: options.target, anchor: options.anchor, props, context: options.context, intro: options.intro ?? false, recover: options.recover }); // We don't flushSync for custom element wrappers or if the user doesn't want it, // or if we're in async mode since `flushSync()` will fail if (!async_mode_flag && (!options?.props?.$$host || options.sync === false)) { flushSync(); } this.#events = props.$$events; for (const key of Object.keys(this.#instance)) { if (key === '$set' || key === '$destroy' || key === '$on') continue; define_property(this, key, { get() { return this.#instance[key]; }, /** @param {any} value */ set(value) { this.#instance[key] = value; }, enumerable: true }); } this.#instance.$set = /** @param {Record<string, any>} next */ (next) => { Object.assign(props, next); }; this.#instance.$destroy = () => { unmount(this.#instance); }; } /** @param {Record<string, any>} props */ $set(props) { this.#instance.$set(props); } /** * @param {string} event * @param {(...args: any[]) => any} callback * @returns {any} */ $on(event, callback) { this.#events[event] = this.#events[event] || []; /** @param {any[]} args */ const cb = (...args) => callback.call(this, ...args); this.#events[event].push(cb); return () => { this.#events[event] = this.#events[event].filter(/** @param {any} fn */ (fn) => fn !== cb); }; } $destroy() { this.#instance.$destroy(); } } /** * Runs the given function once immediately on the server, and works like `$effect.pre` on the client. * * @deprecated Use this only as a temporary solution to migrate your component code to Svelte 5. * @param {() => void | (() => void)} fn * @returns {void} */ export function run(fn) { user_pre_effect(() => { fn(); var effect = /** @type {import('#client').Effect} */ (active_effect); // If the effect is immediately made dirty again, mark it as maybe dirty to emulate legacy behaviour if ((effect.f & DIRTY) !== 0) { let filename = "a file (we can't know which one)"; if (DEV) { // @ts-ignore filename = dev_current_component_function?.[FILENAME] ?? filename; } w.legacy_recursive_reactive_block(filename); set_signal_status(effect, MAYBE_DIRTY); } }); } /** * Function to mimic the multiple listeners available in svelte 4 * @deprecated * @param {EventListener[]} handlers * @returns {EventListener} */ export function handlers(...handlers) { return function (event) { const { stopImmediatePropagation } = event; let stopped = false; event.stopImmediatePropagation = () => { stopped = true; stopImmediatePropagation.call(event); }; const errors = []; for (const handler of handlers) { try { // @ts-expect-error `this` is not typed handler?.call(this, event); } catch (e) { errors.push(e); } if (stopped) { break; } } for (let error of errors) { queueMicrotask(() => { throw error; }); } }; } /** * Function to create a `bubble` function that mimic the behavior of `on:click` without handler available in svelte 4. * @deprecated Use this only as a temporary solution to migrate your automatically delegated events in Svelte 5. */ export function createBubbler() { const active_component_context = component_context; if (active_component_context === null) { e.lifecycle_outside_component('createBubbler'); } return (/**@type {string}*/ type) => (/**@type {Event}*/ event) => { const events = /** @type {Record<string, Function | Function[]>} */ ( active_component_context.s.$$events )?.[/** @type {any} */ (type)]; if (events) { const callbacks = is_array(events) ? events.slice() : [events]; for (const fn of callbacks) { fn.call(active_component_context.x, event); } return !event.defaultPrevented; } return true; }; } export { once, preventDefault, self, stopImmediatePropagation, stopPropagation, trusted, passive, nonpassive } from '../internal/client/dom/legacy/event-modifiers.js';
```

# legacy/legacy-server.js

```js
/** @import { SvelteComponent } from '../index.js' */ import { asClassComponent as as_class_component, createClassComponent } from './legacy-client.js'; import { render } from '../internal/server/index.js'; // By having this as a separate entry point for server environments, we save the client bundle from having to include the server runtime export { createClassComponent }; /** * Takes a Svelte 5 component and returns a Svelte 4 compatible component constructor. * * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5. * * @template {Record<string, any>} Props * @template {Record<string, any>} Exports * @template {Record<string, any>} Events * @template {Record<string, any>} Slots * * @param {SvelteComponent<Props, Events, Slots>} component * @returns {typeof SvelteComponent<Props, Events, Slots> & Exports} */ export function asClassComponent(component) { const component_constructor = as_class_component(component); /** @type {(props?: {}, opts?: { $$slots?: {}; context?: Map<any, any>; }) => { html: any; css: { code: string; map: any; }; head: string; } } */ const _render = (props, { context } = {}) => { // @ts-expect-error the typings are off, but this will work if the component is compiled in SSR mode const result = render(component, { props, context }); return { css: { code: '', map: null }, head: result.head, html: result.body }; }; // @ts-expect-error this is present for SSR component_constructor.render = _render; // @ts-ignore return component_constructor; } /** * Runs the given function once immediately on the server, and works like `$effect.pre` on the client. * * @deprecated Use this only as a temporary solution to migrate your component code to Svelte 5. * @param {() => void | (() => void)} fn * @returns {void} */ export function run(fn) { fn(); } const noop = () => {}; // event stuff, no need to worry about it for SSR but needs to be there or it will crash export { noop as handlers, noop as createBubbler, noop as once, noop as preventDefault, noop as self, noop as stopImmediatePropagation, noop as stopPropagation, noop as trusted, noop as passive, noop as nonpassive };
```

# motion/index.js

```js
import { MediaQuery } from 'svelte/reactivity'; export * from './spring.js'; export * from './tweened.js'; /** * A [media query](https://svelte.dev/docs/svelte/svelte-reactivity#MediaQuery) that matches if the user [prefers reduced motion](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion). * * \`\`\`svelte * <script> * import { prefersReducedMotion } from 'svelte/motion'; * import { fly } from 'svelte/transition'; * * let visible = $state(false); * </script> * * <button onclick={() => visible = !visible}> * toggle * </button> * * {#if visible} * <p transition:fly={{ y: prefersReducedMotion.current ? 0 : 200 }}> * flies in, unless the user prefers reduced motion * </p> * {/if} * \`\`\` * @type {MediaQuery} * @since 5.7.0 */ export const prefersReducedMotion = /*@__PURE__*/ new MediaQuery( '(prefers-reduced-motion: reduce)' );
```

# motion/private.d.ts

```ts
export interface TickContext { inv_mass: number; dt: number; opts: { stiffness: number; damping: number; precision: number; }; settled: boolean; } export interface SpringOpts { stiffness?: number; damping?: number; precision?: number; } export interface SpringUpdateOpts { /** * @deprecated Only use this for the spring store; does nothing when set on the Spring class */ hard?: any; /** * @deprecated Only use this for the spring store; does nothing when set on the Spring class */ soft?: string | number | boolean; /** * Only use this for the Spring class; does nothing when set on the spring store */ instant?: boolean; /** * Only use this for the Spring class; does nothing when set on the spring store */ preserveMomentum?: number; } export type Updater<T> = (target_value: T, value: T) => T; export interface TweenedOptions<T> { delay?: number; duration?: number | ((from: T, to: T) => number); easing?: (t: number) => number; interpolate?: (a: T, b: T) => (t: number) => T; }
```

# motion/public.d.ts

```ts
import { Readable, type Unsubscriber } from '../store/public.js'; import { SpringUpdateOpts, TweenedOptions, Updater, SpringOpts } from './private.js'; // TODO we do declaration merging here in order to not have a breaking change (renaming the Spring interface) // this means both the Spring class and the Spring interface are merged into one with some things only // existing on one side. In Svelte 6, remove the type definition and move the jsdoc onto the class in spring.js export interface Spring<T> extends Readable<T> { set(new_value: T, opts?: SpringUpdateOpts): Promise<void>; /** * @deprecated Only exists on the legacy `spring` store, not the `Spring` class */ update: (fn: Updater<T>, opts?: SpringUpdateOpts) => Promise<void>; /** * @deprecated Only exists on the legacy `spring` store, not the `Spring` class */ subscribe(fn: (value: T) => void): Unsubscriber; precision: number; damping: number; stiffness: number; } /** * A wrapper for a value that behaves in a spring-like fashion. Changes to `spring.target` will cause `spring.current` to * move towards it over time, taking account of the `spring.stiffness` and `spring.damping` parameters. * * \`\`\`svelte * <script> * import { Spring } from 'svelte/motion'; * * const spring = new Spring(0); * </script> * * <input type="range" bind:value={spring.target} /> * <input type="range" bind:value={spring.current} disabled /> * \`\`\` * @since 5.8.0 */ export class Spring<T> { constructor(value: T, options?: SpringOpts); /** * Create a spring whose value is bound to the return value of `fn`. This must be called * inside an effect root (for example, during component initialisation). * * \`\`\`svelte * <script> * import { Spring } from 'svelte/motion'; * * let { number } = $props(); * * const spring = Spring.of(() => number); * </script> * \`\`\` */ static of<U>(fn: () => U, options?: SpringOpts): Spring<U>; /** * Sets `spring.target` to `value` and returns a `Promise` that resolves if and when `spring.current` catches up to it. * * If `options.instant` is `true`, `spring.current` immediately matches `spring.target`. * * If `options.preserveMomentum` is provided, the spring will continue on its current trajectory for * the specified number of milliseconds. This is useful for things like 'fling' gestures. */ set(value: T, options?: SpringUpdateOpts): Promise<void>; damping: number; precision: number; stiffness: number; /** * The end value of the spring. * This property only exists on the `Spring` class, not the legacy `spring` store. */ target: T; /** * The current value of the spring. * This property only exists on the `Spring` class, not the legacy `spring` store. */ get current(): T; } export interface Tweened<T> extends Readable<T> { set(value: T, opts?: TweenedOptions<T>): Promise<void>; update(updater: Updater<T>, opts?: TweenedOptions<T>): Promise<void>; } export { prefersReducedMotion, spring, tweened, Tween } from './index.js';
```

# motion/spring.js

```js
/** @import { Task } from '#client' */ /** @import { SpringOpts, SpringUpdateOpts, TickContext } from './private.js' */ /** @import { Spring as SpringStore } from './public.js' */ import { writable } from '../store/shared/index.js'; import { loop } from '../internal/client/loop.js'; import { raf } from '../internal/client/timing.js'; import { is_date } from './utils.js'; import { set, state } from '../internal/client/reactivity/sources.js'; import { render_effect } from '../internal/client/reactivity/effects.js'; import { tag } from '../internal/client/dev/tracing.js'; import { get } from '../internal/client/runtime.js'; import { deferred, noop } from '../internal/shared/utils.js'; import { DEV } from 'esm-env'; /** * @template T * @param {TickContext} ctx * @param {T} last_value * @param {T} current_value * @param {T} target_value * @returns {T} */ function tick_spring(ctx, last_value, current_value, target_value) { if (typeof current_value === 'number' || is_date(current_value)) { // @ts-ignore const delta = target_value - current_value; // @ts-ignore const velocity = (current_value - last_value) / (ctx.dt || 1 / 60); // guard div by 0 const spring = ctx.opts.stiffness * delta; const damper = ctx.opts.damping * velocity; const acceleration = (spring - damper) * ctx.inv_mass; const d = (velocity + acceleration) * ctx.dt; if (Math.abs(d) < ctx.opts.precision && Math.abs(delta) < ctx.opts.precision) { return target_value; // settled } else { ctx.settled = false; // signal loop to keep ticking // @ts-ignore return is_date(current_value) ? new Date(current_value.getTime() + d) : current_value + d; } } else if (Array.isArray(current_value)) { // @ts-ignore return current_value.map((_, i) => // @ts-ignore tick_spring(ctx, last_value[i], current_value[i], target_value[i]) ); } else if (typeof current_value === 'object') { const next_value = {}; for (const k in current_value) { // @ts-ignore next_value[k] = tick_spring(ctx, last_value[k], current_value[k], target_value[k]); } // @ts-ignore return next_value; } else { throw new Error(`Cannot spring ${typeof current_value} values`); } } /** * The spring function in Svelte creates a store whose value is animated, with a motion that simulates the behavior of a spring. This means when the value changes, instead of transitioning at a steady rate, it "bounces" like a spring would, depending on the physics parameters provided. This adds a level of realism to the transitions and can enhance the user experience. * * @deprecated Use [`Spring`](https://svelte.dev/docs/svelte/svelte-motion#Spring) instead * @template [T=any] * @param {T} [value] * @param {SpringOpts} [opts] * @returns {SpringStore<T>} */ export function spring(value, opts = {}) { const store = writable(value); const { stiffness = 0.15, damping = 0.8, precision = 0.01 } = opts; /** @type {number} */ let last_time; /** @type {Task | null} */ let task; /** @type {object} */ let current_token; let last_value = /** @type {T} */ (value); let target_value = /** @type {T | undefined} */ (value); let inv_mass = 1; let inv_mass_recovery_rate = 0; let cancel_task = false; /** * @param {T} new_value * @param {SpringUpdateOpts} opts * @returns {Promise<void>} */ function set(new_value, opts = {}) { target_value = new_value; const token = (current_token = {}); if (value == null || opts.hard || (spring.stiffness >= 1 && spring.damping >= 1)) { cancel_task = true; // cancel any running animation last_time = raf.now(); last_value = new_value; store.set((value = target_value)); return Promise.resolve(); } else if (opts.soft) { const rate = opts.soft === true ? 0.5 : +opts.soft; inv_mass_recovery_rate = 1 / (rate * 60); inv_mass = 0; // infinite mass, unaffected by spring forces } if (!task) { last_time = raf.now(); cancel_task = false; task = loop((now) => { if (cancel_task) { cancel_task = false; task = null; return false; } inv_mass = Math.min(inv_mass + inv_mass_recovery_rate, 1); // clamp elapsed time to 1/30th of a second, so that longer pauses // (blocked thread or inactive tab) don't cause the spring to go haywire const elapsed = Math.min(now - last_time, 1000 / 30); /** @type {TickContext} */ const ctx = { inv_mass, opts: spring, settled: true, dt: (elapsed * 60) / 1000 }; // @ts-ignore const next_value = tick_spring(ctx, last_value, value, target_value); last_time = now; last_value = /** @type {T} */ (value); store.set((value = /** @type {T} */ (next_value))); if (ctx.settled) { task = null; } return !ctx.settled; }); } return new Promise((fulfil) => { /** @type {Task} */ (task).promise.then(() => { if (token === current_token) fulfil(); }); }); } /** @type {SpringStore<T>} */ // @ts-expect-error - class-only properties are missing const spring = { set, update: (fn, opts) => set(fn(/** @type {T} */ (target_value), /** @type {T} */ (value)), opts), subscribe: store.subscribe, stiffness, damping, precision }; return spring; } /** * A wrapper for a value that behaves in a spring-like fashion. Changes to `spring.target` will cause `spring.current` to * move towards it over time, taking account of the `spring.stiffness` and `spring.damping` parameters. * * \`\`\`svelte * <script> * import { Spring } from 'svelte/motion'; * * const spring = new Spring(0); * </script> * * <input type="range" bind:value={spring.target} /> * <input type="range" bind:value={spring.current} disabled /> * \`\`\` * @template T * @since 5.8.0 */ export class Spring { #stiffness = state(0.15); #damping = state(0.8); #precision = state(0.01); #current; #target; #last_value = /** @type {T} */ (undefined); #last_time = 0; #inverse_mass = 1; #momentum = 0; /** @type {import('../internal/client/types').Task | null} */ #task = null; /** @type {ReturnType<typeof deferred> | null} */ #deferred = null; /** * @param {T} value * @param {SpringOpts} [options] */ constructor(value, options = {}) { this.#current = DEV ? tag(state(value), 'Spring.current') : state(value); this.#target = DEV ? tag(state(value), 'Spring.target') : state(value); if (typeof options.stiffness === 'number') this.#stiffness.v = clamp(options.stiffness, 0, 1); if (typeof options.damping === 'number') this.#damping.v = clamp(options.damping, 0, 1); if (typeof options.precision === 'number') this.#precision.v = options.precision; if (DEV) { tag(this.#stiffness, 'Spring.stiffness'); tag(this.#damping, 'Spring.damping'); tag(this.#precision, 'Spring.precision'); tag(this.#current, 'Spring.current'); tag(this.#target, 'Spring.target'); } } /** * Create a spring whose value is bound to the return value of `fn`. This must be called * inside an effect root (for example, during component initialisation). * * \`\`\`svelte * <script> * import { Spring } from 'svelte/motion'; * * let { number } = $props(); * * const spring = Spring.of(() => number); * </script> * \`\`\` * @template U * @param {() => U} fn * @param {SpringOpts} [options] */ static of(fn, options) { const spring = new Spring(fn(), options); render_effect(() => { spring.set(fn()); }); return spring; } /** @param {T} value */ #update(value) { set(this.#target, value); this.#current.v ??= value; this.#last_value ??= this.#current.v; if (!this.#task) { this.#last_time = raf.now(); var inv_mass_recovery_rate = 1000 / (this.#momentum * 60); this.#task ??= loop((now) => { this.#inverse_mass = Math.min(this.#inverse_mass + inv_mass_recovery_rate, 1); // clamp elapsed time to 1/30th of a second, so that longer pauses // (blocked thread or inactive tab) don't cause the spring to go haywire const elapsed = Math.min(now - this.#last_time, 1000 / 30); /** @type {import('./private').TickContext} */ const ctx = { inv_mass: this.#inverse_mass, opts: { stiffness: this.#stiffness.v, damping: this.#damping.v, precision: this.#precision.v }, settled: true, dt: (elapsed * 60) / 1000 }; var next = tick_spring(ctx, this.#last_value, this.#current.v, this.#target.v); this.#last_value = this.#current.v; this.#last_time = now; set(this.#current, next); if (ctx.settled) { this.#task = null; } return !ctx.settled; }); } return this.#task.promise; } /** * Sets `spring.target` to `value` and returns a `Promise` that resolves if and when `spring.current` catches up to it. * * If `options.instant` is `true`, `spring.current` immediately matches `spring.target`. * * If `options.preserveMomentum` is provided, the spring will continue on its current trajectory for * the specified number of milliseconds. This is useful for things like 'fling' gestures. * * @param {T} value * @param {SpringUpdateOpts} [options] */ set(value, options) { this.#deferred?.reject(new Error('Aborted')); if (options?.instant || this.#current.v === undefined) { this.#task?.abort(); this.#task = null; set(this.#current, set(this.#target, value)); this.#last_value = value; return Promise.resolve(); } if (options?.preserveMomentum) { this.#inverse_mass = 0; this.#momentum = options.preserveMomentum; } var d = (this.#deferred = deferred()); d.promise.catch(noop); this.#update(value).then(() => { if (d !== this.#deferred) return; d.resolve(undefined); }); return d.promise; } get current() { return get(this.#current); } get damping() { return get(this.#damping); } set damping(v) { set(this.#damping, clamp(v, 0, 1)); } get precision() { return get(this.#precision); } set precision(v) { set(this.#precision, v); } get stiffness() { return get(this.#stiffness); } set stiffness(v) { set(this.#stiffness, clamp(v, 0, 1)); } get target() { return get(this.#target); } set target(v) { this.set(v); } } /** * @param {number} n * @param {number} min * @param {number} max */ function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
```

# motion/tweened.js

```js
/** @import { Task } from '../internal/client/types' */ /** @import { Tweened } from './public' */ /** @import { TweenedOptions } from './private' */ import { writable } from '../store/shared/index.js'; import { raf } from '../internal/client/timing.js'; import { loop } from '../internal/client/loop.js'; import { linear } from '../easing/index.js'; import { is_date } from './utils.js'; import { set, state } from '../internal/client/reactivity/sources.js'; import { tag } from '../internal/client/dev/tracing.js'; import { get, render_effect } from 'svelte/internal/client'; import { DEV } from 'esm-env'; /** * @template T * @param {T} a * @param {T} b * @returns {(t: number) => T} */ function get_interpolator(a, b) { if (a === b || a !== a) return () => a; const type = typeof a; if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) { throw new Error('Cannot interpolate values of different type'); } if (Array.isArray(a)) { const arr = /** @type {Array<any>} */ (b).map((bi, i) => { return get_interpolator(/** @type {Array<any>} */ (a)[i], bi); }); // @ts-ignore return (t) => arr.map((fn) => fn(t)); } if (type === 'object') { if (!a || !b) { throw new Error('Object cannot be null'); } if (is_date(a) && is_date(b)) { const an = a.getTime(); const bn = b.getTime(); const delta = bn - an; // @ts-ignore return (t) => new Date(an + t * delta); } const keys = Object.keys(b); /** @type {Record<string, (t: number) => T>} */ const interpolators = {}; keys.forEach((key) => { // @ts-ignore interpolators[key] = get_interpolator(a[key], b[key]); }); // @ts-ignore return (t) => { /** @type {Record<string, any>} */ const result = {}; keys.forEach((key) => { result[key] = interpolators[key](t); }); return result; }; } if (type === 'number') { const delta = /** @type {number} */ (b) - /** @type {number} */ (a); // @ts-ignore return (t) => a + t * delta; } // for non-numeric values, snap to the final value immediately return () => b; } /** * A tweened store in Svelte is a special type of store that provides smooth transitions between state values over time. * * @deprecated Use [`Tween`](https://svelte.dev/docs/svelte/svelte-motion#Tween) instead * @template T * @param {T} [value] * @param {TweenedOptions<T>} [defaults] * @returns {Tweened<T>} */ export function tweened(value, defaults = {}) { const store = writable(value); /** @type {Task} */ let task; let target_value = value; /** * @param {T} new_value * @param {TweenedOptions<T>} [opts] */ function set(new_value, opts) { target_value = new_value; if (value == null) { store.set((value = new_value)); return Promise.resolve(); } /** @type {Task | null} */ let previous_task = task; let started = false; let { delay = 0, duration = 400, easing = linear, interpolate = get_interpolator } = { ...defaults, ...opts }; if (duration === 0) { if (previous_task) { previous_task.abort(); previous_task = null; } store.set((value = target_value)); return Promise.resolve(); } const start = raf.now() + delay; /** @type {(t: number) => T} */ let fn; task = loop((now) => { if (now < start) return true; if (!started) { fn = interpolate(/** @type {any} */ (value), new_value); if (typeof duration === 'function') duration = duration(/** @type {any} */ (value), new_value); started = true; } if (previous_task) { previous_task.abort(); previous_task = null; } const elapsed = now - start; if (elapsed > /** @type {number} */ (duration)) { store.set((value = new_value)); return false; } // @ts-ignore store.set((value = fn(easing(elapsed / duration)))); return true; }); return task.promise; } return { set, update: (fn, opts) => set(fn(/** @type {any} */ (target_value), /** @type {any} */ (value)), opts), subscribe: store.subscribe }; } /** * A wrapper for a value that tweens smoothly to its target value. Changes to `tween.target` will cause `tween.current` to * move towards it over time, taking account of the `delay`, `duration` and `easing` options. * * \`\`\`svelte * <script> * import { Tween } from 'svelte/motion'; * * const tween = new Tween(0); * </script> * * <input type="range" bind:value={tween.target} /> * <input type="range" bind:value={tween.current} disabled /> * \`\`\` * @template T * @since 5.8.0 */ export class Tween { #current; #target; /** @type {TweenedOptions<T>} */ #defaults; /** @type {import('../internal/client/types').Task | null} */ #task = null; /** * @param {T} value * @param {TweenedOptions<T>} options */ constructor(value, options = {}) { this.#current = state(value); this.#target = state(value); this.#defaults = options; if (DEV) { tag(this.#current, 'Tween.current'); tag(this.#target, 'Tween.target'); } } /** * Create a tween whose value is bound to the return value of `fn`. This must be called * inside an effect root (for example, during component initialisation). * * \`\`\`svelte * <script> * import { Tween } from 'svelte/motion'; * * let { number } = $props(); * * const tween = Tween.of(() => number); * </script> * \`\`\` * @template U * @param {() => U} fn * @param {TweenedOptions<U>} [options] */ static of(fn, options) { const tween = new Tween(fn(), options); render_effect(() => { tween.set(fn()); }); return tween; } /** * Sets `tween.target` to `value` and returns a `Promise` that resolves if and when `tween.current` catches up to it. * * If `options` are provided, they will override the tween's defaults. * @param {T} value * @param {TweenedOptions<T>} [options] * @returns */ set(value, options) { set(this.#target, value); let { delay = 0, duration = 400, easing = linear, interpolate = get_interpolator } = { ...this.#defaults, ...options }; if (duration === 0) { this.#task?.abort(); set(this.#current, value); return Promise.resolve(); } const start = raf.now() + delay; /** @type {(t: number) => T} */ let fn; let started = false; let previous_task = this.#task; this.#task = loop((now) => { if (now < start) { return true; } if (!started) { started = true; const prev = this.#current.v; fn = interpolate(prev, value); if (typeof duration === 'function') { duration = duration(prev, value); } previous_task?.abort(); } const elapsed = now - start; if (elapsed > /** @type {number} */ (duration)) { set(this.#current, value); return false; } set(this.#current, fn(easing(elapsed / /** @type {number} */ (duration)))); return true; }); return this.#task.promise; } get current() { return get(this.#current); } get target() { return get(this.#target); } set target(v) { this.set(v); } }
```

# motion/utils.js

```js
/** * @param {any} obj * @returns {obj is Date} */ export function is_date(obj) { return Object.prototype.toString.call(obj) === '[object Date]'; }
```

# reactivity/create-subscriber.js

```js
import { get, tick, untrack } from '../internal/client/runtime.js'; import { effect_tracking, render_effect } from '../internal/client/reactivity/effects.js'; import { source, increment } from '../internal/client/reactivity/sources.js'; import { tag } from '../internal/client/dev/tracing.js'; import { DEV } from 'esm-env'; import { queue_micro_task } from '../internal/client/dom/task.js'; /** * Returns a `subscribe` function that, if called in an effect (including expressions in the template), * calls its `start` callback with an `update` function. Whenever `update` is called, the effect re-runs. * * If `start` returns a function, it will be called when the effect is destroyed. * * If `subscribe` is called in multiple effects, `start` will only be called once as long as the effects * are active, and the returned teardown function will only be called when all effects are destroyed. * * It's best understood with an example. Here's an implementation of [`MediaQuery`](https://svelte.dev/docs/svelte/svelte-reactivity#MediaQuery): * * \`\`\`js * import { createSubscriber } from 'svelte/reactivity'; * import { on } from 'svelte/events'; * * export class MediaQuery { * #query; * #subscribe; * * constructor(query) { * this.#query = window.matchMedia(`(${query})`); * * this.#subscribe = createSubscriber((update) => { * // when the `change` event occurs, re-run any effects that read `this.current` * const off = on(this.#query, 'change', update); * * // stop listening when all the effects are destroyed * return () => off(); * }); * } * * get current() { * this.#subscribe(); * * // Return the current state of the query, whether or not we're in an effect * return this.#query.matches; * } * } * \`\`\` * @param {(update: () => void) => (() => void) | void} start * @since 5.7.0 */ export function createSubscriber(start) { let subscribers = 0; let version = source(0); /** @type {(() => void) | void} */ let stop; if (DEV) { tag(version, 'createSubscriber version'); } return () => { if (effect_tracking()) { get(version); render_effect(() => { if (subscribers === 0) { stop = untrack(() => start(() => increment(version))); } subscribers += 1; return () => { queue_micro_task(() => { // Only count down after a microtask, else we would reach 0 before our own render effect reruns, // but reach 1 again when the tick callback of the prior teardown runs. That would mean we // re-subcribe unnecessarily and create a memory leak because the old subscription is never cleaned up. subscribers -= 1; if (subscribers === 0) { stop?.(); stop = undefined; } }); }; }); } }; }
```

# reactivity/date.js

```js
/** @import { Source } from '#client' */ import { derived } from '../internal/client/index.js'; import { set, state } from '../internal/client/reactivity/sources.js'; import { tag } from '../internal/client/dev/tracing.js'; import { active_reaction, get, set_active_reaction } from '../internal/client/runtime.js'; import { DEV } from 'esm-env'; var inited = false; /** * A reactive version of the built-in [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) object. * Reading the date (whether with methods like `date.getTime()` or `date.toString()`, or via things like [`Intl.DateTimeFormat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat)) * in an [effect](https://svelte.dev/docs/svelte/$effect) or [derived](https://svelte.dev/docs/svelte/$derived) * will cause it to be re-evaluated when the value of the date changes. * * \`\`\`svelte * <script> * import { SvelteDate } from 'svelte/reactivity'; * * const date = new SvelteDate(); * * const formatter = new Intl.DateTimeFormat(undefined, { * hour: 'numeric', * minute: 'numeric', * second: 'numeric' * }); * * $effect(() => { * const interval = setInterval(() => { * date.setTime(Date.now()); * }, 1000); * * return () => { * clearInterval(interval); * }; * }); * </script> * * <p>The time is {formatter.format(date)}</p> * \`\`\` */ export class SvelteDate extends Date { #time = state(super.getTime()); /** @type {Map<keyof Date, Source<unknown>>} */ #deriveds = new Map(); #reaction = active_reaction; /** @param {any[]} params */ constructor(...params) { // @ts-ignore super(...params); if (DEV) { tag(this.#time, 'SvelteDate.#time'); } if (!inited) this.#init(); } #init() { inited = true; var proto = SvelteDate.prototype; var date_proto = Date.prototype; var methods = /** @type {Array<keyof Date & string>} */ ( Object.getOwnPropertyNames(date_proto) ); for (const method of methods) { if (method.startsWith('get') || method.startsWith('to') || method === 'valueOf') { // @ts-ignore proto[method] = function (...args) { // don't memoize if there are arguments // @ts-ignore if (args.length > 0) { get(this.#time); // @ts-ignore return date_proto[method].apply(this, args); } var d = this.#deriveds.get(method); if (d === undefined) { // lazily create the derived, but as though it were being // created at the same time as the class instance const reaction = active_reaction; set_active_reaction(this.#reaction); d = derived(() => { get(this.#time); // @ts-ignore return date_proto[method].apply(this, args); }); this.#deriveds.set(method, d); set_active_reaction(reaction); } return get(d); }; } if (method.startsWith('set')) { // @ts-ignore proto[method] = function (...args) { // @ts-ignore var result = date_proto[method].apply(this, args); set(this.#time, date_proto.getTime.call(this)); return result; }; } } } }
```

# reactivity/date.test.ts

```ts
import { render_effect, effect_root } from '../internal/client/reactivity/effects.js'; import { flushSync } from '../index-client.js'; import { SvelteDate } from './date.js'; import { assert, test } from 'vitest'; import { derived, get } from 'svelte/internal/client'; const initial_date = new Date(2023, 0, 2, 0, 0, 0, 0); const a = new Date(2024, 1, 3, 1, 1, 1, 1); const b = new Date(2025, 2, 4, 2, 2, 2, 2); const c = new Date(2026, 3, 5, 3, 3, 3, 3); test('date.setDate and date.setUTCDate', () => { const date = new SvelteDate(initial_date); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(date.getDate()); }); render_effect(() => { log.push(date.getUTCDate()); }); }); flushSync(() => { date.setDate(a.getDate()); }); flushSync(() => { date.setDate(date.getDate() + 1); }); flushSync(() => { date.setDate(date.getDate()); // no change expected }); flushSync(() => { date.setUTCDate(date.getUTCDate() + 1); }); // Date/UTCDate may vary on some timezones const date_plus_zero = new Date(initial_date); date_plus_zero.setDate(a.getDate()); const date_plus_one = new Date(initial_date); date_plus_one.setDate(a.getDate() + 1); const date_plus_two = new Date(initial_date); date_plus_two.setDate(a.getDate() + 2); assert.deepEqual(log, [ initial_date.getDate(), initial_date.getUTCDate(), date_plus_zero.getDate(), date_plus_zero.getUTCDate(), date_plus_one.getDate(), date_plus_one.getUTCDate(), date_plus_two.getDate(), date_plus_two.getUTCDate() ]); cleanup(); }); test('date.setFullYear and date.setUTCFullYear', () => { const date = new SvelteDate(initial_date); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(date.getFullYear()); }); render_effect(() => { log.push(date.getUTCFullYear()); }); }); flushSync(() => { date.setFullYear(a.getFullYear()); }); flushSync(() => { date.setFullYear(b.getFullYear()); }); flushSync(() => { date.setFullYear(b.getFullYear()); // no change expected }); flushSync(() => { date.setUTCFullYear(c.getUTCFullYear()); }); assert.deepEqual(log, [ initial_date.getFullYear(), initial_date.getUTCFullYear(), a.getFullYear(), a.getUTCFullYear(), b.getFullYear(), b.getUTCFullYear(), c.getFullYear(), c.getUTCFullYear() ]); cleanup(); }); test('date.setHours and date.setUTCHours', () => { const date = new SvelteDate(initial_date); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(date.getHours() % 24); }); render_effect(() => { log.push(date.getUTCHours() % 24); }); }); flushSync(() => { date.setHours(a.getHours()); }); flushSync(() => { date.setHours(date.getHours() + 1); }); flushSync(() => { date.setHours(date.getHours()); // no change expected }); flushSync(() => { date.setUTCHours(date.getUTCHours() + 1); }); assert.deepEqual(log, [ initial_date.getHours(), initial_date.getUTCHours(), a.getHours() % 24, a.getUTCHours() % 24, (a.getHours() + 1) % 24, (a.getUTCHours() + 1) % 24, (a.getHours() + 2) % 24, (a.getUTCHours() + 2) % 24 ]); cleanup(); }); test('date.setMilliseconds and date.setUTCMilliseconds', () => { const date = new SvelteDate(initial_date); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(date.getMilliseconds()); }); render_effect(() => { log.push(date.getUTCMilliseconds()); }); }); flushSync(() => { date.setMilliseconds(a.getMilliseconds()); }); flushSync(() => { date.setMilliseconds(b.getMilliseconds()); }); flushSync(() => { date.setMilliseconds(b.getMilliseconds()); // no change expected }); flushSync(() => { date.setUTCMilliseconds(c.getUTCMilliseconds()); }); assert.deepEqual(log, [ initial_date.getMilliseconds(), initial_date.getUTCMilliseconds(), a.getMilliseconds(), a.getUTCMilliseconds(), b.getMilliseconds(), b.getUTCMilliseconds(), c.getMilliseconds(), c.getUTCMilliseconds() ]); cleanup(); }); test('date.setMinutes and date.setUTCMinutes', () => { const date = new SvelteDate(initial_date); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(date.getMinutes()); }); render_effect(() => { log.push(date.getUTCMinutes()); }); }); flushSync(() => { date.setMinutes(a.getMinutes()); }); flushSync(() => { date.setMinutes(b.getMinutes()); }); flushSync(() => { date.setMinutes(b.getMinutes()); // no change expected }); flushSync(() => { date.setUTCMinutes(c.getUTCMinutes()); }); assert.deepEqual(log, [ initial_date.getMinutes(), initial_date.getUTCMinutes(), a.getMinutes(), a.getUTCMinutes(), b.getMinutes(), b.getUTCMinutes(), c.getMinutes(), c.getUTCMinutes() ]); cleanup(); }); test('date.setMonth and date.setUTCMonth', () => { const date = new SvelteDate(initial_date); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(date.getMonth()); }); render_effect(() => { log.push(date.getUTCMonth()); }); }); flushSync(() => { date.setMonth(a.getMonth()); }); flushSync(() => { date.setMonth(b.getMonth()); }); flushSync(() => { date.setMonth(b.getMonth()); // no change expected }); flushSync(() => { date.setUTCMonth(c.getUTCMonth()); }); assert.deepEqual(log, [ initial_date.getMonth(), initial_date.getUTCMonth(), a.getMonth(), a.getUTCMonth(), b.getMonth(), b.getUTCMonth(), c.getMonth(), c.getUTCMonth() ]); cleanup(); }); test('date.setSeconds and date.setUTCSeconds', () => { const date = new SvelteDate(initial_date); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(date.getSeconds()); }); render_effect(() => { log.push(date.getUTCSeconds()); }); }); flushSync(() => { date.setSeconds(a.getSeconds()); }); flushSync(() => { date.setSeconds(b.getSeconds()); }); flushSync(() => { date.setSeconds(b.getSeconds()); // no change expected }); flushSync(() => { date.setUTCSeconds(c.getUTCSeconds()); }); assert.deepEqual(log, [ initial_date.getSeconds(), initial_date.getUTCSeconds(), a.getSeconds(), a.getUTCSeconds(), b.getSeconds(), b.getUTCSeconds(), c.getSeconds(), c.getUTCSeconds() ]); cleanup(); }); test('date.setTime', () => { const date = new SvelteDate(initial_date); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(date.getTime()); }); }); flushSync(() => { date.setTime(a.getTime()); }); flushSync(() => { date.setTime(b.getTime()); }); flushSync(() => { // nothing should happen here date.setTime(b.getTime()); }); assert.deepEqual(log, [initial_date.getTime(), a.getTime(), b.getTime()]); cleanup(); }); test('date.setYear', () => { const date = new SvelteDate(initial_date); const log: any = []; // @ts-expect-error if (!date.setYear) { return; } const cleanup = effect_root(() => { render_effect(() => { // @ts-expect-error log.push(date.getYear()); }); }); flushSync(() => { // @ts-expect-error date.setYear(22); }); flushSync(() => { // @ts-expect-error date.setYear(23); }); flushSync(() => { // nothing should happen here // @ts-expect-error date.setYear(23); }); // @ts-expect-error assert.deepEqual(log, [initial_date.getYear(), 22, 23]); cleanup(); }); test('date.setSeconds - edge cases', () => { const date = new SvelteDate(initial_date); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(date.getSeconds()); }); render_effect(() => { log.push(date.getMinutes()); }); }); flushSync(() => { date.setSeconds(60); }); flushSync(() => { date.setSeconds(61); }); assert.deepEqual(log, [ initial_date.getSeconds(), initial_date.getMinutes(), initial_date.getMinutes() + 1, initial_date.getSeconds() + 1, initial_date.getMinutes() + 2 ]); cleanup(); }); test('Date propagated changes', () => { const date = new SvelteDate(initial_date); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(date.getSeconds()); }); render_effect(() => { log.push(date.getMonth()); }); render_effect(() => { log.push(date.getFullYear()); }); }); flushSync(() => { date.setMonth(13); }); assert.deepEqual(log, [ initial_date.getSeconds(), initial_date.getMonth(), initial_date.getFullYear(), 1, 2024 ]); cleanup(); }); test('Date fine grained tests', () => { const date = new SvelteDate(initial_date); let changes: Record<string, boolean> = { getFullYear: true, getUTCFullYear: true, getMonth: true, getUTCMonth: true, getDate: true, getUTCDate: true, getDay: true, getUTCDay: true, getHours: true, getUTCHours: true, getMinutes: true, getUTCMinutes: true, getSeconds: true, getUTCSeconds: true, getMilliseconds: true, getUTCMilliseconds: true, getTime: true, toISOString: true, toJSON: true, toUTCString: true, toString: true, toLocaleString: true }; let test_description: string = ''; const expect_all_changes_to_be_false = () => { for (const key of Object.keys(changes) as Array<keyof typeof Date>) { assert.equal(changes[key], false, `${test_description}: effect for ${key} was not fired`); } }; const cleanup = effect_root(() => { for (const key of Object.keys(changes)) { render_effect(() => { // @ts-ignore date[key](); assert.equal(changes[key], true, `${test_description}: for ${key}`); changes[key] = false; }); } }); flushSync(() => { expect_all_changes_to_be_false(); changes = { ...changes, getFullYear: true, getUTCFullYear: true, getMonth: true, getUTCMonth: true, getDay: true, getUTCDay: true, getTime: true, toISOString: true, toJSON: true, toUTCString: true, toString: true, toLocaleString: true }; test_description = 'changing setFullYear that will cause month/day change as well'; date.setFullYear(initial_date.getFullYear() + 1, initial_date.getMonth() + 1); }); flushSync(() => { expect_all_changes_to_be_false(); changes = { ...changes, getDate: true, getUTCDate: true, getDay: true, getUTCDay: true, getHours: true, getUTCHours: true, getMinutes: true, getUTCMinutes: true, getSeconds: true, getUTCSeconds: true, getMilliseconds: true, getUTCMilliseconds: true, getTime: true, toISOString: true, toJSON: true, toUTCString: true, toString: true, toLocaleString: true }; test_description = 'changing seconds that will change day/hour/minutes/seconds/milliseconds'; date.setSeconds(61 * 60 * 25 + 1, 10); }); flushSync(() => { expect_all_changes_to_be_false(); changes = { ...changes, getMonth: true, getUTCMonth: true, getDay: true, getUTCDay: true, getMilliseconds: true, getUTCMilliseconds: true, getTime: true, toISOString: true, toJSON: true, toUTCString: true, toString: true, toLocaleString: true }; test_description = 'changing month'; date.setMonth(date.getMonth() + 1); }); cleanup(); }); test('Date.toLocaleString', () => { const date = new SvelteDate(initial_date); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(date.toLocaleString(undefined, { month: 'long', year: 'numeric' })); }); render_effect(() => { log.push(date.toLocaleString(undefined, { month: 'long' })); }); }); flushSync(); assert.deepEqual(log, [ initial_date.toLocaleString(undefined, { month: 'long', year: 'numeric' }), initial_date.toLocaleString(undefined, { month: 'long' }) ]); cleanup(); }); test('Date.valueOf', () => { const date = new SvelteDate(initial_date); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(date.valueOf()); }); }); flushSync(); assert.deepEqual(log, [initial_date.valueOf()]); flushSync(() => { date.setTime(date.getTime() + 10); }); assert.deepEqual(log, [initial_date.valueOf(), new Date(initial_date.getTime() + 10).valueOf()]); cleanup(); }); test('Date.instanceOf', () => { assert.equal(new SvelteDate() instanceof Date, true); }); test('Date methods invoked for the first time in a derived', () => { const date = new SvelteDate(initial_date); const log: any = []; const cleanup = effect_root(() => { const months = derived(() => { return date.getMonth(); }); render_effect(() => { log.push(get(months)); }); flushSync(() => { date.setMonth(date.getMonth() + 1); }); flushSync(() => { date.setMonth(date.getMonth() + 1); }); }); assert.deepEqual(log, [0, 1, 2]); cleanup(); }); test('Date methods shared between deriveds', () => { const date = new SvelteDate(initial_date); const log: any = []; const cleanup = effect_root(() => { const year = derived(() => { return date.getFullYear(); }); const year2 = derived(() => { return date.getTime(), date.getFullYear(); }); render_effect(() => { log.push(get(year) + '/' + get(year2).toString()); }); flushSync(() => { date.setFullYear(date.getFullYear() + 1); }); flushSync(() => { date.setFullYear(date.getFullYear() + 1); }); }); assert.deepEqual(log, ['2023/2023', '2024/2024', '2025/2025']); cleanup(); });
```

# reactivity/index-client.js

```js
export { SvelteDate } from './date.js'; export { SvelteSet } from './set.js'; export { SvelteMap } from './map.js'; export { SvelteURL } from './url.js'; export { SvelteURLSearchParams } from './url-search-params.js'; export { MediaQuery } from './media-query.js'; export { createSubscriber } from './create-subscriber.js';
```

# reactivity/index-server.js

```js
export const SvelteDate = globalThis.Date; export const SvelteSet = globalThis.Set; export const SvelteMap = globalThis.Map; export const SvelteURL = globalThis.URL; export const SvelteURLSearchParams = globalThis.URLSearchParams; export class MediaQuery { current; /** * @param {string} query * @param {boolean} [matches] */ constructor(query, matches = false) { this.current = matches; } } /** * @param {any} _ */ export function createSubscriber(_) { return () => {}; }
```

# reactivity/map.js

```js
/** @import { Source } from '#client' */ import { DEV } from 'esm-env'; import { set, source, state, increment } from '../internal/client/reactivity/sources.js'; import { label, tag } from '../internal/client/dev/tracing.js'; import { get, update_version } from '../internal/client/runtime.js'; /** * A reactive version of the built-in [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) object. * Reading contents of the map (by iterating, or by reading `map.size` or calling `map.get(...)` or `map.has(...)` as in the [tic-tac-toe example](https://svelte.dev/playground/0b0ff4aa49c9443f9b47fe5203c78293) below) in an [effect](https://svelte.dev/docs/svelte/$effect) or [derived](https://svelte.dev/docs/svelte/$derived) * will cause it to be re-evaluated as necessary when the map is updated. * * Note that values in a reactive map are _not_ made [deeply reactive](https://svelte.dev/docs/svelte/$state#Deep-state). * * \`\`\`svelte * <script> * import { SvelteMap } from 'svelte/reactivity'; * import { result } from './game.js'; * * let board = new SvelteMap(); * let player = $state('x'); * let winner = $derived(result(board)); * * function reset() { * player = 'x'; * board.clear(); * } * </script> * * <div class="board"> * {#each Array(9), i} * <button * disabled={board.has(i) || winner} * onclick={() => { * board.set(i, player); * player = player === 'x' ? 'o' : 'x'; * }} * >{board.get(i)}</button> * {/each} * </div> * * {#if winner} * <p>{winner} wins!</p> * <button onclick={reset}>reset</button> * {:else} * <p>{player} is next</p> * {/if} * \`\`\` * * @template K * @template V * @extends {Map<K, V>} */ export class SvelteMap extends Map { /** @type {Map<K, Source<number>>} */ #sources = new Map(); #version = state(0); #size = state(0); #update_version = update_version || -1; /** * @param {Iterable<readonly [K, V]> | null | undefined} [value] */ constructor(value) { super(); if (DEV) { // If the value is invalid then the native exception will fire here value = new Map(value); tag(this.#version, 'SvelteMap version'); tag(this.#size, 'SvelteMap.size'); } if (value) { for (var [key, v] of value) { super.set(key, v); } this.#size.v = super.size; } } /** * If the source is being created inside the same reaction as the SvelteMap instance, * we use `state` so that it will not be a dependency of the reaction. Otherwise we * use `source` so it will be. * * @template T * @param {T} value * @returns {Source<T>} */ #source(value) { return update_version === this.#update_version ? state(value) : source(value); } /** @param {K} key */ has(key) { var sources = this.#sources; var s = sources.get(key); if (s === undefined) { var ret = super.get(key); if (ret !== undefined) { s = this.#source(0); if (DEV) { tag(s, `SvelteMap get(${label(key)})`); } sources.set(key, s); } else { // We should always track the version in case // the Set ever gets this value in the future. get(this.#version); return false; } } get(s); return true; } /** * @param {(value: V, key: K, map: Map<K, V>) => void} callbackfn * @param {any} [this_arg] */ forEach(callbackfn, this_arg) { this.#read_all(); super.forEach(callbackfn, this_arg); } /** @param {K} key */ get(key) { var sources = this.#sources; var s = sources.get(key); if (s === undefined) { var ret = super.get(key); if (ret !== undefined) { s = this.#source(0); if (DEV) { tag(s, `SvelteMap get(${label(key)})`); } sources.set(key, s); } else { // We should always track the version in case // the Set ever gets this value in the future. get(this.#version); return undefined; } } get(s); return super.get(key); } /** * @param {K} key * @param {V} value * */ set(key, value) { var sources = this.#sources; var s = sources.get(key); var prev_res = super.get(key); var res = super.set(key, value); var version = this.#version; if (s === undefined) { s = this.#source(0); if (DEV) { tag(s, `SvelteMap get(${label(key)})`); } sources.set(key, s); set(this.#size, super.size); increment(version); } else if (prev_res !== value) { increment(s); // if not every reaction of s is a reaction of version we need to also include version var v_reactions = version.reactions === null ? null : new Set(version.reactions); var needs_version_increase = v_reactions === null || !s.reactions?.every((r) => /** @type {NonNullable<typeof v_reactions>} */ (v_reactions).has(r) ); if (needs_version_increase) { increment(version); } } return res; } /** @param {K} key */ delete(key) { var sources = this.#sources; var s = sources.get(key); var res = super.delete(key); if (s !== undefined) { sources.delete(key); set(this.#size, super.size); set(s, -1); increment(this.#version); } return res; } clear() { if (super.size === 0) { return; } // Clear first, so we get nice console.log outputs with $inspect super.clear(); var sources = this.#sources; set(this.#size, 0); for (var s of sources.values()) { set(s, -1); } increment(this.#version); sources.clear(); } #read_all() { get(this.#version); var sources = this.#sources; if (this.#size.v !== sources.size) { for (var key of super.keys()) { if (!sources.has(key)) { var s = this.#source(0); if (DEV) { tag(s, `SvelteMap get(${label(key)})`); } sources.set(key, s); } } } for ([, s] of this.#sources) { get(s); } } keys() { get(this.#version); return super.keys(); } values() { this.#read_all(); return super.values(); } entries() { this.#read_all(); return super.entries(); } [Symbol.iterator]() { return this.entries(); } get size() { get(this.#size); return super.size; } }
```

# reactivity/map.test.ts

```ts
import { render_effect, effect_root } from '../internal/client/reactivity/effects.js'; import { flushSync } from '../index-client.js'; import { SvelteMap } from './map.js'; import { assert, test } from 'vitest'; test('map.values()', () => { const map = new SvelteMap([ [1, 1], [2, 2], [3, 3], [4, 4], [5, 5] ]); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(map.size); }); render_effect(() => { log.push(map.has(3)); }); render_effect(() => { log.push(Array.from(map.values())); }); }); flushSync(() => { map.delete(3); }); flushSync(() => { map.clear(); }); flushSync(() => { map.set(3, 3); }); flushSync(() => { map.set(3, 4); }); assert.deepEqual(log, [ 5, true, [1, 2, 3, 4, 5], 4, false, [1, 2, 4, 5], 0, false, [], 1, true, [3], true, [4] ]); cleanup(); }); test('map.get(...)', () => { const map = new SvelteMap([ [1, 1], [2, 2], [3, 3] ]); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push('get 1', map.get(1)); }); render_effect(() => { log.push('get 2', map.get(2)); }); render_effect(() => { log.push('get 3', map.get(3)); }); }); flushSync(() => { map.delete(2); }); flushSync(() => { map.set(2, 2); }); assert.deepEqual(log, ['get 1', 1, 'get 2', 2, 'get 3', 3, 'get 2', undefined, 'get 2', 2]); cleanup(); }); test('map.has(...)', () => { const map = new SvelteMap([ [1, 1], [2, 2], [3, 3] ]); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push('has 1', map.has(1)); }); render_effect(() => { log.push('has 2', map.has(2)); }); render_effect(() => { log.push('has 3', map.has(3)); }); }); flushSync(() => { map.delete(2); }); flushSync(() => { map.set(2, 2); }); assert.deepEqual(log, [ 'has 1', true, 'has 2', true, 'has 3', true, 'has 2', false, 'has 2', true ]); cleanup(); }); test('map.forEach(...)', () => { const map = new SvelteMap([ [1, 1], [2, 2], [3, 3] ]); const log: any = []; const this_arg = {}; map.forEach(function (this: unknown, ...args) { log.push([...args, this]); }, this_arg); assert.deepEqual(log, [ [1, 1, map, this_arg], [2, 2, map, this_arg], [3, 3, map, this_arg] ]); }); test('map.delete(...)', () => { const map = new SvelteMap([ [1, 1], [2, 2], [3, 3] ]); assert.equal(map.delete(3), true); assert.equal(map.delete(3), false); assert.deepEqual(Array.from(map.values()), [1, 2]); }); test('map handling of undefined values', () => { const map = new SvelteMap(); const log: any = []; const cleanup = effect_root(() => { map.set(1, undefined); render_effect(() => { log.push(map.get(1)); }); flushSync(() => { map.delete(1); }); flushSync(() => { map.set(1, 1); }); }); assert.deepEqual(log, [undefined, undefined, 1]); cleanup(); }); test('not invoking reactivity when value is not in the map after changes', () => { const map = new SvelteMap([[1, 1]]); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(map.get(1)); }); render_effect(() => { log.push(map.get(2)); }); flushSync(() => { map.delete(1); }); flushSync(() => { map.set(1, 1); }); }); assert.deepEqual(log, [1, undefined, undefined, undefined, 1, undefined]); cleanup(); }); test('Map.instanceOf', () => { assert.equal(new SvelteMap() instanceof Map, true); });
```

# reactivity/media-query.js

```js
import { on } from '../events/index.js'; import { ReactiveValue } from './reactive-value.js'; const parenthesis_regex = /\(.+\)/; // these keywords are valid media queries but they need to be without parenthesis // // eg: new MediaQuery('screen') // // however because of the auto-parenthesis logic in the constructor since there's no parentehesis // in the media query they'll be surrounded by parenthesis // // however we can check if the media query is only composed of these keywords // and skip the auto-parenthesis // // https://github.com/sveltejs/svelte/issues/15930 const non_parenthesized_keywords = new Set(['all', 'print', 'screen', 'and', 'or', 'not', 'only']); /** * Creates a media query and provides a `current` property that reflects whether or not it matches. * * Use it carefully — during server-side rendering, there is no way to know what the correct value should be, potentially causing content to change upon hydration. * If you can use the media query in CSS to achieve the same effect, do that. * * \`\`\`svelte * <script> * import { MediaQuery } from 'svelte/reactivity'; * * const large = new MediaQuery('min-width: 800px'); * </script> * * <h1>{large.current ? 'large screen' : 'small screen'}</h1> * \`\`\` * @extends {ReactiveValue<boolean>} * @since 5.7.0 */ export class MediaQuery extends ReactiveValue { /** * @param {string} query A media query string * @param {boolean} [fallback] Fallback value for the server */ constructor(query, fallback) { let final_query = parenthesis_regex.test(query) || // we need to use `some` here because technically this `window.matchMedia('random,screen')` still returns true query.split(/[\s,]+/).some((keyword) => non_parenthesized_keywords.has(keyword.trim())) ? query : `(${query})`; const q = window.matchMedia(final_query); super( () => q.matches, (update) => on(q, 'change', update) ); } }
```

# reactivity/reactive-value.js

```js
import { createSubscriber } from './create-subscriber.js'; /** * @template T */ export class ReactiveValue { #fn; #subscribe; /** * * @param {() => T} fn * @param {(update: () => void) => void} onsubscribe */ constructor(fn, onsubscribe) { this.#fn = fn; this.#subscribe = createSubscriber(onsubscribe); } get current() { this.#subscribe(); return this.#fn(); } }
```

# reactivity/set.js

```js
/** @import { Source } from '#client' */ import { DEV } from 'esm-env'; import { source, set, state, increment } from '../internal/client/reactivity/sources.js'; import { label, tag } from '../internal/client/dev/tracing.js'; import { get, update_version } from '../internal/client/runtime.js'; var read_methods = ['forEach', 'isDisjointFrom', 'isSubsetOf', 'isSupersetOf']; var set_like_methods = ['difference', 'intersection', 'symmetricDifference', 'union']; var inited = false; /** * A reactive version of the built-in [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) object. * Reading contents of the set (by iterating, or by reading `set.size` or calling `set.has(...)` as in the [example](https://svelte.dev/playground/53438b51194b4882bcc18cddf9f96f15) below) in an [effect](https://svelte.dev/docs/svelte/$effect) or [derived](https://svelte.dev/docs/svelte/$derived) * will cause it to be re-evaluated as necessary when the set is updated. * * Note that values in a reactive set are _not_ made [deeply reactive](https://svelte.dev/docs/svelte/$state#Deep-state). * * \`\`\`svelte * <script> * import { SvelteSet } from 'svelte/reactivity'; * let monkeys = new SvelteSet(); * * function toggle(monkey) { * if (monkeys.has(monkey)) { * monkeys.delete(monkey); * } else { * monkeys.add(monkey); * } * } * </script> * * {#each ['🙈', '🙉', '🙊'] as monkey} * <button onclick={() => toggle(monkey)}>{monkey}</button> * {/each} * * <button onclick={() => monkeys.clear()}>clear</button> * * {#if monkeys.has('🙈')}<p>see no evil</p>{/if} * {#if monkeys.has('🙉')}<p>hear no evil</p>{/if} * {#if monkeys.has('🙊')}<p>speak no evil</p>{/if} * \`\`\` * * @template T * @extends {Set<T>} */ export class SvelteSet extends Set { /** @type {Map<T, Source<boolean>>} */ #sources = new Map(); #version = state(0); #size = state(0); #update_version = update_version || -1; /** * @param {Iterable<T> | null | undefined} [value] */ constructor(value) { super(); if (DEV) { // If the value is invalid then the native exception will fire here value = new Set(value); tag(this.#version, 'SvelteSet version'); tag(this.#size, 'SvelteSet.size'); } if (value) { for (var element of value) { super.add(element); } this.#size.v = super.size; } if (!inited) this.#init(); } /** * If the source is being created inside the same reaction as the SvelteSet instance, * we use `state` so that it will not be a dependency of the reaction. Otherwise we * use `source` so it will be. * * @template T * @param {T} value * @returns {Source<T>} */ #source(value) { return update_version === this.#update_version ? state(value) : source(value); } // We init as part of the first instance so that we can treeshake this class #init() { inited = true; var proto = SvelteSet.prototype; var set_proto = Set.prototype; for (const method of read_methods) { // @ts-ignore proto[method] = function (...v) { get(this.#version); // @ts-ignore return set_proto[method].apply(this, v); }; } for (const method of set_like_methods) { // @ts-ignore proto[method] = function (...v) { get(this.#version); // @ts-ignore var set = /** @type {Set<T>} */ (set_proto[method].apply(this, v)); return new SvelteSet(set); }; } } /** @param {T} value */ has(value) { var has = super.has(value); var sources = this.#sources; var s = sources.get(value); if (s === undefined) { if (!has) { // If the value doesn't exist, track the version in case it's added later // but don't create sources willy-nilly to track all possible values get(this.#version); return false; } s = this.#source(true); if (DEV) { tag(s, `SvelteSet has(${label(value)})`); } sources.set(value, s); } get(s); return has; } /** @param {T} value */ add(value) { if (!super.has(value)) { super.add(value); set(this.#size, super.size); increment(this.#version); } return this; } /** @param {T} value */ delete(value) { var deleted = super.delete(value); var sources = this.#sources; var s = sources.get(value); if (s !== undefined) { sources.delete(value); set(s, false); } if (deleted) { set(this.#size, super.size); increment(this.#version); } return deleted; } clear() { if (super.size === 0) { return; } // Clear first, so we get nice console.log outputs with $inspect super.clear(); var sources = this.#sources; for (var s of sources.values()) { set(s, false); } sources.clear(); set(this.#size, 0); increment(this.#version); } keys() { return this.values(); } values() { get(this.#version); return super.values(); } entries() { get(this.#version); return super.entries(); } [Symbol.iterator]() { return this.keys(); } get size() { return get(this.#size); } }
```

# reactivity/set.test.ts

```ts
import { render_effect, effect_root } from '../internal/client/reactivity/effects.js'; import { flushSync } from '../index-client.js'; import { SvelteSet } from './set.js'; import { assert, test } from 'vitest'; test('set.values()', () => { const set = new SvelteSet([1, 2, 3, 4, 5]); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(set.size); }); render_effect(() => { log.push(set.has(3)); }); render_effect(() => { log.push(Array.from(set)); }); }); flushSync(() => { set.delete(3); }); flushSync(() => { set.clear(); }); assert.deepEqual(log, [5, true, [1, 2, 3, 4, 5], 4, false, [1, 2, 4, 5], 0, false, []]); cleanup(); }); test('set.has(...)', () => { const set = new SvelteSet([1, 2, 3]); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push('has 1', set.has(1)); }); render_effect(() => { log.push('has 2', set.has(2)); }); render_effect(() => { log.push('has 3', set.has(3)); }); }); flushSync(() => { set.delete(2); }); flushSync(() => { set.add(2); }); assert.deepEqual(log, [ 'has 1', true, 'has 2', true, 'has 3', true, 'has 2', false, 'has 2', true ]); cleanup(); }); test('set.delete(...)', () => { const set = new SvelteSet([1, 2, 3]); assert.equal(set.delete(3), true); assert.equal(set.delete(3), false); assert.deepEqual(Array.from(set.values()), [1, 2]); }); test('set.forEach()', () => { const set = new SvelteSet([1, 2, 3, 4, 5]); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { set.forEach((v) => log.push(v)); }); }); flushSync(() => { set.add(6); }); assert.deepEqual(log, [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6]); cleanup(); }); test('not invoking reactivity when value is not in the set after changes', () => { const set = new SvelteSet([1, 2]); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push('has 1', set.has(1)); }); render_effect(() => { log.push('has 2', set.has(2)); }); render_effect(() => { log.push('has 3', set.has(3)); }); }); flushSync(() => { set.delete(2); }); flushSync(() => { set.add(2); }); assert.deepEqual(log, [ 'has 1', true, 'has 2', true, 'has 3', false, 'has 2', false, 'has 3', false, 'has 2', true, 'has 3', false ]); cleanup(); }); test('Set.instanceOf', () => { assert.equal(new SvelteSet() instanceof Set, true); });
```

# reactivity/url-search-params.js

```js
import { DEV } from 'esm-env'; import { state, increment } from '../internal/client/reactivity/sources.js'; import { tag } from '../internal/client/dev/tracing.js'; import { get } from '../internal/client/runtime.js'; import { get_current_url } from './url.js'; export const REPLACE = Symbol(); /** * A reactive version of the built-in [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) object. * Reading its contents (by iterating, or by calling `params.get(...)` or `params.getAll(...)` as in the [example](https://svelte.dev/playground/b3926c86c5384bab9f2cf993bc08c1c8) below) in an [effect](https://svelte.dev/docs/svelte/$effect) or [derived](https://svelte.dev/docs/svelte/$derived) * will cause it to be re-evaluated as necessary when the params are updated. * * \`\`\`svelte * <script> * import { SvelteURLSearchParams } from 'svelte/reactivity'; * * const params = new SvelteURLSearchParams('message=hello'); * * let key = $state('key'); * let value = $state('value'); * </script> * * <input bind:value={key} /> * <input bind:value={value} /> * <button onclick={() => params.append(key, value)}>append</button> * * <p>?{params.toString()}</p> * * {#each params as [key, value]} * <p>{key}: {value}</p> * {/each} * \`\`\` */ export class SvelteURLSearchParams extends URLSearchParams { #version = DEV ? tag(state(0), 'SvelteURLSearchParams version') : state(0); #url = get_current_url(); #updating = false; #update_url() { if (!this.#url || this.#updating) return; this.#updating = true; const search = this.toString(); this.#url.search = search && `?${search}`; this.#updating = false; } /** * @param {URLSearchParams} params * @internal */ [REPLACE](params) { if (this.#updating) return; this.#updating = true; for (const key of [...super.keys()]) { super.delete(key); } for (const [key, value] of params) { super.append(key, value); } increment(this.#version); this.#updating = false; } /** * @param {string} name * @param {string} value * @returns {void} */ append(name, value) { super.append(name, value); this.#update_url(); increment(this.#version); } /** * @param {string} name * @param {string=} value * @returns {void} */ delete(name, value) { var has_value = super.has(name, value); super.delete(name, value); if (has_value) { this.#update_url(); increment(this.#version); } } /** * @param {string} name * @returns {string|null} */ get(name) { get(this.#version); return super.get(name); } /** * @param {string} name * @returns {string[]} */ getAll(name) { get(this.#version); return super.getAll(name); } /** * @param {string} name * @param {string=} value * @returns {boolean} */ has(name, value) { get(this.#version); return super.has(name, value); } keys() { get(this.#version); return super.keys(); } /** * @param {string} name * @param {string} value * @returns {void} */ set(name, value) { var previous = super.getAll(name).join(''); super.set(name, value); // can't use has(name, value), because for something like https://svelte.dev?foo=1&bar=2&foo=3 // if you set `foo` to 1, then foo=3 gets deleted whilst `has("foo", "1")` returns true if (previous !== super.getAll(name).join('')) { this.#update_url(); increment(this.#version); } } sort() { super.sort(); this.#update_url(); increment(this.#version); } toString() { get(this.#version); return super.toString(); } values() { get(this.#version); return super.values(); } entries() { get(this.#version); return super.entries(); } [Symbol.iterator]() { return this.entries(); } get size() { get(this.#version); return super.size; } }
```

# reactivity/url-search-params.test.ts

```ts
import { render_effect, effect_root } from '../internal/client/reactivity/effects.js'; import { flushSync } from '../index-client.js'; import { assert, test } from 'vitest'; import { SvelteURLSearchParams } from './url-search-params'; test('new URLSearchParams', () => { const params = new SvelteURLSearchParams('a=b'); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(params.toString()); }); }); flushSync(() => { params.set('a', 'c'); }); flushSync(() => { // nothing should happen here params.set('a', 'c'); }); assert.deepEqual(log, ['a=b', 'a=c']); cleanup(); }); test('URLSearchParams.set', () => { const params = new SvelteURLSearchParams(); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(params.toString()); }); }); flushSync(() => { params.set('a', 'b'); }); flushSync(() => { params.set('a', 'c'); }); flushSync(() => { // nothing should happen here params.set('a', 'c'); }); assert.deepEqual(log, ['', 'a=b', 'a=c']); cleanup(); }); test('URLSearchParams.append', () => { const params = new SvelteURLSearchParams(); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(params.toString()); }); }); flushSync(() => { params.append('a', 'b'); }); flushSync(() => { // nothing should happen here params.set('a', 'b'); }); flushSync(() => { params.append('a', 'c'); }); assert.deepEqual(log, ['', 'a=b', 'a=b&a=c']); cleanup(); }); test('URLSearchParams.delete', () => { const params = new SvelteURLSearchParams('a=b&c=d'); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(params.toString()); }); }); flushSync(() => { params.delete('a'); }); flushSync(() => { // nothing should happen here params.delete('a'); }); flushSync(() => { params.set('a', 'b'); }); assert.deepEqual(log, ['a=b&c=d', 'c=d', 'c=d&a=b']); cleanup(); }); test('URLSearchParams.get', () => { const params = new SvelteURLSearchParams('a=b&c=d'); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(params.get('a')); }); render_effect(() => { log.push(params.get('c')); }); render_effect(() => { log.push(params.get('e')); }); }); flushSync(() => { params.set('a', 'b'); }); flushSync(() => { params.set('a', 'new-b'); }); flushSync(() => { params.delete('a'); }); assert.deepEqual(log, ['b', 'd', null, 'new-b', 'd', null, null, 'd', null]); cleanup(); }); test('URLSearchParams.getAll', () => { const params = new SvelteURLSearchParams('a=b&c=d'); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(params.getAll('a')); }); render_effect(() => { log.push(params.getAll('q')); }); }); flushSync(() => { params.append('a', 'b1'); }); flushSync(() => { params.append('q', 'z'); }); assert.deepEqual(log, [ // initial ['b'], [], // first flush ['b', 'b1'], [], // second flush ['b', 'b1'], ['z'] ]); cleanup(); }); test('URLSearchParams.toString', () => { const params = new SvelteURLSearchParams(); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(params.toString()); }); }); flushSync(() => { params.set('a', 'b'); }); flushSync(() => { params.append('a', 'c'); }); assert.deepEqual(log, ['', 'a=b', 'a=b&a=c']); cleanup(); }); test('SvelteURLSearchParams instanceof URLSearchParams', () => { assert.ok(new SvelteURLSearchParams() instanceof URLSearchParams); });
```

# reactivity/url.js

```js
import { DEV } from 'esm-env'; import { set, state } from '../internal/client/reactivity/sources.js'; import { tag } from '../internal/client/dev/tracing.js'; import { get } from '../internal/client/runtime.js'; import { REPLACE, SvelteURLSearchParams } from './url-search-params.js'; /** @type {SvelteURL | null} */ let current_url = null; export function get_current_url() { // ideally we'd just export `current_url` directly, but it seems Vitest doesn't respect live bindings return current_url; } /** * A reactive version of the built-in [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL) object. * Reading properties of the URL (such as `url.href` or `url.pathname`) in an [effect](https://svelte.dev/docs/svelte/$effect) or [derived](https://svelte.dev/docs/svelte/$derived) * will cause it to be re-evaluated as necessary when the URL changes. * * The `searchParams` property is an instance of [SvelteURLSearchParams](https://svelte.dev/docs/svelte/svelte-reactivity#SvelteURLSearchParams). * * [Example](https://svelte.dev/playground/5a694758901b448c83dc40dc31c71f2a): * * \`\`\`svelte * <script> * import { SvelteURL } from 'svelte/reactivity'; * * const url = new SvelteURL('https://example.com/path'); * </script> * * <!-- changes to these... --> * <input bind:value={url.protocol} /> * <input bind:value={url.hostname} /> * <input bind:value={url.pathname} /> * * <hr /> * * <!-- will update `href` and vice versa --> * <input bind:value={url.href} size="65" /> * \`\`\` */ export class SvelteURL extends URL { #protocol = state(super.protocol); #username = state(super.username); #password = state(super.password); #hostname = state(super.hostname); #port = state(super.port); #pathname = state(super.pathname); #hash = state(super.hash); #search = state(super.search); #searchParams; /** * @param {string | URL} url * @param {string | URL} [base] */ constructor(url, base) { url = new URL(url, base); super(url); if (DEV) { tag(this.#protocol, 'SvelteURL.protocol'); tag(this.#username, 'SvelteURL.username'); tag(this.#password, 'SvelteURL.password'); tag(this.#hostname, 'SvelteURL.hostname'); tag(this.#port, 'SvelteURL.port'); tag(this.#pathname, 'SvelteURL.pathname'); tag(this.#hash, 'SvelteURL.hash'); tag(this.#search, 'SvelteURL.search'); } current_url = this; this.#searchParams = new SvelteURLSearchParams(url.searchParams); current_url = null; } get hash() { return get(this.#hash); } set hash(value) { super.hash = value; set(this.#hash, super.hash); } get host() { get(this.#hostname); get(this.#port); return super.host; } set host(value) { super.host = value; set(this.#hostname, super.hostname); set(this.#port, super.port); } get hostname() { return get(this.#hostname); } set hostname(value) { super.hostname = value; set(this.#hostname, super.hostname); } get href() { get(this.#protocol); get(this.#username); get(this.#password); get(this.#hostname); get(this.#port); get(this.#pathname); get(this.#hash); get(this.#search); return super.href; } set href(value) { super.href = value; set(this.#protocol, super.protocol); set(this.#username, super.username); set(this.#password, super.password); set(this.#hostname, super.hostname); set(this.#port, super.port); set(this.#pathname, super.pathname); set(this.#hash, super.hash); set(this.#search, super.search); this.#searchParams[REPLACE](super.searchParams); } get password() { return get(this.#password); } set password(value) { super.password = value; set(this.#password, super.password); } get pathname() { return get(this.#pathname); } set pathname(value) { super.pathname = value; set(this.#pathname, super.pathname); } get port() { return get(this.#port); } set port(value) { super.port = value; set(this.#port, super.port); } get protocol() { return get(this.#protocol); } set protocol(value) { super.protocol = value; set(this.#protocol, super.protocol); } get search() { return get(this.#search); } set search(value) { super.search = value; set(this.#search, value); this.#searchParams[REPLACE](super.searchParams); } get username() { return get(this.#username); } set username(value) { super.username = value; set(this.#username, super.username); } get origin() { get(this.#protocol); get(this.#hostname); get(this.#port); return super.origin; } get searchParams() { return this.#searchParams; } toString() { return this.href; } toJSON() { return this.href; } }
```

# reactivity/url.test.ts

```ts
import { render_effect, effect_root } from '../internal/client/reactivity/effects.js'; import { flushSync } from '../index-client.js'; import { SvelteURL } from './url.js'; import { assert, test } from 'vitest'; test('url.hash', () => { const url = new SvelteURL('https://svelte.dev'); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(url.hash); }); }); flushSync(() => { url.hash = 'abc'; }); flushSync(() => { url.href = 'https://svelte.dev/a/b/c#def'; }); flushSync(() => { // does not affect hash url.pathname = 'e/f'; }); assert.deepEqual(log, ['', '#abc', '#def']); cleanup(); }); test('url.href', () => { const url = new SvelteURL('https://svelte.dev?foo=bar&t=123'); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push(url.href); }); }); flushSync(() => { url.search = '?q=kit&foo=baz'; }); flushSync(() => { // changes from searchParams should be synced to URL instance as well url.searchParams.append('foo', 'qux'); }); flushSync(() => { url.searchParams.delete('foo'); }); flushSync(() => { url.searchParams.set('love', 'svelte5'); }); assert.deepEqual(log, [ 'https://svelte.dev/?foo=bar&t=123', 'https://svelte.dev/?q=kit&foo=baz', 'https://svelte.dev/?q=kit&foo=baz&foo=qux', 'https://svelte.dev/?q=kit', 'https://svelte.dev/?q=kit&love=svelte5' ]); cleanup(); }); test('url.searchParams', () => { const url = new SvelteURL('https://svelte.dev?foo=bar&t=123'); const log: any = []; const cleanup = effect_root(() => { render_effect(() => { log.push('search: ' + url.search); }); render_effect(() => { log.push('foo: ' + url.searchParams.get('foo')); }); render_effect(() => { log.push('q: ' + url.searchParams.has('q')); }); }); flushSync(() => { url.search = '?q=kit&foo=baz'; }); flushSync(() => { url.searchParams.append('foo', 'qux'); }); flushSync(() => { url.searchParams.delete('foo'); }); assert.deepEqual(log, [ 'search: ?foo=bar&t=123', 'foo: bar', 'q: false', 'search: ?q=kit&foo=baz', 'foo: baz', 'q: true', 'search: ?q=kit&foo=baz&foo=qux', 'foo: baz', 'q: true', 'search: ?q=kit', 'foo: null', 'q: true' ]); cleanup(); }); test('SvelteURL instanceof URL', () => { assert.ok(new SvelteURL('https://svelte.dev') instanceof URL); });
```

# reactivity/window/index.js

```js
import { BROWSER, DEV } from 'esm-env'; import { on } from '../../events/index.js'; import { ReactiveValue } from '../reactive-value.js'; import { get } from '../../internal/client/index.js'; import { set, source } from '../../internal/client/reactivity/sources.js'; import { tag } from '../../internal/client/dev/tracing.js'; /** * `scrollX.current` is a reactive view of `window.scrollX`. On the server it is `undefined`. * @since 5.11.0 */ export const scrollX = new ReactiveValue( BROWSER ? () => window.scrollX : () => undefined, (update) => on(window, 'scroll', update) ); /** * `scrollY.current` is a reactive view of `window.scrollY`. On the server it is `undefined`. * @since 5.11.0 */ export const scrollY = new ReactiveValue( BROWSER ? () => window.scrollY : () => undefined, (update) => on(window, 'scroll', update) ); /** * `innerWidth.current` is a reactive view of `window.innerWidth`. On the server it is `undefined`. * @since 5.11.0 */ export const innerWidth = new ReactiveValue( BROWSER ? () => window.innerWidth : () => undefined, (update) => on(window, 'resize', update) ); /** * `innerHeight.current` is a reactive view of `window.innerHeight`. On the server it is `undefined`. * @since 5.11.0 */ export const innerHeight = new ReactiveValue( BROWSER ? () => window.innerHeight : () => undefined, (update) => on(window, 'resize', update) ); /** * `outerWidth.current` is a reactive view of `window.outerWidth`. On the server it is `undefined`. * @since 5.11.0 */ export const outerWidth = new ReactiveValue( BROWSER ? () => window.outerWidth : () => undefined, (update) => on(window, 'resize', update) ); /** * `outerHeight.current` is a reactive view of `window.outerHeight`. On the server it is `undefined`. * @since 5.11.0 */ export const outerHeight = new ReactiveValue( BROWSER ? () => window.outerHeight : () => undefined, (update) => on(window, 'resize', update) ); /** * `screenLeft.current` is a reactive view of `window.screenLeft`. It is updated inside a `requestAnimationFrame` callback. On the server it is `undefined`. * @since 5.11.0 */ export const screenLeft = new ReactiveValue( BROWSER ? () => window.screenLeft : () => undefined, (update) => { let value = window.screenLeft; let frame = requestAnimationFrame(function check() { frame = requestAnimationFrame(check); if (value !== (value = window.screenLeft)) { update(); } }); return () => { cancelAnimationFrame(frame); }; } ); /** * `screenTop.current` is a reactive view of `window.screenTop`. It is updated inside a `requestAnimationFrame` callback. On the server it is `undefined`. * @since 5.11.0 */ export const screenTop = new ReactiveValue( BROWSER ? () => window.screenTop : () => undefined, (update) => { let value = window.screenTop; let frame = requestAnimationFrame(function check() { frame = requestAnimationFrame(check); if (value !== (value = window.screenTop)) { update(); } }); return () => { cancelAnimationFrame(frame); }; } ); /** * `online.current` is a reactive view of `navigator.onLine`. On the server it is `undefined`. * @since 5.11.0 */ export const online = new ReactiveValue( BROWSER ? () => navigator.onLine : () => undefined, (update) => { const unsub_online = on(window, 'online', update); const unsub_offline = on(window, 'offline', update); return () => { unsub_online(); unsub_offline(); }; } ); /** * `devicePixelRatio.current` is a reactive view of `window.devicePixelRatio`. On the server it is `undefined`. * Note that behaviour differs between browsers — on Chrome it will respond to the current zoom level, * on Firefox and Safari it won't. * @type {{ get current(): number | undefined }} * @since 5.11.0 */ export const devicePixelRatio = /* @__PURE__ */ new (class DevicePixelRatio { #dpr = source(BROWSER ? window.devicePixelRatio : undefined); #update() { const off = on( window.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`), 'change', () => { set(this.#dpr, window.devicePixelRatio); off(); this.#update(); } ); } constructor() { if (BROWSER) { this.#update(); } if (DEV) { tag(this.#dpr, 'window.devicePixelRatio'); } } get current() { get(this.#dpr); return BROWSER ? window.devicePixelRatio : undefined; } })();
```

# server/index.d.ts

```ts
import type { RenderOutput } from '#server'; import type { ComponentProps, Component, SvelteComponent, ComponentType } from 'svelte'; /** * Only available on the server and when compiling with the `server` option. * Takes a component and returns an object with `body` and `head` properties on it, which you can use to populate the HTML when server-rendering your app. */ export function render< Comp extends SvelteComponent<any> | Component<any>, Props extends ComponentProps<Comp> = ComponentProps<Comp> >( ...args: {} extends Props ? [ component: Comp extends SvelteComponent<any> ? ComponentType<Comp> : Comp, options?: { props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string; } ] : [ component: Comp extends SvelteComponent<any> ? ComponentType<Comp> : Comp, options: { props: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string; } ] ): RenderOutput;
```

# server/index.js

```js
export { render } from '../internal/server/index.js';
```

# store/index-client.js

```js
/** @import { Readable, Writable } from './public.js' */ import { effect_root, effect_tracking, render_effect } from '../internal/client/reactivity/effects.js'; import { get, writable } from './shared/index.js'; import { createSubscriber } from '../reactivity/create-subscriber.js'; import { active_effect, active_reaction, set_active_effect, set_active_reaction } from '../internal/client/runtime.js'; export { derived, get, readable, readonly, writable } from './shared/index.js'; /** * @template V * @overload * @param {() => V} get * @param {(v: V) => void} set * @returns {Writable<V>} */ /** * @template V * @overload * @param {() => V} get * @returns {Readable<V>} */ /** * Create a store from a function that returns state, and (to make a writable store), an * optional second function that sets state. * * \`\`\`ts * import { toStore } from 'svelte/store'; * * let count = $state(0); * * const store = toStore(() => count, (v) => (count = v)); * \`\`\` * @template V * @param {() => V} get * @param {(v: V) => void} [set] * @returns {Writable<V> | Readable<V>} */ export function toStore(get, set) { var effect = active_effect; var reaction = active_reaction; var init_value = get(); const store = writable(init_value, (set) => { // If the value has changed before we call subscribe, then // we need to treat the value as already having run var ran = init_value !== get(); // TODO do we need a different implementation on the server? var teardown; // Apply the reaction and effect at the time of toStore being called var previous_reaction = active_reaction; var previous_effect = active_effect; set_active_reaction(reaction); set_active_effect(effect); try { teardown = effect_root(() => { render_effect(() => { const value = get(); if (ran) set(value); }); }); } finally { set_active_reaction(previous_reaction); set_active_effect(previous_effect); } ran = true; return teardown; }); if (set) { return { set, update: (fn) => set(fn(get())), subscribe: store.subscribe }; } return { subscribe: store.subscribe }; } /** * @template V * @overload * @param {Writable<V>} store * @returns {{ current: V }} */ /** * @template V * @overload * @param {Readable<V>} store * @returns {{ readonly current: V }} */ /** * Convert a store to an object with a reactive `current` property. If `store` * is a readable store, `current` will be a readonly property. * * \`\`\`ts * import { fromStore, get, writable } from 'svelte/store'; * * const store = writable(0); * * const count = fromStore(store); * * count.current; // 0; * store.set(1); * count.current; // 1 * * count.current += 1; * get(store); // 2 * \`\`\` * @template V * @param {Writable<V> | Readable<V>} store */ export function fromStore(store) { let value = /** @type {V} */ (undefined); const subscribe = createSubscriber((update) => { let ran = false; const unsubscribe = store.subscribe((v) => { value = v; if (ran) update(); }); ran = true; return unsubscribe; }); function current() { if (effect_tracking()) { subscribe(); return value; } return get(store); } if ('set' in store) { return { get current() { return current(); }, set current(v) { store.set(v); } }; } return { get current() { return current(); } }; }
```

# store/index-server.js

```js
/** @import { Readable, Writable } from './public.js' */ import { get, writable } from './shared/index.js'; export { derived, get, readable, readonly, writable } from './shared/index.js'; /** * @template V * @overload * @param {() => V} get * @param {(v: V) => void} set * @returns {Writable<V>} */ /** * @template V * @overload * @param {() => V} get * @returns {Readable<V>} */ /** * Create a store from a function that returns state, and (to make a writable store), an * optional second function that sets state. * * \`\`\`ts * import { toStore } from 'svelte/store'; * * let count = $state(0); * * const store = toStore(() => count, (v) => (count = v)); * \`\`\` * @template V * @param {() => V} get * @param {(v: V) => void} [set] * @returns {Writable<V> | Readable<V>} */ export function toStore(get, set) { const store = writable(get()); if (set) { return { set, update: (fn) => set(fn(get())), subscribe: store.subscribe }; } return { subscribe: store.subscribe }; } /** * @template V * @overload * @param {Writable<V>} store * @returns {{ current: V }} */ /** * @template V * @overload * @param {Readable<V>} store * @returns {{ readonly current: V }} */ /** * Convert a store to an object with a reactive `current` property. If `store` * is a readable store, `current` will be a readonly property. * * \`\`\`ts * import { fromStore, get, writable } from 'svelte/store'; * * const store = writable(0); * * const count = fromStore(store); * * count.current; // 0; * store.set(1); * count.current; // 1 * * count.current += 1; * get(store); // 2 * \`\`\` * @template V * @param {Writable<V> | Readable<V>} store */ export function fromStore(store) { if ('set' in store) { return { get current() { return get(store); }, set current(v) { store.set(v); } }; } return { get current() { return get(store); } }; }
```

# store/private.d.ts

```ts
import { Readable, Subscriber } from './public.js'; /** Pair of subscriber and invalidator. */ type SubscribeInvalidateTuple<T> = [Subscriber<T>, () => void]; /** One or more `Readable`s. */ type Stores = Readable<any> | [Readable<any>, ...Array<Readable<any>>] | Array<Readable<any>>; /** One or more values from `Readable` stores. */ type StoresValues<T> = T extends Readable<infer U> ? U : { [K in keyof T]: T[K] extends Readable<infer U> ? U : never }; export { SubscribeInvalidateTuple, Stores, StoresValues };
```

# store/public.d.ts

```ts
/** Callback to inform of a value updates. */ export type Subscriber<T> = (value: T) => void; /** Unsubscribes from value updates. */ export type Unsubscriber = () => void; /** Callback to update a value. */ export type Updater<T> = (value: T) => T; /** * Start and stop notification callbacks. * This function is called when the first subscriber subscribes. * * @param {(value: T) => void} set Function that sets the value of the store. * @param {(value: Updater<T>) => void} update Function that sets the value of the store after passing the current value to the update function. * @returns {void | (() => void)} Optionally, a cleanup function that is called when the last remaining * subscriber unsubscribes. */ export type StartStopNotifier<T> = ( set: (value: T) => void, update: (fn: Updater<T>) => void ) => void | (() => void); /** Readable interface for subscribing. */ export interface Readable<T> { /** * Subscribe on value changes. * @param run subscription callback * @param invalidate cleanup callback */ subscribe(this: void, run: Subscriber<T>, invalidate?: () => void): Unsubscriber; } /** Writable interface for both updating and subscribing. */ export interface Writable<T> extends Readable<T> { /** * Set value and inform subscribers. * @param value to set */ set(this: void, value: T): void; /** * Update value using callback and inform subscribers. * @param updater callback */ update(this: void, updater: Updater<T>): void; } export * from './index-client.js';
```

# store/shared/index.js

```js
/** @import { Readable, StartStopNotifier, Subscriber, Unsubscriber, Updater, Writable } from '../public.js' */ /** @import { Stores, StoresValues, SubscribeInvalidateTuple } from '../private.js' */ import { noop, run_all } from '../../internal/shared/utils.js'; import { safe_not_equal } from '../../internal/client/reactivity/equality.js'; import { subscribe_to_store } from '../utils.js'; /** * @type {Array<SubscribeInvalidateTuple<any> | any>} */ const subscriber_queue = []; /** * Creates a `Readable` store that allows reading by subscription. * * @template T * @param {T} [value] initial value * @param {StartStopNotifier<T>} [start] * @returns {Readable<T>} */ export function readable(value, start) { return { subscribe: writable(value, start).subscribe }; } /** * Create a `Writable` store that allows both updating and reading by subscription. * * @template T * @param {T} [value] initial value * @param {StartStopNotifier<T>} [start] * @returns {Writable<T>} */ export function writable(value, start = noop) { /** @type {Unsubscriber | null} */ let stop = null; /** @type {Set<SubscribeInvalidateTuple<T>>} */ const subscribers = new Set(); /** * @param {T} new_value * @returns {void} */ function set(new_value) { if (safe_not_equal(value, new_value)) { value = new_value; if (stop) { // store is ready const run_queue = !subscriber_queue.length; for (const subscriber of subscribers) { subscriber[1](); subscriber_queue.push(subscriber, value); } if (run_queue) { for (let i = 0; i < subscriber_queue.length; i += 2) { subscriber_queue[i][0](subscriber_queue[i + 1]); } subscriber_queue.length = 0; } } } } /** * @param {Updater<T>} fn * @returns {void} */ function update(fn) { set(fn(/** @type {T} */ (value))); } /** * @param {Subscriber<T>} run * @param {() => void} [invalidate] * @returns {Unsubscriber} */ function subscribe(run, invalidate = noop) { /** @type {SubscribeInvalidateTuple<T>} */ const subscriber = [run, invalidate]; subscribers.add(subscriber); if (subscribers.size === 1) { stop = start(set, update) || noop; } run(/** @type {T} */ (value)); return () => { subscribers.delete(subscriber); if (subscribers.size === 0 && stop) { stop(); stop = null; } }; } return { set, update, subscribe }; } /** * Derived value store by synchronizing one or more readable stores and * applying an aggregation function over its input values. * * @template {Stores} S * @template T * @overload * @param {S} stores * @param {(values: StoresValues<S>, set: (value: T) => void, update: (fn: Updater<T>) => void) => Unsubscriber | void} fn * @param {T} [initial_value] * @returns {Readable<T>} */ /** * Derived value store by synchronizing one or more readable stores and * applying an aggregation function over its input values. * * @template {Stores} S * @template T * @overload * @param {S} stores * @param {(values: StoresValues<S>) => T} fn * @param {T} [initial_value] * @returns {Readable<T>} */ /** * @template {Stores} S * @template T * @param {S} stores * @param {Function} fn * @param {T} [initial_value] * @returns {Readable<T>} */ export function derived(stores, fn, initial_value) { const single = !Array.isArray(stores); /** @type {Array<Readable<any>>} */ const stores_array = single ? [stores] : stores; if (!stores_array.every(Boolean)) { throw new Error('derived() expects stores as input, got a falsy value'); } const auto = fn.length < 2; return readable(initial_value, (set, update) => { let started = false; /** @type {T[]} */ const values = []; let pending = 0; let cleanup = noop; const sync = () => { if (pending) { return; } cleanup(); const result = fn(single ? values[0] : values, set, update); if (auto) { set(result); } else { cleanup = typeof result === 'function' ? result : noop; } }; const unsubscribers = stores_array.map((store, i) => subscribe_to_store( store, (value) => { values[i] = value; pending &= ~(1 << i); if (started) { sync(); } }, () => { pending |= 1 << i; } ) ); started = true; sync(); return function stop() { run_all(unsubscribers); cleanup(); // We need to set this to false because callbacks can still happen despite having unsubscribed: // Callbacks might already be placed in the queue which doesn't know it should no longer // invoke this derived store. started = false; }; }); } /** * Takes a store and returns a new one derived from the old one that is readable. * * @template T * @param {Readable<T>} store - store to make readonly * @returns {Readable<T>} */ export function readonly(store) { return { // @ts-expect-error TODO i suspect the bind is unnecessary subscribe: store.subscribe.bind(store) }; } /** * Get the current value from a store by subscribing and immediately unsubscribing. * * @template T * @param {Readable<T>} store * @returns {T} */ export function get(store) { let value; subscribe_to_store(store, (_) => (value = _))(); // @ts-expect-error return value; }
```

# store/utils.js

```js
/** @import { Readable } from './public' */ import { untrack } from '../index-client.js'; import { noop } from '../internal/shared/utils.js'; /** * @template T * @param {Readable<T> | null | undefined} store * @param {(value: T) => void} run * @param {(value: T) => void} [invalidate] * @returns {() => void} */ export function subscribe_to_store(store, run, invalidate) { if (store == null) { // @ts-expect-error run(undefined); // @ts-expect-error if (invalidate) invalidate(undefined); return noop; } // Svelte store takes a private second argument // StartStopNotifier could mutate state, and we want to silence the corresponding validation error const unsub = untrack(() => store.subscribe( run, // @ts-expect-error invalidate ) ); // Also support RxJS // @ts-expect-error TODO fix this in the types? return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub; }
```

# transition/index.js

```js
/** @import { BlurParams, CrossfadeParams, DrawParams, FadeParams, FlyParams, ScaleParams, SlideParams, TransitionConfig } from './public' */ import { DEV } from 'esm-env'; import * as w from '../internal/client/warnings.js'; /** @param {number} x */ const linear = (x) => x; /** @param {number} t */ function cubic_out(t) { const f = t - 1.0; return f * f * f + 1.0; } /** * @param {number} t * @returns {number} */ function cubic_in_out(t) { return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0; } /** @param {number | string} value * @returns {[number, string]} */ function split_css_unit(value) { const split = typeof value === 'string' && value.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/); return split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px']; } /** * Animates a `blur` filter alongside an element's opacity. * * @param {Element} node * @param {BlurParams} [params] * @returns {TransitionConfig} */ export function blur( node, { delay = 0, duration = 400, easing = cubic_in_out, amount = 5, opacity = 0 } = {} ) { const style = getComputedStyle(node); const target_opacity = +style.opacity; const f = style.filter === 'none' ? '' : style.filter; const od = target_opacity * (1 - opacity); const [value, unit] = split_css_unit(amount); return { delay, duration, easing, css: (_t, u) => `opacity: ${target_opacity - od * u}; filter: ${f} blur(${u * value}${unit});` }; } /** * Animates the opacity of an element from 0 to the current opacity for `in` transitions and from the current opacity to 0 for `out` transitions. * * @param {Element} node * @param {FadeParams} [params] * @returns {TransitionConfig} */ export function fade(node, { delay = 0, duration = 400, easing = linear } = {}) { const o = +getComputedStyle(node).opacity; return { delay, duration, easing, css: (t) => `opacity: ${t * o}` }; } /** * Animates the x and y positions and the opacity of an element. `in` transitions animate from the provided values, passed as parameters to the element's default values. `out` transitions animate from the element's default values to the provided values. * * @param {Element} node * @param {FlyParams} [params] * @returns {TransitionConfig} */ export function fly( node, { delay = 0, duration = 400, easing = cubic_out, x = 0, y = 0, opacity = 0 } = {} ) { const style = getComputedStyle(node); const target_opacity = +style.opacity; const transform = style.transform === 'none' ? '' : style.transform; const od = target_opacity * (1 - opacity); const [x_value, x_unit] = split_css_unit(x); const [y_value, y_unit] = split_css_unit(y); return { delay, duration, easing, css: (t, u) => ` transform: ${transform} translate(${(1 - t) * x_value}${x_unit}, ${(1 - t) * y_value}${y_unit}); opacity: ${target_opacity - od * u}` }; } var slide_warning = false; /** * Slides an element in and out. * * @param {Element} node * @param {SlideParams} [params] * @returns {TransitionConfig} */ export function slide(node, { delay = 0, duration = 400, easing = cubic_out, axis = 'y' } = {}) { const style = getComputedStyle(node); if (DEV && !slide_warning && /(contents|inline|table)/.test(style.display)) { slide_warning = true; Promise.resolve().then(() => (slide_warning = false)); w.transition_slide_display(style.display); } const opacity = +style.opacity; const primary_property = axis === 'y' ? 'height' : 'width'; const primary_property_value = parseFloat(style[primary_property]); const secondary_properties = axis === 'y' ? ['top', 'bottom'] : ['left', 'right']; const capitalized_secondary_properties = secondary_properties.map( (e) => /** @type {'Left' | 'Right' | 'Top' | 'Bottom'} */ (`${e[0].toUpperCase()}${e.slice(1)}`) ); const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]); const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]); const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]); const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]); const border_width_start_value = parseFloat( style[`border${capitalized_secondary_properties[0]}Width`] ); const border_width_end_value = parseFloat( style[`border${capitalized_secondary_properties[1]}Width`] ); return { delay, duration, easing, css: (t) => 'overflow: hidden;' + `opacity: ${Math.min(t * 20, 1) * opacity};` + `${primary_property}: ${t * primary_property_value}px;` + `padding-${secondary_properties[0]}: ${t * padding_start_value}px;` + `padding-${secondary_properties[1]}: ${t * padding_end_value}px;` + `margin-${secondary_properties[0]}: ${t * margin_start_value}px;` + `margin-${secondary_properties[1]}: ${t * margin_end_value}px;` + `border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;` + `border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;` + `min-${primary_property}: 0` }; } /** * Animates the opacity and scale of an element. `in` transitions animate from the provided values, passed as parameters, to an element's current (default) values. `out` transitions animate from an element's default values to the provided values. * * @param {Element} node * @param {ScaleParams} [params] * @returns {TransitionConfig} */ export function scale( node, { delay = 0, duration = 400, easing = cubic_out, start = 0, opacity = 0 } = {} ) { const style = getComputedStyle(node); const target_opacity = +style.opacity; const transform = style.transform === 'none' ? '' : style.transform; const sd = 1 - start; const od = target_opacity * (1 - opacity); return { delay, duration, easing, css: (_t, u) => ` transform: ${transform} scale(${1 - sd * u}); opacity: ${target_opacity - od * u} ` }; } /** * Animates the stroke of an SVG element, like a snake in a tube. `in` transitions begin with the path invisible and draw the path to the screen over time. `out` transitions start in a visible state and gradually erase the path. `draw` only works with elements that have a `getTotalLength` method, like `<path>` and `<polyline>`. * * @param {SVGElement & { getTotalLength(): number }} node * @param {DrawParams} [params] * @returns {TransitionConfig} */ export function draw(node, { delay = 0, speed, duration, easing = cubic_in_out } = {}) { let len = node.getTotalLength(); const style = getComputedStyle(node); if (style.strokeLinecap !== 'butt') { len += parseInt(style.strokeWidth); } if (duration === undefined) { if (speed === undefined) { duration = 800; } else { duration = len / speed; } } else if (typeof duration === 'function') { duration = duration(len); } return { delay, duration, easing, css: (_, u) => ` stroke-dasharray: ${len}; stroke-dashoffset: ${u * len}; ` }; } /** * @template T * @template S * @param {T} tar * @param {S} src * @returns {T & S} */ function assign(tar, src) { // @ts-ignore for (const k in src) tar[k] = src[k]; return /** @type {T & S} */ (tar); } /** * The `crossfade` function creates a pair of [transitions](https://svelte.dev/docs/svelte/transition) called `send` and `receive`. When an element is 'sent', it looks for a corresponding element being 'received', and generates a transition that transforms the element to its counterpart's position and fades it out. When an element is 'received', the reverse happens. If there is no counterpart, the `fallback` transition is used. * * @param {CrossfadeParams & { * fallback?: (node: Element, params: CrossfadeParams, intro: boolean) => TransitionConfig; * }} params * @returns {[(node: any, params: CrossfadeParams & { key: any; }) => () => TransitionConfig, (node: any, params: CrossfadeParams & { key: any; }) => () => TransitionConfig]} */ export function crossfade({ fallback, ...defaults }) { /** @type {Map<any, Element>} */ const to_receive = new Map(); /** @type {Map<any, Element>} */ const to_send = new Map(); /** * @param {Element} from_node * @param {Element} node * @param {CrossfadeParams} params * @returns {TransitionConfig} */ function crossfade(from_node, node, params) { const { delay = 0, duration = /** @param {number} d */ (d) => Math.sqrt(d) * 30, easing = cubic_out } = assign(assign({}, defaults), params); const from = from_node.getBoundingClientRect(); const to = node.getBoundingClientRect(); const dx = from.left - to.left; const dy = from.top - to.top; const dw = from.width / to.width; const dh = from.height / to.height; const d = Math.sqrt(dx * dx + dy * dy); const style = getComputedStyle(node); const transform = style.transform === 'none' ? '' : style.transform; const opacity = +style.opacity; return { delay, duration: typeof duration === 'function' ? duration(d) : duration, easing, css: (t, u) => ` opacity: ${t * opacity}; transform-origin: top left; transform: ${transform} translate(${u * dx}px,${u * dy}px) scale(${t + (1 - t) * dw}, ${ t + (1 - t) * dh }); ` }; } /** * @param {Map<any, Element>} items * @param {Map<any, Element>} counterparts * @param {boolean} intro * @returns {(node: any, params: CrossfadeParams & { key: any; }) => () => TransitionConfig} */ function transition(items, counterparts, intro) { // @ts-expect-error TODO improve typings (are the public types wrong?) return (node, params) => { items.set(params.key, node); return () => { if (counterparts.has(params.key)) { const other_node = counterparts.get(params.key); counterparts.delete(params.key); return crossfade(/** @type {Element} */ (other_node), node, params); } // if the node is disappearing altogether // (i.e. wasn't claimed by the other list) // then we need to supply an outro items.delete(params.key); return fallback && fallback(node, params, intro); }; }; } return [transition(to_send, to_receive, false), transition(to_receive, to_send, true)]; }
```

# transition/public.d.ts

```ts
export type EasingFunction = (t: number) => number; export interface TransitionConfig { delay?: number; duration?: number; easing?: EasingFunction; css?: (t: number, u: number) => string; tick?: (t: number, u: number) => void; } export interface BlurParams { delay?: number; duration?: number; easing?: EasingFunction; amount?: number | string; opacity?: number; } export interface FadeParams { delay?: number; duration?: number; easing?: EasingFunction; } export interface FlyParams { delay?: number; duration?: number; easing?: EasingFunction; x?: number | string; y?: number | string; opacity?: number; } export interface SlideParams { delay?: number; duration?: number; easing?: EasingFunction; axis?: 'x' | 'y'; } export interface ScaleParams { delay?: number; duration?: number; easing?: EasingFunction; start?: number; opacity?: number; } export interface DrawParams { delay?: number; speed?: number; duration?: number | ((len: number) => number); easing?: EasingFunction; } export interface CrossfadeParams { delay?: number; duration?: number | ((len: number) => number); easing?: EasingFunction; } export * from './index.js';
```

# utils.js

```js
const regex_return_characters = /\r/g; /** * @param {string} str * @returns {string} */ export function hash(str) { str = str.replace(regex_return_characters, ''); let hash = 5381; let i = str.length; while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i); return (hash >>> 0).toString(36); } const VOID_ELEMENT_NAMES = [ 'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr' ]; /** * Returns `true` if `name` is of a void element * @param {string} name */ export function is_void(name) { return VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === '!doctype'; } const RESERVED_WORDS = [ 'arguments', 'await', 'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'enum', 'eval', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'implements', 'import', 'in', 'instanceof', 'interface', 'let', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'static', 'super', 'switch', 'this', 'throw', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield' ]; /** * Returns `true` if `word` is a reserved JavaScript keyword * @param {string} word */ export function is_reserved(word) { return RESERVED_WORDS.includes(word); } /** * @param {string} name */ export function is_capture_event(name) { return name.endsWith('capture') && name !== 'gotpointercapture' && name !== 'lostpointercapture'; } /** List of Element events that will be delegated */ const DELEGATED_EVENTS = [ 'beforeinput', 'click', 'change', 'dblclick', 'contextmenu', 'focusin', 'focusout', 'input', 'keydown', 'keyup', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'pointerdown', 'pointermove', 'pointerout', 'pointerover', 'pointerup', 'touchend', 'touchmove', 'touchstart' ]; /** * Returns `true` if `event_name` is a delegated event * @param {string} event_name */ export function is_delegated(event_name) { return DELEGATED_EVENTS.includes(event_name); } /** * Attributes that are boolean, i.e. they are present or not present. */ const DOM_BOOLEAN_ATTRIBUTES = [ 'allowfullscreen', 'async', 'autofocus', 'autoplay', 'checked', 'controls', 'default', 'disabled', 'formnovalidate', 'hidden', 'indeterminate', 'inert', 'ismap', 'loop', 'multiple', 'muted', 'nomodule', 'novalidate', 'open', 'playsinline', 'readonly', 'required', 'reversed', 'seamless', 'selected', 'webkitdirectory', 'defer', 'disablepictureinpicture', 'disableremoteplayback' ]; /** * Returns `true` if `name` is a boolean attribute * @param {string} name */ export function is_boolean_attribute(name) { return DOM_BOOLEAN_ATTRIBUTES.includes(name); } /** * @type {Record<string, string>} * List of attribute names that should be aliased to their property names * because they behave differently between setting them as an attribute and * setting them as a property. */ const ATTRIBUTE_ALIASES = { // no `class: 'className'` because we handle that separately formnovalidate: 'formNoValidate', ismap: 'isMap', nomodule: 'noModule', playsinline: 'playsInline', readonly: 'readOnly', defaultvalue: 'defaultValue', defaultchecked: 'defaultChecked', srcobject: 'srcObject', novalidate: 'noValidate', allowfullscreen: 'allowFullscreen', disablepictureinpicture: 'disablePictureInPicture', disableremoteplayback: 'disableRemotePlayback' }; /** * @param {string} name */ export function normalize_attribute(name) { name = name.toLowerCase(); return ATTRIBUTE_ALIASES[name] ?? name; } const DOM_PROPERTIES = [ ...DOM_BOOLEAN_ATTRIBUTES, 'formNoValidate', 'isMap', 'noModule', 'playsInline', 'readOnly', 'value', 'volume', 'defaultValue', 'defaultChecked', 'srcObject', 'noValidate', 'allowFullscreen', 'disablePictureInPicture', 'disableRemotePlayback' ]; /** * @param {string} name */ export function is_dom_property(name) { return DOM_PROPERTIES.includes(name); } const NON_STATIC_PROPERTIES = ['autofocus', 'muted', 'defaultValue', 'defaultChecked']; /** * Returns `true` if the given attribute cannot be set through the template * string, i.e. needs some kind of JavaScript handling to work. * @param {string} name */ export function cannot_be_set_statically(name) { return NON_STATIC_PROPERTIES.includes(name); } /** * Subset of delegated events which should be passive by default. * These two are already passive via browser defaults on window, document and body. * But since * - we're delegating them * - they happen often * - they apply to mobile which is generally less performant * we're marking them as passive by default for other elements, too. */ const PASSIVE_EVENTS = ['touchstart', 'touchmove']; /** * Returns `true` if `name` is a passive event * @param {string} name */ export function is_passive_event(name) { return PASSIVE_EVENTS.includes(name); } const CONTENT_EDITABLE_BINDINGS = ['textContent', 'innerHTML', 'innerText']; /** @param {string} name */ export function is_content_editable_binding(name) { return CONTENT_EDITABLE_BINDINGS.includes(name); } const LOAD_ERROR_ELEMENTS = [ 'body', 'embed', 'iframe', 'img', 'link', 'object', 'script', 'style', 'track' ]; /** * Returns `true` if the element emits `load` and `error` events * @param {string} name */ export function is_load_error_element(name) { return LOAD_ERROR_ELEMENTS.includes(name); } const SVG_ELEMENTS = [ 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor', 'animateMotion', 'animateTransform', 'circle', 'clipPath', 'color-profile', 'cursor', 'defs', 'desc', 'discard', 'ellipse', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'filter', 'font', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignObject', 'g', 'glyph', 'glyphRef', 'hatch', 'hatchpath', 'hkern', 'image', 'line', 'linearGradient', 'marker', 'mask', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'metadata', 'missing-glyph', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'set', 'solidcolor', 'stop', 'svg', 'switch', 'symbol', 'text', 'textPath', 'tref', 'tspan', 'unknown', 'use', 'view', 'vkern' ]; /** @param {string} name */ export function is_svg(name) { return SVG_ELEMENTS.includes(name); } const MATHML_ELEMENTS = [ 'annotation', 'annotation-xml', 'maction', 'math', 'merror', 'mfrac', 'mi', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mprescripts', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msubsup', 'msup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'semantics' ]; /** @param {string} name */ export function is_mathml(name) { return MATHML_ELEMENTS.includes(name); } const STATE_CREATION_RUNES = /** @type {const} */ ([ '$state', '$state.raw', '$derived', '$derived.by' ]); const RUNES = /** @type {const} */ ([ ...STATE_CREATION_RUNES, '$state.snapshot', '$props', '$props.id', '$bindable', '$effect', '$effect.pre', '$effect.tracking', '$effect.root', '$effect.pending', '$inspect', '$inspect().with', '$inspect.trace', '$host' ]); /** @typedef {RUNES[number]} RuneName */ /** * @param {string} name * @returns {name is RuneName} */ export function is_rune(name) { return RUNES.includes(/** @type {RuneName} */ (name)); } /** @typedef {STATE_CREATION_RUNES[number]} StateCreationRuneName */ /** * @param {string} name * @returns {name is StateCreationRuneName} */ export function is_state_creation_rune(name) { return STATE_CREATION_RUNES.includes(/** @type {StateCreationRuneName} */ (name)); } /** List of elements that require raw contents and should not have SSR comments put in them */ const RAW_TEXT_ELEMENTS = /** @type {const} */ (['textarea', 'script', 'style', 'title']); /** @param {string} name */ export function is_raw_text_element(name) { return RAW_TEXT_ELEMENTS.includes(/** @type {RAW_TEXT_ELEMENTS[number]} */ (name)); } /** * Prevent devtools trying to make `location` a clickable link by inserting a zero-width space * @template {string | undefined} T * @param {T} location * @returns {T}; */ export function sanitize_location(location) { return /** @type {T} */ (location?.replace(/\//g, '/\u200b')); }
```

# version.js

```js
// generated during release, do not modify /** * The current version, as set in package.json. * @type {string} */ export const VERSION = '5.36.0'; export const PUBLIC_VERSION = '5';
```

